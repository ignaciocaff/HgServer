// Game.cpp: implementation of the CGame class.
//
//////////////////////////////////////////////////////////////////////

#include "Game.h"

class CDebugWindow *DbgWnd;

extern void PutLogList(char * cMsg);
extern char G_cTxt[512];
extern char	G_cData50000[50000];
extern void PutLogFileList(char * cStr);
extern void PutAdminLogFileList(char * cStr);
extern void PutItemLogFileList(char * cStr);
extern void PutLogEventFileList(char * cStr);
extern void PutHackLogFileList(char * cStr);
extern void PutPvPLogFileList(char * cStr);
extern FILE * pLogFile;
extern HWND	G_hWnd;



int _tmp_iMoveLocX[9][37] = 
{
	 // 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	// 1
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//2
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,-1},
	//3
	{20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//4
	{20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,19,18,17,16,
	 15,14,13,12,11,10,9,8,7,6,
	 5,4,3,2,1,0,-1},
	//5
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//6
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,1,2,3,4,
	 5,6,7,8,9,10,11,12,13,14,
	 15,16,17,18,19,20,-1},
	//7
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//8
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,1,2,3,4,
	 5,6,7,8,9,10,11,12,13,14,
	 15,16,17,18,19,20,-1}
};

int _tmp_iMoveLocY[9][37] = 
{
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//1
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//2
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1},
	//3
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//4
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,-1},
	//5
	{15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//6
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,-1},
	//7
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	// 8
	{15,14,13,12,11,10,9,8,7,6,
	 5,4,3,2,1,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,-1}
};

char _tmp_cTmpDirX[9] = 
{ 
	0,0,1,1,1,0,-1,-1,-1 
};

char _tmp_cTmpDirY[9] = 
{ 
	0,-1,-1,0,1,1,1,0,-1 
};

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

extern BOOL	G_bIsThread;
extern unsigned __stdcall ThreadProc(void *ch);

/*********************************************************************************************************************
**  CGame::CGame(HWND hWnd)																							**
**  DESCRIPTION			:: general variable initializer																**
**  LAST_UPDATED		:: March 13, 2005; 9:27 AM; Hypnotoad														**
**	RETURN_VALUE		:: none																						**
**  NOTES				::	- m_bIsWLServerAvailable is new															**
**							- m_cServerName changed from m_cServerName[11] to m_cServerName[12]						**
**							- set m_sForceRecallTime to 0															**
**							- /// Highlighted 1 /// is incorrect													**
**							- missing <17> variables																**
**							- <6> unidentified variables															**
**	MODIFICATION		::	- Added external variable initialization to:											**
**							m_bEnemyKillMode, m_iEnemyKillAdjust													**
**							m_bAdminSecurity m_sRaidTimeMonday m_sRaidTimeTuesday m_sRaidTimeWednesday				**
**							m_sRaidTimeThursday m_sRaidTimeFriday m_sRaidTimeSaturday m_sRaidTimeSunday				**
**							m_sCharPointLimit m_sSlateSuccessRate													**
**********************************************************************************************************************/
CGame::CGame(HWND hWnd)
{
	int i, x;
	GSID = -1;
	m_bIsGameServerRegistered = FALSE;
	ReceivedAllConfig		= FALSE;
	m_bIsGameStarted = FALSE;
	m_hWnd           = hWnd;
	m_pMainLogSock   = NULL;
	m_pGateSock      = NULL;
	m_bIsLogSockAvailable   = FALSE;
	m_bIsGateSockAvailable  = FALSE;
	m_bIsItemAvailable      = FALSE;
	m_bIsBuildItemAvailable = FALSE;
	m_bIsNpcAvailable       = FALSE;
	m_bIsMagicAvailable     = FALSE;
	m_bIsSkillAvailable     = FALSE;
	m_bIsQuestAvailable     = FALSE;
	m_bIsPotionAvailable    = FALSE;
	m_bIsWLServerAvailable  = FALSE; // new
	ZeroMemory(m_cServerName, sizeof(m_cServerName)); // changed to 12
	m_iPlayerMaxLevel = DEF_PLAYERMAXLEVEL;
	m_sForceRecallTime = 0; // new
	for (i = 0; i < DEF_MAXCLIENTS; i++) m_pClientList[i] = NULL;
	for (i = 0; i < DEF_MAXMAPS; i++) m_pMapList[i] = NULL;
	for (i = 0; i < DEF_MAXITEMTYPES; i++) m_pItemConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXNPCTYPES; i++) m_pNpcConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXNPCS; i++) m_pNpcList[i] = NULL;
	for (i = 0; i < DEF_MSGQUENESIZE; i++) m_pMsgQuene[i] = NULL;
	for (i = 0; i < DEF_MAXMAGICTYPE; i++) m_pMagicConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXSKILLTYPE; i++) m_pSkillConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXQUESTTYPE; i++) m_pQuestConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++) m_pDynamicObjectList[i] = NULL;
	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) m_pDelayEventList[i] = NULL;
	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++) m_pNoticeMsgList[i] = NULL;
	for (i = 0; i < DEF_MAXFISHS; i++) m_pFish[i] = NULL;
	for (i = 0; i < DEF_MAXMINERALS; i++) m_pMineral[i] = NULL;
	for (i = 0; i < DEF_MAXPOTIONTYPES; i++) {
		m_pPotionConfigList[i] = NULL;
		m_pCraftingConfigList[i] = NULL;// Crafting
	}
	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
#ifdef DEF_DBGAMESERVER
		m_bIsSocketConnected[i] = FALSE;
#endif
	}
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pBuildItemList[i] = NULL;
	for (i = 0; i < DEF_MAXDUPITEMID; i++) m_pDupItemIDList[i] = NULL;
	//// Highlighted 1 ///
	for (i = 0; i < DEF_MAXCLIENTS; i++) { // asm is 5000, this is 2000 ?
		m_stPartyInfo[i].iTotalMembers = 0;
		for(x = 0; x < DEF_MAXPARTYMEMBERS; x++) 
			m_stPartyInfo[i].iIndex[x] = 0;
	}
	//// End Highlight ///
	m_iQueneHead = 0;
	m_iQueneTail = 0;
	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;
	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;
	m_MaxUserSysTime.wHour   = 0;
	m_MaxUserSysTime.wMinute = 0;
	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;
	m_iMiddlelandMapIndex = -1;
	m_iBTFieldMapIndex = -1;
	m_iGodHMapIndex = -1;
	m_iRampartMapIndex = -1;
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;
	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;
	m_pNoticementData = 0;
	m_stCityStatus[1].iCrimes = 0; // UNIDENTIFIED
	m_stCityStatus[1].iFunds  = 0; // UNIDENTIFIED
	m_stCityStatus[1].iWins   = 0; // UNIDENTIFIED
	m_stCityStatus[2].iCrimes = 0; // UNIDENTIFIED
	m_stCityStatus[2].iFunds  = 0; // UNIDENTIFIED
	m_stCityStatus[2].iWins   = 0; // UNIDENTIFIED
	m_iAutoRebootingCount	= 0;
	m_bReceivedItemList = FALSE;
	///////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////Modifications////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////
	m_bEnemyKillMode		= FALSE; 
	m_iEnemyKillAdjust      = 1; 
	m_bAdminSecurity		= TRUE; 
	m_sRaidTimeMonday		= 0; 
	m_sRaidTimeTuesday      = 0; 
	m_sRaidTimeWednesday	= 0; 
	m_sRaidTimeThursday     = 0; 
	m_sRaidTimeFriday		= 0; 
	m_sRaidTimeSaturday     = 0; 
	m_sRaidTimeSunday		= 0;
	m_sCharPointLimit		= 0;
	m_sSlateSuccessRate		= 0;
	///////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////
	m_dwHeldenianWarTime	= 15*60*1000;  // 15 minutes before effective War start
	m_dwHeldenianEndTime	= 105*60*1000; // 90 minutes effective battle
	m_bNpcItemConfig = FALSE;
	m_iNotifyCleanMap = TRUE;
	m_iMaxGizonPerLevel = 1;
	m_iMaxGizonItem = 1000;
}

CGame::~CGame()
{
}

/*********************************************************************************************************************
**  BOOL CGame::bAccept																								**
**  DESCRIPTION			:: function following player connect														**
**  LAST_UPDATED		:: March 13, 2005; 9:34 AM; Hypnotoad														**
**	RETURN_VALUE		:: BOOL																						**
**  NOTES				::	- added (m_bIsWLServerAvailable == FALSE)												**
**							- modified "<%d> New client: %s" to "<%d> Client connected: (%s)"						**
**							- added "Maximum Players: %d" code														**
**  MODIFICATION		::	- added print message if CLOSE_ANYWAY													**
**********************************************************************************************************************/
BOOL CGame::bAccept(class XSocket * pXSock)
{
	int i, x, iTotalip = 0;
	class XSocket * pTmpSock;
	if ((m_bIsGateSockAvailable == FALSE)  || (m_bIsLogSockAvailable == FALSE)   || 
		(m_bIsItemAvailable == FALSE)      || (m_bIsNpcAvailable == FALSE)       || 
		(m_bIsMagicAvailable == FALSE)     || (m_bIsSkillAvailable == FALSE)     || 
		(m_bIsPotionAvailable == FALSE)    || (m_bOnExitProcess == TRUE)         || 
		(m_bIsQuestAvailable == FALSE)     || (m_bIsBuildItemAvailable == FALSE) || 
		(m_bIsGameStarted == FALSE))
		goto CLOSE_ANYWAY;
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] == NULL) {	
			m_pClientList[i] = new class CClient(m_hWnd);
			bAddClientShortCut(i);
			m_pClientList[i]->m_dwSPTime = m_pClientList[i]->m_dwMPTime = m_pClientList[i]->m_dwHPTime = 
				m_pClientList[i]->m_dwAutoSaveTime = m_pClientList[i]->m_dwTime = m_pClientList[i]->m_dwHungerTime = 
					m_pClientList[i]->m_dwExpStockTime = m_pClientList[i]->m_dwRecentAttackTime = 
						m_pClientList[i]->m_dwAutoExpTime = m_pClientList[i]->m_dwSpeedHackCheckTime = timeGetTime();
			pXSock->bAccept(m_pClientList[i]->m_pXSock, WM_ONCLIENTSOCKETEVENT + i); 
			ZeroMemory(m_pClientList[i]->m_cIPaddress, sizeof(m_pClientList[i]->m_cIPaddress));
			m_pClientList[i]->m_pXSock->iGetPeerAddress(m_pClientList[i]->m_cIPaddress);
			//centu: Anti-Downer
			for (x = 1; x < DEF_MAXCLIENTS; x++) 
			if(m_pClientList[x] != NULL) { 
				if(strcmp(m_pClientList[x]->m_cIPaddress, m_pClientList[i]->m_cIPaddress) == 0) iTotalip++; 
			} 
			if(iTotalip > 10) {
				delete m_pClientList[i]; 
				m_pClientList[i] = NULL; 
				return FALSE; 
			} 
			if(strlen(m_pClientList[i]->m_cIPaddress) < 10) { 
				delete m_pClientList[i]; 
				m_pClientList[i] = NULL; 
				return FALSE; 
			}
			wsprintf(G_cTxt,"<%d> Client connected: (%s)", i, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);
			m_iTotalClients++;
			if (m_iTotalClients > m_iMaxClients) { 
				m_iMaxClients = m_iTotalClients;
				// new March 13, 2005 - Hypnotoad
				GetLocalTime(&m_MaxUserSysTime);
				wsprintf(G_cTxt, "Maximum Players: %d", m_iMaxClients);
				PutLogFileList(G_cTxt);
			}
			return TRUE;
		}
CLOSE_ANYWAY:;
	/****MODIFICATION****/
	wsprintf(G_cTxt,"(!) bAccept->CLOSE_ANYWAY");
	PutLogList(G_cTxt);
	/********END*********/
	pTmpSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	pXSock->bAccept(pTmpSock, NULL); 
	delete pTmpSock;
	return FALSE;
}

/*********************************************************************************************************************
**  void CGame::OnClientSocketEvent																					**
**  DESCRIPTION			:: socket connection manager																**
**  LAST_UPDATED		:: March 13, 2005; 9:58 AM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- removed DEF_XSOCKEVENT_BLOCK															**
**							- modified DeleteClient																	**
**	MODIFICATION		::	- Added Logout Hack Check code															**
**********************************************************************************************************************/
void CGame::OnClientSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 UINT iTmp;
 int iClientH, iRet;
 DWORD dwTime = timeGetTime();

	iTmp = WM_ONCLIENTSOCKETEVENT;
	iClientH = message - iTmp;
	if (m_pClientList[iClientH] == NULL) return;
	iRet = m_pClientList[iClientH]->m_pXSock->iOnSocketEvent(wParam, lParam);
	switch (iRet) {
	case DEF_XSOCKEVENT_READCOMPLETE:
		OnClientRead(iClientH);
		m_pClientList[iClientH]->m_dwTime = timeGetTime();
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		wsprintf(G_cTxt,"<%d> Confirmcode notmatch!", iClientH);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, FALSE, TRUE, TRUE, FALSE);
		break;
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		wsprintf(G_cTxt,"<%d> Client connection Lost! (%s)", iClientH, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(G_cTxt); 
		/****MODIFICATION****/
		if ((dwTime - m_pClientList[iClientH]->m_dwLogoutHackCheck) < 10000) { // 1000 -> 10000
			wsprintf(G_cTxt, "Logout Hack: (%s) Player: (%s) - disconnected within 10 seconds of most recent damage. Hack? Lag?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
		}
		/********END*********/
		DeleteClient(iClientH, TRUE, TRUE, TRUE, FALSE);
		break;
	}													    
}

/*********************************************************************************************************************
**  BOOL CGame::bInit()		   																						**
**  DESCRIPTION			:: general variable initializer																**
**  LAST_UPDATED		:: March 13, 2005; 8:00 PM; Hypnotoad														**
**	RETURN_VALUE		:: BOOL																						**
**  NOTES				::	- Added Nulliy to "m_pTeleportDestination[i]"											**
**							- reduced MaxLevel from 3500 to 300														**
**							- changed DEF_MAXGATESERVERSTOCKMSGSIZE from 10000 to 30000								**
**							- added m_bIsApocalypseStarter, m_bIsApocalypseGateOpen, m_cApocalypseMapName,			**
**							  m_bHeldinianDuty, m_bF10pressed, m_cHeldenianMapName, m_bIsHeldenianReady				**
**							- missing <13> variables																**
**							- <6> variables unidentified															**
**	MODIFICATION		::	- Added read to Settings.cfg, AdminList.cfg, BannedList.cfg, AdminSettings.cfg			**
**							- Added Admin and Banned List initialization											**
**							- Added initialization to Apocalypse end/start and Heldenian Timer						**
**********************************************************************************************************************/
BOOL CGame::bInit()		   
{
 char * cp, cTxt[120];
 DWORD * dwp;
 WORD * wp;
 int  i;
 SYSTEMTIME SysTime;
 DWORD dwTime = timeGetTime();

	PutLogList("(!) INITIALIZING GAME SERVER...");
#ifdef DEF_DBGAMESERVER
	for (i = 0; i < DEF_MAXCLIENTS+1; i++)  	m_iClientShortCut[i] = 0;
	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) 	SAFEDELETE(m_pSubLogSock[i]);
	for (i = 0; i < DEF_MAXCLIENTS; i++)            SAFEDELETE(m_pClientList[i]);
	for (i = 0; i < DEF_MAXNPCS; i++)               SAFEDELETE(m_pNpcList[i]);
	for (i = 0; i < DEF_MAXMAPS; i++)               SAFEDELETE(m_pMapList[i]);
	for (i = 0; i < DEF_MAXITEMTYPES; i++)          SAFEDELETE(m_pItemConfigList[i]);
	for (i = 0; i < DEF_MAXNPCTYPES; i++)           SAFEDELETE(m_pNpcConfigList[i]);
	for (i = 0; i < DEF_MAXMAGICTYPE; i++)          SAFEDELETE(m_pMagicConfigList[i]);
	for (i = 0; i < DEF_MAXSKILLTYPE; i++)          SAFEDELETE(m_pSkillConfigList[i]);
	for (i = 0; i < DEF_MAXQUESTTYPE; i++)          SAFEDELETE(m_pQuestConfigList[i]);
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)     SAFEDELETE(m_pDynamicObjectList[i]);
	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)        SAFEDELETE(m_pDelayEventList[i]);
	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)         SAFEDELETE(m_pNoticeMsgList[i]);
	for (i = 0; i < DEF_MAXFISHS; i++)              SAFEDELETE(m_pFish[i]);
	for (i = 0; i < DEF_MAXMINERALS; i++)           SAFEDELETE(m_pMineral[i]);
	for (i = 0; i < DEF_MAXPOTIONTYPES; i++)       SAFEDELETE(m_pPotionConfigList[i]);
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)         SAFEDELETE(m_pBuildItemList[i]);
#else
	for (i = 0; i < DEF_MAXCLIENTS+1; i++) 
		m_iClientShortCut[i] = 0;
	if (m_pMainLogSock != NULL) delete m_pMainLogSock;
	if (m_pGateSock != NULL) delete m_pGateSock;
	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];
	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) delete m_pClientList[i];
	for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) delete m_pNpcList[i];
	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != NULL) delete m_pMapList[i];
	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];
	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		if (m_pNpcConfigList[i] != NULL) delete m_pNpcConfigList[i];
	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];
	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];
	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];
	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];
	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];
	for (i = 0; i < DEF_MAXFISHS; i++)
		if (m_pFish[i] != NULL) delete m_pFish[i];
	for (i = 0; i < DEF_MAXMINERALS; i++)
		if (m_pMineral[i] != NULL) delete m_pMineral[i];
	for (i = 0; i < DEF_MAXPOTIONTYPES; i++) {
		if (m_pPotionConfigList[i] != NULL) delete m_pPotionConfigList[i];
		if (m_pCraftingConfigList[i] != NULL) delete m_pCraftingConfigList[i];	// Crafting
	}
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];
#endif
	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_iNpcConstructionPoint[i] = NULL;
	for (i = 0; i < DEF_MAXSCHEDULE; i++) {
		m_stCrusadeWarSchedule[i].iDay = -1;
		m_stCrusadeWarSchedule[i].iHour = -1;
		m_stCrusadeWarSchedule[i].iMinute = -1;
	}	
	m_iNpcConstructionPoint[1]  = 100; // MS
	m_iNpcConstructionPoint[2]  = 100; // MS
	m_iNpcConstructionPoint[3]  = 100; // MS
	m_iNpcConstructionPoint[4]  = 100; // MS
	m_iNpcConstructionPoint[5]  = 100; // MS
	m_iNpcConstructionPoint[6]  = 100; // MS
	m_iNpcConstructionPoint[43] = 1000; // LWB
	m_iNpcConstructionPoint[44] = 2000; // GHK
	m_iNpcConstructionPoint[45] = 3000; // GHKABS
	m_iNpcConstructionPoint[46] = 2000; // TK
	m_iNpcConstructionPoint[47] = 3000; // BG
	m_iNpcConstructionPoint[51] = 1500; // Catapult
	m_bIsGameStarted = FALSE;
	m_pMainLogSock = NULL;
	m_pGateSock = NULL;
	m_bIsLogSockAvailable   = FALSE;
	m_bIsGateSockAvailable  = FALSE;
	m_bIsItemAvailable      = FALSE;
	m_bIsBuildItemAvailable = FALSE;
	m_bIsNpcAvailable       = FALSE;
	m_bIsMagicAvailable     = FALSE;
	m_bIsSkillAvailable     = FALSE;
	m_bIsQuestAvailable     = FALSE;
	m_bIsPotionAvailable    = FALSE;
	m_bIsWLServerAvailable  = FALSE;
	ZeroMemory(m_cServerName, sizeof(m_cServerName));
	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = NULL;
	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = NULL;
	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = NULL;
	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;
	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;
	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;
	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = NULL;
	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = NULL;
	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = NULL;
	for (i = 0; i < DEF_MAXPOTIONTYPES; i++) {
		m_pPotionConfigList[i] = NULL;
		m_pCraftingConfigList[i] = NULL;	// Crafting
	}
	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
	}
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = NULL;
	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		ZeroMemory(m_stCrusadeStructures[i].cMapName, sizeof(m_stCrusadeStructures[i].cMapName));
		m_stCrusadeStructures[i].cType = NULL;
		m_stCrusadeStructures[i].dX    = NULL;
		m_stCrusadeStructures[i].dY    = NULL;
	}
	// new
	for (i = 0; i < DEF_MAXTELEPORTDESTINATION; i++)
		m_pTeleportDestination[i] = NULL;
	for (i = 0; i < DEF_MAXGUILDS; i++)
		m_pGuildTeleportLoc[i].m_iV1 = NULL;

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		m_stMiddleCrusadeStructureInfo[i].cType = NULL;
		m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
		m_stMiddleCrusadeStructureInfo[i].sX = NULL;
		m_stMiddleCrusadeStructureInfo[i].sY = NULL;
	}
	m_iTotalMiddleCrusadeStructures = 0;
	m_pNoticementData = NULL;
	m_iQueneHead = 0;
	m_iQueneTail = 0;
	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;
	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;
	m_MaxUserSysTime.wHour   = 0;
	m_MaxUserSysTime.wMinute = 0;
	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;
	m_iMiddlelandMapIndex = -1;
	m_iAresdenMapIndex    = -1;
	m_iElvineMapIndex     = -1;
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;
	m_iSubLogSockInitIndex   = 0;
	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;
	///////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////Modifications////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////
	for (i = 0; i < DEF_MAXAPOCALYPSE; i++) {
		m_stApocalypseScheduleStart[i].iDay = -1;
		m_stApocalypseScheduleStart[i].iHour = -1;
		m_stApocalypseScheduleStart[i].iMinute = -1;
	}
	for (i = 0; i < DEF_MAXHELDENIAN; i++) {
		m_stHeldenianSchedule[i].iDay = -1;
		m_stHeldenianSchedule[i].StartiHour = -1;
		m_stHeldenianSchedule[i].StartiMinute = -1;
		m_stHeldenianSchedule[i].EndiHour = -1;
		m_stHeldenianSchedule[i].EndiMinute = -1;
	}

	for (i = 0; i < DEF_MAXAPOCALYPSE; i++) {
		m_stApocalypseScheduleEnd[i].iDay = -1;
		m_stApocalypseScheduleEnd[i].iHour = -1;
		m_stApocalypseScheduleEnd[i].iMinute = -1;
	}
	for (i = 0; i < DEF_MAXADMINS; i++) {
		ZeroMemory(m_stAdminList[i].m_cGMName, sizeof(m_stAdminList[i].m_cGMName));
	}

	for (i = 0; i < DEF_MAXBANNED; i++) {
		ZeroMemory(m_stBannedList[i].m_cBannedIPaddress, sizeof(m_stBannedList[i].m_cBannedIPaddress));
	}
	///////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////
	m_stCityStatus[1].iCrimes = 0; // UNIDENTIFIED
	m_stCityStatus[1].iFunds  = 0; // UNIDENTIFIED
	m_stCityStatus[1].iWins   = 0; // UNIDENTIFIED
	m_stCityStatus[2].iCrimes = 0; // UNIDENTIFIED
	m_stCityStatus[2].iFunds  = 0; // UNIDENTIFIED
	m_stCityStatus[2].iWins   = 0; // UNIDENTIFIED
	m_iStrategicStatus = 0;
	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;
	m_iAresdenMana = 0;
	m_iElvineMana  = 0;
	m_dwSpecialEventTime = m_dwWhetherTime = m_dwGameTime1 = m_dwGameTime2 = m_dwGameTime3 = 
		m_dwGameTime4 = m_dwGameTime5 = m_dwGameTime6 = m_dwFishTime = dwTime;
	m_bIsSpecialEventTime = FALSE;
	GetLocalTime(&SysTime);
	m_dwCanFightzoneReserveTime = dwTime - ((SysTime.wHour%2)*60*60 + SysTime.wMinute*60)*1000;
	for(i =0; i < DEF_MAXFIGHTZONE; i++) 
		m_iFightZoneReserve[i] = 0 ;
	m_iFightzoneNoForceRecall = 0;
	for (i = 1; i < 300; i++) {
		m_iLevelExpTable[i] = iGetLevelExp(i);
	}
	m_iLimitedUserExp = m_iLevelExpTable[DEF_LEVELLIMIT+1];
	m_iLevelExp20     = m_iLevelExpTable[20]; 
	m_iGameServerMode = 0;
	if (bReadProgramConfigFile("GServer.cfg") == FALSE) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! GServer.cfg file contents error!");
		return FALSE;	
	}
	/****MODIFICATION****/
	if (bReadSettingsConfigFile("..\\GameConfigs\\Settings.cfg") == FALSE) {;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Settings.cfg file contents error!");
		return FALSE;
	}
	if (bReadAdminListConfigFile("..\\GameConfigs\\AdminList.cfg") == FALSE) {;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! AdminList.cfg file contents error!");
		return FALSE;
	}
	if (bReadBannedListConfigFile("..\\GameConfigs\\BannedList.cfg") == FALSE) {;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! BannedList.cfg file contents error!");
		return FALSE;
	}
	if (bReadAdminSetConfigFile("..\\GameConfigs\\AdminSettings.cfg") == FALSE) {;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! AdminSettings.cfg file contents error!");
		return FALSE;
	}	
	if (bReadMajesticLogSettings() == FALSE) 
	{	PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! MajesticSettings.cfg file contents error!");
		return FALSE;
	}
	/********END*********/
	srand((unsigned)time(NULL));   
	m_pMainLogSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	m_pMainLogSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_ONLOGSOCKETEVENT);
	m_pMainLogSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
	wsprintf(cTxt, "(!) Try to Connect main-log-socket... Addr:%s  Port:%d", m_cLogServerAddr, m_iLogServerPort);
	PutLogList(cTxt);
	m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
	m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
	m_iGateSockConnRetryTimes = 1;
	wsprintf(cTxt, "(!) Try to Connect Gate Server... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
	PutLogList(cTxt);
	// modification - m_bF5pressed
	m_bF1pressed = m_bF4pressed = m_bF12pressed = m_bF5pressed = FALSE; 
	m_bOnExitProcess = FALSE;
	for (i = 0; i <= 100; i++) {
		m_iSkillSSNpoint[i] = _iCalcSkillSSNpoint(i);
	}
	GetLocalTime(&SysTime);
	if (SysTime.wHour >= 20 || SysTime.wHour <= 5)  
		 m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	bReadNotifyMsgListFile("notice.txt");
	m_dwNoticeTime = dwTime;
	m_iCurSubLogSockIndex    = 0;
	m_iSubLogSockFailCount   = 0;
	m_iSubLogSockActiveCount = 0;
	m_pNoticementData      = NULL;
	m_dwNoticementDataSize = 0;
	m_dwMapSectorInfoTime = dwTime;
	m_iMapSectorInfoUpdateCount = 0;
	m_iCrusadeCount  = NULL;
	m_bIsCrusadeMode = FALSE;
	m_wServerID_GSS = iDice(1,65535);
	// changed DEF_MAXGATESERVERSTOCKMSGSIZE from 10000 to 30000
	ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
	cp = (char *)m_cGateServerStockMsg;
	dwp = (DWORD *)cp;
	*dwp = MSGID_SERVERSTOCKMSG;
	cp += 4;
	wp = (WORD *)cp;
	*wp = DEF_MSGTYPE_CONFIRM;
	cp += 2;
	m_iIndexGSS = 6;
	m_dwCrusadeGUID   = NULL;
	m_iCrusadeWinnerSide = NULL;
	m_iLastCrusadeWinner = 0;
	// <MISSING_VARIABLE_HERE> 107704h - unknown variable and unreferenced!
	m_bIsCrusadeWarStarter = FALSE;
	m_iLatestCrusadeDayOfWeek = -1;
	m_iFinalShutdownCount = 0;
	m_bIsApocalypseMode = FALSE;
	m_bIsApocalypseStarter = FALSE; // new
	m_bIsApocalypseGateOpen = FALSE; // new
	ZeroMemory(m_cApocalypseMapName, sizeof(m_cApocalypseMapName)); // new
	bDeathmatch = FALSE;
	iLastKill = -1;
	iTotalKills = 0;
	dwTimeLastKill = timeGetTime();
	iDGtop1=iDGtop2=iDGtop3=iDGtop4=iDGtop5=iDGtop6=iDGtop7=iDGtop8=iDGtop9=iDGtop10=0;
	// 	Heldenian
	m_bIsHeldenianMode			 = FALSE;
	m_bHeldenianWarInitiated	 = FALSE;
	m_cHeldenianType			 = 0;
	m_sLastHeldenianWinner		 = 0; 
	m_cHeldenianWinner			 = -1;
	m_dwHeldenianGUID			 = NULL;
	m_dwHeldenianWarStartTime	 = 0;
	m_dwHeldenianFinishTime		 = 0;
	m_cHeldenianFirstDestroyedTowerWinner = -1;
	m_iHeldenianAresdenDead		 = 0;
	m_iHeldenianElvineDead		 = 0;
	m_iHeldenianAresdenFlags	 = 0;
	m_iHeldenianElvineFlags		 = 0;
	m_iHeldenianAresdenLeftTower = 0;
	m_iHeldenianElvineLeftTower  = 0;
	ZeroMemory(m_cHeldenianMapName, sizeof(m_cHeldenianMapName)); // new
	m_bF10pressed = FALSE; // new

	m_dwCleanTime = dwTime;

	m_bIsEventEnabled = FALSE;
	m_bIsEventTPEnabled = FALSE;
	ZeroMemory(cEventMapName, sizeof(cEventMapName));

	return TRUE;
}

/*********************************************************************************************************************
**  void CGame::OnClientRead																						**
**  DESCRIPTION			:: reports error message if client data invalid												**
**  LAST_UPDATED		:: March 13, 2005; 8:25 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				:: none																						**
**	MODIFICATION		:: none																						**
**********************************************************************************************************************/
void CGame::OnClientRead(int iClientH)
{
 char  * pData, cKey;
 DWORD  dwMsgSize;
	
	if (m_pClientList[iClientH] == NULL) return;
	pData = m_pClientList[iClientH]->m_pXSock->pGetRcvDataPointer(&dwMsgSize, &cKey);
	if (bPutMsgQuene(DEF_MSGFROM_CLIENT, pData, dwMsgSize, iClientH, cKey) == FALSE) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}

/*********************************************************************************************************************
**  void CGame::DisplayInfo																							**
**  DESCRIPTION			:: prints header																			**
**  LAST_UPDATED		:: March 13, 2005; 9:06 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				:: none																						**
**	MODIFICATION		:: links to GayDave to print personalized message											**
**********************************************************************************************************************/
void CGame::DisplayInfo(HDC hdc)
{
 char cTxt[350];  
 int  i, iLine;

    TextOut(hdc, 650, 4, "[Server Config]", 15);
    wsprintf(cTxt, "Server Name: %s", m_cServerName);
    TextOut(hdc, 605, 40, cTxt, strlen(cTxt));
    wsprintf(cTxt, "Max Level: %d", m_iPlayerMaxLevel);
    TextOut(hdc, 605, 55, cTxt, strlen(cTxt));
    wsprintf(cTxt, "Max Stats: %d", m_sCharStatLimit);
    TextOut(hdc, 605, 70, cTxt, strlen(cTxt));
    wsprintf(cTxt, "Players online: %d", m_iTotalGameServerClients);
    TextOut(hdc, 605, 85, cTxt, strlen(cTxt));
    wsprintf(cTxt, "EK per Kill: %d", m_iEnemyKillAdjust);
    TextOut(hdc, 605, 100, cTxt, strlen(cTxt));
    wsprintf(cTxt, "Total Players: %d", m_iTotalGameServerMaxClients);
    TextOut(hdc, 605, 115, cTxt, strlen(cTxt));
    ZeroMemory(cTxt, sizeof(cTxt));
    TextOut(hdc, 602, 220, "   ", 3);
    TextOut(hdc, 605, 130, "__________________________", 32);
    TextOut(hdc, 605, 160, "[MAPS]                  [MOBS]", 30);

    iLine = 0;
    for (i = 0; i < DEF_MAXMAPS; i++)
    if (m_pMapList[i] != NULL) {
        ZeroMemory(G_cTxt, sizeof(G_cTxt));
        wsprintf(G_cTxt, m_pMapList[i]->m_cName);
        TextOut(hdc, 605, 175 + iLine*14, G_cTxt, strlen(G_cTxt));
        wsprintf(G_cTxt, "%d",m_pMapList[i]->m_iTotalActiveObject);
        TextOut(hdc, 740, 175 + iLine*14, G_cTxt, strlen(G_cTxt));
        iLine++;
    }
 
}

/*********************************************************************************************************************
**  void CGame::ClientMotionHandler																					**
**  DESCRIPTION			:: controls most client actions																**
**  LAST_UPDATED		:: March 13, 2005; 10:19 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				:: - in DEF_OBJECTATTACKMOVE iRet 1's iClientMotion_Attack_Handler bResponse set to TRUE	**
**	MODIFICATION		:: - added checks and logging to 2 variants of magic hacks (instant packet, speed)			**
**********************************************************************************************************************/
void CGame::ClientMotionHandler(int iClientH, char * pData)
{
 DWORD * dwp, dwClientTime;
 WORD * wp, wCommand, wTargetObjectID;
 short * sp, sX, sY, dX, dY, wType;
 char  * cp, cDir;
 int   iRet, iTemp;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;

	sp = (short *)cp;
	dX = *sp;
	cp += 2;

	sp = (short *)cp;
	dY = *sp;
	cp += 2;

	sp = (short *)cp;
	wType = *sp;
	cp += 2;

	if ((wCommand == DEF_OBJECTATTACK) || (wCommand == DEF_OBJECTATTACKMOVE)) {
		wp = (WORD *)cp;
		wTargetObjectID = *wp;
		cp += 2;
	}
	dwp = (DWORD *)cp;
	dwClientTime = *dwp;
	cp += 4;

	if (!CheckDenialServiceAttack(iClientH, dwClientTime)) return;

	m_pClientList[iClientH]->m_dwLastActionTime = m_pClientList[iClientH]->m_dwAFKCheckTime = timeGetTime();

	switch (wCommand) {
	case DEF_OBJECTSTOP:
		iRet = iClientMotion_Stop_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTSTOP, NULL, NULL, NULL);
		}
		else if (iRet == 2) {
			SendObjectMotionRejectMsg(iClientH);
		}
		break;

	case DEF_OBJECTRUN:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 1);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTRUN, NULL, NULL, NULL);
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) {
			ClientKilledHandler(iClientH, NULL, NULL, 1);
		}
		bCheckClientMoveFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 2);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) {
			ClientKilledHandler(iClientH, NULL, NULL, 1);
		}
		bCheckClientMoveFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTDAMAGEMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 0);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, m_pClientList[iClientH]->m_iLastDamage, NULL, NULL);
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) {
			ClientKilledHandler(iClientH, NULL, NULL, 1);
		}
		break;

	case DEF_OBJECTATTACKMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 0);
		if ((iRet == 1) && (m_pClientList[iClientH] != NULL)) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACKMOVE, NULL, NULL, NULL);
			// changed bResponse to TRUE
			iClientMotion_Attack_Handler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, wType, cDir, wTargetObjectID, FALSE, TRUE);
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) {
			ClientKilledHandler(iClientH, NULL, NULL, 1);
		}
		bCheckClientAttackFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTATTACK:
		_CheckAttackType(iClientH, &wType);
		iRet = iClientMotion_Attack_Handler(iClientH, sX, sY, dX, dY, wType, cDir, wTargetObjectID, TRUE, FALSE);
		if (iRet == 1) {
			if (wType >= 20) {
				m_pClientList[iClientH]->m_iSuperAttackLeft--;
				if (m_pClientList[iClientH]->m_iSuperAttackLeft < 0) m_pClientList[iClientH]->m_iSuperAttackLeft = 0;
			}
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, wType);
		}
		else if (iRet == 2) {
			SendObjectMotionRejectMsg(iClientH);
		}
		bCheckClientAttackFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTGETITEM:
		iRet = iClientMotion_GetItem_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTGETITEM, NULL, NULL, NULL);
		}
		else if (iRet == 2) {
			SendObjectMotionRejectMsg(iClientH);
		}
		break;

	case DEF_OBJECTMAGIC:
		iRet = iClientMotion_Magic_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			/****MODIFICATION****/
			if (m_pClientList[iClientH]->m_bMagicPauseTime == FALSE) {
				m_pClientList[iClientH]->m_bMagicPauseTime = TRUE;
				iTemp = 10;
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMAGIC, dX, iTemp, NULL);
				m_pClientList[iClientH]->m_iSpellCount++;
				bCheckClientMagicFrequency(iClientH, dwClientTime);
			}
			else if (m_pClientList[iClientH]->m_bMagicPauseTime == TRUE) {
				wsprintf(G_cTxt, "Cast Delay Hack: (%s) Player: (%s) - player casting too fast.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
				DeleteClient(iClientH, TRUE, TRUE);
			}
			/********END*********/
		}
		else if (iRet == 2) {
			SendObjectMotionRejectMsg(iClientH);
		}
		break;

	default:
		break;
	}
}

/*********************************************************************************************************************
**  int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, char cMoveType)				**
**  DESCRIPTION			:: Handles how player or npc run, walk, attack, or get flown by attack						**
**  LAST_UPDATED		:: March 14, 2005; 11:34 AM; Hypnotoad														**
**	RETURN_VALUE		:: int																						**
**  NOTES				::	- added speed hack detection															**
**							- cMoveType changed from bRun															**
**							- added apocalypse gate teleporter														**
**							- added motion isBlocked (1050)															**
**	MODIFICATION		:: none																						**
**********************************************************************************************************************/
int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, char cMoveType)
{
 char  * cp, cData[3000];
 class CTile * pTile;
 DWORD * dwp, dwTime;
 WORD  * wp, wObjectID;
 short * sp, dX, dY, sDOtype, pTopItem, wV1, wV2;
 int   * ip, iRet, iSize, iDamage, iStX, iStY, iTemp, iTemp2;
 BOOL  bRet, bIsBlocked = FALSE;
 char cTemp[11];

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	if ((sX != m_pClientList[iClientH]->m_sX) && (sY != m_pClientList[iClientH]->m_sY)) return 2;
	
	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;
	
	// new - speed hack detection
	if (cMoveType == 2) {
		if (m_pClientList[iClientH]->m_iRecentWalkTime <= dwTime - 16) {
			m_pClientList[iClientH]->m_iRecentWalkTime = dwTime;
		}
		else if ((m_pClientList[iClientH]->m_sV1 >= 1) && (dwTime < m_pClientList[iClientH]->m_iRecentWalkTime)) {
			wsprintf(G_cTxt, "Test iClientMotion_Move_Handler walk");
			PutHackLogFileList(G_cTxt);
			bIsBlocked = TRUE;
			m_pClientList[iClientH]->m_sV1 = 0;	
		}
		else {
			m_pClientList[iClientH]->m_sV1++;	
		}
		m_pClientList[iClientH]->m_iRecentWalkTime = dwTime;
		if (bIsBlocked == FALSE) m_pClientList[iClientH]->m_iMoveMsgRecvCount++;
		if ((m_pClientList[iClientH]->m_iMoveMsgRecvCount >= 3) && (m_pClientList[iClientH]->m_dwMoveLAT != 0)) {
			if ((m_pClientList[iClientH]->m_dwMoveLAT - dwTime) < 20) {
				wsprintf(G_cTxt, "3.51 Walk Speeder: (%s) Player: (%s) walk difference: %d. Speed Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, (dwTime - m_pClientList[iClientH]->m_dwMoveLAT));
				PutHackLogFileList(G_cTxt);
				bIsBlocked = TRUE;
			}
		}
		m_pClientList[iClientH]->m_dwMoveLAT = dwTime;
		m_pClientList[iClientH]->m_iMoveMsgRecvCount = 0;
	}
	else if (cMoveType == 1) {
		if (m_pClientList[iClientH]->m_iRecentRunTime <= dwTime - 8) {
			m_pClientList[iClientH]->m_iRecentRunTime = dwTime;
		}
		else if ((m_pClientList[iClientH]->m_sV1 >= 1) && (dwTime < m_pClientList[iClientH]->m_iRecentRunTime)) {
			wsprintf(G_cTxt, "Test iClientMotion_Move_Handler run");
			PutHackLogFileList(G_cTxt);
			bIsBlocked = TRUE;
			m_pClientList[iClientH]->m_sV1 = 0;
		}
		else {
			m_pClientList[iClientH]->m_sV1++;
		}
		m_pClientList[iClientH]->m_iRecentRunTime = dwTime;
		if (bIsBlocked == FALSE) m_pClientList[iClientH]->m_iRunMsgRecvCount++;
		if ((m_pClientList[iClientH]->m_iRunMsgRecvCount >= 3) && (m_pClientList[iClientH]->m_dwRunLAT != 0)) {
			if ((dwTime - m_pClientList[iClientH]->m_dwRunLAT) < 12) {
				wsprintf(G_cTxt, "3.51 Run Speeder: (%s) Player: (%s) run difference: %d. Speed Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, (dwTime - m_pClientList[iClientH]->m_dwRunLAT));
				PutHackLogFileList(G_cTxt);
				bIsBlocked = TRUE;
			}
		}
		m_pClientList[iClientH]->m_dwRunLAT	= dwTime;
		m_pClientList[iClientH]->m_iRunMsgRecvCount = 0;
	}
	// end speed hack detection

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
		switch (m_pClientList[iClientH]->m_cSide) {
			case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
			case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
			case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	
	ClearSkillUsingStatus(iClientH);	
	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;
	switch (cDir) {
		case 1:	dY--; break;
		case 2:	dX++; dY--;	break;
		case 3:	dX++; break;
		case 4:	dX++; dY++;	break;
		case 5: dY++; break;
		case 6:	dX--; dY++;	break;
		case 7:	dX--; break;
		case 8:	dX--; dY--;	break;
	}
	pTopItem = 0;
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(dX, dY, &sDOtype, &pTopItem);
	if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) bRet = FALSE;
	if ((bRet == TRUE) && (bIsBlocked == FALSE)) {
		if (m_pClientList[iClientH]->m_iQuest != NULL) _bCheckIsQuestCompleted(iClientH);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		m_pClientList[iClientH]->m_sX   = dX;
		m_pClientList[iClientH]->m_sY   = dY;
		m_pClientList[iClientH]->m_cDir = cDir;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, dX, dY);
		if (sDOtype == DEF_DYNAMICOBJECT_SPIKE) {
			if ((m_pClientList[iClientH]->m_bIsNeutral == TRUE) && ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0)) {

			}
			else {
				iDamage = iDice(2,4);
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
					m_pClientList[iClientH]->m_iHP -= iDamage;
			}
		}
		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOVE_CONFIRM;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE+2);
		
		sp  = (short *)cp;
		*sp = (short)(dX - 10); 
		cp += 2;
		
		sp  = (short *)cp;
		*sp = (short)(dY - 7); 
		cp += 2;
		
		*cp = cDir;
		cp++;
		if (cMoveType == 1) {
			if (m_pClientList[iClientH]->m_iSP > 0) {
				*cp = 0;
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
			}
			else {
				*cp = 0;
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
				if (m_pClientList[iClientH]->m_iSP < -10) {
					m_pClientList[iClientH]->m_iSP = 0;
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
				}
			}
		}
		else *cp = 0;
		cp++;

		pTile = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + dX + dY*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
		*cp = (char)pTile->m_iOccupyStatus;
		cp++;
		
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iHP;
		cp += 4;
		
		iSize = iComposeMoveMapData((short)(dX - 10), (short)(dY - 7), iClientH, cDir, cp);	
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE, TRUE, FALSE);
			return 0;
		}
		// new - apocalypse gate teleport
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsGateAvailable == TRUE) {	
			bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bApocalypseGateTeleporter(dX, dY, &*cTemp, &wV1, &wV2);
			if (bRet == 1) {
				RequestTeleportHandler(iClientH, "2   ", cTemp, wV1, wV2);
			}
		}
		// end - apocalypse gate teleport
	}
	else {
		// new motion
		m_pClientList[iClientH]->m_bIsMoveBlocked = TRUE;
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		if (bIsBlocked == TRUE) *dwp = DEF_OBJECTMOTION_BLOCKED;
			else *wp = DEF_OBJECTMOVE_REJECT;

		wObjectID = (WORD)iClientH;

		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		wp  = (WORD *)cp;
		*wp = wObjectID;
		cp += 2;

		sp  = (short *)cp;
		sX  = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;

		sp  = (short *)cp;
		sY  = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;

		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;

		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;

		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;

		ip  = (int *)cp;
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp += 4;
		
		// new
		ip  = (int *)cp;
		iTemp = m_pClientList[wObjectID]->m_iStatus;
		iTemp = 0x0FFFFFFF & iTemp;
		iTemp2 = iGetPlayerABSStatus(wObjectID, iClientH);
		iTemp  = (iTemp | (iTemp2 << 28));
		*ip = iTemp;
		cp += 4;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 42);
		
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
		return 0;
	}

	return 1;
}

/*********************************************************************************************************************
**  void CGame::RequestInitPlayerHandler(int iClientH, char * pData, char cKey)										**
**  DESCRIPTION			:: player login varifier																	**
**  LAST_UPDATED		:: March 14, 2005; 9:52 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- expanded DeleteClient and bSendMsgToLS												**
**	MODIFICATION		:: none																						**
**********************************************************************************************************************/
void CGame::RequestInitPlayerHandler(int iClientH, char * pData, char cKey)
{
 int i;
 char * cp, cCharName[11], cAccountName[11], cAccountPassword[11], cTxt[120];
 BOOL bIsObserverMode;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return;

	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(m_pClientList[iClientH]->m_cCharName, sizeof(m_pClientList[iClientH]->m_cCharName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountName, sizeof(m_pClientList[iClientH]->m_cAccountName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountPassword, sizeof(m_pClientList[iClientH]->m_cAccountPassword));

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt));
	memcpy(cTxt, cCharName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cCharName, sizeof(cCharName));
	memcpy(cCharName, cTxt, 10);

	if (strlen(cTxt) == 0) PutLogList("RIPH - cTxt: Char NULL!");

	memcpy(cAccountName, cp, 10);
	cp += 10;
	
	ZeroMemory(cTxt, sizeof(cTxt));
	memcpy(cTxt, cAccountName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountName, sizeof(cAccountName));
	memcpy(cAccountName, cTxt, 10);

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt));
	memcpy(cTxt, cAccountPassword, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	memcpy(cAccountPassword, cTxt, 10);
	
	bIsObserverMode = (BOOL)*cp;
	cp++;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cAccountName, cAccountName, 10) == 0)) {
		if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) { 
			wsprintf(G_cTxt, "<%d> Duplicate account player! Deleted with data save : CharName(%s) AccntName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);
			DeleteClient(i, TRUE, TRUE, FALSE);
		}
		else {
			memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
			DeleteClient(iClientH, FALSE, FALSE, FALSE);
			return;
		}
	}	
	
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {
		if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) { 
			wsprintf(G_cTxt, "<%d> Duplicate player! Deleted with data save : CharName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);
			DeleteClient(i, TRUE, TRUE, FALSE);	
		}
		else {
			memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
			DeleteClient(iClientH, FALSE, FALSE, TRUE, FALSE); // added TRUE at 4
			return;
		}
	}

	memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
	m_pClientList[iClientH]->m_bIsObserverMode = bIsObserverMode;
	bSendMsgToLS(MSGID_REQUEST_PLAYERDATA, iClientH, TRUE); // added TRUE to 3
}

/*********************************************************************************************************************
**  void CGame::RequestInitDataHandler																				**
**  DESCRIPTION			:: manages player data/variables on enter zone												**
**  LAST_UPDATED		:: March 15, 2005; 7:32 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- added bIsResurrected to save process time												**
**						 	- added m_cWarType																		**
**						 	- expanded DeleteClient to include TRUE(4)												**
**						 	- missing <4> cp++																		**
**						 	- added temporary position list to stop items from scrambling on enter zone				**
**						 	- added checks to _iGetArrowItemIndex, and CalcTotalItemEffect							**
**						 	- forces player above 100 and in own town to become citizen								**
**						 	- completely redid force recall on login												**
**						 	- m_bIsInsideEnemyBuilding stores if have been inside enemy buildings					**
**						 	- now heldinain compatible (stores GUID and summon points)								**
**						 	- changed "fightzone" to "fight"														**
**						 	- notifies player if apocalypse gate is open as he enters zone							**
**	MODIFICATION		:: none																						**
**********************************************************************************************************************/
void CGame::RequestInitDataHandler(int iClientH, char * pData, char cKey, BOOL bIsResurrected)
{
 short * sp, sSummonPoints;
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cPlayerName[11], cTxt[120], cPoints;
 int   * ip, i, iTotalItemA, iTotalItemB, iSize, iRet;
 SYSTEMTIME SysTime;
 char  * pBuffer = NULL;
 int iMapSide, iMapSide2;
 BOOL bIsItemListNull;
 POINT TempItemPosList[DEF_MAXITEMS];

	if (m_pClientList[iClientH] == NULL) return;
	pBuffer = new char [DEF_MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE+1);

	// new - check to save time process time when resurrecting
	if (bIsResurrected == FALSE) {
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		ZeroMemory(cPlayerName, sizeof(cPlayerName));

		memcpy(cPlayerName, cp, 10);
		ZeroMemory(cTxt, sizeof(cTxt));

		memcpy(cTxt, cPlayerName, 10);
		m_Misc.bDecode(cKey, cTxt);

		ZeroMemory(cPlayerName, sizeof(cPlayerName));
		memcpy(cPlayerName, cTxt, 10);

		if (memcmp(m_pClientList[iClientH]->m_cCharName, cPlayerName, 10) != 0) {
			DeleteClient(iClientH, FALSE, TRUE, TRUE, FALSE); // added TRUE to 4
			return;
		}
	}
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERCHARACTERCONTENTS;
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iSP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDefenseRatio;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHitRatio;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iLevel;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iStr;		
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iInt;					
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iVit;								
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDex;			
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMag;						
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iCharisma;
	cp  += 4;

	wp = (WORD *)cp; 
	*wp = m_pClientList[iClientH]->m_iLU_Pool;
	cp += 2;

	*cp = m_pClientList[iClientH]->m_cWarType; // new
	cp++;

	*cp = 0; // missing data
	cp++;

	*cp = 0; // missing data
	cp++;

	*cp = 0; // missing data
	cp++;

	*cp = 0; // missing data
	cp++;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iExp;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iEnemyKillCount;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMaxEK;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iPKCount;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iRewardGold;
	cp  += 4;

	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp  += 10;

	memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
	cp  += 20;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iGuildRank;
	cp  += 4;

	*cp = (char)m_pClientList[iClientH]->m_iSuperAttackLeft;
	cp++;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iFightzoneNumber;
	cp  += 4;
 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 116);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE, TRUE, FALSE); // added TRUE (4)
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERITEMLISTCONTENTS;
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	iTotalItemA = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
			iTotalItemA++;

	// new
	bIsItemListNull = FALSE;
	if (!bIsItemListNull) {
		bIsItemListNull = TRUE;
		for (i = 0; i < DEF_MAXITEMS-1; i++) {
			if ((m_pClientList[iClientH]->m_pItemList[i] == NULL) && (m_pClientList[iClientH] != NULL)) {
				m_pClientList[iClientH]->m_ItemPosList[i].x = TempItemPosList[i].x; 
				m_pClientList[iClientH]->m_ItemPosList[i].y = TempItemPosList[i].y;
				bIsItemListNull = FALSE;
			}
		}
	}
	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH); // new
	CalcTotalItemEffect(iClientH, -1, FALSE); // new

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);
	*cp = iTotalItemA;
	cp++;

	for (i = 0; i < iTotalItemA; i++) {
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, FALSE, TRUE, TRUE, FALSE); // added TRUE (4)
			if(pBuffer != NULL) delete pBuffer;
			return;
		}

		memcpy(cp, m_pClientList[iClientH]->m_pItemList[i]->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		cp += 4;

		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemType;
		cp++;

		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos;
		cp++;

		*cp = (char)m_pClientList[iClientH]->m_bIsItemEquipped[i];
		cp++;

		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sLevelLimit;
		cp += 2;

		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cGenderLimit;
		cp++;

		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSpriteFrame;
		cp += 2;

		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor;
		cp++;

		*cp = (char)m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2; 
		cp++;

		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute;
		cp += 4;
	}
	iTotalItemB = 0;
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) 
			iTotalItemB++;

	*cp = iTotalItemB;
	cp++;

	for (i = 0; i < iTotalItemB; i++) {
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Bank-Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, FALSE, TRUE, TRUE, FALSE); // added TRUE (4)
			if(pBuffer != NULL) delete pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount;
		cp += 4;

		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemType;
		cp++;

		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cEquipPos;
		cp++;

		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sLevelLimit;
		cp += 2;

		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cGenderLimit;
		cp++;

		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSpriteFrame;
		cp += 2;

		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor;
		cp++;

		*cp = (char)m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2; 
		cp++;

		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute;
		cp += 4;
	}

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cMagicMastery[i];
		cp++;
	}

	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cSkillMastery[i];
		cp++;
	}

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 6 + 1 + iTotalItemA*44 + iTotalItemB*43 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE, TRUE, FALSE); // added TRUE (4)
		if(pBuffer != NULL) delete pBuffer;
		return;
	}
		
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE)
		bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	wp  = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;

	ip  = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;

	ip  = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iStatus;
	cp += 4;

	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;

	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		*cp = 1;
	else *cp = m_cDayOrNight;
	cp++;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		*cp = NULL;
	else *cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	cp++;

	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;

	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	}

	*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;

	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;

	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;

	// new
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == TRUE) {
		cPoints = 0;
		if ((m_pClientList[iClientH]->m_cSide != m_sLastHeldenianWinner) && (m_sLastHeldenianWinner != 0)) {
			cPoints = 100;
		}
	}
	*cp = cPoints;
	cp++;

	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 10, m_pClientList[iClientH]->m_sY - 7, iClientH, cp );
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, iSize + 66);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE, TRUE, FALSE); // new TRUE (4)
		if(pBuffer != NULL) delete pBuffer;
		return;
	}
	if(pBuffer != NULL) delete pBuffer;
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
	// new
	if ((m_pClientList[iClientH]->m_iLevel > 100) && (m_pClientList[iClientH]->m_bIsInCombatantOnlyZone == TRUE)) {
		ForceChangePlayMode(iClientH, TRUE);
	}

	if ((m_pClientList[iClientH]->m_cSide == 1) && 
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)  && 
		(m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		CheckForceRecallTime(iClientH);
	}
	else if ((m_pClientList[iClientH]->m_cSide == 2) && 
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) &&
		(m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		CheckForceRecallTime(iClientH);
	}
	else if ((m_pClientList[iClientH]->m_cSide == 0) && (m_bIsCrusadeMode == TRUE)) {
		if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) ||
			(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0)) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
				m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
				m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
			}
		}
		if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
			m_pClientList[iClientH]->m_bIsWarLocation = FALSE;
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
		}
	}

	iMapSide = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
	if (iMapSide > 3) iMapSide2 = iMapSide - 2;
		else iMapSide2 = iMapSide;
	m_pClientList[iClientH]->m_bIsInsideEnemyBuilding = FALSE; // new
	if ((m_pClientList[iClientH]->m_cSide != iMapSide2) && (iMapSide != 0)) {
		if ((iMapSide <= 2) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
			if (m_pClientList[iClientH]->m_cSide != 0) {
				m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
				m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
				m_pClientList[iClientH]->m_bIsInsideEnemyBuilding = TRUE; // new
			}
		}
	}
	else{
		if ((m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsFightZone == TRUE) &&
			(m_iFightzoneNoForceRecall == FALSE) && 
			(m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*60*20 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20;
		}
		else{
			if ((memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0) ||
				(memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0)) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
					m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
					m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
					if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
					}
					else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 100) {
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
					}
				}
			}
		}
	}

	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FORCERECALLTIME,  m_pClientList[iClientH]->m_iTimeLeft_ForceRecall , NULL, NULL, NULL);
		wsprintf(G_cTxt,"(!) Game Server Force Recall Time  %d (%d)min", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall/20) ;
		PutLogList(G_cTxt);
	}

	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 0) {
		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = 0;
	}

	if (bDeathmatch)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DEATHMATCHSTART, NULL, NULL, NULL, NULL);

	if ((memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone1", 10) == 0) && (!bDeathmatch))
		RequestTeleportHandler(iClientH, "1   ");

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);		
	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);

	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
	}

	if (m_bIsCrusadeMode == TRUE) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			m_pClientList[iClientH]->m_iCrusadeDuty			= 0;
			m_pClientList[iClientH]->m_iConstructionPoint	= 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID		= m_dwCrusadeGUID;
		}
		else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
		}
		m_pClientList[iClientH]->m_cWarType = 1;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
	}
	// Heldenian
	else if (m_bIsHeldenianMode == TRUE) 
	{	sSummonPoints = 10000 + m_pClientList[iClientH]->m_iCharisma*100;
		if (sSummonPoints > DEF_MAXHELDENIANSUMMONPOINT) sSummonPoints = (short)DEF_MAXHELDENIANSUMMONPOINT;
		if (m_pClientList[iClientH]->m_dwHeldenianGUID == NULL) 
		{	m_pClientList[iClientH]->m_dwHeldenianGUID    = m_dwHeldenianGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			if (   (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) 
				&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1))
			{	// Player connecting on Heldenian map, and not been advised of Heldenian start will recall
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL);	
				m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 3;
			}
		}else if (m_pClientList[iClientH]->m_dwHeldenianGUID != m_dwHeldenianGUID) 
		{	m_pClientList[iClientH]->m_dwHeldenianGUID    = m_dwHeldenianGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			if (   (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) 
				&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1))
			{	// Player connecting on Heldenian map, and not been advised of this Heldenian start will recall
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL);	
				m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 3;
		}	}
		if (m_cHeldenianWinner == -1) 
		{	if (m_bHeldenianWarInitiated == TRUE) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL);
			}else
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, NULL, NULL, NULL, NULL);
			}
		}else // Force recall loosers
		{	if (   (m_pClientList[iClientH]->m_cSide != m_cHeldenianWinner)
				&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1))
			{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2;
		}	}
		m_pClientList[iClientH]->m_cWarType = 2;// character have been informed of heldenian starting...
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);
		UpdateHeldenianStatus(iClientH);
	}
	else if ((m_pClientList[iClientH]->m_cWarType == 1) && (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)) {
		m_pClientList[iClientH]->m_iCrusadeDuty = 0;
		m_pClientList[iClientH]->m_iConstructionPoint = 0;
	}
	else if ((m_pClientList[iClientH]->m_dwCrusadeGUID != 0) && (m_pClientList[iClientH]->m_cWarType == 1)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, NULL, NULL, -1);
	}
	// The Heldenian he has participated is over...
	else if ( (m_pClientList[iClientH]->m_dwHeldenianGUID == m_dwHeldenianGUID)
			&& (m_pClientList[iClientH]->m_dwHeldenianGUID != NULL)) 
	{	m_pClientList[iClientH]->m_iConstructionPoint = 0;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANEND, NULL, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_cWarType = 0; // Character is informed of Hedenian end... so he'll get XP later
	}
	else {
		m_pClientList[iClientH]->m_iWarContribution = 0; 
		m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		m_pClientList[iClientH]->m_iConstructionPoint = 0;
	}
	// new fightzone changed to fight
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
		wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAJESTIC_LEVEL, m_pClientList[iClientH]->m_iMajesticLevel, NULL, NULL, NULL, NULL);
	
	//50Cent - Critical Count Login Fix
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
	
	// SNOOPY: Send gate positions if applicable.
	Notify_ApocalypseGateState(iClientH);

	if (m_pClientList[iClientH]->m_iLU_Pool < 3) m_pClientList[iClientH]->m_iLU_Pool = 3;

}

/*********************************************************************************************************************
**  CGame::iComposeInitMapData(short sX, short sY, int iClientH, char * pData)										**
**  DESCRIPTION			::																							**
**  LAST_UPDATED		:: March 16, 2005; 11:59 AM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- added iGetPlayerStatus()																**
**	MODIFICATION		::  - added check for invis hack															**
**********************************************************************************************************************/
int CGame::iComposeInitMapData(short sX, short sY, int iClientH, char * pData)
{
 int * ip, ix, iy, iSize, iTileExists;
 class CTile * pTileSrc, * pTile;
 unsigned char ucHeader;
 short * sp, * pTotal;
 int iTemp, iTemp2;
 WORD  * wp;
 char  * cp;

	if (m_pClientList[iClientH] == NULL) return 0;
	pTotal = (short *)pData;
	cp = (char *)(pData + 2);
	iSize = 2;
	iTileExists = 0;
	pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + (sX) + (sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
	for (iy = 0; iy < 16; iy++)
	for (ix = 0; ix < 21; ix++) {
		if (((sX + ix) == 100) && ((sY + iy) == 100)) sX = sX;
		pTile = (class CTile *)(pTileSrc + ix + iy*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
		/****MODIFICATION****/
		//If player not same side and is invied (Beholder Hack)
		if ((m_pClientList[pTile->m_sOwner] != NULL) && (pTile->m_sOwner != iClientH))
			if ((m_pClientList[pTile->m_sOwner]->m_cSide != 0) &&
				(m_pClientList[pTile->m_sOwner]->m_cSide != m_pClientList[iClientH]->m_cSide) && 
				((m_pClientList[pTile->m_sOwner]->m_iStatus & 0x00000010) != 0)) {
				continue;
			}
		/********************/
		if ((pTile->m_sOwner != NULL) || (pTile->m_sDeadOwner != NULL) || 
			(pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != NULL)) {
			iTileExists++;
			sp = (short *)cp;
			*sp = ix;
			cp += 2;
			sp = (short *)cp;
			*sp = iy;
			cp += 2;
			iSize += 4;
			ucHeader = 0;
			if (pTile->m_sOwner != NULL) {
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else {
						wsprintf(G_cTxt, "Empty player handle: %d", pTile->m_sOwner);
						pTile->m_sOwner = NULL;
					}
				}
			
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sOwner] != NULL ) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;
				}
			}
			if (pTile->m_sDeadOwner != NULL) {
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
				   	else pTile->m_sDeadOwner = NULL;
				}
			}
			if (pTile->m_pItem[0] != NULL)				ucHeader = ucHeader | 0x04;
			if (pTile->m_sDynamicObjectType != NULL)    ucHeader = ucHeader | 0x08;

			*cp = ucHeader;
			cp++;
			iSize++;

			if ((ucHeader & 0x01) != 0) {
				switch (pTile->m_cOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number(Player) : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner;
					cp += 2;
					iSize += 2;
 					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 ApprColor
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;
					// Status
					ip  = (int *)cp;
					iTemp = iGetPlayerStatus(iClientH, pTile->m_sOwner); // CHANGED
					iTemp = 0x0FFFFFFF & iTemp;//  4 
					iTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH); 
					iTemp  = (iTemp | (iTemp2 << 28));//Original : 12
					*ip = iTemp;
					cp += 4;
					iSize += 4;//Original 2
					// Name
					memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number(NPC) : 10000~
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appr2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					ip  = (int *)cp;	
					iTemp = m_pNpcList[pTile->m_sOwner]->m_iStatus;
					iTemp = 0x0FFFFFFF & iTemp;//  4 
					iTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH);
					iTemp  = (iTemp | (iTemp2 << 28));//Original : 12
					*ip = iTemp;
					cp += 4;
					iSize += 4;
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}
			if ((ucHeader & 0x02) != 0) {
				switch (pTile->m_cDeadOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 ApprColor
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;
					// Status
					ip  = (int *)cp;		
					iTemp = iGetPlayerStatus(iClientH, pTile->m_sDeadOwner); // CHANGED 
					iTemp = 0x0FFFFFFF & iTemp;//  4 
					iTemp2 = iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH); 
					iTemp  = (iTemp | (iTemp2 << 28));//Original : 12
					*ip = iTemp;
					cp += 4;
					iSize += 4;
					// Name
					memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number : 10000	~
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appr2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					ip  = (int *)cp;
					iTemp = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
					iTemp = 0x0FFFFFFF & iTemp;//  4 
					iTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
					iTemp  = (iTemp | (iTemp2 << 28));//Original : 12
					*ip = iTemp;
					cp += 4;//Original 2
					iSize += 4;//Original 2
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}

			if (pTile->m_pItem[0] != NULL) {
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSprite;
				cp += 2;
				iSize += 2;

				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSpriteFrame;
				cp += 2;
				iSize += 2;

				*cp = pTile->m_pItem[0]->m_cItemColor;
				cp++;
				iSize++;
			}

			if (pTile->m_sDynamicObjectType != NULL) {
				wp  = (WORD *)cp;
				*wp = pTile->m_wDynamicObjectID;
				cp += 2;
				iSize += 2;
				
				sp  = (short *)cp;
				*sp	= pTile->m_sDynamicObjectType;
				cp += 2;
				iSize += 2;
			}
		} // Big if
	} // while(1)

	*pTotal = iTileExists;
	return iSize;
}

/*********************************************************************************************************************
**  void CGame::DeleteClient(int iClientH, BOOL bSave, BOOL bNotify, BOOL bCountLogout, BOOL bForceCloseConn)		**
**  DESCRIPTION			:: manages disconnect player																**
**  LAST_UPDATED		:: March 16, 2005; 12:02 AM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				:: n/a																						**
**	MODIFICATION		:: n/a																						**
**********************************************************************************************************************/
void CGame::DeleteClient(int iClientH, BOOL bSave, BOOL bNotify, BOOL bCountLogout, BOOL bForceCloseConn)
{
	int i, iExH;
	char * cp, cData[120], cTmpMap[30];
	DWORD * dwp;
	WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			wsprintf(G_cTxt, "Char(%s)-Exit(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName);
			PutLogEventFileList(G_cTxt);
		}

		if (m_pClientList[iClientH]->m_cExchangeMode != 0) {
			iExH = m_pClientList[iClientH]->m_iExchangeH;
			_ClearExchangeStatus(iExH);
			_ClearExchangeStatus(iClientH);
		}

		if ((m_pClientList[iClientH]->m_iAllocatedFish != NULL) && (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL)) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		if (bNotify == TRUE)
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);

		RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iWhisperPlayerIndex	== iClientH)) {
				m_pClientList[i]->m_iWhisperPlayerIndex = -1;
				SendNotifyMsg(NULL, i, DEF_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);
			}

			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			*cp = GSM_DISCONNECT;
			cp++;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			bStockMsgToGateServer(cData, 11);

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER,
				m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY);

			bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, NULL);
	}

	if ((bSave == TRUE) && (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE)) {
		
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) {
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;

			strcpy(cTmpMap,m_pClientList[iClientH]->m_cMapName) ;

			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));

			if (m_pClientList[iClientH]->m_cSide == 0) {
				strcpy(m_pClientList[iClientH]->m_cMapName, "default");
			}
			else {
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
					if (m_bIsCrusadeMode == TRUE) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
							m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
						}
						else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
						}
					}

					if (strcmp(cTmpMap, "elvine") == 0){
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ;
						memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
					}else if (m_pClientList[iClientH]->m_iLevel > 80)
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "arefarm", 7);
				}
				else {
					if (m_bIsCrusadeMode == TRUE) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
							m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
						}
						else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
						}
					}
					if (strcmp(cTmpMap, "aresden") == 0){
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ;
						memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);

					}else if (m_pClientList[iClientH]->m_iLevel > 80)
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "elvfarm", 7);
				}
			}
		}
		else if (bForceCloseConn == TRUE) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, "bisle", 5);
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;

			ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
			strcpy(m_pClientList[iClientH]->m_cLockedMapName, "bisle");
			m_pClientList[iClientH]->m_iLockedMapTime = 10*60;
		}

		if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				switch (iDice(1,2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				switch (iDice(1,2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) {
			if (m_pClientList[iClientH]->m_iPartyID != NULL) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;

				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;

				wp = (WORD*)cp;
				*wp = 4;
				cp += 2;

				wp = (WORD *)cp;
				*wp = iClientH;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;

				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;
		
				PutLogList("DeleteClient send 4 to GateServer");
				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}
			if (bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout) == FALSE) LocalSavePlayerData(iClientH);
		}
		else bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
	}
	else {
		if (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE) {
			if (m_pClientList[iClientH]->m_iPartyID != NULL) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;

				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;

				wp = (WORD*)cp;
				*wp = 4;
				cp += 2;

				wp = (WORD *)cp;
				*wp = iClientH;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;

				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;

				PutLogList("DeleteClient send 4 to GateServer");
				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}

			bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
		}
		else {
			if (m_pClientList[iClientH]->m_iPartyID != NULL) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;

				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;

				wp = (WORD*)cp;
				*wp = 7;
				cp += 2;

				wp = (WORD *)cp;
				*wp = NULL;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;

				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;
			
				PutLogList("DeleteClient send 7 to GateServer");
				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}

			bSendMsgToLS(MSGID_REQUEST_SETACCOUNTWAITSTATUS, iClientH, FALSE); 
		}
	}

	if (m_pClientList[iClientH]->m_iPartyID != NULL) {
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;
				wsprintf(G_cTxt, "PartyID:%d member:%d Out(Delete) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto DC_LOOPBREAK1;
			}
DC_LOOPBREAK1:;
			for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
				if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] != 0)) {
					m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i]   = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1];
					m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] = 0;
				}
	}

	m_iTotalClients--;

	delete m_pClientList[iClientH];
	m_pClientList[iClientH] = NULL;

	RemoveClientShortCut(iClientH);
}

/*********************************************************************************************************************
**  void CGame::SendEventToNearClient_TypeA(short sOwnerH, char cOwnerType, DWORD dwMsgID, WORD wMsgType,			**
**		short sV1, short sV2, short sV3)																			**
**  DESCRIPTION			:: updates client screen																	**
**  LAST_UPDATED		:: March 16, 2005; 12:26 AM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- updated m_iStatus calculation															**
**							- changed npc psock sendmsg to 29 from 27												**	
**	MODIFICATION		::  - should have a invis hack check (commented)											**
**********************************************************************************************************************/
void CGame::SendEventToNearClient_TypeA(short sOwnerH, char cOwnerType, DWORD dwMsgID, WORD wMsgType, short sV1, short sV2, short sV3)
{
	int * ip, i, iRet, iShortCutIndex;
	char  * cp_a, * cp_s, * cp_sv, cData_All[200], cData_Srt[200], cData_Srt_Av[200];
	DWORD * dwp;
	WORD  * wp;
	int * ipStatus,iDumm;
	short * sp, sRange, sX, sY;
	BOOL  bFlag, cOwnerSend;
	char cKey;
	int iTemp3,iTemp,iTemp2;				
	
	ZeroMemory(cData_All, sizeof(cData_All));
	ZeroMemory(cData_Srt, sizeof(cData_Srt));
	ZeroMemory(cData_Srt_Av, sizeof(cData_Srt_Av));
	ipStatus = (int *)&iDumm;
	cKey = (rand() % 255) + 1;

	dwp  = (DWORD *)(cData_All + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_All + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;

	dwp  = (DWORD *)(cData_Srt + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;

	dwp  = (DWORD *)(cData_Srt_Av + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;

	cp_a  = (char *)(cData_All + DEF_INDEX2_MSGTYPE + 2);
	cp_s  = (char *)(cData_Srt + DEF_INDEX2_MSGTYPE + 2);
	cp_sv = (char *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE + 2);


	if ((dwMsgID == MSGID_EVENT_LOG) || (wMsgType == DEF_OBJECTMOVE) || (wMsgType == DEF_OBJECTRUN) || 
		(wMsgType == DEF_OBJECTATTACKMOVE) || (wMsgType == DEF_OBJECTDAMAGEMOVE) || (wMsgType == DEF_OBJECTDYING))
		sRange = 1;
	else sRange = 0;


	if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sOwnerH] == NULL) return;
		switch(wMsgType){
			case DEF_OBJECTNULLACTION:
			case DEF_OBJECTDAMAGE:
			case DEF_OBJECTDYING:
			case DEF_MSGTYPE_CONFIRM:
				cOwnerSend = TRUE;
				break;
			default:
				cOwnerSend = FALSE;
				break;
		}

		wp  = (WORD *)cp_a;
		*wp = sOwnerH;
		cp_a += 2;

		sp  = (short *)cp_a;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;

		sp  = (short *)cp_a;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;

		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sType;
		cp_a += 2;

		*cp_a = m_pClientList[sOwnerH]->m_cDir;
		cp_a++;

		memcpy(cp_a, m_pClientList[sOwnerH]->m_cCharName, 10);
		cp_a += 10;

		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr1;
		cp_a += 2;

		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr2;
		cp_a += 2;

		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr3;
		cp_a += 2;

		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr4;
		cp_a += 2;

		ip = (int *)cp_a;
		*ip = m_pClientList[sOwnerH]->m_iApprColor;
		cp_a += 4;

		ip  = (int *)cp_a;
		ipStatus = ip;
		*ip = m_pClientList[sOwnerH]->m_iStatus;
		cp_a += 4;

		iTemp = m_pClientList[sOwnerH]->m_iStatus; // new
		iTemp = 0x0F0 & iTemp; // new
		iTemp3 = m_pClientList[sOwnerH]->m_iStatus & 0x0F0FFFF7F;

		if (wMsgType == DEF_OBJECTNULLACTION) {
			if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE)
				*cp_a = 1; 
			else *cp_a = 0; 
		}
		else *cp_a = 0;
		cp_a++;

		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 30000;
		cp_s += 2;

		*cp_s = m_pClientList[sOwnerH]->m_cDir;
		cp_s++;

		*cp_s = (unsigned char)sV1;
		cp_s++;

		*cp_s = (unsigned char)sV2;
		cp_s++;

		sp  = (short *)cp_s;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;

		sp  = (short *)cp_s;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;

		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 30000;
		cp_sv += 2;

		*cp_sv = m_pClientList[sOwnerH]->m_cDir;
		cp_sv++;

		*cp_sv = sV1 - sX;
		cp_sv++;

		*cp_sv = sV2 - sY;
		cp_sv++;

		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;

		bFlag = TRUE;
		iShortCutIndex = 0;
		while(bFlag){
			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;
				if ((bFlag == TRUE) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))

				if ((m_pClientList[i]->m_cMapIndex == m_pClientList[sOwnerH]->m_cMapIndex) &&
					(m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 10 - sRange) &&
					(m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 10 + sRange) &&
					(m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 8 - sRange) &&
					(m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 8 + sRange) ) {						
													
						if (m_pClientList[sOwnerH]->m_cSide != m_pClientList[i]->m_cSide) {
							if (m_pClientList[i]->m_iAdminUserLevel > 0) {
								iTemp = m_pClientList[sOwnerH]->m_iStatus;
							}
							else if (i != sOwnerH)	{	
								iTemp = iTemp3;
							}
							else {
								iTemp = m_pClientList[sOwnerH]->m_iStatus;
							}
						}
						else {
							iTemp = m_pClientList[sOwnerH]->m_iStatus;
						}

						iTemp = 0x0FFFFFFF & iTemp;
						iTemp2 = iGetPlayerABSStatus(sOwnerH, i);
						iTemp  = (iTemp | (iTemp2 << 28));
						*ipStatus = iTemp;

						if ((m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 9) &&
							(m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 9) &&
							(m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 7) &&
							(m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 7)	) {

								switch (wMsgType) {
									case DEF_MSGTYPE_CONFIRM:
									case DEF_MSGTYPE_REJECT:
									case DEF_OBJECTNULLACTION:
										if (cOwnerSend == TRUE) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
										break;

									case DEF_OBJECTATTACK:
									case DEF_OBJECTATTACKMOVE:
										if (cOwnerSend == TRUE) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
										break;

									case DEF_OBJECTMAGIC:
									case DEF_OBJECTDAMAGE:
									case DEF_OBJECTDAMAGEMOVE:
										if (cOwnerSend == TRUE) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
										break;

									case DEF_OBJECTDYING:
										if (cOwnerSend == TRUE) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
										break;

									default:
										if (cOwnerSend == TRUE) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
										break;
								} //Switch
							} // If 2
						else {
							switch (wMsgType) {
								case DEF_MSGTYPE_CONFIRM:
								case DEF_MSGTYPE_REJECT:
								case DEF_OBJECTNULLACTION:
									if (cOwnerSend == TRUE) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									break;

								case DEF_OBJECTATTACK:
								case DEF_OBJECTATTACKMOVE:
									if (cOwnerSend == TRUE) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
									break;

								case DEF_OBJECTMAGIC:
								case DEF_OBJECTDAMAGE:
								case DEF_OBJECTDAMAGEMOVE:
									if (cOwnerSend == TRUE) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
									break;

								case DEF_OBJECTDYING:
									if (cOwnerSend == TRUE) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
									break;

								default:
									if (cOwnerSend == TRUE) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									break;
							} //Switch
						} //else
					} // If 1
		} //While finish
	} //Finish Player
	else {
		if (m_pNpcList[sOwnerH] == NULL) return;

		wp  = (WORD *)cp_a;
		*wp = sOwnerH + 10000;
		cp_a += 2;

		sp  = (short *)cp_a;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;

		sp  = (short *)cp_a;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;

		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sType;
		cp_a += 2;

		*cp_a = m_pNpcList[sOwnerH]->m_cDir;
		cp_a++;

		memcpy(cp_a, m_pNpcList[sOwnerH]->m_cName, 5);
		cp_a += 5;

		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sAppr2;
		cp_a += 2;

		ip  = (int *)cp_a;
		ipStatus = ip;
		*ip = m_pNpcList[sOwnerH]->m_iStatus;
		cp_a += 4;

		if (wMsgType == DEF_OBJECTNULLACTION) {
			if (m_pNpcList[sOwnerH]->m_bIsKilled == TRUE)
				*cp_a = 1; 
			else *cp_a = 0;
		}
		else *cp_a = 0;
		cp_a++;

		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 40000;
		cp_s += 2;

		*cp_s = m_pNpcList[sOwnerH]->m_cDir;
		cp_s++;

		*cp_s = (unsigned char)sV1;
		cp_s++;
		*cp_s = (unsigned char)sV2;
		cp_s++;

		sp  = (short *)cp_s;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;
		sp  = (short *)cp_s;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;

		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 40000;
		cp_sv += 2;
		*cp_sv = m_pNpcList[sOwnerH]->m_cDir;
		cp_sv++;
		*cp_sv = sV1 - sX;
		cp_sv++;
		*cp_sv = sV2 - sY;
		cp_sv++;
		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;

		bFlag = TRUE;
		iShortCutIndex = 0;

		while(bFlag){
			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;
			if ((bFlag == TRUE) && (m_pClientList[i] != NULL))
				if ((m_pClientList[i]->m_cMapIndex == m_pNpcList[sOwnerH]->m_cMapIndex) &&
					(m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 10 - sRange) &&
					(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 10 + sRange) &&
					(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 8 - sRange) &&
					(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 8 + sRange)) {

						iTemp = *ipStatus;
						iTemp = 0x0FFFFFFF & iTemp;
						iTemp2 = iGetNpcRelationship(sOwnerH, i);
						iTemp  = (iTemp | (iTemp2 << 28));
						*ipStatus = iTemp;

						if ((m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 9) &&
							(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 9) &&
							(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 7) &&
							(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 7)) {
								switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 29,cKey); // changed from 27
							break;

						case DEF_OBJECTDYING:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
							break;

						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
							break;

						default:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
							break;

								} //Switch
							}
						else{
							switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 29,cKey); // changed from 27
							break;

						case DEF_OBJECTDYING:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
							break;

						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
							break;

						default:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 29, cKey); // changed from 27
							break;

							} //Switch
						}
					}
		}
	} // else - NPC
}

/*********************************************************************************************************************
**  int CGame::iComposeMoveMapData(short sX, short sY, int iClientH, char cDir, char * pData)						**
**  DESCRIPTION			:: updates client screen on movement														**
**  LAST_UPDATED		:: March 16, 2005; 1:11 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- added iGetPlayerStatus on PLAYER														**
**	MODIFICATION		::  - invis hack 																			**
**********************************************************************************************************************/
int CGame::iComposeMoveMapData(short sX, short sY, int iClientH, char cDir, char * pData)
{
 int * ip, ix, iy, iSize, iTileExists, iIndex;
 class CTile * pTileSrc, * pTile;
 unsigned char ucHeader;
 short * sp, * pTotal;
 int iTemp, iTemp2;
 WORD  * wp;
 char  * cp;

	if (m_pClientList[iClientH] == NULL) return 0;
	pTotal = (short *)pData;
	cp = (char *)(pData + 2);
	iSize = 2;
	iTileExists = 0;
	pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + (sX) + (sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
	iIndex = 0;
	while (1) {
		ix = _tmp_iMoveLocX[cDir][iIndex];
		iy = _tmp_iMoveLocY[cDir][iIndex];
		if ((ix == -1) || (iy == -1)) break;
		iIndex++;
		pTile = (class CTile *)(pTileSrc + ix + iy*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
		/****MODIFICATION****/
		//If player not same side and is invied (Beholder Hack)
		// there is another person on the tiles, and the owner is not the player
		if ((m_pClientList[pTile->m_sOwner] != NULL) && (pTile->m_sOwner != iClientH))
			if ((m_pClientList[pTile->m_sOwner]->m_cSide != 0) &&
				(m_pClientList[pTile->m_sOwner]->m_cSide != m_pClientList[iClientH]->m_cSide) &&
				((m_pClientList[pTile->m_sOwner]->m_iStatus & 0x00000010) != 0)) {
				continue;
			}
		/*********************/
		if ((pTile->m_sOwner != NULL) || (pTile->m_sDeadOwner != NULL) || 	(pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != NULL)) {
				iTileExists++;
				sp = (short *)cp;
				*sp = ix;
				cp += 2;
				sp = (short *)cp;
				*sp = iy;
				cp += 2;
				iSize += 4;
				ucHeader = 0;

				if (pTile->m_sOwner != NULL) {
					if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) { 
						if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
						else pTile->m_sOwner = NULL;
					}
					if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) {
						if (m_pNpcList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
						else pTile->m_sOwner = NULL;
					}
				}
				if (pTile->m_sDeadOwner != NULL) {
					if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) { 
						if (m_pClientList[pTile->m_sDeadOwner] != NULL)	ucHeader = ucHeader | 0x02;
						else pTile->m_sDeadOwner = NULL;
					}
					if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) { 
						if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
						else pTile->m_sDeadOwner = NULL;
					}
				}

					if (pTile->m_pItem[0] != NULL)				ucHeader = ucHeader | 0x04;
					if (pTile->m_sDynamicObjectType != NULL)    ucHeader = ucHeader | 0x08;

					*cp = ucHeader;
					cp++;
					iSize++;
					if ((ucHeader & 0x01) != 0) {
					switch (pTile->m_cOwnerClass) {
						case DEF_OWNERTYPE_PLAYER:
								sp  = (short *)cp;
								*sp	= pTile->m_sOwner;
								cp += 2;
								iSize += 2;

								sp  = (short *)cp;
								*sp	= m_pClientList[pTile->m_sOwner]->m_sType;
								cp += 2;
								iSize += 2;

								*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
								cp++;
								iSize++;

								sp  = (short *)cp;
								*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr1;
								cp += 2;
								iSize += 2;

								sp  = (short *)cp;
								*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr2;
								cp += 2;
								iSize += 2;

								sp  = (short *)cp;
								*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr3;
								cp += 2;
								iSize += 2;

								sp  = (short *)cp;
								*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr4;
								cp += 2;
								iSize += 2;

								ip = (int *)cp;
								*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
								cp += 4;
								iSize += 4;

								ip  = (int *)cp;

								iTemp = iGetPlayerStatus(iClientH, pTile->m_sOwner); // new
								iTemp = 0x0FFFFFFF & iTemp;
								iTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH);
								iTemp  = (iTemp | (iTemp2 << 28));
								*ip = iTemp;
								cp += 4;
								iSize += 4;

								memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
								cp    += 10;
								iSize += 10;
								break;

						case DEF_OWNERTYPE_NPC:
							sp  = (short *)cp;
							*sp	= pTile->m_sOwner + 10000;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pNpcList[pTile->m_sOwner]->m_sType;
							cp += 2;
							iSize += 2;

							*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
							cp++;
							iSize++;

							sp  = (short *)cp;
							*sp	= m_pNpcList[pTile->m_sOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;

							ip  = (int *)cp;
							iTemp = m_pNpcList[pTile->m_sOwner]->m_iStatus;
							iTemp = 0x0FFFFFFF & iTemp;
							iTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH);
							iTemp  = (iTemp | (iTemp2 << 28));
							*ip = iTemp;
							cp += 4;
							iSize += 4;

							memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
							cp    += 5;
							iSize += 5;
						}//end switch
					}// if 

					if ((ucHeader & 0x02) != 0) {
						switch (pTile->m_cDeadOwnerClass) {
						case DEF_OWNERTYPE_PLAYER:

							sp  = (short *)cp;
							*sp	= pTile->m_sDeadOwner;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sType;
							cp += 2;
							iSize += 2;

							*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
							cp++;
							iSize++;

							sp  = (short *)cp;
							*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
							cp += 2;
							iSize += 2;

							ip = (int *)cp;
							*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
							cp += 4;
							iSize += 4;

							ip  = (int *)cp;
							
							iTemp = iGetPlayerStatus(iClientH, pTile->m_sDeadOwner); // new
							iTemp = 0x0FFFFFFF & iTemp;
							iTemp2 = iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH);
							iTemp  = (iTemp | (iTemp2 << 28));
							*ip = iTemp;
							cp += 4;
							iSize += 4;

							memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
							cp    += 10;
							iSize += 10;
							break;

						case DEF_OWNERTYPE_NPC:
							sp  = (short *)cp;
							*sp	= pTile->m_sDeadOwner + 10000;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sType;
							cp += 2;
							iSize += 2;

							*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
							cp++;
							iSize++;

							sp  = (short *)cp;
							*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;

							ip  = (int *)cp;

							iTemp = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
							iTemp = 0x0FFFFFFF & iTemp;
							iTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
							iTemp  = (iTemp | (iTemp2 << 28));
							*ip = iTemp;

							cp += 4;
							iSize += 4;

							memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
							cp    += 5;
							iSize += 5;
							break;
						}//End Switch
					}// if 
					if (pTile->m_pItem[0] != NULL) {
						sp  = (short *)cp;
						*sp	= pTile->m_pItem[0]->m_sSprite;
						cp += 2;
						iSize += 2;

						sp  = (short *)cp;
						*sp	= pTile->m_pItem[0]->m_sSpriteFrame;
						cp += 2;
						iSize += 2;

						*cp = pTile->m_pItem[0]->m_cItemColor;
						cp++;
						iSize++;
					}
					if (pTile->m_sDynamicObjectType != NULL) {

						wp  = (WORD *)cp;
						*wp = pTile->m_wDynamicObjectID;
						cp += 2;
						iSize += 2;

						sp  = (short *)cp;
						*sp	= pTile->m_sDynamicObjectType;
						cp += 2;
						iSize += 2;
					} //
				} //
		} // end While(1)
		*pTotal = iTileExists;
		return iSize;
}

/*********************************************************************************************************************
**  void CGame::OnTimer(char cType)																					**
**  DESCRIPTION			:: events occuring automatically after a set period of time									**
**  LAST_UPDATED		:: March 17, 2005; 2:24 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- added "&& (m_bIsWLServerAvailable == TRUE)" to list of Send Messages <commented>		**
**							- changed m_iSubLogSockInitIndex location												**
**							- added new functions ApocalypseWarStarter(), AutomaticApocalypseEnd(),					**
**							DoAbaddonThunderDamageHandler(), HeldenianWarStarter(), AutomaticHeldenianEnd(),		**
**							AutomatedHeldenianTimer()																**
**	MODIFICATION		::  n/a			 																			**
**********************************************************************************************************************/
void CGame::OnTimer(char cType)
{
 DWORD dwTime;
 int i;
 char notifyclean[51];

	dwTime = timeGetTime();
	NpcProcess();
	MsgProcess();
	if ((dwTime - m_dwGameTime2) > 3000) {
		CheckClientResponseTime();
		SendMsgToGateServer(MSGID_GAMESERVERALIVE, NULL, NULL);
		CheckDayOrNightMode();
		InvalidateRect(G_hWnd, NULL, TRUE);
		_CheckGateSockConnection();
		if ((m_bIsGameStarted == FALSE)     && (m_bIsItemAvailable == TRUE)      && 
			(m_bIsNpcAvailable == TRUE)     && (m_bIsGateSockAvailable == TRUE)  &&
			(m_bIsLogSockAvailable == TRUE) && (m_bIsMagicAvailable == TRUE)     &&
			(m_bIsSkillAvailable == TRUE)   && (m_bIsPotionAvailable == TRUE)   &&
			(m_bIsQuestAvailable == TRUE)   && (m_bIsBuildItemAvailable == TRUE) && 
			(m_iSubLogSockActiveCount == DEF_MAXSUBLOGSOCK)) { 
			PutLogList("Sending start message...");
			SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL);
			m_bIsGameStarted = TRUE;
		}
		m_dwGameTime2 = dwTime;
	}
	if ((dwTime - m_dwGameTime6) > 1000) {
		DelayEventProcessor();
		SendStockMsgToGateServer();
		if (m_iFinalShutdownCount != 0) {
			m_iFinalShutdownCount--;
			wsprintf(G_cTxt, "Final Shutdown...%d", m_iFinalShutdownCount);
			PutLogList(G_cTxt);
			if (m_iFinalShutdownCount <= 1) {
				SendMessage(m_hWnd, WM_CLOSE, NULL, NULL);
				return;
				
			}
		}
		// new location
		if (m_iSubLogSockInitIndex < DEF_MAXSUBLOGSOCK) {
			m_pSubLogSock[m_iSubLogSockInitIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
			m_pSubLogSock[m_iSubLogSockInitIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iSubLogSockInitIndex + 1));
			m_pSubLogSock[m_iSubLogSockInitIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);
			wsprintf(G_cTxt, "(!) Try to connect sub-log-socket(%d)... Addr:%s  Port:%d", m_iSubLogSockInitIndex, m_cLogServerAddr, m_iLogServerPort);
			PutLogList(G_cTxt);
			m_iSubLogSockInitIndex++;
		}
		m_dwGameTime6 = dwTime; // moved
	}
	if ((dwTime - m_dwGameTime3) > 3000) {
		SyncMiddlelandMapInfo();
		CheckDynamicObjectList();
		DynamicObjectEffectProcessor();
		NoticeHandler();
		SpecialEventHandler();
		EnergySphereProcessor(NULL, NULL);
		//SNOOPY:Check if Apocalypse Gate nedd to be closed
		OpenCloseApocalypseGate();
		m_dwGameTime3 = dwTime;
	}

	if (m_iNotifyCleanMap) {
		if ((dwTime - m_dwCleanTime) > (3600-120)*1000) // 2 min
		{	PutLogList("The maps will be cleaned in 2 minutes.");
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			{	if (m_pClientList[i] != NULL) 
				{		
					SendNotifyMsg(NULL, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "The maps will be cleaned in 2 minutes. Get drops!");
			}	}	
			m_dwCleanTime = dwTime;
		}else if ((dwTime - m_dwCleanTime) > (3600-60)*1000) // 1 min
		{	PutLogList("The maps will be cleaned in 1 minute.");
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			{	if (m_pClientList[i] != NULL) 
				{		
					SendNotifyMsg(NULL, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "The maps will be cleaned in 1 minute. Get drops!");
			}	}	
			m_dwCleanTime = dwTime;
		}else if ((dwTime - m_dwCleanTime) > (3600-30)*1000) // 30 sec
		{	PutLogList("The maps will be cleaned in 30 seconds.");
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			{	if (m_pClientList[i] != NULL) 
				{		
					SendNotifyMsg(NULL, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "The maps will be cleaned in 30 seconds. Get drops!");
			}	}	
			m_dwCleanTime = dwTime;
		}else if ((dwTime - m_dwCleanTime) > (3600-1)*1000) // done
		{	PutLogList("The maps are been cleaned successfully.");
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			{	if (m_pClientList[i] != NULL) 
				{		
					SendNotifyMsg(NULL, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "The maps are been cleaned successfully.");
					
			}	}	
			m_dwCleanTime = dwTime;
			m_iNotifyCleanMap = FALSE;
		}
	}
	else if ((dwTime - m_dwCleanTime) > 3600*1000) // 2700*1000 = 45 min 1800*1000 = 30 min 3600*1000 = 1h	
	{	ClearMap();
		m_dwCleanTime = dwTime;
	}

	if ((dwTime - m_dwGameTime4) > 600) { // time millisecond = *60*10*10
		MobGenerator();
#ifdef DEF_DBGAMESERVER
		BYTE b;
		if (!m_bIsGameServerRegistered && m_pSubLogSock[0] == NULL) {
			m_pSubLogSock[0] = new XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
			m_pSubLogSock[0]->bConnect(m_cLogServerAddr, m_iGateServerPort, (WM_ONLOGSOCKETEVENT + 1));
			m_pSubLogSock[0]->bInitBufferSize(DEF_MSGBUFFERSIZE);
			wsprintf(G_cTxt, "(!) Try to connect sub-log-socket(0)... Addr:%s  Port:%d", m_cLogServerAddr, m_iGateServerPort);
			PutLogList(G_cTxt);
		 }
		 else if(m_bIsGameServerRegistered) for (b = 1; b < DEF_MAXSUBLOGSOCK; b++){
			 if(m_pSubLogSock[b] == NULL && !m_bIsSocketConnected[b] && m_bIsSocketConnected[b-1]){
				m_pSubLogSock[b] = new XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
				m_pSubLogSock[b]->bConnect(m_cLogServerAddr, m_iGateServerPort, (WM_ONLOGSOCKETEVENT + b + 1));
				m_pSubLogSock[b]->bInitBufferSize(DEF_MSGBUFFERSIZE);
				wsprintf(G_cTxt, "(!) Try to connect sub-log-socket(%d)... Addr:%s  Port:%d", b, m_cLogServerAddr, m_iGateServerPort);
				PutLogList(G_cTxt);
			 }		 
		 }
#endif
		m_dwGameTime4 = dwTime;
	}
	if ((dwTime - m_dwGameTime5) > 180000) {
		m_dwGameTime5 = dwTime;
		srand((unsigned)time(NULL));   
	}
	if ((dwTime - m_dwFishTime) > 4000) {
		FishProcessor();
		FishGenerator();
		SendCollectedMana();
		CrusadeWarStarter();
		if (m_bIsApocalypseMode == TRUE) DoAbaddonThunderDamageHandler(-1); // -1 only affects Abaddon map
		//SNOOPY: check if Heldenian war must be started or finished.
		if (m_bIsHeldenianMode == TRUE)		  
		{	HeldenianStartWarNow();
			HeldenianEndWarNow();
		}
		AFKChecker();
		m_dwFishTime = dwTime;
	}
	
	if ((dwTime - m_dwWhetherTime) > 20000) {
		WeatherProcessor();
		m_dwWhetherTime = dwTime;
	}
	
	if ((dwTime - m_dwCanFightzoneReserveTime) > 7200000) {
		m_dwCanFightzoneReserveTime = dwTime;
	}

	if ((m_bIsServerShutdowned == FALSE) && (m_bOnExitProcess == TRUE) && ((dwTime - m_dwExitProcessTime) > 1000*2)) {
		if (_iForcePlayerDisconect(15) == 0) {
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS COMPLETED! All players are disconnected.");
			m_bIsServerShutdowned = TRUE;
			if ((m_cShutDownCode == 3) || (m_cShutDownCode == 4)) {
				PutLogFileList("(!!!) AUTO-SERVER-REBOOTING!");
				bInit();
				m_iAutoRebootingCount++;
			}
			else {
				if (m_iFinalShutdownCount == 0)	m_iFinalShutdownCount = 20;
			}
		}
		m_dwExitProcessTime = dwTime;
	}

	if ((dwTime - m_dwMapSectorInfoTime) > 10000) {
		UpdateMapSectorInfo();
		MineralGenerator();
		m_iMapSectorInfoUpdateCount++;
		if (m_iMapSectorInfoUpdateCount >= 5) {
			AgingMapSectorInfo();
			m_iMapSectorInfoUpdateCount = 0;
		}
		m_dwMapSectorInfoTime = dwTime;
	}
}

/*********************************************************************************************************************
**  void CGame::HeldenianStartWarNow()																				**
**  description		:: War will start 15 min after event beginning for players to prepare themselves       			**
**             		:: This function will start war																	**
**	Called on timer, by OnTimer																												**
*********************************************************************************************************************/
void CGame::HeldenianStartWarNow() 
{
	if (m_bHeldenianWarInitiated == TRUE)	return; // Already started
	if (m_cHeldenianWinner != -1)			return; // Battle is already won
	DWORD dwTime = timeGetTime();
	if (dwTime < m_dwHeldenianWarStartTime) return;	// Not yet time to start battle
	m_bHeldenianWarInitiated = TRUE;	
	wsprintf(G_cTxt,"(!) HELDENIAN Start: Fighting starting now...");
	PutLogList(G_cTxt);
	PutLogEventFileList(G_cTxt);
 int i;
	// Tell clients that war has begun
	for (i = 0; i < DEF_MAXCLIENTS; i++) 
	{	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
		{	m_pClientList[i]->m_cWarType = 2;
			SendNotifyMsg(NULL, i, DEF_NOTIFY_HELDENIANSTART,  NULL , NULL, NULL, NULL); // You can now, fight on the battle field
			UpdateHeldenianStatus(i);
	}	}
	for (i = 0; i < DEF_MAXNPCS; i++) // Remove summons from last Heldenian
	{	if (   (m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_bIsKilled == FALSE) 
			&& (m_pMapList[m_pNpcList[i]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) )
		{	if (m_pNpcList[i]->m_bIsSummoned == FALSE)
			{	m_pNpcList[i]->m_cSide = m_pNpcList[i]->m_cOriginalSide; // All mobs become aggressive again
	}	}	}
}
/*********************************************************************************************************************
**  void CGame::HeldenianVictoryNow(int iSide) 																		**
**  description		:: Called by meating a victory condition before maximum time					      			**
**             		:: Called when all tower destroyed (type 1) or when flag set (type 2)							**
**					:: Will recall all defeated characters, others can stay until normal end time					**
*********************************************************************************************************************/
void CGame::HeldenianVictoryNow(int iSide) 
{	if (m_bHeldenianWarInitiated == FALSE) return;
	DWORD dwTime = timeGetTime();
	m_bHeldenianWarInitiated = FALSE;	
	m_cHeldenianWinner = iSide;
	switch(m_cHeldenianWinner) {
	case 1: 
		wsprintf(G_cTxt, "Heldenian victory before allowed time, Aresden victory.");
		break;
	case 2: 
		wsprintf(G_cTxt, "Heldenian victory before allowed time, Elvine victory.");
		break;
	default: 
		wsprintf(G_cTxt, "Heldenian victory before allowed time, Draw.");
		break;
	}
	PutLogList(G_cTxt);	
	m_dwHeldenianFinishTime   = timeGetTime() + 5*60*1000;  // war will end in 5 minutes
	int m;	
 int j, n;
	for (m = 0; m < DEF_MAXMAPS; m++)
	{	if (m_pMapList[m] == NULL) break;
		if (m_pMapList[m]->m_bIsHeldenianMap == TRUE) 
		{	for (j = 0; j < DEF_MAXCLIENTS; j++)
			{	if (   (m_pClientList[j] != NULL)
					&& (m_pClientList[j]->m_bIsInitComplete == TRUE)
					&& (m_pClientList[j]->m_cMapIndex == m))
				{	UpdateHeldenianStatus(j);
					SendNotifyMsg(NULL, j, DEF_NOTIFY_HELDENIANVICTORY,  m_cHeldenianWinner, NULL, NULL, NULL); // Victory defeat screen
					if (   (m_pClientList[j]->m_cSide != iSide)// recall loosers only
						&& (m_pClientList[j]->m_iAdminUserLevel == 0))
					{	SendNotifyMsg(NULL, j, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL);
						m_pClientList[j]->m_bIsWarLocation = TRUE;
						m_pClientList[j]->m_iTimeLeft_ForceRecall = 3;
			}	}	}
			for (n = 0; n < DEF_MAXNPCS; n++)
			{	if (   (m_pNpcList[n] != NULL) 
					&& (m_pNpcList[n]->m_cMapIndex == m)
					&& (m_pNpcList[n]->m_cSide != iSide))
				{	if (m_pNpcList[n]->m_bIsSummoned == TRUE) 
					{	NpcKilledHandler(NULL, NULL, n, NULL);
					}else
					{	m_pNpcList[n]->m_cSide = 0; // All mobs become neutral as players no more have spells or attacks...
	}	}	}	}	}
}
/*********************************************************************************************************************
**  void CGame::HeldenianEndWarNow()																				**
**  description		:: Checks if Heldenian should be finished, and victory conditions                      			**
**             		:: used only on Heldenian server																**
**																													**
*********************************************************************************************************************/
void CGame::HeldenianEndWarNow()
{	if (m_bIsHeldenianMode == FALSE) return;
	DWORD dwTime = timeGetTime();
	if (dwTime < m_dwHeldenianFinishTime) return;
	if (m_cHeldenianType == 1) 
	{	if (m_iBTFieldMapIndex == -1) return;		
		// Type 1: BtField, victory depends on Tower destroyed...
		if (m_cHeldenianWinner == -1)
		{	if (m_iHeldenianAresdenLeftTower > m_iHeldenianElvineLeftTower) 
			{	m_cHeldenianWinner = 1;
			}else if (m_iHeldenianAresdenLeftTower < m_iHeldenianElvineLeftTower) 
			{	m_cHeldenianWinner = 2;
			}else if (m_iHeldenianAresdenFlags > m_iHeldenianElvineFlags)
			{	m_cHeldenianWinner = 1;
			}else if (m_iHeldenianAresdenFlags < m_iHeldenianElvineFlags) 
			{	m_cHeldenianWinner = 2;
			}else if(m_iHeldenianAresdenDead < m_iHeldenianElvineDead)
			{	m_cHeldenianWinner = 1;
			}else if(m_iHeldenianAresdenDead > m_iHeldenianElvineDead)
			{	m_cHeldenianWinner = 2;
			}else // 1st destroyed tower wins...
			{	m_cHeldenianWinner = m_cHeldenianFirstDestroyedTowerWinner;
		}	}		
	}else if (m_cHeldenianType == 2)
	{	if (m_iGodHMapIndex == -1) return;
		// Type 2: Victory for defenders if no victory before
		if (m_cHeldenianWinner == -1)
		{	m_cHeldenianWinner = m_sLastHeldenianWinner;
	}	}
	switch(m_cHeldenianWinner) {
	case 1: 
		wsprintf(G_cTxt, "Heldenian Terminated, Aresden victory.");
		break;
	case 2: 
		wsprintf(G_cTxt, "Heldenian Terminated, Elvine victory.");
		break;
	default: 
		wsprintf(G_cTxt, "Heldenian Terminated, Draw.");
		break;
	}
	PutLogList(G_cTxt);
	GlobalEndHeldenianMode();
}

/*********************************************************************************************************************
**  void CGame::OnTimer(char cType)																					**
**  DESCRIPTION			:: events occuring indefinately while a player is connected									**
**  LAST_UPDATED		:: March 17, 2005; 2:24 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- changed autosave message to log server's bFlag to TRUE								**
**							- increased exp gained in autoexp. now level rather than level/2						**
**							- recall player if crusade is false and is a civilian inside a combatant only zone		**
**							- simplified alot of tasks to improve serverside latency								**
**	MODIFICATION		::  - includes link to _bCheckCharacterData to check for inconsistancies (see that function)**
**********************************************************************************************************************/
void CGame::CheckClientResponseTime()
{
 int i, iPlusTime, iMaxSuperAttack, iValue;
 short sTemp;
 DWORD dwTime;
 short sItemIndex;

	dwTime = timeGetTime();
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL) {		
			if ((dwTime - m_pClientList[i]->m_dwTime) > DEF_CLIENTTIMEOUT ) {
				if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
					wsprintf(G_cTxt, "Client Timeout: %s", m_pClientList[i]->m_cIPaddress);
					PutLogList(G_cTxt);
					DeleteClient(i, TRUE, TRUE, TRUE, FALSE);
				}
				else if ((dwTime - m_pClientList[i]->m_dwTime) > DEF_CLIENTTIMEOUT) {
					DeleteClient(i, FALSE, FALSE, TRUE, FALSE);
				}
			}
			else if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
				m_pClientList[i]->m_iTimeLeft_ShutUp--;
				if (m_pClientList[i]->m_iTimeLeft_ShutUp < 0) m_pClientList[i]->m_iTimeLeft_ShutUp = 0;
				m_pClientList[i]->m_iTimeLeft_Rating--;
				if (m_pClientList[i]->m_iTimeLeft_Rating < 0) m_pClientList[i]->m_iTimeLeft_Rating = 0;
				
				
				if (((dwTime - m_pClientList[i]->m_dwHungerTime) > DEF_HUNGERTIME) && (m_pClientList[i]->m_bIsKilled == FALSE)) {
					if ((m_pClientList[i]->m_iLevel < DEF_LEVELLIMIT) || (m_pClientList[i]->m_iAdminUserLevel >= 1 )) {
					}
					else 
					{
						m_pClientList[i]->m_iHungerStatus--;
						SendNotifyMsg(NULL, i, DEF_NOTIFY_HUNGER, m_pClientList[i]->m_iHungerStatus, NULL, NULL, NULL); // MORLA2 - Muestra el hunger status
					}
					if (m_pClientList[i]->m_iHungerStatus <= 0) m_pClientList[i]->m_iHungerStatus = 0;
					m_pClientList[i]->m_dwHungerTime = dwTime;
					
					if ( (m_pClientList[i]->m_iHP > 0) && (m_pClientList[i]->m_iHungerStatus < 100) ) { // MORLA2 - Para que informe el hunger constantemente
						SendNotifyMsg(NULL, i, DEF_NOTIFY_HUNGER, m_pClientList[i]->m_iHungerStatus, NULL, NULL, NULL);
					}
				}

				/*****MODIFICATION*****/
				// checks all player data for general and packet errors
				if (_bCheckCharacterData(i) == FALSE) {
					DeleteClient(i, TRUE, TRUE);
					break;	
				}
				/*********END**********/
				// Snoopy added Tile where you can't stay (behind crusade structures)
				if (   (m_bIsCrusadeMode == TRUE)
					&& (m_pClientList[i]->m_iAdminUserLevel == 0)
					&& (m_pMapList[m_pClientList[i]->m_cMapIndex]->bGetIsStayAllowedTile(m_pClientList[i]->m_sX, m_pClientList[i]->m_sY) == FALSE))
				{	char iDir = (char)iDice(1,7);
					if (iDir >= 5) iDir += 1;
					int iDamage = m_pClientList[i]->m_iHP/8 + iDice(1,20);					
					if (iDamage < 40) iDamage = 30 + iDice(1,20);
					if (iDamage > m_pClientList[i]->m_iHP) iDamage = m_pClientList[i]->m_iHP -1;
					m_pClientList[i]->m_iHP -= iDamage;					
					m_pClientList[i]->m_iLastDamage = iDamage;		
					m_pClientList[i]->m_dwRecentAttackTime = dwTime;
					SendNotifyMsg(NULL, i, DEF_NOTIFY_DAMAGEMOVE, iDir, iDamage, 0, NULL);
				}
				if ((m_pClientList[i]->m_iHungerStatus <= 40) && (m_pClientList[i]->m_iHungerStatus >= 0)) 
					iPlusTime = (40 - m_pClientList[i]->m_iHungerStatus)*1000;
				else iPlusTime = 0;
				iPlusTime = abs(iPlusTime);
				if ((dwTime - m_pClientList[i]->m_dwHPTime) > (DWORD)(DEF_HPUPTIME + iPlusTime)) {
					TimeHitPointsUp(i);
					m_pClientList[i]->m_dwHPTime = dwTime;
				}
				if ((dwTime - m_pClientList[i]->m_dwMPTime) > (DWORD)(DEF_MPUPTIME + iPlusTime)) {
					TimeManaPointsUp(i);
					m_pClientList[i]->m_dwMPTime = dwTime;
				}
				if ((dwTime - m_pClientList[i]->m_dwSPTime) > (DWORD)(DEF_SPUPTIME + iPlusTime)) {
					TimeStaminarPointsUp(i);
					m_pClientList[i]->m_dwSPTime = dwTime;
				}
				if ((m_pClientList[i]->m_bIsPoisoned == TRUE) && ((dwTime - m_pClientList[i]->m_dwPoisonTime) > DEF_POISONTIME)) {
					PoisonEffect(i, NULL);
					m_pClientList[i]->m_dwPoisonTime = dwTime;
				}
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFightZone == FALSE) &&	((dwTime - m_pClientList[i]->m_dwAutoSaveTime) > (DWORD)DEF_AUTOSAVETIME)) {
					bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i, TRUE); 
					m_pClientList[i]->m_dwAutoSaveTime = dwTime;
				}
				if ((dwTime - m_pClientList[i]->m_dwExpStockTime) > (DWORD)DEF_EXPSTOCKTIME) {
					m_pClientList[i]->m_dwExpStockTime = dwTime;
					CalcExpStock(i);
					CheckUniqueItemEquipment(i);
					CheckCrusadeResultCalculation(i);
					CheckHeldenianResultCalculation(i); // new
				}
				if ((dwTime - m_pClientList[i]->m_dwAutoExpTime) > (DWORD)DEF_AUTOEXPTIME) {
					iValue = m_pClientList[i]->m_iLevel; // changed from /2
					if (iValue <= 0) iValue = 1;
					if (m_pClientList[i]->m_iAutoExpAmount < iValue) {
						if ((m_pClientList[i]->m_iExp + iValue) < m_iLevelExpTable[m_pClientList[i]->m_iLevel+1]) {
							GetExp(i, iValue, FALSE);
							CalcExpStock(i);
						}
					}
					m_pClientList[i]->m_iAutoExpAmount = 0;
					m_pClientList[i]->m_dwAutoExpTime = dwTime;
				}
				// SNOOPY: Added shinning DemonSlayer if Demon/GG around
				sItemIndex = m_pClientList[i]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];	
				if(sItemIndex != -1) 
				{	if(m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 616)   // DS equiped
					{	if(SpecialWeapon_DS(i) == true )
						{	sTemp = m_pClientList[i]->m_sAppr4;
							sTemp = sTemp | 0x0004;		
						}else
						{	sTemp = m_pClientList[i]->m_sAppr4;
							sTemp = sTemp & 0xFFFB;					
						}
						if (m_pClientList[i]->m_sAppr4 != sTemp) // has changed
						{	m_pClientList[i]->m_sAppr4 = sTemp;
							SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				}	}	}
				if (m_pClientList[i]->m_iSpecialAbilityTime == 3) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
					sItemIndex = m_pClientList[i]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
					if (sItemIndex != -1) {
						if ((m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
							if(((m_pClientList[i]->m_iInt+m_pClientList[i]->m_iAngelicInt) > 99) && ((m_pClientList[i]->m_iMag+m_pClientList[i]->m_iAngelicMag) > 99)){
								m_pClientList[i]->m_cMagicMastery[94] = TRUE;
								SendNotifyMsg(NULL, i, DEF_NOTIFY_RESUR_ON, NULL, NULL, NULL, NULL);
							}
						}
					}
				}
				m_pClientList[i]->m_iSpecialAbilityTime -= 3;
				if (m_pClientList[i]->m_iSpecialAbilityTime < 0) m_pClientList[i]->m_iSpecialAbilityTime = 0;
				if (m_pClientList[i]->m_bIsSpecialAbilityEnabled == TRUE) {
					if (((dwTime - m_pClientList[i]->m_dwSpecialAbilityStartTime)/1000) > m_pClientList[i]->m_iSpecialAbilityLastSec) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL);
						m_pClientList[i]->m_bIsSpecialAbilityEnabled = FALSE;
						m_pClientList[i]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
						sTemp = m_pClientList[i]->m_sAppr4;
						sTemp = 0xFF0F & sTemp;
						m_pClientList[i]->m_sAppr4 = sTemp;
						SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}
				}
				m_pClientList[i]->m_iLockedMapTime -= 3;
				if (m_pClientList[i]->m_iLockedMapTime < 0) {
					m_pClientList[i]->m_iLockedMapTime = 0;
					ZeroMemory(m_pClientList[i]->m_cLockedMapName, sizeof(m_pClientList[i]->m_cLockedMapName));
					strcpy(m_pClientList[i]->m_cLockedMapName, "NONE");
				}
				// changed to include ImpossibleZone recall
				m_pClientList[i]->m_iDeadPenaltyTime -= 3;
				if (m_pClientList[i]->m_iDeadPenaltyTime < 0) m_pClientList[i]->m_iDeadPenaltyTime = 0;	
				if (m_pClientList[i]->m_bIsWarLocation == TRUE) {
					if ((m_bIsCrusadeMode != FALSE) && (m_pClientList[i]->m_bIsInsideEnemyBuilding == TRUE)) {
						m_pClientList[i]->m_iTimeLeft_ForceRecall--;
						if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
							m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
							m_pClientList[i]->m_dwWarBeginTime = dwTime;
							m_pClientList[i]->m_bIsWarLocation = FALSE;
							SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
							RequestTeleportHandler(i, "0   ");
						}
					}
					if (m_pClientList[i]->m_bIsImpossibleZone == TRUE) {
						m_pClientList[i]->m_iTimeLeft_ForceRecall--;
						if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
							m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
							m_pClientList[i]->m_bIsImpossibleZone = FALSE;
							SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
							RequestTeleportHandler(i, "0   ");
						}
					}
				}
				// Every 3 seconds, give Hero flag effect if Flag set arround...
				if (   (m_bHeldenianWarInitiated == TRUE)
					&& (bCheckHeldenianMap(i, DEF_OWNERTYPE_PLAYER) == 1)) 
				{		SetHeroFlag(i, DEF_OWNERTYPE_PLAYER, TRUE);
				}else 
				{		SetHeroFlag(i, DEF_OWNERTYPE_PLAYER, FALSE);
				}

				
				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_iSkillMsgRecvCount >= 2) {
					DeleteClient(i, TRUE, TRUE, TRUE, FALSE);
				}
				else {
					m_pClientList[i]->m_iSkillMsgRecvCount = 0;
				}

				if (m_pClientList[i] == NULL) break;
				if ((m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) && 
					(m_pClientList[i]->m_iAdminUserLevel < 1)) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == NULL) break;
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
					(m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) && 
					(m_pClientList[i]->m_iAdminUserLevel < 1)) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				// new - recall player if crusade is false and is a civilian inside a combatant only zone
				if (m_pClientList[i] == NULL) break;
				if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[i]->m_bIsInCombatantOnlyZone == TRUE) && (m_pMapList[i]->m_bIsCitizenLimit = TRUE)) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");

				}

				// KaoZureS - Heldenian Maps Auto Recall
				if (m_pClientList[i] == NULL) break;
				if ((m_bIsHeldenianMode == FALSE) &&
				((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "BtField", 7) == 0) ||
				(memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "GodH", 4) == 0) ||
				(memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "HRampart", 8) == 0)) &&
				(m_pClientList[i]->m_cSide != m_sLastHeldenianWinner) && (m_pClientList[i]->m_iAdminUserLevel == 0)) {
					if (m_pClientList[i]->m_cSide == 1) {
						RequestTeleportHandler(i, "2   ", "aresden", -1, -1); }
					else { RequestTeleportHandler(i, "2   ", "elvine", -1, -1); }
				}

				// Recall clients from apocalypse map if not Apocalypse time
				if (m_pClientList[i] == NULL) break;
				if (   (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsApocalypseMap == TRUE) 
					&& (m_bIsApocalypseMode == FALSE)
					&& (m_pClientList[i]->m_iAdminUserLevel == 0))
				{	m_pClientList[i]->m_bIsWarLocation = TRUE;
					m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;				
				}


				// SNOOPY:added Apoc teleport Gates here		
				Use_ApocalypseGate(i);
				
				if (m_pClientList[i] == NULL) break;
				m_pClientList[i]->m_iSuperAttackCount++;
				if (m_pClientList[i]->m_iSuperAttackCount > 12) {					
					m_pClientList[i]->m_iSuperAttackCount = 0;
					iMaxSuperAttack = (m_pClientList[i]->m_iLevel / 10);
					if (m_pClientList[i]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[i]->m_iSuperAttackLeft++;
					SendNotifyMsg(NULL, i, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
				}
				
				
				m_pClientList[i]->m_iTimeLeft_FirmStaminar--;
				if (m_pClientList[i]->m_iTimeLeft_FirmStaminar < 0) m_pClientList[i]->m_iTimeLeft_FirmStaminar = 0;
				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_bIsSendingMapStatus == TRUE) _SendMapStatus(i);
				if (m_pClientList[i]->m_iConstructionPoint > 0) {
					CheckCommanderConstructionPoint(i);
				}
			}
		}
	}
}

bool CGame::SpecialWeapon_DS(int iClientH)
{
 register int ix, iy, sX, sY;
 short sOwnerH;
 char  cOwnerType;
	
	if (m_pClientList[iClientH] == NULL) return FALSE;

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	for (ix = sX - 20; ix <= sX + 20; ix++)
	for (iy = sY - 20; iy <= sY + 20; iy++) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if (   (sOwnerH != NULL) 
			&& (cOwnerType == DEF_OWNERTYPE_NPC) 
			&& (m_pNpcList[sOwnerH] != NULL) )
		{	if (   ((m_pNpcList[sOwnerH]->m_sType == 31))
				&& (m_pNpcList[sOwnerH]->m_bIsKilled == FALSE) ) 
			{	return TRUE;
			}			
		}
	} 
	return FALSE;
}

/*********************************************************************************************************************
**  void CGame::OnMainLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)									**
**  DESCRIPTION			:: main log socket connection manager														**
**  LAST_UPDATED		:: March 17, 2005; 4:41 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- removed DEF_XSOCKEVENT_BLOCK															**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
void CGame::OnMainLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 int   iRet;
	
	if (m_pMainLogSock == NULL) return;
	iRet = m_pMainLogSock->iOnSocketEvent(wParam, lParam);
	switch (iRet) {
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		PutLogList("(!!!) Main-log-socket connected!");
		break;
		
	case DEF_XSOCKEVENT_READCOMPLETE:
		OnMainLogRead();
		break;

	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		delete m_pMainLogSock;
		m_pMainLogSock = NULL;
		PutLogList("(!!!) Main-log-socket connection lost!");
		m_bIsLogSockAvailable = FALSE;
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 3;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			PutLogList("(!!!) GAME SERVER SHUTDOWN PROCESS BEGIN(by main-log-socket connection Lost)!!!");
		}
		break;
	}
}

/*********************************************************************************************************************
**  void CGame::OnMainLogRead()																						**
**  DESCRIPTION			:: report critical error if mainlog isn't available											**
**  LAST_UPDATED		:: March 17, 2005; 4:42 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	n/a																						**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
void CGame::OnMainLogRead()
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pMainLogSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}

#ifdef DEF_DBGAMESERVER
//==============================================================================
int CGame::iSendMsgToLS(char * cData, DWORD dwSize, char cKey)
{
    if (_bCheckSubLogSocketIndex() == FALSE) return -1;
    return m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(cData, dwSize, cKey);
}
//==============================================================================
BOOL CGame::bSendMsgToLS(DWORD dwMsg, int iClientH, BOOL bFlag, char* pData)
{
 DWORD * dwp;
 WORD  * wp;
 BYTE  * bp;
 int     iRet, i, iSize;
 char    cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;
 char    cGuildLoc[11], cTemp[120];
 int   * ip, iSendSize;
 

	// v1.41
	ZeroMemory(G_cData50000, sizeof(G_cData50000));
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,   sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));
	ZeroMemory(cGuildLoc,  sizeof(cGuildLoc));

	switch (dwMsg) {
	
	case MSGID_PARTYOPERATION:
		iRet = iSendMsgToLS(pData, 50, 0);
		if (iRet == -1) return FALSE;
		break;

	case MSGID_SERVERSTOCKMSG:
		iRet = iSendMsgToLS(pData, m_iIndexGSS+1, 0);
		if (iRet == -1) return FALSE;
		break;
	
	case MSGID_GAMESERVERALIVE:
		if(!m_bIsGameStarted) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERALIVE;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp  = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		wp  = (WORD *)cp;
		*wp = m_iTotalClients;
		cp += 2;
		
		iRet = iSendMsgToLS(G_cData50000, 8, 0);
		if (iRet == -1) return FALSE;
		break;

	// New 07/05/2004
	case MSGID_GAMEMASTERLOG:
		if (pData == NULL) return FALSE ;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMEMASTERLOG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		iSize =  strlen(pData) ;
		SafeCopy((char *)cp, pData, iSize);

		iRet = iSendMsgToLS(G_cData50000, 6 + iSize, 0);
		if (iRet == -1) return FALSE;
		iSendSize = 6 + iSize;
		break;
		// v2.15 

	case MSGID_GAMEITEMLOG:
		if (pData == NULL) return FALSE ;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMEITEMLOG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		iSize =  strlen(pData) ;
		SafeCopy((char *)cp, pData, iSize);

		iRet = iSendMsgToLS(G_cData50000, 6 + iSize, 0);
		if (iRet == -1) return FALSE;
		iSendSize = 6 + iSize;
		break;
	
	case MSGID_SENDSERVERSHUTDOWNMSG:
		
		break;
	
	case MSGID_GAMESERVERSHUTDOWNED:
		
		return TRUE;

	case MSGID_REQUEST_SETACCOUNTWAITSTATUS:
	case MSGID_REQUEST_SETACCOUNTINITSTATUS:
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (strlen(m_pClientList[iClientH]->m_cCharName) == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		SafeCopy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;

		iRet = iSendMsgToLS(G_cData50000, 20, 0);
		if (iRet == -1) return FALSE;
		iSendSize = 16;
		break;

	case MSGID_ENTERGAMECONFIRM:

		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_ENTERGAMECONFIRM;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		SafeCopy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;

		SafeCopy(cp, m_pClientList[iClientH]->m_cAccountPassword, 10);
		cp += 10;

		SafeCopy(cp, m_cServerName, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt));
		m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTxt);
		SafeCopy(cp, cTxt, 16);
		cp += 16;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;

		//testcode
		wsprintf(G_cTxt, "(TestLog) Enter Game Confirm Level: %d", m_pClientList[iClientH]->m_iLevel);
		PutLogList(G_cTxt);

		iRet = iSendMsgToLS(G_cData50000, 56, 0);
		if (iRet == -1) return FALSE;
		iSendSize = 56;
		break;
	
	case MSGID_REQUEST_REGISTERGAMESERVER:

		wsprintf(cTxt, "(!) Try to register game server(%s)", m_cServerName);
		PutLogList(cTxt);

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		if (m_iGameServerMode == 1)
		{
			SafeCopy(cAddress, m_cGameServerAddrExternal, strlen(m_cGameServerAddrExternal));
		}
		if (m_iGameServerMode == 2)
		{
			SafeCopy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));
		}
		SafeCopy(cp, m_cServerName, 10);
		cp += 10;

		SafeCopy(cp, cAddress, 16);
		cp += 16;

		wp  = (WORD *)cp;
		*wp = m_iGameServerPort;
		cp += 2;

		bp  = (BYTE *)cp;
		*bp = ReceivedAllConfig;
		cp++;

		*cp = m_iTotalMaps;
		cp++;

		wp  = (WORD *)cp;
		*wp = m_wServerID_GSS;
		cp += 2;

		for (i = 0; i < m_iTotalMaps; i++) {
			SafeCopy(cp, m_pMapList[i]->m_cName, 11);
			cp += 11;
		}

		m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37 + m_iTotalMaps*11);
		return TRUE;

    case MSGID_REQUEST_REGISTERGAMESERVERSOCKET:
        dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVERSOCKET;
        wp  = (WORD *)(G_cData50000 + 4);
        *wp = GSID;
        m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6);
        wsprintf(cTxt, "(!) Try to register game server socket(%d) on ID[%u]",m_iCurSubLogSockIndex, GSID);
		PutLogList(cTxt);
		return TRUE;

	case MSGID_REQUEST_PLAYERDATA:

		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_PLAYERDATA;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//testcode
		if (strlen(m_pClientList[iClientH]->m_cCharName) == 0) PutLogList("(X) CharName NULL!");

		SafeCopy((char *)cp, m_pClientList[iClientH]->m_cCharName, 0);
		cp += 10;

		SafeCopy((char *)cp, m_pClientList[iClientH]->m_cAccountName, 0);
		cp += 10;

		SafeCopy((char *)cp, m_pClientList[iClientH]->m_cAccountPassword, 0);
		cp += 10;

		ZeroMemory(cTemp, sizeof(cTemp));
		iRet = m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp);
		SafeCopy((char *)cp, cTemp, 15);
		cp += 15;

		iRet = iSendMsgToLS(G_cData50000, 52, 0);
		if (iRet == -1) return FALSE;
		iSendSize = 52;
		break;

	case MSGID_REQUEST_SAVEPLAYERDATA_REPLY:
	case MSGID_REQUEST_SAVEPLAYERDATA:
	case MSGID_REQUEST_SAVEPLAYERDATALOGOUT:

		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (strlen(m_pClientList[iClientH]->m_cCharName) == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		SafeCopy(cp, m_pClientList[iClientH]->m_cCharName, 0);
		cp += 10;

		SafeCopy(cp, m_pClientList[iClientH]->m_cAccountName, 0);
		cp += 10;

		SafeCopy(cp, m_pClientList[iClientH]->m_cAccountPassword, 0);
		cp += 10;

		*cp = (char)bFlag;
		cp++;

		iSize = _iComposePlayerDataFileContents(iClientH, cp);


		iSendSize = (37 + iSize);
        iRet = iSendMsgToLS(G_cData50000, iSendSize, 0);
		if (iRet == -1) return FALSE;
        break;

	case MSGID_REQUEST_NOSAVELOGOUT:

		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (strlen(m_pClientList[iClientH]->m_cCharName) == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_NOSAVELOGOUT;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		SafeCopy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		SafeCopy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		SafeCopy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		SafeCopy((char *)cp, cCharName, 10);
		cp += 10;

		SafeCopy((char *)cp, cAccountName, 10);
		cp += 10;

		SafeCopy((char *)cp, cAccountPassword, 10);
		cp += 10;

		*cp = (char)bFlag;
		cp++;

		iRet = iSendMsgToLS(G_cData50000, 37, 0);
		if (iRet == -1) return FALSE;
		iSendSize = 37;
		break;
	
	case MSGID_REQUEST_CREATENEWGUILD:

		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_CREATENEWGUILD;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		SafeCopy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		SafeCopy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		SafeCopy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		SafeCopy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
		SafeCopy(cGuildLoc, m_pClientList[iClientH]->m_cLocation, 10);

		SafeCopy((char *)cp, cCharName, 10);
		cp += 10;

		SafeCopy((char *)cp, cAccountName, 10);
		cp += 10;

		SafeCopy((char *)cp, cAccountPassword, 10);
		cp += 10;

		SafeCopy((char *)cp, cGuildName, 20);
		cp += 20;
		SafeCopy((char *)cp, cGuildLoc, 10);
		cp += 10;

		iRet = iSendMsgToLS(G_cData50000, 71, 0);
		if (iRet == -1) return FALSE;
		iSendSize = 71;
		break;

	case MSGID_REQUEST_DISBANDGUILD:

		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_DISBANDGUILD;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		SafeCopy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		SafeCopy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		SafeCopy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		SafeCopy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		SafeCopy((char *)cp, cCharName, 10);
		cp += 10;

		SafeCopy((char *)cp, cAccountName, 10);
		cp += 10;

		SafeCopy((char *)cp, cAccountPassword, 10);
		cp += 10;

		SafeCopy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = iSendMsgToLS(G_cData50000, 56, 0);
		if (iRet == -1) return FALSE;
		iSendSize = 56;
		break;

	case MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN:

		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		SafeCopy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		SafeCopy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		SafeCopy((char *)cp, cCharName, 10);
		cp += 10;

		SafeCopy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = iSendMsgToLS(G_cData50000, 36, 0);
		if (iRet == -1) return FALSE;
		iSendSize = 36;
		break;

	case MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN:

		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		SafeCopy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		SafeCopy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		SafeCopy((char *)cp, cCharName, 10);
		cp += 10;

		SafeCopy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = iSendMsgToLS(G_cData50000, 36, 0);
		if (iRet == -1) return FALSE;
		iSendSize = 36;
		break;

	case MSGID_REQUEST_HELDENIAN_WINNER:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_HELDENIAN_WINNER;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		if (m_cHeldenianWinner == 1)
			memcpy(cp, "aresden", 7);
		else if (m_cHeldenianWinner == 2)
			memcpy(cp, "elvine", 6);
		else 
			memcpy(cp, "draw", 4);

		iRet = iSendMsgToLS(G_cData50000, 21, 0);
		if (iRet == -1) return FALSE;
		iSendSize = 21;
		break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) send error!", m_iCurSubLogSockIndex);
		PutLogList(G_cTxt);

		SAFEDELETE(m_pSubLogSock[m_iCurSubLogSockIndex]);
		m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] = FALSE;
		m_iSubLogSockActiveCount--;

		m_pSubLogSock[m_iCurSubLogSockIndex] = new XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pSubLogSock[m_iCurSubLogSockIndex]->bConnect(m_cLogServerAddr, m_iGateServerPort, (WM_ONLOGSOCKETEVENT + m_iCurSubLogSockIndex + 1));
		m_pSubLogSock[m_iCurSubLogSockIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);

		wsprintf(G_cTxt, "(!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", m_iCurSubLogSockIndex, m_cLogServerAddr, m_iGateServerPort);
		PutLogList(G_cTxt);

		m_iSubLogSockFailCount++;

		
		if(iSendMsgToLS(G_cData50000, iSendSize, 0) == -1) return FALSE;

		return FALSE;
	}

	return TRUE;
}
#else
BOOL CGame::bSendMsgToLS(DWORD dwMsg, int iClientH, BOOL bFlag, char* pData)
{
 DWORD * dwp;
 WORD  * wp;
 int     iRet, i, iSize;
 char    cCharName[12], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;
 char    cGuildLoc[11], cTemp[120];
 int   * ip, iSendSize;	

	// v1.41
	ZeroMemory(G_cData50000, sizeof(G_cData50000));
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,   sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));
	ZeroMemory(cGuildLoc,  sizeof(cGuildLoc));

	switch (dwMsg) {
	case MSGID_SENDSERVERSHUTDOWNMSG:
		if (m_pMainLogSock == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_SENDSERVERSHUTDOWNMSG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
		break;

	case MSGID_REQUEST_CREATENEWGUILD:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;	
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_CREATENEWGUILD;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
		memcpy(cGuildLoc, m_pClientList[iClientH]->m_cLocation, 10);
		memcpy((char *)cp, cCharName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;
		memcpy((char *)cp, cGuildName, 20);
		cp += 20;
		memcpy((char *)cp, cGuildLoc, 10);
		cp += 10;
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iGuildGUID;
		cp += 4;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 75);
		iSendSize = 75;
		break;

	case MSGID_REQUEST_SAVEPLAYERDATA_REPLY:
	case MSGID_REQUEST_SAVEPLAYERDATA:
	case MSGID_REQUEST_SAVEPLAYERDATALOGOUT:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy((char *)cp, cCharName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		*cp = (char)bFlag;
		cp++;
		iSize = _iComposePlayerDataFileContents(iClientH, cp);
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 41 + iSize);
		iSendSize = 41 + iSize;
		break;
		
	case MSGID_GAMEMASTERLOG:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (pData == NULL) return FALSE ;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMEMASTERLOG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		iSize =  strlen(pData) ;
		memcpy((char *)cp, pData, iSize);
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		iSendSize = 6 + iSize;
		break;

	case MSGID_GAMEITEMLOG:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (pData == NULL) return FALSE ;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMEITEMLOG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		iSize =  strlen(pData) ;
		memcpy((char *)cp, pData, iSize);
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		iSendSize = 6 + iSize;
		break;

	
	case MSGID_GAMESERVERSHUTDOWNED:
		if (m_pMainLogSock == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERSHUTDOWNED;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
		return TRUE;

	case MSGID_REQUEST_SETACCOUNTWAITSTATUS:
	case MSGID_REQUEST_SETACCOUNTINITSTATUS:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 20);
		iSendSize = 16;
		break;

	case MSGID_ENTERGAMECONFIRM:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_ENTERGAMECONFIRM;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;
		memcpy(cp, m_pClientList[iClientH]->m_cAccountPassword, 10);
		cp += 10;
		memcpy(cp, m_cServerName, 10);
		cp += 10;
		ZeroMemory(cTxt, sizeof(cTxt));
		m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTxt);
		memcpy(cp, cTxt, 16);
		cp += 16;
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;
		wsprintf(G_cTxt, "Confirmed. Account: (%s) Name: (%s) Level: (%d)", m_pClientList[iClientH]->m_cAccountName, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iLevel);
		PutLogList(G_cTxt);
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		iSendSize = 56;
		break;
	
	case MSGID_REQUEST_REGISTERGAMESERVER:
		if (m_pMainLogSock == NULL) return FALSE;		
		wsprintf(cTxt, "(!) Try to register game server(%s)", m_cServerName);
		PutLogList(cTxt);
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cAccountName, m_cServerName, 10);
		if (m_iGameServerMode == 1)	{
			memcpy(cAddress, m_cGameServerAddrExternal, strlen(m_cGameServerAddrExternal));
		}
		else if (m_iGameServerMode == 2)	{
			memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));
		}
		memcpy(cp, cAccountName, 10);
		cp += 10;
		memcpy(cp, cAddress, 16);
		cp += 16;
		wp  = (WORD *)cp;
		*wp = m_iGameServerPort;
		cp += 2;
		*cp = m_iTotalMaps;
		cp++;
		
		for (i = 0; i < m_iTotalMaps; i++) {
			memcpy(cp, m_pMapList[i]->m_cName, 11);
			cp += 11;
		}
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 35 + m_iTotalMaps*11);
		
		return TRUE;

	case MSGID_REQUEST_PLAYERDATA:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_PLAYERDATA;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		if (strlen(m_pClientList[iClientH]->m_cCharName) == 0) PutLogList("(X) CharName NULL!");
		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy((char *)cp, cCharName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;
		ZeroMemory(cTemp, sizeof(cTemp));
		iRet = m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp);
		memcpy((char *)cp, cTemp, 15);
		cp += 15;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 52);
		iSendSize = 52;
		break;

	case MSGID_REQUEST_NOSAVELOGOUT:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_NOSAVELOGOUT;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy((char *)cp, cCharName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;
		*cp = (char)bFlag;
		cp++;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37);
		iSendSize = 37;
		break;

	case MSGID_REQUEST_DISBANDGUILD:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_DISBANDGUILD;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
		memcpy((char *)cp, cCharName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountName, 10);
		cp += 10;
		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;
		memcpy((char *)cp, cGuildName, 20);
		cp += 20;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		iSendSize = 56;
		break;

	case MSGID_3D001242h:
	case MSGID_3D00123Eh:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_3D001242h;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6);
		iSendSize = 6;
		break;
		
	case MSGID_REQUEST_HELDENIAN_WINNER: // Sub-log-socket	
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_HELDENIAN_WINNER;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		if (m_cHeldenianWinner == 1)
			memcpy(cp, "aresden", 7);
		else if (m_cHeldenianWinner == 2)
			memcpy(cp, "elvine", 6);
		else 
			memcpy(cp, "draw", 4);
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 21);
		iSendSize = 21;
		break;
	
	case MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
		memcpy((char *)cp, cCharName, 10);
		cp += 10;
		memcpy((char *)cp, cGuildName, 20);
		cp += 20;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;

	case MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
		memcpy((char *)cp, cCharName, 10);
		cp += 10;
		memcpy((char *)cp, cGuildName, 20);
		cp += 20;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) send error!", m_iCurSubLogSockIndex);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
		delete m_pSubLogSock[m_iCurSubLogSockIndex];
		m_pSubLogSock[m_iCurSubLogSockIndex] = NULL;
		m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] = FALSE;
		m_iSubLogSockActiveCount--;
		m_pSubLogSock[m_iCurSubLogSockIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pSubLogSock[m_iCurSubLogSockIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iCurSubLogSockIndex + 1));
		m_pSubLogSock[m_iCurSubLogSockIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);
		wsprintf(G_cTxt, "(!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", m_iCurSubLogSockIndex, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);		
		m_iSubLogSockFailCount++;
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);
		return FALSE;
	}

	return TRUE;
}
#endif

/*********************************************************************************************************************
**  void CGame::ResponsePlayerDataHandler(char * pData, DWORD dwSize)												**
**  DESCRIPTION			:: action taken following player login														**
**  LAST_UPDATED		:: March 17, 2005; 6:24 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- new code inside LOGRESMSGTYPE_REJECT 													**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
void CGame::ResponsePlayerDataHandler(char * pData, DWORD dwSize)
{
 char * cp, cCharName[11], cTxt[120], cData[120];
 int  i; 
 DWORD * dwp;
 WORD  * wp;
 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
			wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
			switch (*wp) {
			case DEF_LOGRESMSGTYPE_CONFIRM:
				InitPlayerData(i, pData, dwSize); 
				break;
	
			case DEF_LOGRESMSGTYPE_REJECT:
				// new
				if (1) {
					ZeroMemory(cData, sizeof(cData));
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_RESPONSE_INITPLAYER;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_MSGTYPE_CONFIRM;
					m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
				}
				// end
				wsprintf(G_cTxt, "(HACK?) Not existing character(%s) data request! Rejected!", m_pClientList[i]->m_cCharName);
				PutLogList(G_cTxt);
				DeleteClient(i, FALSE, FALSE, TRUE, FALSE);
				break;
			
			default:
				break;
			}				
			return;
		}	
	}
	wsprintf(cTxt, "(!)Non-existing player data received from Log server: CharName(%s)", cCharName);
	PutLogList(cTxt);
}

/*********************************************************************************************************************
**  BOOL CGame::bReadProgramConfigFile(char * cFn)																	**
**  DESCRIPTION			:: function that reads GServer.cfg															**
**  LAST_UPDATED		:: March 17, 2005; 12:09 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- with DMZ walkaround is internet and lan option necissary?								**
**							- does dns work? (unable to test)														**
**	MODIFICATION		::	- game-server-internal-address (internal lan ip address)								**
**							- game-server-external-address (DNS Server)												**
**							- game-server-mode (if inside LAN put "LAN" if not put "INTERNET" (without quotes)		**
**							- gate-server-dns (if set to "true" put in alphabetical dns address)					**
**							- log-server-dns (both dns options benefitial if ip is dynamic and server is no-ip.com	**
**********************************************************************************************************************/
BOOL CGame::bReadProgramConfigFile(char * cFn)
{	
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, * token, cReadMode, cTxt[120], cGSMode[16] = "";
	char seps[] = "= \t\n";	
	class CStrTok * pStrTok;
	bool bGateDNS = FALSE; // bGateDNS added by snaipperi
	bool bLogDNS = FALSE; // bLogDNS added by snaipperi

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		return FALSE;
	}
	else {
		PutLogList("(!) Reading configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL )   {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					ZeroMemory(m_cServerName, sizeof(m_cServerName));
					if (strlen(token) > 10) {
						wsprintf(cTxt, "(!!!) Game server name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cServerName, token);
					wsprintf(cTxt, "(*) Game server name : %s", m_cServerName);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 2:
					ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
					char ServerAddr[50];
					::gethostname(ServerAddr,50); 
					struct hostent *pHostEnt;
					pHostEnt = ::gethostbyname(ServerAddr);
					if( pHostEnt != NULL ){
						wsprintf(ServerAddr, "%d.%d.%d.%d",
							( pHostEnt->h_addr_list[0][0] & 0x00ff ),
							( pHostEnt->h_addr_list[0][1] & 0x00ff ),
							( pHostEnt->h_addr_list[0][2] & 0x00ff ),
							( pHostEnt->h_addr_list[0][3] & 0x00ff ) );
					}
					strcpy(m_cGameServerAddr,ServerAddr );

					wsprintf(cTxt, "(*) Game server address : %s", m_cGameServerAddr);
					PutLogList(cTxt);

					m_iGameServerPort = atoi(token);
					wsprintf(cTxt, "(*) Game server port : %d", m_iGameServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 3:
					ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
					if (bLogDNS == true) { //bLogDNS by Snaipperi
						PutLogList(cTxt);
						char *cAddress = token;
						char cDnsResult[40];
						struct hostent *host_entry;

						host_entry = gethostbyname(cAddress);
						if (host_entry == NULL) {
							wsprintf(cTxt, "(!)DNS (%s) failed",token);
							PutLogList(cTxt);
							return FALSE;
						}
							wsprintf(cDnsResult, "%d.%d.%d.%d",
							( pHostEnt->h_addr_list[0][0] & 0x00ff ),
							( pHostEnt->h_addr_list[0][1] & 0x00ff ),
							( pHostEnt->h_addr_list[0][2] & 0x00ff ),
							( pHostEnt->h_addr_list[0][3] & 0x00ff ) );
				
							wsprintf(cTxt, "(!)DNS from (%s) to (%s) success!",token,cDnsResult);
							PutLogList(cTxt);
							strcpy(m_cLogServerAddr, cDnsResult);
							wsprintf(cTxt, "(*) Log server address : %s", m_cLogServerAddr);
							PutLogList(cTxt);
							cReadMode = 0;
							break;
					}

					if (strlen(token) > 20) {
						wsprintf(cTxt, "(!!!) Log server address(%s) must within 20 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cLogServerAddr, token);
					wsprintf(cTxt, "(*) Log server address : %s", m_cLogServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;


				case 4:
					m_iLogServerPort = atoi(token);
					wsprintf(cTxt, "(*) Log server port : %d", m_iLogServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 5:
					if (strlen(token) > 10) {
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					if (_bRegisterMap(token) == FALSE) {
						return FALSE;
					}
					cReadMode = 0;
					break;

				case 6:
					ZeroMemory(m_cGateServerAddr, sizeof(m_cGateServerAddr));
					if (bGateDNS == true) { //bGateDNS by Snaipperi
						PutLogList(cTxt);
						char *cAddress = token;
						char cDnsResult[40];
						struct hostent *host_entry;
						host_entry = gethostbyname(cAddress);
						if (host_entry == NULL) {
							wsprintf(cTxt, "(!)DNS (%s) failed",token);
							PutLogList(cTxt);
							return FALSE;
						}
							wsprintf(cDnsResult, "%d.%d.%d.%d",
							( host_entry->h_addr_list[0][0] & 0x00ff ),
							( host_entry->h_addr_list[0][1] & 0x00ff ),
							( host_entry->h_addr_list[0][2] & 0x00ff ),
							( host_entry->h_addr_list[0][3] & 0x00ff ) );
				
							wsprintf(cTxt, "(!)DNS from (%s) to (%s) success!",token,cDnsResult);
							PutLogList(cTxt);
							strcpy(m_cGateServerAddr, cDnsResult);
							wsprintf(cTxt, "(*) Gate server address : %s", m_cGateServerAddr);
							PutLogList(cTxt);
							cReadMode = 0;
							break;
					}
					if (strlen(token) > 20) {
						wsprintf(cTxt, "(!!!) Gate server address(%s) must within 20 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGateServerAddr, token);
					wsprintf(cTxt, "(*) Gate server address : %s", m_cGateServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 7:
					m_iGateServerPort = atoi(token);
					wsprintf(cTxt, "(*) Gate server port : %d", m_iGateServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 8:
					ZeroMemory(m_cGameServerAddrInternal, sizeof(m_cGameServerAddrInternal));
					if (strlen(token) > 15) {
						wsprintf(cTxt, "(!!!) Internal (LAN) Game server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGameServerAddrInternal, token);
					wsprintf(cTxt, "(*) Internal (LAN) Game server address : %s", m_cGameServerAddrInternal);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 9:
					ZeroMemory(m_cGameServerAddrExternal, sizeof(m_cGameServerAddrExternal));
					if (strlen(token) > 15) {
						wsprintf(cTxt, "(!!!) External (Internet) Game server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGameServerAddrExternal, token);
					wsprintf(cTxt, "(*) External (Internet) Game server address : %s", m_cGameServerAddrExternal);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 10:
					ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
					if (strlen(token) > 15) {
						wsprintf(cTxt, "(!!!) Game server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGameServerAddr, token);
					wsprintf(cTxt, "(*) Game server address : %s", m_cGameServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 11:
					if ((memcmp(token, "lan", 3) == 0) || (memcmp(token, "LAN", 3) == 0))
					{
						m_iGameServerMode = 1;
						memcpy(cGSMode, "LAN", 3);
					}
					if ((memcmp(token, "internet", 3) == 0) || (memcmp(token, "INTERNET", 3) == 0))
					{
						m_iGameServerMode = 2;
						memcpy(cGSMode, "INTERNET", 8);
					}
					if (m_iGameServerMode == 0)
					{
						wsprintf(cTxt, "(!!!) Game server mode(%s) must be either LAN/lan/INTERNET/internet", token);
						PutLogList(cTxt);
						return FALSE;
					}
					wsprintf(cTxt, "(*) Game server mode : %s", cGSMode);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
			
				case 12: //Gate DNS by SNaipperi
					if (memcmp(token, "true", 4) == 0) {
						bGateDNS = TRUE;
					}
					else bGateDNS = FALSE;
					wsprintf(cTxt, "Gate DNS is set to %i",bGateDNS);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 13: //Log DNS by Snaipperi
					if (memcmp(token, "true", 4) == 0) {
						bLogDNS = TRUE;
					}
					else bLogDNS = FALSE;
					wsprintf(cTxt, "Log DNS is set to %i",bLogDNS);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "game-server-name", 16) == 0)					cReadMode = 1;
				if (memcmp(token, "game-server-port", 16) == 0)					cReadMode = 2;
				if (memcmp(token, "log-server-address", 18) == 0)				cReadMode = 3;
				if (memcmp(token, "internal-log-server-port", 24) == 0)			cReadMode = 4;
				if (memcmp(token, "game-server-map", 15) == 0)					cReadMode = 5;
				if (memcmp(token, "gate-server-address", 19) == 0)				cReadMode = 6;
				if (memcmp(token, "gate-server-port", 16) == 0)					cReadMode = 7;
				if (memcmp(token, "game-server-internal-address", 28) == 0)		cReadMode = 8; // modification
				if (memcmp(token, "game-server-external-address", 28) == 0)		cReadMode = 9; // modification
				if (memcmp(token, "game-server-address", 19) == 0)				cReadMode = 10;// modification
				if (memcmp(token, "game-server-mode", 16) == 0)					cReadMode = 11;// modification
				if (memcmp(token, "gate-server-dns", 15) == 0)					cReadMode = 12;// modification
				if (memcmp(token, "log-server-dns", 14) == 0)					cReadMode = 13;// modification

			}
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	if (m_iGameServerMode == 0) 
	{	wsprintf(cTxt, "(!!!) Game server mode cannot be empty. It must be either ROUTER/router/LAN/lan or INTERNET/internet", token);
		PutLogList(cTxt);
		return FALSE;	
	}	
	if (m_iGameServerMode == 1) // Default address is always internal in ROUTER mode
	{   ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
		strcpy(m_cGameServerAddr, m_cGameServerAddrInternal);
	}else if (m_iGameServerMode == 2) // Internal are always normal in INTERNET mode
	{   ZeroMemory(m_cGameServerAddrInternal, sizeof(m_cGameServerAddrInternal));
		ZeroMemory(m_cGameServerAddrExternal, sizeof(m_cGameServerAddrExternal));
		strcpy(m_cGameServerAddrInternal, m_cGameServerAddr);
		strcpy(m_cGameServerAddrExternal, m_cGameServerAddr);
	}

	return TRUE;
}

/*********************************************************************************************************************
**  void CGame::GameProcess()																						**
**  DESCRIPTION			:: reads Crusade.cfg file																	**
**  LAST_UPDATED		:: March 17, 2005; 12:30 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	n/a																						**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
BOOL CGame::bReadCrusadeStructureConfigFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 int   iIndex;
 class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		PutLogList("(!) Cannot open Crusade configuration file."); //  added for test purposes
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Crusade configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while(token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
					case 1:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format(1).");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						iIndex = atoi(token);

						if (m_stCrusadeStructures[iIndex].cType != NULL) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Duplicate crusade number."); // changed from "duplicate potion number"
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						cReadModeB = 2;
						break;

					case 2:
						ZeroMemory(m_stCrusadeStructures[iIndex].cMapName, sizeof(m_stCrusadeStructures[iIndex].cMapName));
						memcpy(m_stCrusadeStructures[iIndex].cMapName, token, strlen(token));
						cReadModeB = 3;
						break;
					
					case 3:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].cType = atoi(token);
						cReadModeB = 4;
						break;

					case 4:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].dX = atoi(token);
						cReadModeB = 5;
						break;
	
					case 5:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].dY = atoi(token);
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				default: 
					break;
				}
			}
			else {
				if (memcmp(token, "crusade-structure", 17) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}	
		delete pStrTok;
		delete cp;
		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			PutLogList("(!!!) CRITICAL ERROR! Crusade Structure configuration file contents error!");
			return FALSE;
		}
	}
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

/*********************************************************************************************************************
**  BOOL CGame::_bRegisterMap(char * pName)																			**
**  DESCRIPTION			:: manages maps																				**
**  LAST_UPDATED		:: March 17, 2005; 12:38 PM; Hypnotoad														**
**	RETURN_VALUE		:: BOOL																						**
**  NOTES				::	- added m_iBTFieldMapIndex and m_iGodHMapIndex											**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
BOOL CGame::_bRegisterMap(char * pName)
{
 int i;
 char cTmpName[11], cTxt[120];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);
	for (i = 0; i < DEF_MAXMAPS; i++)
	if ((m_pMapList[i] != NULL) && (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
		wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) is already installed! cannot add.", cTmpName);
		PutLogList(cTxt);
		return FALSE;
	}
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] == NULL) {
		m_pMapList[i] = (class CMap *)new class CMap(this);
		wsprintf(cTxt, "(*) Add map (%s)   - Loading map info files...", pName);
		PutLogList(cTxt);
		if (m_pMapList[i]->bInit(pName) == FALSE) {
			wsprintf(cTxt, "(!!!) Data file loading fail!", pName);
			PutLogList(cTxt);
			return FALSE;	
		};
		PutLogList("(*) Data file loading success.");
		if ((m_iMiddlelandMapIndex == -1) && (strcmp("middleland", pName) == 0)) m_iMiddlelandMapIndex = i;
		if ((m_iAresdenMapIndex == -1) && (strcmp("aresden", pName) == 0)) m_iAresdenMapIndex = i;
		if ((m_iElvineMapIndex == -1) && (strcmp("elvine", pName) == 0)) m_iElvineMapIndex = i;
		if ((m_iBTFieldMapIndex == -1) && (strcmp("BtField", pName) == 0)) m_iBTFieldMapIndex = i; // new
		if ((m_iGodHMapIndex == -1) && (strcmp("GodH", pName) == 0)) m_iGodHMapIndex = i; // new
		if ((m_iRampartMapIndex == -1) && (strcmp("HRampart", pName) == 0)) m_iRampartMapIndex = i;
		m_iTotalMaps++;
		return TRUE;
	}
	wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) canot be added - no more map space.", pName);
	PutLogList(cTxt);
	return FALSE;
}

#ifdef DEF_DBGAMESERVER
BOOL CGame::_bDecodePlayerDatafileContents(int iClientH, char * pData, DWORD dwSize)
{
 int    i, iNotUsedItemPrice;
 char   cTxt[200], ItemName[25], OriginBlockDate[25];
 BYTE   NItems, NBankItems;
 DWORD  ItemCount;
 BOOL   IsItemEquipped;
 WORD   BankItemIndex, TotalSkillPoints, sTmpType, sTmpAppr1;
 CStrTok * pStrTok;

	iNotUsedItemPrice = 0;

        if(m_pClientList[iClientH] == NULL) return FALSE;
        ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
		SafeCopy(m_pClientList[iClientH]->m_cMapName, pData, 10);
        for(i = 0; i < DEF_MAXMAPS; i++)
		if((m_pMapList[i] != NULL) && (IsSame(m_pMapList[i]->m_cName, m_pClientList[iClientH]->m_cMapName)))
              m_pClientList[iClientH]->m_cMapIndex = (char)i;
        if (m_pClientList[iClientH]->m_cMapIndex == -1)
			{
			 wsprintf(cTxt, "(!) Player(%s) tries to enter unknown map : %s", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName);
			 PutLogList(cTxt);
			 return FALSE;
			}
        m_pClientList[iClientH]->m_sX = (short)wGetOffsetValue(pData, 10);
        m_pClientList[iClientH]->m_sY = (short)wGetOffsetValue(pData, 12);
        m_pClientList[iClientH]->m_cSex = bGetOffsetValue(pData, 14);
		m_pClientList[iClientH]->m_cSkin = bGetOffsetValue(pData, 15);
		m_pClientList[iClientH]->m_cHairStyle = bGetOffsetValue(pData, 16);
		m_pClientList[iClientH]->m_cHairColor = bGetOffsetValue(pData, 17);
		m_pClientList[iClientH]->m_cUnderwear = bGetOffsetValue(pData, 18);
        ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
		SafeCopy(m_pClientList[iClientH]->m_cGuildName, pData+19, 20);
		m_pClientList[iClientH]->m_iGuildRank = (signed char)bGetOffsetValue(pData, 39);
        m_pClientList[iClientH]->m_iHP = dwGetOffsetValue(pData, 40);
        m_pClientList[iClientH]->m_iLevel = wGetOffsetValue(pData, 44);
        m_pClientList[iClientH]->m_iStr = bGetOffsetValue(pData, 46);
        m_pClientList[iClientH]->m_iVit = bGetOffsetValue(pData, 47);
		m_pClientList[iClientH]->m_iDex = bGetOffsetValue(pData, 48);
		m_pClientList[iClientH]->m_iInt = bGetOffsetValue(pData, 49);
		m_pClientList[iClientH]->m_iMag = bGetOffsetValue(pData, 50);
		m_pClientList[iClientH]->m_iCharisma = bGetOffsetValue(pData, 51);
		m_pClientList[iClientH]->m_iLuck = bGetOffsetValue(pData, 52);
		m_pClientList[iClientH]->m_iExp = dwGetOffsetValue(pData, 53);
        for (i = 0; i < DEF_MAXMAGICTYPE; i++) m_pClientList[iClientH]->m_cMagicMastery[i] = bGetOffsetValue(pData, 57+i) - 48;
        ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
		SafeCopy(m_pClientList[iClientH]->m_cLocation, pData+181, 10);
		if (memcmp(m_pClientList[iClientH]->m_cLocation+3,"hunter",6) == 0) m_pClientList[iClientH]->m_bIsPlayerCivil = TRUE;
        m_pClientList[iClientH]->m_iMP = dwGetOffsetValue(pData, 191);
		m_pClientList[iClientH]->m_iSP = dwGetOffsetValue(pData, 195);
		m_pClientList[iClientH]->m_iLU_Pool = bGetOffsetValue(pData, 199);
		m_pClientList[iClientH]->m_iEnemyKillCount = dwGetOffsetValue(pData, 200);
		m_pClientList[iClientH]->m_iPKCount = (int)dwGetOffsetValue(pData, 204);
		m_pClientList[iClientH]->m_iRewardGold = dwGetOffsetValue(pData, 208);
        for(BYTE b = 0; b < 24; b++)
              {
               m_pClientList[iClientH]->m_cSkillMastery[b] = bGetOffsetValue(pData, (157+b));
               m_pClientList[iClientH]->m_iSkillSSN[b] = dwGetOffsetValue(pData, (212+(b*4)));
              }
        m_pClientList[iClientH]->m_iHungerStatus = bGetOffsetValue(pData, 312);
		m_pClientList[iClientH]->m_iAdminUserLevel = bGetOffsetValue(pData, 313);
		m_pClientList[iClientH]->m_iTimeLeft_ShutUp = dwGetOffsetValue(pData, 314);
		m_pClientList[iClientH]->m_iTimeLeft_Rating = dwGetOffsetValue(pData, 318);
		m_pClientList[iClientH]->m_iRating = (int)dwGetOffsetValue(pData, 322);
		m_pClientList[iClientH]->m_iGuildGUID = (short)wGetOffsetValue(pData, 326);
		m_pClientList[iClientH]->m_iDownSkillIndex = (signed char)bGetOffsetValue(pData, 330);
        m_pClientList[iClientH]->m_sCharIDnum1 = (short)dwGetOffsetValue(pData, 335);
		m_pClientList[iClientH]->m_sCharIDnum2 = (short)dwGetOffsetValue(pData, 339);
		m_pClientList[iClientH]->m_sCharIDnum3 = (short)dwGetOffsetValue(pData, 343);
        ZeroMemory(OriginBlockDate, sizeof(OriginBlockDate));
        SafeCopy(OriginBlockDate, pData+347, 20);
        char seps[] = " :-";
		pStrTok = new CStrTok(OriginBlockDate, seps);
		m_pClientList[iClientH]->m_iPenaltyBlockYear = atoi(pStrTok->pGet());
        m_pClientList[iClientH]->m_iPenaltyBlockMonth = atoi(pStrTok->pGet());
        m_pClientList[iClientH]->m_iPenaltyBlockDay = atoi(pStrTok->pGet());
		SAFEDELETE(pStrTok);
        m_pClientList[iClientH]->m_iQuest = wGetOffsetValue(pData, 367);
		m_pClientList[iClientH]->m_iCurQuestCount = wGetOffsetValue(pData, 369);
		m_pClientList[iClientH]->m_iQuestRewardType = (sWORD)wGetOffsetValue(pData, 371);
		m_pClientList[iClientH]->m_iQuestRewardAmount = dwGetOffsetValue(pData, 373);
		m_pClientList[iClientH]->m_iContribution = dwGetOffsetValue(pData, 377);
		m_pClientList[iClientH]->m_iQuestID = dwGetOffsetValue(pData, 381);
		m_pClientList[iClientH]->m_bIsQuestCompleted = bGetOffsetValue(pData, 385);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = dwGetOffsetValue(pData, 386);
		m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = dwGetOffsetValue(pData, 390);
		m_pClientList[iClientH]->m_iSpecialEventID = dwGetOffsetValue(pData, 394);
        m_pClientList[iClientH]->m_iSuperAttackLeft = wGetOffsetValue(pData, 398);
        m_pClientList[iClientH]->m_iFightzoneNumber = bGetOffsetValue(pData, 400);
        m_pClientList[iClientH]->m_iReserveTime = dwGetOffsetValue(pData, 401);
        m_pClientList[iClientH]->m_iFightZoneTicketNumber = bGetOffsetValue(pData, 405);
		m_pClientList[iClientH]->m_iSpecialAbilityTime = dwGetOffsetValue(pData, 406);
		m_pClientList[iClientH]->m_iWarContribution = dwGetOffsetValue(pData, 410);
		ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
		SafeCopy(m_pClientList[iClientH]->m_cLockedMapName, pData+414, 10);
		m_pClientList[iClientH]->m_iLockedMapTime = dwGetOffsetValue(pData, 424);
		m_pClientList[iClientH]->m_iCrusadeDuty = bGetOffsetValue(pData, 428);
		m_pClientList[iClientH]->m_iConstructionPoint = dwGetOffsetValue(pData, 429);
		m_pClientList[iClientH]->m_dwCrusadeGUID = dwGetOffsetValue(pData, 433);
		m_pClientList[iClientH]->m_iDeadPenaltyTime = dwGetOffsetValue(pData, 437);
		m_pClientList[iClientH]->m_iPartyID = dwGetOffsetValue(pData, 441);
		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = wGetOffsetValue(pData, 445);
		// majestic-level
		// ip2
		// ip 
		// heldenian-GUID
        for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++) m_pClientList[iClientH]->m_sItemEquipmentStatus[i] = -1;
        for (i = 0; i < DEF_MAXITEMS; i++) m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
        NItems = bGetOffsetValue(pData, 447);
        NBankItems = bGetOffsetValue(pData, (448 + (NItems*60)+1));
        if(NItems > DEF_MAXITEMS || NBankItems > DEF_MAXBANKITEMS) return FALSE;
        if(NItems > 0)
        for(BYTE b = 0; b < NItems; b++)
           {
            WORD IndexForItem = (448 + (b*60));
            ZeroMemory(ItemName, sizeof(ItemName));
            SafeCopy(ItemName, pData+IndexForItem, 20);
            m_pClientList[iClientH]->m_pItemList[b] = new CItem;
            if(_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[b], ItemName) == FALSE)
              {
               ZeroMemory(cTxt, sizeof(cTxt));
			   wsprintf(cTxt, "(!!!) Client(%s)-Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, ItemName);
			  PutLogList(cTxt);
               SAFEDELETE(m_pClientList[iClientH]->m_pItemList[b]);
               return FALSE;
              }
            ItemCount = dwGetOffsetValue(pData, (IndexForItem+20));
            if(iGetItemWeight(m_pClientList[iClientH]->m_pItemList[b], ItemCount) > _iCalcMaxLoad(iClientH) )
              {
			   ItemCount = 1;
               ZeroMemory(cTxt, sizeof(cTxt));
			   wsprintf(cTxt, "(!) Client(%s)-Item(%s) is too heavy.", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[b]->m_cName);
			   PutLogList(cTxt);
               SAFEDELETE(m_pClientList[iClientH]->m_pItemList[b]);
               return FALSE;
				}
            m_pClientList[iClientH]->m_pItemList[b]->m_dwCount = ItemCount;
            m_pClientList[iClientH]->m_pItemList[b]->m_sTouchEffectType = wGetOffsetValue(pData, (IndexForItem+24));
            m_pClientList[iClientH]->m_pItemList[b]->m_sTouchEffectValue1 = (short)dwGetOffsetValue(pData, (IndexForItem+26));
			m_pClientList[iClientH]->m_pItemList[b]->m_sTouchEffectValue2 = (short)dwGetOffsetValue(pData, (IndexForItem+30));
			m_pClientList[iClientH]->m_pItemList[b]->m_sTouchEffectValue3 = (short)dwGetOffsetValue(pData, (IndexForItem+34));
			m_pClientList[iClientH]->m_pItemList[b]->m_cItemColor = bGetOffsetValue(pData, (IndexForItem+38));
			m_pClientList[iClientH]->m_pItemList[b]->m_sItemSpecEffectValue1 = (short)wGetOffsetValue(pData, (IndexForItem+39));
			m_pClientList[iClientH]->m_pItemList[b]->m_sItemSpecEffectValue2 = (short)wGetOffsetValue(pData, (IndexForItem+41));
			m_pClientList[iClientH]->m_pItemList[b]->m_sItemSpecEffectValue3 = (short)wGetOffsetValue(pData, (IndexForItem+43));
			m_pClientList[iClientH]->m_pItemList[b]->m_wCurLifeSpan = wGetOffsetValue(pData, (IndexForItem+45));
            m_pClientList[iClientH]->m_pItemList[b]->m_dwAttribute = dwGetOffsetValue(pData, (IndexForItem+47));
            if(m_pClientList[iClientH]->m_pItemList[b]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER)
              {
				if((m_pClientList[iClientH]->m_pItemList[b]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
					(m_pClientList[iClientH]->m_pItemList[b]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
					(m_pClientList[iClientH]->m_pItemList[b]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3) )
                  {
                   ZeroMemory(cTxt, sizeof(cTxt));
				   wsprintf(cTxt,"(!) Player(%s) have Item(%s) with another owner ID-> [%d  %d  %d] - [%d  %d  %d]", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[b]->m_cName,
                                                                                m_pClientList[iClientH]->m_pItemList[b]->m_sTouchEffectValue1, m_pClientList[iClientH]->m_pItemList[b]->m_sTouchEffectValue2,
                                                                                m_pClientList[iClientH]->m_pItemList[b]->m_sTouchEffectValue3, m_pClientList[iClientH]->m_sCharIDnum1, m_pClientList[iClientH]->m_sCharIDnum2,
                                                                                m_pClientList[iClientH]->m_sCharIDnum3);
                   PutLogList(cTxt);
					}
				}
            if((m_pClientList[iClientH]->m_pItemList[b]->m_dwAttribute & 0x00000001 ) != NULL) m_pClientList[iClientH]->m_pItemList[b]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[b]->m_sItemSpecEffectValue1;
            _AdjustRareItemValue(m_pClientList[iClientH]->m_pItemList[b]);
            if(m_pClientList[iClientH]->m_pItemList[b]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemList[b]->m_wMaxLifeSpan) m_pClientList[iClientH]->m_pItemList[b]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[b]->m_wMaxLifeSpan;
            if((m_pClientList[iClientH]->m_pItemList[b]->m_wCurLifeSpan == 0) && (m_pClientList[iClientH]->m_pItemList[b]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP))
              {
               ZeroMemory(cTxt, sizeof(cTxt));
               wsprintf(cTxt, "(!) Player(%s) have a Zemstone with lifespan = 0!", m_pClientList[iClientH]->m_cCharName);
               PutLogList(cTxt);
               m_pClientList[iClientH]->m_pItemList[b]->m_wCurLifeSpan = 1;
		      }
            bCheckAndConvertPlusWeaponItem(iClientH, b);
            if (m_pClientList[iClientH]->m_pItemList[b]->m_cItemType == DEF_ITEMTYPE_NOTUSED)
               {
		    	iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[b]->m_wPrice;
				SAFEDELETE(m_pClientList[iClientH]->m_pItemList[b]);
				}
			else if(_bCheckDupItemID(m_pClientList[iClientH]->m_pItemList[b]) == TRUE)
               {
				_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[b]);
                iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[b]->m_wPrice;
                SAFEDELETE(m_pClientList[iClientH]->m_pItemList[b]);
               }
            if(m_pClientList[iClientH]->m_pItemList[b] != NULL)
              {
               IsItemEquipped = bGetOffsetValue(pData, (IndexForItem+51));
               if(IsItemEquipped && m_pClientList[iClientH]->m_pItemList[b]->m_cItemType == DEF_ITEMTYPE_EQUIP)
                  m_pClientList[iClientH]->m_bIsItemEquipped[b] = TRUE;
				}
            if(m_pClientList[iClientH]->m_bIsItemEquipped[b] == TRUE && bEquipItemHandler(iClientH, b) == FALSE) m_pClientList[iClientH]->m_bIsItemEquipped[b] = FALSE;
            m_pClientList[iClientH]->m_ItemPosList[b].x = (int)wGetOffsetValue(pData, (IndexForItem+52));
		    m_pClientList[iClientH]->m_ItemPosList[b].y = (int)wGetOffsetValue(pData, (IndexForItem+54));
            if (m_pClientList[iClientH]->m_ItemPosList[b].y < -10) m_pClientList[iClientH]->m_ItemPosList[b].y = -10;
           }
        BankItemIndex = (448 + (NItems*60)+2);
        if(NBankItems > 0)
        for(BYTE b = 0; b < NBankItems; b++)
           {
            WORD IndexForItem = (BankItemIndex + (b*55));
            ZeroMemory(ItemName, sizeof(ItemName));
            SafeCopy(ItemName, pData+IndexForItem, 20);
            m_pClientList[iClientH]->m_pItemInBankList[b] = new CItem;
            if(_bInitItemAttr(m_pClientList[iClientH]->m_pItemInBankList[b], ItemName) == FALSE)
              {
               ZeroMemory(cTxt, sizeof(cTxt));
			   wsprintf(cTxt, "(!!!) Client(%s)-Bank Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, ItemName);
			   PutLogList(cTxt);
               SAFEDELETE(m_pClientList[iClientH]->m_pItemInBankList[b]);
               return FALSE;
              }
            ItemCount = dwGetOffsetValue(pData, (IndexForItem+20));
            if(iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[b], ItemCount) > _iCalcMaxLoad(iClientH) )
              {
               ItemCount = 1;
               ZeroMemory(cTxt, sizeof(cTxt));
			   wsprintf(cTxt, "(!) Client(%s)-BankItem(%s) is too heavy.", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemInBankList[b]->m_cName);
			   PutLogList(cTxt);
               SAFEDELETE(m_pClientList[iClientH]->m_pItemInBankList[b]);
               return FALSE;
				}
            m_pClientList[iClientH]->m_pItemInBankList[b]->m_dwCount = ItemCount;
            m_pClientList[iClientH]->m_pItemInBankList[b]->m_sTouchEffectType = wGetOffsetValue(pData, (IndexForItem+24));
			m_pClientList[iClientH]->m_pItemInBankList[b]->m_sTouchEffectValue1 = (short)dwGetOffsetValue(pData, (IndexForItem+26));
			m_pClientList[iClientH]->m_pItemInBankList[b]->m_sTouchEffectValue2 = (short)dwGetOffsetValue(pData, (IndexForItem+30));
			m_pClientList[iClientH]->m_pItemInBankList[b]->m_sTouchEffectValue3 = (short)dwGetOffsetValue(pData, (IndexForItem+34));
			m_pClientList[iClientH]->m_pItemInBankList[b]->m_cItemColor = bGetOffsetValue(pData, (IndexForItem+38));
			m_pClientList[iClientH]->m_pItemInBankList[b]->m_sItemSpecEffectValue1 = (short)wGetOffsetValue(pData, (IndexForItem+39));
			m_pClientList[iClientH]->m_pItemInBankList[b]->m_sItemSpecEffectValue2 = (short)wGetOffsetValue(pData, (IndexForItem+41));
			m_pClientList[iClientH]->m_pItemInBankList[b]->m_sItemSpecEffectValue3 = (short)wGetOffsetValue(pData, (IndexForItem+43));
			m_pClientList[iClientH]->m_pItemInBankList[b]->m_wCurLifeSpan = wGetOffsetValue(pData, (IndexForItem+45));
            m_pClientList[iClientH]->m_pItemInBankList[b]->m_dwAttribute = dwGetOffsetValue(pData, (IndexForItem+47));
            
            if((m_pClientList[iClientH]->m_pItemInBankList[b]->m_dwAttribute & 0x00000001) != NULL)
	        m_pClientList[iClientH]->m_pItemInBankList[b]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[b]->m_sItemSpecEffectValue1;

            int iValue = (m_pClientList[iClientH]->m_pItemInBankList[b]->m_dwAttribute & 0xF0000000) >> 28;
            if(iValue > 0)
              {
				switch (m_pClientList[iClientH]->m_pItemInBankList[b]->m_cCategory) {
               	case 5:
				case 6:
				m_pClientList[iClientH]->m_pItemInBankList[b]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[b]->m_sItemSpecEffectValue1;
	       		break;
				}
			}
            _AdjustRareItemValue(m_pClientList[iClientH]->m_pItemInBankList[b]);
            if(m_pClientList[iClientH]->m_pItemInBankList[b]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemInBankList[b]->m_wMaxLifeSpan)
	        m_pClientList[iClientH]->m_pItemInBankList[b]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[b]->m_wMaxLifeSpan;
	        if((m_pClientList[iClientH]->m_pItemInBankList[b]->m_wCurLifeSpan == 0) && (m_pClientList[iClientH]->m_pItemInBankList[b]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP))
              {
               ZeroMemory(cTxt, sizeof(cTxt));
               wsprintf(cTxt, "(!) Player(%s) have a Zemstone with lifespan = 0!", m_pClientList[iClientH]->m_cCharName);
               PutLogList(cTxt);
	           m_pClientList[iClientH]->m_pItemInBankList[b]->m_wCurLifeSpan = 1;
				}
            if(m_pClientList[iClientH]->m_pItemInBankList[b]->m_cItemType == DEF_ITEMTYPE_NOTUSED)
              {
			   iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[b]->m_wPrice;
	           SAFEDELETE(m_pClientList[iClientH]->m_pItemInBankList[b]);
				}
            else if(_bCheckDupItemID(m_pClientList[iClientH]->m_pItemInBankList[b]) == TRUE)
                {
				 _bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemInBankList[b]);
                 iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[b]->m_wPrice;
		         SAFEDELETE(m_pClientList[iClientH]->m_pItemInBankList[b]);
				}
           }
        WORD InfoSize = (BankItemIndex +(NBankItems*55)+1);
        ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
	    SafeCopy(m_pClientList[iClientH]->m_cProfile, pData+InfoSize, strlen(pData+InfoSize));

		BOOL bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bIsValidLoc(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		if(bRet == FALSE)
          {
		   if ((m_pClientList[iClientH]->m_sX != -1) || (m_pClientList[iClientH]->m_sY != -1))
              {
               ZeroMemory(cTxt, sizeof(cTxt));
			   wsprintf(cTxt, "Invalid location error! %s (%d, %d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	           PutLogList(cTxt);
	           return FALSE;
				}
			}
        if((m_pClientList[iClientH]->m_iLU_Pool < 0) || (m_pClientList[iClientH]->m_iLU_Pool > DEF_CHARPOINTLIMIT)) return FALSE;
		if((m_pClientList[iClientH]->m_iStr < 10) || (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT)) return FALSE;
		if((m_pClientList[iClientH]->m_iDex < 10) || (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT)) return FALSE;
		if((m_pClientList[iClientH]->m_iVit < 10) || (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT)) return FALSE;
		if((m_pClientList[iClientH]->m_iInt < 10) || (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT)) return FALSE;
		if((m_pClientList[iClientH]->m_iMag < 10) || (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT)) return FALSE;
		if((m_pClientList[iClientH]->m_iCharisma < 10) || (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT)) return FALSE;
		if((m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cCharName) == FALSE) || (m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cAccountName) == FALSE)) return FALSE;
        if(m_pClientList[iClientH]->m_iPenaltyBlockYear != 0 && !IsDatePast(OriginBlockDate)) return FALSE;
        if(m_pClientList[iClientH]->m_iReserveTime != 0)
          {
           SYSTEMTIME SysTime;
		   GetLocalTime(&SysTime);
	       __int64 iDateSum1 = (__int64)m_pClientList[iClientH]->m_iReserveTime;
	       __int64 iDateSum2 = (__int64)(SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour);
	       if(iDateSum2 >= iDateSum1)
             {
	          SendNotifyMsg(NULL, i, DEF_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
	          m_pClientList[iClientH]->m_iFightzoneNumber = 0;
	          m_pClientList[iClientH]->m_iReserveTime = 0;
	          m_pClientList[iClientH]->m_iFightZoneTicketNumber = 0;
			}
	  }
	if(m_pClientList[iClientH]->m_iAdminUserLevel < 0) m_pClientList[iClientH]->m_iAdminUserLevel = 0;
	if(m_pClientList[iClientH]->m_cSex == 1) sTmpType = 1;
	else if(m_pClientList[iClientH]->m_cSex == 2) sTmpType = 4;
	switch (m_pClientList[iClientH]->m_cSkin) {
	case 1:
		break;
	case 2:
		sTmpType ++;
		break;
	case 3:
		sTmpType += 2;
		break;
	}
	if(m_pClientList[iClientH]->m_iAdminUserLevel >= 10) sTmpType = m_pClientList[iClientH]->m_iAdminUserLevel;
	sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);

	m_pClientList[iClientH]->m_sType  = sTmpType;
	m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1;

    iCalcTotalWeight(iClientH);
    TotalSkillPoints = 0;
	BYTE b;
    for(b = 0; b < 24; b++) TotalSkillPoints += m_pClientList[iClientH]->m_cSkillMastery[b];
    if(TotalSkillPoints > DEF_MAXSKILLPOINTS && m_pClientList[iClientH]->m_iAdminUserLevel == 0)
      {
       ZeroMemory(cTxt, sizeof(cTxt));
       wsprintf(cTxt, "(!) Player(%s) with skill's sum(%u) above permitted!", m_pClientList[iClientH]->m_cCharName, TotalSkillPoints);
	   PutLogList(cTxt);
	   return FALSE;
      }
	if (m_pClientList[iClientH]->m_sCharIDnum1 == 0) {
		int _i, _iTemp1, _iTemp2;
		short _sID1, _sID2, _sID3;

		_iTemp1 = 1;
		_iTemp2 = 1;
		for (_i = 0; _i < 10; _i++) {
			_iTemp1 += m_pClientList[iClientH]->m_cCharName[_i];
			_iTemp2 += abs(m_pClientList[iClientH]->m_cCharName[_i] ^ m_pClientList[iClientH]->m_cCharName[_i]);
		}

		_sID1 = (short)timeGetTime(); 
		_sID2 = (short)_iTemp1; 
		_sID3 = (short)_iTemp2;

		m_pClientList[iClientH]->m_sCharIDnum1 = _sID1;
		m_pClientList[iClientH]->m_sCharIDnum2 = _sID2;
		m_pClientList[iClientH]->m_sCharIDnum3 = _sID3;
	}

	m_pClientList[iClientH]->m_iRewardGold += iNotUsedItemPrice;
	m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	if (IsSame(m_pClientList[iClientH]->m_cLocation, "NONE")) m_pClientList[iClientH]->m_bIsNeutral = TRUE;

	return TRUE;
}
#else
/*********************************************************************************************************************
**  BOOL CGame::_bDecodePlayerDatafileContents(int iClientH, char * pData, DWORD dwSize)							**
**  DESCRIPTION			:: decodes <PLAYERNAME>.txt file in Character folder										**
**  LAST_UPDATED		:: March 17, 2005; 12:42 PM; Hypnotoad														**
**	RETURN_VALUE		:: BOOL																						**
**  NOTES				::	- MOST OF THIS FUNCTION UPGRADE IS IGNORED DUE TO MYSQL<->ASCII ISSUES					**
**							- changed stat point checks code														**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
BOOL CGame::_bDecodePlayerDatafileContents(int iClientH, char * pData, DWORD dwSize)
{
	char * pContents, * token, * pOriginContents, cTmpName[11], cTxt[120];
	char   seps[] = "= \t\n";
	char   cReadModeA, cReadModeB;
	int    i, iItemIndex, iItemInBankIndex, iTotalGold, iNotUsedItemPrice;
	class  CStrTok * pStrTok;
	short  sTmpType, sTmpAppr1;
	BOOL   bRet;
	int    iTemp;
	SYSTEMTIME SysTime;
	__int64 iDateSum1, iDateSum2;
	BOOL   bIsNotUsedItemFound = FALSE;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	iTotalGold = 0;
	iItemIndex = 0;
	iItemInBankIndex  = 0;
	iNotUsedItemPrice = 0;
	cReadModeA = 0;
	cReadModeB = 0;

	pContents = new char[dwSize+2];
	ZeroMemory(pContents, dwSize+2);
	memcpy(pContents, pData, dwSize);
	pOriginContents = pContents;
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				//     . 
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				strcpy(m_pClientList[iClientH]->m_cMapName, token);
				//      . 
				ZeroMemory(cTmpName, sizeof(cTmpName));
				strcpy(cTmpName, token);
				for (i = 0; i < DEF_MAXMAPS; i++)
					if ((m_pMapList[i] != NULL)	&& (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
						//   i.
						m_pClientList[iClientH]->m_cMapIndex = (char)i;
					}

					if (m_pClientList[iClientH]->m_cMapIndex == -1) {
						wsprintf(cTxt, "(!) Player(%s) tries to enter unknown map : %s", m_pClientList[iClientH]->m_cCharName, cTmpName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					cReadModeA = 0;
					break;

			case 2:
				//    X
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_sX = atoi(token);
				cReadModeA = 0;
				break;

			case 3:
				//    Y
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_sY = atoi(token);
				cReadModeA = 0;
				break;

			case 4:
				//    . <-     .    
				
				cReadModeA = 0;
				break;

			case 5:
				//       .
				switch(cReadModeB) {
			case 1:
				// New 07/05/2004
				// v2.12
				if (iItemIndex >= DEF_MAXITEMS) {
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				// token  .      m_pItemConfigList  .
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], token) == FALSE) {
					//     . 
					wsprintf(cTxt, "(!!!) Client(%s)-Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token); 
					PutLogList(cTxt);

					// Debug code @@@@@@@@@@@@@@@
					HANDLE hFile;
					DWORD  nWrite;
					hFile = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
					WriteFile(hFile, (char *)pContents, dwSize+2, &nWrite, NULL);
					CloseHandle(hFile);
					///////////// @@@@@@@@@@@@@@@

					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				cReadModeB = 2;
				break;

			case 2:
				// m_dwCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				//   1 .
				iTemp = atoi(token);
				if (iTemp < 0) iTemp = 1;
				//   1 .
				if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], iTemp) > _iCalcMaxLoad(iClientH) ) {
					iTemp = 1;
					wsprintf(G_cTxt, "(!) Player(%s) Item (%s) too heavy for player to carry", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName);
					PutLogFileList(G_cTxt);
					PutLogList(G_cTxt);
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = (DWORD)iTemp;
				cReadModeB = 3;

				// v1.3      . 
				if (memcmp(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, "Gold", 4) == 0)
					iTotalGold += iTemp;
				break;

			case 3:
				// m_sTouchEffectType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// m_sTouchEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				// m_sTouchEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// m_sTouchEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = atoi(token);
				cReadModeB = 7;
				break;

			case 7:
				// m_cItemColor
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = atoi(token);
				cReadModeB = 8;
				break;

			case 8:
				// m_sItemSpecEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = atoi(token);
				cReadModeB = 9;
				break;

			case 9:
				// m_sItemSpecEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 = atoi(token);
				cReadModeB = 10;
				break;

			case 10:
				// m_sItemSpecEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3 = atoi(token);
				cReadModeB = 11;
				break;

			case 11:
				// m_wCurLifeSpan
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = atoi(token);
				cReadModeB = 12;
				break;

			case 12:
				// m_dwAttribute
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = atoi(token);

				// v1.4    . 
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) {
					if ( (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
						(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
						(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3) ) {
							//      . 
							wsprintf(cTxt, "(!)    : Player(%s) Item(%s) %d %d %d - %d %d %d", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1,
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2,
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3,
								m_pClientList[iClientH]->m_sCharIDnum1,
								m_pClientList[iClientH]->m_sCharIDnum2,
								m_pClientList[iClientH]->m_sCharIDnum3); 
							PutLogList(cTxt);
							
						}
				}

				cReadModeA = 0;
				cReadModeB = 0;

				// v1.41  Custom-Made  . 
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001 ) != NULL) {
					//   ItemSpecialEffectValue1
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
					//     ItemSpecialEffectValue2
				}

				// v1.42       , ,     . 
				_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemList[iItemIndex]);

				// v1.41       .
				

				// v1.433
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan == 0) && 
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
						//  . 
						wsprintf(G_cTxt, "(!) (%s)  0  !", m_pClientList[iClientH]->m_cCharName);
						PutLogFileList(G_cTxt);
						//  1  
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = 1;
					}

					// v2.05 +    ,  
					bCheckAndConvertPlusWeaponItem(iClientH, iItemIndex);

					// v1.4        . 
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

						// v1.41
						bIsNotUsedItemFound = TRUE;
					}
					else
						if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemList[iItemIndex]) == TRUE) {
							// v1.42   .
							_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

							iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice;
							delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
							m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
						}
						else iItemIndex++;
						break;
				}
				break;

			case 6:
				//   
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSex = atoi(token);
				cReadModeA = 0;
				break;

			case 7:
				//   
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSkin = atoi(token);
				cReadModeA = 0;
				break;

			case 8:
				//    
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cHairStyle = atoi(token);
				cReadModeA = 0;
				break;

			case 9:
				//   
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cHairColor = atoi(token);
				cReadModeA = 0;
				break;

			case 10:
				//  
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cUnderwear = atoi(token);
				cReadModeA = 0;
				break;

			case 11:
				//      !!!!!

				//      .
				for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++) 
					m_pClientList[iClientH]->m_sItemEquipmentStatus[i] = -1;

				//   .
				for (i = 0; i < DEF_MAXITEMS; i++) 
					m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

				// v1.41        . 
				if (bIsNotUsedItemFound == FALSE) {
					for (i = 0; i < DEF_MAXITEMS; i++) {
						wsprintf(cTxt, "%d", token[i]);
						if ((token[i] == '1') && (m_pClientList[iClientH]->m_pItemList[i] != NULL)) {
							//       
							if (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP) 
								m_pClientList[iClientH]->m_bIsItemEquipped[i] = TRUE;
							else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
						}
						else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

						if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE)) {
							//      .
							if (bEquipItemHandler(iClientH, i) == FALSE) // FALSE
								m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE; //            
						}
					}
				}

				cReadModeA = 0;
				break;

			case 12:
				//   .
				//    20 
				ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
				strcpy(m_pClientList[iClientH]->m_cGuildName, token);
				cReadModeA = 0;
				break;

			case 13:
				//   
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iGuildRank = atoi(token);
				cReadModeA = 0;
				break;

			case 14:
				// HP 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iHP = atoi(token);
				cReadModeA = 0;
				break;

			case 15:
				// DefenseRatio  .   
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				cReadModeA = 0;
				break;

			case 16:
				// HitRatio   .   
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				cReadModeA = 0;
				break;

			case 17:
				// Level  
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLevel = atoi(token);
				cReadModeA = 0;
				break;

			case 18:
				// Str 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iStr = atoi(token);
				cReadModeA = 0;
				break;

			case 19:
				// Int 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iInt = atoi(token);
				cReadModeA = 0;
				break;

			case 20:
				// Vit 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iVit = atoi(token);
				cReadModeA = 0;
				break;

			case 21:
				// Dex 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDex = atoi(token);
				cReadModeA = 0;
				break;

			case 22:
				// Mag 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iMag = atoi(token);
				cReadModeA = 0;
				break;

			case 23:
				// Charisma 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iCharisma = atoi(token);
				cReadModeA = 0;
				break;

			case 24:
				// Luck 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLuck = atoi(token);
				cReadModeA = 0;
				break;

			case 25:
				// Exp 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iExp = atoi(token);
				cReadModeA = 0;
				break;

			case 26:
				// Magic-Mastery . // 0  . 1  .
				for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
					m_pClientList[iClientH]->m_cMagicMastery[i] = token[i] - 48;
				}
				cReadModeA = 0;
				break;

			case 27:
				// Skill-Mastery .
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSkillMastery[cReadModeB] = atoi(token);
				cReadModeB++;

				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;
				//
			case 28:
				// Warehouse      .
				switch(cReadModeB) {
			case 1:
				if (iItemInBankIndex >= DEF_MAXBANKITEMS) {
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				// token  .      m_pItemConfigList  .
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], token) == FALSE) {
					//      . 
					wsprintf(cTxt, "(!!!) Client(%s)-Bank Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token); 
					PutLogList(cTxt);

					// Debug code @@@@@@@@@@@@@@@
					HANDLE hFile;
					DWORD  nWrite;
					hFile = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
					WriteFile(hFile, (char *)pOriginContents, dwSize+2, &nWrite, NULL);
					CloseHandle(hFile);
					///////////// @@@@@@@@@@@@@@@

					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				cReadModeB = 2;
				break;

			case 2:
				// m_dwCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				//   1 .
				iTemp = atoi(token);
				if (iTemp < 0) iTemp = 1;

				//         1 .
				if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], iTemp) > _iCalcMaxLoad(iClientH) ) {
					iTemp = 1;
					wsprintf(G_cTxt, "(!) (%s) (%s)  ", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName);
					PutLogFileList(G_cTxt);
					PutLogList(G_cTxt);
				}

				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwCount = (DWORD)iTemp;
				cReadModeB = 3;

				// v1.3      . 
				if (memcmp(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName, "Gold", 4) == 0)
					iTotalGold += iTemp;
				break;

			case 3:
				// m_sTouchEffectType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectType = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// m_sTouchEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue1 = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				// m_sTouchEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue2 = atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// m_sTouchEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue3 = atoi(token);
				cReadModeB = 7;
				break;

			case 7:
				// m_cItemColor
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemColor = atoi(token);
				cReadModeB = 8;
				break;

			case 8:
				// m_sItemSpecEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1 = atoi(token);
				cReadModeB = 9;
				break;

			case 9:
				// m_sItemSpecEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue2 = atoi(token);
				cReadModeB = 10;
				break;

			case 10:
				// m_sItemSpecEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue3 = atoi(token);
				cReadModeB = 11;
				break;

			case 11:
				// m_wCurLifeSpan
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = atoi(token);

				cReadModeB = 12;
				break;


			case 12:
				// m_dwAttribute
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;

				// v1.41  Custom-Made  . 
				if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0x00000001) != NULL) {
					//   ItemSpecialEffectValue1
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;
					//     ItemSpecialEffectValue2

				}

				// v2.16 2002-5-21  
				int iValue = (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (iValue > 0) {
					//   .     ItemSpecialEffectValue1 .
					switch (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cCategory) {
			case 5: //  
			case 6: //  
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;
				break;
					}
				}

				// v1.42       , ,     . 
				_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);

				// v1.41     .
				

				// v1.433
				if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan == 0) && 
					(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
						//  . 
						wsprintf(G_cTxt, "(!) (%s)  0  !", m_pClientList[iClientH]->m_cCharName);
						PutLogFileList(G_cTxt);
						//  1  
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = 1;
					}

					// v1.4        . 
					if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = NULL;
					}
					else 
						if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]) == TRUE) {
							// v1.42   .
							_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);

							iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
							delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = NULL;		
						}
						else iItemInBankIndex++;
						break;
				}
				break;
				//

			case 29:
				//    .
				ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
				strcpy(m_pClientList[iClientH]->m_cLocation, token);
				if (memcmp(m_pClientList[iClientH]->m_cLocation+3,"hunter",6) == 0)
					m_pClientList[iClientH]->m_bIsPlayerCivil = TRUE;
				cReadModeA = 0;
				break;


			case 30:
				// m_iMP
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iMP = atoi(token);
				cReadModeA = 0;
				break;

			case 31:
				// m_iSP
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iSP = atoi(token);
				cReadModeA = 0;
				break;

			case 32:
				// m_cLU_Pool
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLU_Pool = atoi(token);
				cReadModeA = 0;
				break;
			
			case 38:
				// m_iEnemyKillCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iEnemyKillCount = atoi(token);
				cReadModeA = 0;
				break;

			case 39:
				// m_iPKCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPKCount = atoi(token);
				cReadModeA = 0;
				break;

			case 40:
				// m_iRewardGold
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iRewardGold = atoi(token);
				cReadModeA = 0;
				break;

			case 41:
				// Skill-SSN .
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iSkillSSN[cReadModeB] = atoi(token);
				cReadModeB++;

				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 42:
				if (token != NULL) {
					ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
					strcpy(m_pClientList[iClientH]->m_cProfile, token);
				}
				cReadModeA = 0;
				break;

			case 43:
				// Hunger-Status .
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iHungerStatus = atoi(token);
				cReadModeA = 0;
				break;

				case 44:
				// AdminUserLevel
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iAdminUserLevel = 0; //Default it to 0
				if (atoi(token) > 0) {
				for (i = 0; i < DEF_MAXADMINS; i++) {
					if(strlen(m_stAdminList[i].m_cGMName) == 0) break; //No more GM's on list
						if ((strlen(m_stAdminList[i].m_cGMName)) == (strlen(m_pClientList[iClientH]->m_cCharName))) {
							if(memcmp(m_stAdminList[i].m_cGMName,m_pClientList[iClientH]->m_cCharName,strlen(m_pClientList[iClientH]->m_cCharName)) == 0){
								m_pClientList[iClientH]->m_iAdminUserLevel = atoi(token);
								break; //Break goes to cReadModeA = 0, so no need to do it again
							}
						}
					}
				}
				cReadModeA = 0;
				break;
				
				

			case 45:
				// TimeLeft_ShutUp
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTimeLeft_ShutUp = atoi(token);
				cReadModeA = 0;
				break;

			case 46:
				// TimeLeft_Rating
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTimeLeft_Rating = atoi(token);
				cReadModeA = 0;
				break;

			case 47:
				// Rating
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iRating = atoi(token);
				cReadModeA = 0;
				break;

			case 48:
				// Guild GUID:     -1   .
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iGuildGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 49:
				// Down Skill Index
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDownSkillIndex = atoi(token);
				cReadModeA = 0;
				break;

			case 50:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].x = atoi(token);
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 51:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y = atoi(token);
				// v1.3   . 
				if (m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y < -10) m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y = -10;
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 52:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_sCharIDnum1 = atoi(token);
				cReadModeA = 0;
				break;

			case 53:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_sCharIDnum2 = atoi(token);
				cReadModeA = 0;
				break;

			case 54:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_sCharIDnum3 = atoi(token);
				cReadModeA = 0;
				break;

			case 55:
				switch (cReadModeB) {
			case 1:
				// Penalty Block Year
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPenaltyBlockYear = atoi(token);

				cReadModeB = 2;
				break;

			case 2:
				// Penalty Block Month
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPenaltyBlockMonth = atoi(token);

				cReadModeB = 3;
				break;

			case 3:
				// Penalty Block day
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPenaltyBlockDay = atoi(token);

				cReadModeA = 0;
				cReadModeB = 0;
				break;
				}
				break;

			case 56:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iQuest = atoi(token);
				cReadModeA = 0;
				break;

			case 57:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iCurQuestCount = atoi(token);
				cReadModeA = 0;
				break;

			case 58:
				cReadModeA = 0;
				break;

			case 59:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iQuestRewardType = atoi(token);
				cReadModeA = 0;
				break;

			case 60:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iQuestRewardAmount = atoi(token);
				cReadModeA = 0;
				break;

			case 61:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iContribution = atoi(token);
				cReadModeA = 0;
				break;

			case 62:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iQuestID = atoi(token);
				cReadModeA = 0;
				break;

			case 63:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_bIsQuestCompleted = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 64:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 65:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 66:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iSpecialEventID = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

				// v1.4311-3        
			case 67:
				switch (cReadModeB) {
			case 1:
				// FightZone Number
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iFightzoneNumber = atoi(token);

				cReadModeB = 2;
				break;

			case 2:
				//   
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iReserveTime = atoi(token);


				cReadModeB = 3;
				break;
			case 3:
				//   
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iFightZoneTicketNumber = atoi(token);

				cReadModeA = 0;
				cReadModeB = 0;
				break;

				}
				break;

			case 70:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iSuperAttackLeft = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 71:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iSpecialAbilityTime = atoi(token);
				cReadModeA = 0;
				break;

			case 72:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iWarContribution = atoi(token);
				cReadModeA = 0;
				break;

			case 73:
				if (strlen(token) > 10) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
				strcpy(m_pClientList[iClientH]->m_cLockedMapName, token);
				cReadModeA = 0;
				break;

			case 74:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iLockedMapTime = atoi(token);
				cReadModeA = 0;
				break;

			case 75:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iCrusadeDuty = atoi(token);
				cReadModeA = 0;
				break;

			case 76:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iConstructionPoint = atoi(token);
				cReadModeA = 0;
				break;

			case 77:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_dwCrusadeGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 78:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iDeadPenaltyTime = atoi(token);
				cReadModeA = 0;
				break;

			case 79: // v2.06 12-4
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iPartyID = atoi(token);
				if (m_pClientList[iClientH]->m_iPartyID != NULL) m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
				cReadModeA = 0;
				break;

			case 80: // v2.15 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = atoi(token);
				if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 0) m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = 0;
				cReadModeA = 0;
				break;

			case 81: 
				if (strlen(token) > 21) strcpy(token, m_pClientList[iClientH]->m_cIPaddress); 
				ZeroMemory(m_pClientList[iClientH]->m_cIP2, sizeof(m_pClientList[iClientH]->m_cIP2)); 
				strcpy(m_pClientList[iClientH]->m_cIP2, token); 
				cReadModeA = 0; 
				break;

			case 82:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_dwHeldenianGUID = atoi(token);
				cReadModeA = 0;
				break;

				
			case 83:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iMajesticLevel = atoi(token);
				cReadModeA = 0;
				break;

			case 84:
				// m_iMaxEK
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iMaxEK = atoi(token);
				cReadModeA = 0;
				break;

			case 85:
				// m_iDeaths MORLA 2.2 - Nuevos datos para el pj
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDeaths = atoi(token);
				cReadModeA = 0;
				break;

			case 86:
				// m_iDGPoints
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDGPoints = atoi(token);
				cReadModeA = 0;
				break;

			case 87:
				// character-DGKills
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDGKills = atoi(token);
				cReadModeA = 0;
				break;

			case 88:
				// character-DGDeaths
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTotalDGDeaths = atoi(token);
				cReadModeA = 0;
				break;

			case 89:
				// character-Kills
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTotalDGKills = atoi(token);
				cReadModeA = 0;
				break;

			}
		}
		else {
			if (memcmp(token, "character-loc-map", 17) == 0)		 cReadModeA = 1;
			if (memcmp(token, "character-loc-x", 15) == 0)			 cReadModeA = 2;
			if (memcmp(token, "character-loc-y", 15) == 0)			 cReadModeA = 3;
			if (memcmp(token, "character-account-status", 21) == 0)  cReadModeA = 4;
			if (memcmp(token, "character-item", 14) == 0) {
				cReadModeA = 5;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
			}
			if (memcmp(token, "character-bank-item", 18) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = new class CItem;
			}
			if (memcmp(token, "sex-status", 10) == 0)        cReadModeA = 6;
			if (memcmp(token, "skin-status", 11) == 0)       cReadModeA = 7;
			if (memcmp(token, "hairstyle-status", 16) == 0)  cReadModeA = 8;
			if (memcmp(token, "haircolor-status", 16) == 0)  cReadModeA = 9;
			if (memcmp(token, "underwear-status", 16) == 0)  cReadModeA = 10;
			if (memcmp(token, "item-equip-status", 17) == 0)    cReadModeA = 11;
			if (memcmp(token, "character-guild-name", 20) == 0) cReadModeA = 12;
			if (memcmp(token, "character-guild-rank", 20) == 0) cReadModeA = 13;
			if (memcmp(token, "character-HP", 12) == 0)         cReadModeA = 14;
			if (memcmp(token, "character-DefenseRatio",22)==0)  cReadModeA = 15;
			if (memcmp(token, "character-HitRatio", 18) == 0)   cReadModeA = 16;
			if (memcmp(token, "character-LEVEL", 15) == 0)      cReadModeA = 17;
			if (memcmp(token, "character-STR", 13) == 0)        cReadModeA = 18;
			if (memcmp(token, "character-INT", 13) == 0)        cReadModeA = 19;
			if (memcmp(token, "character-VIT", 13) == 0)        cReadModeA = 20;
			if (memcmp(token, "character-DEX", 13) == 0)        cReadModeA = 21;
			if (memcmp(token, "character-MAG", 13) == 0)        cReadModeA = 22;
			if (memcmp(token, "character-CHARISMA", 18) == 0)   cReadModeA = 23;
			if (memcmp(token, "character-LUCK", 14) == 0)       cReadModeA = 24;
			if (memcmp(token, "character-EXP", 13) == 0)        cReadModeA = 25;
			if (memcmp(token, "magic-mastery", 13) == 0)        cReadModeA = 26;
			if (memcmp(token, "skill-mastery", 13) == 0) {
				cReadModeA = 27;
				cReadModeB = 0;
			}
			if (memcmp(token, "character-location", 18) == 0)   cReadModeA = 29;
			if (memcmp(token, "character-MP", 12) == 0)         cReadModeA = 30;
			if (memcmp(token, "character-SP", 12) == 0)         cReadModeA = 31;
			if (memcmp(token, "character-LU_Pool", 17) == 0)     cReadModeA = 32;
			
			if (memcmp(token, "character-EK-Count",18) == 0)    cReadModeA = 38;
			if (memcmp(token, "character-PK-Count",18) == 0)    cReadModeA = 39;
			if (memcmp(token, "character-reward-gold",21) == 0) cReadModeA = 40;
			if (memcmp(token, "skill-SSN", 9) == 0) 			cReadModeA = 41;
			if (memcmp(token, "character-profile", 17) == 0)	cReadModeA = 42;
			if (memcmp(token, "hunger-status", 13) == 0) 		cReadModeA = 43;
			if (memcmp(token, "admin-user-level", 16) == 0) 	cReadModeA = 44;
			if (memcmp(token, "timeleft-shutup", 15) == 0) 		cReadModeA = 45;
			if (memcmp(token, "timeleft-rating", 15) == 0) 		cReadModeA = 46;
			if (memcmp(token, "character-RATING", 16) == 0)	    cReadModeA = 47;
			if (memcmp(token, "character-guild-GUID", 20) == 0) cReadModeA = 48;
			if (memcmp(token, "character-downskillindex", 24) == 0) cReadModeA = 49;
			if (memcmp(token, "item-position-x", 16) == 0) {
				cReadModeA = 50;
				cReadModeB = 1;
			}
			if (memcmp(token, "item-position-y", 16) == 0) {
				cReadModeA = 51;
				cReadModeB = 1;
			}
			if (memcmp(token, "character-IDnum1",16) == 0)		cReadModeA = 52;
			if (memcmp(token, "character-IDnum2",16) == 0)		cReadModeA = 53;
			if (memcmp(token, "character-IDnum3",16) == 0)		cReadModeA = 54;
			if (memcmp(token, "penalty-block-date",18) == 0) {
				cReadModeA = 55;
				cReadModeB = 1;
			}
			if (memcmp(token, "character-quest-number",22) == 0) cReadModeA = 56;
			if (memcmp(token, "current-quest-count",19) == 0)	 cReadModeA = 57;
			if (memcmp(token, "quest-reward-type", 17) == 0)    cReadModeA = 59;
			if (memcmp(token, "quest-reward-amount", 19) == 0)  cReadModeA = 60;
			if (memcmp(token, "character-contribution", 22) == 0)   cReadModeA = 61;
			if (memcmp(token, "character-quest-ID",18) == 0)        cReadModeA = 62;
			if (memcmp(token, "character-quest-completed",25) == 0) cReadModeA = 63;
			if (memcmp(token, "timeleft-force-recall", 21) == 0)	cReadModeA = 64;
			if (memcmp(token, "timeleft-firm-staminar", 22) == 0)	cReadModeA = 65;
			if (memcmp(token, "special-event-id", 16) == 0)			cReadModeA = 66;
			if (memcmp(token, "super-attack-left", 17) == 0)		cReadModeA = 70;
			if (memcmp(token, "reserved-fightzone-id", 21) == 0)	{
				cReadModeA = 67;
				cReadModeB = 1;
			}
			if (memcmp(token, "special-ability-time", 20) == 0)       cReadModeA = 71; 
			if (memcmp(token, "character-war-contribution", 26) == 0) cReadModeA = 72; 
			if (memcmp(token, "locked-map-name", 15) == 0) cReadModeA = 73;
			if (memcmp(token, "locked-map-time", 15) == 0) cReadModeA = 74;
			if (memcmp(token, "crusade-job", 11) == 0)     cReadModeA = 75;
			if (memcmp(token, "construct-point", 15) == 0) cReadModeA = 76;
			if (memcmp(token, "crusade-GUID", 12) == 0)    cReadModeA = 77;
			if (memcmp(token, "dead-penalty-time", 17) == 0) cReadModeA = 78;
			if (memcmp(token, "party-id", 8) == 0)           cReadModeA = 79;
			if (memcmp(token, "gizon-item-upgrade-left", 23) == 0) cReadModeA = 80;


			if (memcmp(token, "ip2", 3)== 0) cReadModeA = 81;

			if (memcmp(token, "heldenian-GUID", 14) == 0)    cReadModeA = 82;

			if (memcmp(token, "majestic-level", 14) == 0) cReadModeA = 83;

			if (memcmp(token, "max-ek", 6) == 0) cReadModeA = 84;

			if (memcmp(token, "character-Deaths", 16) == 0)    cReadModeA = 85; // MORLA 2.2 - Nuevos datos para el PJ
			if (memcmp(token, "character-DGPoints", 18) == 0)    cReadModeA = 86;
			if (memcmp(token, "character-DGKills", 17) == 0)    cReadModeA = 87;
			if (memcmp(token, "character-TotalDGDeaths", 23) == 0)    cReadModeA = 88;
			if (memcmp(token, "character-TotalDGKills", 22) == 0)    cReadModeA = 89;

			if (memcmp(token, "[EOF]", 5) == 0) goto DPDC_STOP_DECODING;
		}
		token = pStrTok->pGet();
	}													  

DPDC_STOP_DECODING:;	

	delete pStrTok;
	delete pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		wsprintf(cTxt, "(!!!) Player(%s) data file contents error(%d %d)! Connection closed.", m_pClientList[iClientH]->m_cCharName, cReadModeA, cReadModeB);
		PutLogList(cTxt);
		// Debug code @@@@@@@@@@@@@@@
		HANDLE hFile2;
		DWORD  nWrite2;
		hFile2 = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
		WriteFile(hFile2, (char *)pOriginContents, dwSize+2, &nWrite2, NULL);
		CloseHandle(hFile2);
		///////////// @@@@@@@@@@@@@@@
		return FALSE;
	}

	// verified all data below
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bIsValidLoc(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	if (bRet == FALSE) {
		GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);
	}
	if ((m_pClientList[iClientH]->m_iLU_Pool > 255) || (m_pClientList[iClientH]->m_iLU_Pool < 0)) return FALSE;
	if ((m_pClientList[iClientH]->m_iStr < 10) || (m_pClientList[iClientH]->m_iStr > m_sCharStatLimit)) return FALSE;
	if ((m_pClientList[iClientH]->m_iDex < 10) || (m_pClientList[iClientH]->m_iDex > m_sCharStatLimit)) return FALSE;
	if ((m_pClientList[iClientH]->m_iVit < 10) || (m_pClientList[iClientH]->m_iVit > m_sCharStatLimit)) return FALSE;
	if ((m_pClientList[iClientH]->m_iInt < 10) || (m_pClientList[iClientH]->m_iInt > m_sCharStatLimit)) return FALSE;
	if ((m_pClientList[iClientH]->m_iMag < 10) || (m_pClientList[iClientH]->m_iMag > m_sCharStatLimit)) return FALSE;
	if ((m_pClientList[iClientH]->m_iCharisma < 10) || (m_pClientList[iClientH]->m_iCharisma > m_sCharStatLimit)) return FALSE;
	char cStatPointTotal;
	cStatPointTotal = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;
	if (m_pClientList[iClientH]->m_iLU_Pool < 3) m_pClientList[iClientH]->m_iLU_Pool = 3;
	if ((cStatPointTotal + (m_pClientList[iClientH]->m_iLU_Pool-3)) != ((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) {
		if (cStatPointTotal > ((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) return FALSE;
		m_pClientList[iClientH]->m_iLU_Pool = ((m_pClientList[iClientH]->m_iLevel-1)*3 + 73) - ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma));
	}
	if ((m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cCharName) == FALSE) || (m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cAccountName) == FALSE)) 
		return FALSE;
	if (m_pClientList[iClientH]->m_iPenaltyBlockYear != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)(m_pClientList[iClientH]->m_iPenaltyBlockYear*10000 + m_pClientList[iClientH]->m_iPenaltyBlockMonth*100 + m_pClientList[iClientH]->m_iPenaltyBlockDay);
		iDateSum2 = (__int64)(SysTime.wYear*10000 + SysTime.wMonth*100 + SysTime.wDay);
		if (iDateSum1 >= iDateSum2) return FALSE;
	}
	if (m_pClientList[iClientH]->m_iReserveTime != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)m_pClientList[iClientH]->m_iReserveTime;
		iDateSum2 = (__int64)(SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour);
		if (iDateSum2 >= iDateSum1) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_iFightzoneNumber = 0; 
			m_pClientList[iClientH]->m_iReserveTime = 0;
			m_pClientList[iClientH]->m_iFightZoneTicketNumber = 0;
		}
	}
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 0) m_pClientList[iClientH]->m_iAdminUserLevel = 0;
	if (m_pClientList[iClientH]->m_cSex == 1) {
		sTmpType = 1;
	}
	else if (m_pClientList[iClientH]->m_cSex == 2) {
		sTmpType = 4; 
	}
	switch (m_pClientList[iClientH]->m_cSkin) {
	case 1:
		break;
	case 2:
		sTmpType ++;
		break;
	case 3:
		sTmpType += 2;
		break;
	}
	if (m_pClientList[iClientH]->m_iAdminUserLevel >= 10) sTmpType = m_pClientList[iClientH]->m_iAdminUserLevel;
	sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
	m_pClientList[iClientH]->m_sType  = sTmpType;
	m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1;
	iCalcTotalWeight(iClientH);
	if (m_pClientList[iClientH]->m_sCharIDnum1 == 0) {
		int _i, _iTemp1, _iTemp2;
		short _sID1, _sID2, _sID3;
		_iTemp1 = 1;
		_iTemp2 = 1;
		for (_i = 0; _i < 10; _i++) {
			_iTemp1 += m_pClientList[iClientH]->m_cCharName[_i];
			_iTemp2 += abs(m_pClientList[iClientH]->m_cCharName[_i] ^ m_pClientList[iClientH]->m_cCharName[_i]);
		}
		_sID1 = (short)timeGetTime(); 
		_sID2 = (short)_iTemp1; 
		_sID3 = (short)_iTemp2; 
		m_pClientList[iClientH]->m_sCharIDnum1 = _sID1;
		m_pClientList[iClientH]->m_sCharIDnum2 = _sID2;
		m_pClientList[iClientH]->m_sCharIDnum3 = _sID3;
	}
	m_pClientList[iClientH]->m_iRewardGold += iNotUsedItemPrice;
	m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	return TRUE;
}
#endif

#ifdef DEF_DBGAMESERVER
int CGame::_iComposePlayerDataFileContents(int iClientH, char * pData)
{
 SYSTEMTIME SysTime;
 char  cTxt[30];
 int   i;
 BYTE  NItems, NBankItems;
 WORD  IndexForItem, Index;
 
		if (m_pClientList[iClientH] == NULL) return 0;

		GetLocalTime(&SysTime);
        PutOffsetValue(pData, 0, DEF_WORDSIZE, SysTime.wYear);
        PutOffsetValue(pData, 2, DEF_BYTESIZE, SysTime.wMonth);
        PutOffsetValue(pData, 3, DEF_BYTESIZE, SysTime.wDay);
        PutOffsetValue(pData, 4, DEF_BYTESIZE, SysTime.wHour);
        PutOffsetValue(pData, 5, DEF_BYTESIZE, SysTime.wMinute);
        PutOffsetValue(pData, 6, DEF_BYTESIZE, SysTime.wSecond);
        SafeCopy(pData+7, m_pClientList[iClientH]->m_cLocation, 0);
        SafeCopy(pData+17, m_pClientList[iClientH]->m_cMapName, 0);
        PutOffsetValue(pData, 27, DEF_WORDSIZE, m_pClientList[iClientH]->m_sX);
        PutOffsetValue(pData, 29, DEF_WORDSIZE, m_pClientList[iClientH]->m_sY);
		if (m_pClientList[iClientH]->m_iGuildRank != -1)
           {
            SafeCopy(pData+31, m_pClientList[iClientH]->m_cGuildName, 0);
            PutOffsetValue(pData, 51, DEF_WORDSIZE, m_pClientList[iClientH]->m_iGuildGUID);
           }
		else
           {
            SafeCopy(pData+31, "NONE", 0);
            PutOffsetValue(pData, 51, DEF_WORDSIZE, -1);
           }
        PutOffsetValue(pData, 53, DEF_WORDSIZE, m_pClientList[iClientH]->m_iGuildRank);
        if(m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 30;
        PutOffsetValue(pData, 55, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iHP);
        PutOffsetValue(pData, 59, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iMP);
		if(m_pClientList[iClientH]->m_iSP < 0) m_pClientList[iClientH]->m_iSP = 0;
        PutOffsetValue(pData, 63, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iSP);
        PutOffsetValue(pData, 67, DEF_WORDSIZE, m_pClientList[iClientH]->m_iLevel);
        PutOffsetValue(pData, 69, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iRating);
        PutOffsetValue(pData, 73, DEF_BYTESIZE, m_pClientList[iClientH]->m_iStr);
        PutOffsetValue(pData, 74, DEF_BYTESIZE, m_pClientList[iClientH]->m_iVit);
        PutOffsetValue(pData, 75, DEF_BYTESIZE, m_pClientList[iClientH]->m_iDex);
        PutOffsetValue(pData, 76, DEF_BYTESIZE, m_pClientList[iClientH]->m_iInt);
        PutOffsetValue(pData, 77, DEF_BYTESIZE, m_pClientList[iClientH]->m_iMag);
        PutOffsetValue(pData, 78, DEF_BYTESIZE, m_pClientList[iClientH]->m_iCharisma);
        PutOffsetValue(pData, 79, DEF_BYTESIZE, m_pClientList[iClientH]->m_iLuck);
        PutOffsetValue(pData, 80, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iExp);
        PutOffsetValue(pData, 84, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iEnemyKillCount);
        PutOffsetValue(pData, 88, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iPKCount);
        PutOffsetValue(pData, 92, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iRewardGold);
        PutOffsetValue(pData, 96, DEF_BYTESIZE, m_pClientList[iClientH]->m_iDownSkillIndex);
        PutOffsetValue(pData, 97, DEF_DWORDSIZE, m_pClientList[iClientH]->m_sCharIDnum1);
        PutOffsetValue(pData, 101, DEF_DWORDSIZE, m_pClientList[iClientH]->m_sCharIDnum2);
        PutOffsetValue(pData, 105, DEF_DWORDSIZE, m_pClientList[iClientH]->m_sCharIDnum3);
        PutOffsetValue(pData, 109, DEF_BYTESIZE, m_pClientList[iClientH]->m_cSex);
        PutOffsetValue(pData, 110, DEF_BYTESIZE, m_pClientList[iClientH]->m_cSkin);
        PutOffsetValue(pData, 111, DEF_BYTESIZE, m_pClientList[iClientH]->m_cHairStyle);
        PutOffsetValue(pData, 112, DEF_BYTESIZE, m_pClientList[iClientH]->m_cHairColor);
        PutOffsetValue(pData, 113, DEF_BYTESIZE, m_pClientList[iClientH]->m_cUnderwear);
        PutOffsetValue(pData, 114, DEF_BYTESIZE, m_pClientList[iClientH]->m_iHungerStatus);
        PutOffsetValue(pData, 115, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iTimeLeft_ShutUp);
        PutOffsetValue(pData, 119, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iTimeLeft_Rating);
        PutOffsetValue(pData, 123, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall);
        PutOffsetValue(pData, 127, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar);
        PutOffsetValue(pData, 131, DEF_BYTESIZE, m_pClientList[iClientH]->m_iAdminUserLevel);
        ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d-%d-%d 00:00:00", m_pClientList[iClientH]->m_iPenaltyBlockYear, m_pClientList[iClientH]->m_iPenaltyBlockMonth, m_pClientList[iClientH]->m_iPenaltyBlockDay);
        SafeCopy(pData+132, cTxt, 0);
        PutOffsetValue(pData, 152, DEF_WORDSIZE, m_pClientList[iClientH]->m_iQuest);
        PutOffsetValue(pData, 154, DEF_WORDSIZE, m_pClientList[iClientH]->m_iQuestID);
        PutOffsetValue(pData, 156, DEF_WORDSIZE, m_pClientList[iClientH]->m_iCurQuestCount);
        PutOffsetValue(pData, 158, DEF_WORDSIZE, m_pClientList[iClientH]->m_iQuestRewardType);
        PutOffsetValue(pData, 160, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iQuestRewardAmount);
        PutOffsetValue(pData, 164, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iContribution);
        PutOffsetValue(pData, 168, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iWarContribution);
        PutOffsetValue(pData, 172, DEF_BYTESIZE, m_pClientList[iClientH]->m_bIsQuestCompleted);
        PutOffsetValue(pData, 173, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iSpecialEventID);
        PutOffsetValue(pData, 177, DEF_WORDSIZE, m_pClientList[iClientH]->m_iSuperAttackLeft);
        PutOffsetValue(pData, 179, DEF_BYTESIZE, m_pClientList[iClientH]->m_iFightzoneNumber);
        PutOffsetValue(pData, 180, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iReserveTime);
        PutOffsetValue(pData, 184, DEF_BYTESIZE, m_pClientList[iClientH]->m_iFightZoneTicketNumber);
        PutOffsetValue(pData, 185, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iSpecialAbilityTime);
        SafeCopy(pData+189, m_pClientList[iClientH]->m_cLockedMapName, 0);
        PutOffsetValue(pData, 199, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iLockedMapTime);
        PutOffsetValue(pData, 203, DEF_BYTESIZE, m_pClientList[iClientH]->m_iCrusadeDuty);
        PutOffsetValue(pData, 204, DEF_DWORDSIZE, m_pClientList[iClientH]->m_dwCrusadeGUID);
        PutOffsetValue(pData, 208, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iConstructionPoint);
        PutOffsetValue(pData, 212, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iDeadPenaltyTime);
        PutOffsetValue(pData, 216, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iPartyID);
        PutOffsetValue(pData, 220, DEF_WORDSIZE, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
		// majestic-level
		// ip2
		// ip
		// heldenian-GUID
        PutOffsetValue(pData, 222, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iSpecialAbilityTime);
        PutOffsetValue(pData, 226, DEF_WORDSIZE, m_pClientList[iClientH]->m_sAppr1);
        PutOffsetValue(pData, 230, DEF_WORDSIZE, m_pClientList[iClientH]->m_sAppr2);
        PutOffsetValue(pData, 234, DEF_WORDSIZE, m_pClientList[iClientH]->m_sAppr3);
        PutOffsetValue(pData, 238, DEF_WORDSIZE, m_pClientList[iClientH]->m_sAppr4);
        PutOffsetValue(pData, 242, DEF_DWORDSIZE, m_pClientList[iClientH]->m_iApprColor);
        for (i = 0; i < DEF_MAXMAGICTYPE; i++) PutOffsetValue(pData, 246+i, DEF_BYTESIZE, m_pClientList[iClientH]->m_cMagicMastery[i]+48);
        for (i = 0; i < 24; i++){
             PutOffsetValue(pData, 346+i, DEF_BYTESIZE, m_pClientList[iClientH]->m_cSkillMastery[i]);
             PutOffsetValue(pData, 370+(i*4),DEF_DWORDSIZE, m_pClientList[iClientH]->m_iSkillSSN[i]);
		}

		NItems = 0;
        NBankItems = 0;

        for(i = 0; i < DEF_MAXITEMS; i++)
		if(m_pClientList[iClientH]->m_pItemList[i] != NULL)
          {
           IndexForItem = (471 + (NItems*60));
           SafeCopy(pData+IndexForItem, m_pClientList[iClientH]->m_pItemList[i]->m_cName, 0);
           PutOffsetValue(pData, (IndexForItem+20), DEF_DWORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_dwCount);
           PutOffsetValue(pData, (IndexForItem+24), DEF_WORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType);
           PutOffsetValue(pData, (IndexForItem+26), DEF_DWORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1);
           PutOffsetValue(pData, (IndexForItem+30), DEF_DWORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2);
           PutOffsetValue(pData, (IndexForItem+34), DEF_DWORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3);
           PutOffsetValue(pData, (IndexForItem+38), DEF_BYTESIZE, m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor);
           PutOffsetValue(pData, (IndexForItem+39), DEF_WORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1);
           PutOffsetValue(pData, (IndexForItem+41), DEF_WORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2);
           PutOffsetValue(pData, (IndexForItem+43), DEF_WORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3);
           PutOffsetValue(pData, (IndexForItem+45), DEF_WORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan);
           PutOffsetValue(pData, (IndexForItem+47), DEF_DWORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute);
           PutOffsetValue(pData, (IndexForItem+51), DEF_BYTESIZE, m_pClientList[iClientH]->m_bIsItemEquipped[i]);
           PutOffsetValue(pData, (IndexForItem+52), DEF_WORDSIZE, m_pClientList[iClientH]->m_ItemPosList[i].x);
           PutOffsetValue(pData, (IndexForItem+54), DEF_WORDSIZE, m_pClientList[iClientH]->m_ItemPosList[i].y);
           NItems++;
          }
        PutOffsetValue(pData, 470, DEF_BYTESIZE, NItems);

        Index = 471+(NItems*60);
        for(i = 0; i < DEF_MAXBANKITEMS; i++)
	if(m_pClientList[iClientH]->m_pItemInBankList[i] != NULL)
          {
           IndexForItem = (Index+1+(NBankItems*55));
	   SafeCopy(pData+IndexForItem, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, 0);
           PutOffsetValue(pData, (IndexForItem+20), DEF_DWORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount);
           PutOffsetValue(pData, (IndexForItem+24), DEF_WORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectType);
           PutOffsetValue(pData, (IndexForItem+26), DEF_DWORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue1);
           PutOffsetValue(pData, (IndexForItem+30), DEF_DWORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue2);
           PutOffsetValue(pData, (IndexForItem+34), DEF_DWORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue3);
           PutOffsetValue(pData, (IndexForItem+38), DEF_BYTESIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor);
           PutOffsetValue(pData, (IndexForItem+39), DEF_WORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1);
           PutOffsetValue(pData, (IndexForItem+41), DEF_WORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2);
           PutOffsetValue(pData, (IndexForItem+43), DEF_WORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3);
           PutOffsetValue(pData, (IndexForItem+45), DEF_WORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan);
           PutOffsetValue(pData, (IndexForItem+47), DEF_DWORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute);
           NBankItems++;
	  }
        PutOffsetValue(pData, Index, DEF_BYTESIZE, NBankItems);
        Index += (NBankItems*55)+1;
        if(strlen(m_pClientList[iClientH]->m_cProfile) == 0)
          {
           SafeCopy(pData+Index, "__________", 0);
           return (Index+12);
          }
        else
          {
           SafeCopy(pData+Index, m_pClientList[iClientH]->m_cProfile, 0);
           return (Index+2+strlen(m_pClientList[iClientH]->m_cProfile));
          }                                                         
}

#else

int CGame::_iComposePlayerDataFileContents(int iClientH, char * pData)
{
 SYSTEMTIME SysTime;
 char  cTxt[120], cTmp[21];
 POINT TempItemPosList[DEF_MAXITEMS];
 int   i, iPos;

	if (m_pClientList[iClientH] == NULL) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");
	
	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n");
		
	//  
	strcat(pData, "[NAME-ACCOUNT]\n\n");
	strcat(pData, "character-name     = ");
	strcat(pData, m_pClientList[iClientH]->m_cCharName);
	strcat(pData, "\n");
	strcat(pData, "account-name       = ");
	strcat(pData, m_pClientList[iClientH]->m_cAccountName);
	strcat(pData, "\n\n");

	strcat(pData, "[STATUS]\n\n");
	//   
	strcat(pData, "character-profile 	=");
	if (strlen(m_pClientList[iClientH]->m_cProfile) == 0) {
		//     
		strcat(pData, "__________");
	}
	else strcat(pData, m_pClientList[iClientH]->m_cProfile);
	strcat(pData, "\n");

	//   
	strcat(pData, "character-location   = ");
	strcat(pData, m_pClientList[iClientH]->m_cLocation);
	strcat(pData, "\n");

	///   
	strcat(pData, "character-guild-name = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRank -1  .
		strcat(pData, m_pClientList[iClientH]->m_cGuildName);
	}
	else strcat(pData, "NONE");
	strcat(pData, "\n");
	
	//  GUID 
	strcat(pData, "character-guild-GUID = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRank -1 GUID .
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d", m_pClientList[iClientH]->m_iGuildGUID);
		strcat(pData, cTxt);
	}
	else strcat(pData, "-1");
	strcat(pData, "\n");
		
	//  
	strcat(pData, "character-guild-rank = ");
	itoa( m_pClientList[iClientH]->m_iGuildRank, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	strcat(pData, "character-loc-map = ");
	strcat(pData, m_pClientList[iClientH]->m_cMapName);
	strcat(pData, "\n");
	// X  
	strcat(pData, "character-loc-x   = ");
	itoa( m_pClientList[iClientH]->m_sX, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	// Y  
	strcat(pData, "character-loc-y   = ");
	itoa( m_pClientList[iClientH]->m_sY, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");
	//
	if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
	wsprintf(cTxt, "character-HP       = %d", m_pClientList[iClientH]->m_iHP);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	if (m_pClientList[iClientH]->m_iMP < 0) m_pClientList[iClientH]->m_iMP = 0;
	wsprintf(cTxt, "character-MP       = %d",  m_pClientList[iClientH]->m_iMP);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	if (m_pClientList[iClientH]->m_iSP < 0) m_pClientList[iClientH]->m_iSP = 0; // v1.1
	wsprintf(cTxt, "character-SP       = %d",  m_pClientList[iClientH]->m_iSP);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-LEVEL    = %d", m_pClientList[iClientH]->m_iLevel);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-RATING   = %d", m_pClientList[iClientH]->m_iRating);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-STR      = %d", m_pClientList[iClientH]->m_iStr);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-INT      = %d", m_pClientList[iClientH]->m_iInt);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-VIT      = %d", m_pClientList[iClientH]->m_iVit);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-DEX      = %d", m_pClientList[iClientH]->m_iDex);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-MAG      = %d", m_pClientList[iClientH]->m_iMag);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-CHARISMA = %d", m_pClientList[iClientH]->m_iCharisma);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LUCK     = %d", m_pClientList[iClientH]->m_iLuck);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-EXP      = %d", m_pClientList[iClientH]->m_iExp);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Pool  = %d", m_pClientList[iClientH]->m_iLU_Pool);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	

	wsprintf(cTxt, "character-EK-Count = %d", m_pClientList[iClientH]->m_iEnemyKillCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-PK-Count = %d", m_pClientList[iClientH]->m_iPKCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-reward-gold = %d", m_pClientList[iClientH]->m_iRewardGold);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-downskillindex = %d", m_pClientList[iClientH]->m_iDownSkillIndex);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-IDnum1 = %d", m_pClientList[iClientH]->m_sCharIDnum1);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-IDnum2 = %d", m_pClientList[iClientH]->m_sCharIDnum2);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-IDnum3 = %d", m_pClientList[iClientH]->m_sCharIDnum3);
	strcat(pData, cTxt);
	strcat(pData,"\n");


	wsprintf(cTxt, "party-rank = %d", m_pClientList[iClientH]->m_iPartyRank);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	

	//
	//    
	strcat(pData, "sex-status       = ");
	itoa( m_pClientList[iClientH]->m_cSex, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "skin-status      = ");
	itoa( m_pClientList[iClientH]->m_cSkin, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "hairstyle-status = ");
	itoa( m_pClientList[iClientH]->m_cHairStyle, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "haircolor-status = ");
	itoa( m_pClientList[iClientH]->m_cHairColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "underwear-status = ");
	itoa( m_pClientList[iClientH]->m_cUnderwear, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "hunger-status    = %d", m_pClientList[iClientH]->m_iHungerStatus);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-shutup  = %d", m_pClientList[iClientH]->m_iTimeLeft_ShutUp);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-rating  = %d", m_pClientList[iClientH]->m_iTimeLeft_Rating);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-force-recall  = %d", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-firm-staminar = %d", m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "admin-user-level = %d", m_pClientList[iClientH]->m_iAdminUserLevel);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "penalty-block-date = %d %d %d", m_pClientList[iClientH]->m_iPenaltyBlockYear, m_pClientList[iClientH]->m_iPenaltyBlockMonth, m_pClientList[iClientH]->m_iPenaltyBlockDay);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-number = %d", m_pClientList[iClientH]->m_iQuest);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-ID     = %d", m_pClientList[iClientH]->m_iQuestID);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "current-quest-count    = %d", m_pClientList[iClientH]->m_iCurQuestCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "quest-reward-type      = %d", m_pClientList[iClientH]->m_iQuestRewardType);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "quest-reward-amount    = %d", m_pClientList[iClientH]->m_iQuestRewardAmount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-contribution = %d", m_pClientList[iClientH]->m_iContribution);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-war-contribution = %d", m_pClientList[iClientH]->m_iWarContribution);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-completed = %d", (int)m_pClientList[iClientH]->m_bIsQuestCompleted);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "special-event-id = %d", (int)m_pClientList[iClientH]->m_iSpecialEventID);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "super-attack-left = %d", (int)m_pClientList[iClientH]->m_iSuperAttackLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v1.4311-3      .
	//      reserved-fightzone-id  //
	wsprintf(cTxt, "reserved-fightzone-id = %d %d %d", m_pClientList[iClientH]->m_iFightzoneNumber, m_pClientList[iClientH]->m_iReserveTime,m_pClientList[iClientH]->m_iFightZoneTicketNumber  );
	strcat(pData, cTxt);
	strcat(pData,"\n");

	//     
	wsprintf(cTxt, "special-ability-time = %d", m_pClientList[iClientH]->m_iSpecialAbilityTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	//   
	wsprintf(cTxt, "locked-map-name = %s", m_pClientList[iClientH]->m_cLockedMapName);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	//   
	wsprintf(cTxt, "locked-map-time = %d", m_pClientList[iClientH]->m_iLockedMapTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	//   .
	wsprintf(cTxt, "crusade-job = %d", m_pClientList[iClientH]->m_iCrusadeDuty);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	//    
	wsprintf(cTxt, "crusade-GUID = %d", m_pClientList[iClientH]->m_dwCrusadeGUID);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "construct-point = %d", m_pClientList[iClientH]->m_iConstructionPoint);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v2.04    
	wsprintf(cTxt, "dead-penalty-time = %d", m_pClientList[iClientH]->m_iDeadPenaltyTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v2.06 12-4  
	wsprintf(cTxt, "party-id = %d", m_pClientList[iClientH]->m_iPartyID);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v2.15 
	if (m_pClientList[iClientH]->m_iMajesticLevel < 0) m_pClientList[iClientH]->m_iMajesticLevel = 0;
	wsprintf(cTxt, "gizon-item-upgrade-left = %d", m_pClientList[iClientH]->m_iMajesticLevel);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 0) m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = 0;
	wsprintf(cTxt, "majestic-level = %d", m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// MORLA 2.2- Nuevos datos para el pj
	wsprintf(cTxt, "character-Deaths = %d", m_pClientList[iClientH]->m_iDeaths);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-TotalDGKills = %d", m_pClientList[iClientH]->m_iTotalDGKills);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-DGPoints = %d", m_pClientList[iClientH]->m_iDGPoints);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-TotalDGDeaths = %d", m_pClientList[iClientH]->m_iTotalDGDeaths);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-DGKills = %d", m_pClientList[iClientH]->m_iDGKills);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "max-ek = %d", m_pClientList[iClientH]->m_iMaxEK);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	strcat(pData, "ip2 = "); 
	strcat(pData, m_pClientList[iClientH]->m_cIP2); 
	strcat(pData, "\n"); 
	
	strcat(pData, "ip = "); 
	strcat(pData, m_pClientList[iClientH]->m_cIPaddress); 
	strcat(pData, "\n");

	wsprintf(cTxt, "heldenian-GUID = %d", m_pClientList[iClientH]->m_dwHeldenianGUID);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	strcat(pData,"\n\n");

	//   Appr4 .     -> .
	strcat(pData, "appr1 = ");
	itoa( m_pClientList[iClientH]->m_sAppr1, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr2 = ");
	//   .
	itoa( m_pClientList[iClientH]->m_sAppr2, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr3 = ");
	itoa( m_pClientList[iClientH]->m_sAppr3, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr4 = ");
	itoa( m_pClientList[iClientH]->m_sAppr4, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	// v1.4 ApprColor
	strcat(pData, "appr-color = ");
	itoa( m_pClientList[iClientH]->m_iApprColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");

	//    
	strcat(pData, "[ITEMLIST]\n\n");

	for (i = 0; i < DEF_MAXITEMS; i++) { // v1.4
		TempItemPosList[i].x = 40;
		TempItemPosList[i].y = 30;
	}
	iPos = 0;

	//   .
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		// v1.4   . 
		TempItemPosList[iPos].x = m_pClientList[iClientH]->m_ItemPosList[i].x;
		TempItemPosList[iPos].y = m_pClientList[iClientH]->m_ItemPosList[i].y;
		iPos++;
		
		strcat(pData, "character-item = ");
		memset(cTmp, ' ', 21);
		strcpy(cTmp, m_pClientList[iClientH]->m_pItemList[i]->m_cName);
		cTmp[strlen(m_pClientList[iClientH]->m_pItemList[i]->m_cName)] = (char)' ';
		cTmp[20] = NULL;
		strcat(pData, cTmp);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_dwCount, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}
	strcat(pData, "\n\n");

	// v1.4      
	for (i = 0; i < DEF_MAXITEMS; i++) {
		m_pClientList[iClientH]->m_ItemPosList[i].x = TempItemPosList[i].x; 
		m_pClientList[iClientH]->m_ItemPosList[i].y = TempItemPosList[i].y;
	}

	//m_cAccountName
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) {
		strcat(pData, "character-bank-item = ");
		memset(cTmp, ' ', 21);
		strcpy(cTmp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName);
		cTmp[strlen(m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName)] = (char)' ';
		cTmp[20] = NULL;
		strcat(pData, cTmp);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectType, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}
	strcat(pData, "\n\n");

	
	strcat(pData, "[MAGIC-SKILL-MASTERY]\n\n");

	strcat(pData, "//------------------012345678901234567890123456789012345678901234567890");
	strcat(pData,"\n");

	strcat(pData, "magic-mastery     = ");
	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		wsprintf(cTxt,"%d", (int)m_pClientList[iClientH]->m_cMagicMastery[i]);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");
	
	strcat(pData, "skill-mastery     = ");
			
	
	for (i = 0; i < 60; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_cSkillMastery[i]);

		strcat(pData, cTxt); //  
	}
	strcat(pData,"\n");
			
	strcat(pData, "skill-SSN     = ");
	for (i = 0; i < 60; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_iSkillSSN[i]);

		strcat(pData, cTxt); //  
	}
	strcat(pData,"\n");
	
	//    .     .
	strcat(pData, "[ITEM-EQUIP-STATUS]\n\n");
	strcat(pData, "item-equip-status = ");
	
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "00000000000000000000000000000000000000000000000000");
	              
	int iEP = 0;
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		if ((m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) && 
			(m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP)) {
			 cTxt[iEP] = '1';
		}
		iEP++;
	}
	strcat(pData, cTxt);
	strcat(pData, "\n");

	
	strcat(pData, "item-position-x = ");
	for (i = 0; i < DEF_MAXITEMS; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].x);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");
	
	strcat(pData, "item-position-y = ");
	for (i = 0; i < DEF_MAXITEMS; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].y);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n\n");
	
	strcat(pData, "[EOF]");
	strcat(pData, "\n\n\n\n");

	return strlen(pData);
}
#endif

/*********************************************************************************************************************
**  BOOL CGame::_bDecodeItemConfigFileContents(char * pData, DWORD dwMsgSize)										**
**  DESCRIPTION			:: decodes Item.cfg file																	**
**  LAST_UPDATED		:: March 17, 2005; 2:09 PM; Hypnotoad														**
**	RETURN_VALUE		:: BOOL																						**
**  NOTES				::	n/a																						**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
BOOL CGame::_bDecodeItemConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iItemConfigListIndex, iTemp;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// m_sIDnum
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemIDnumber");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iItemConfigListIndex = atoi(token);
					if (m_pItemConfigList[iItemConfigListIndex] != NULL) {
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Duplicate ItemIDnum(%d)", iItemConfigListIndex);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex] = new class CItem;
					m_pItemConfigList[iItemConfigListIndex]->m_sIDnum = iItemConfigListIndex;
					cReadModeB = 2;
					break;
				case 2:
					// m_cName 
					ZeroMemory(m_pItemConfigList[iItemConfigListIndex]->m_cName, sizeof(m_pItemConfigList[iItemConfigListIndex]->m_cName));
					memcpy(m_pItemConfigList[iItemConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;
				case 3:
					// m_cItemType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemType");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemType = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					// m_cEquipPos
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - EquipPos");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cEquipPos = atoi(token);
					cReadModeB = 5;
					break;
				case 5:
					// m_sItemEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectType");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectType = atoi(token);
					cReadModeB = 6;
					break;
				case 6:
					// m_sItemEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue1");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue1 = atoi(token);
					cReadModeB = 7;
					break;
				case 7:
					// m_sItemEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue2");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue2 = atoi(token);
					cReadModeB = 8;
					break;
				case 8:
					// m_sItemEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue3");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue3 = atoi(token);
					cReadModeB = 9;
					break;
				case 9:
					// m_sItemEffectValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue4");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue4 = atoi(token);
					cReadModeB = 10;
					break;
				case 10:
					// m_sItemEffectValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue5");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue5 = atoi(token);
					cReadModeB = 11;
					break;
				case 11:
					// m_sItemEffectValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue6");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue6 = atoi(token);
					cReadModeB = 12;
					break;
				case 12:
					// m_wMaxLifeSpan
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxLifeSpan");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wMaxLifeSpan = (WORD)atoi(token);
					cReadModeB = 13;
					break;
				case 13:
					// m_sSpecialEffect
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxFixCount");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffect = atoi(token);
					cReadModeB = 14;
					break;
				case 14:
					// m_sSprite
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Sprite");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSprite = atoi(token);
					cReadModeB = 15;
					break;
				case 15:
					// m_sSpriteFrame
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SpriteFrame");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpriteFrame = atoi(token);
					cReadModeB = 16;
					break;
				case 16:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Price");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iTemp = atoi(token);
					if (iTemp < 0) 
						 m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = FALSE;
					else m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = TRUE;
					
					m_pItemConfigList[iItemConfigListIndex]->m_wPrice = abs(iTemp);
					cReadModeB = 17;
					break;
				case 17:
					// m_wWeight
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Weight");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wWeight = atoi(token);
					cReadModeB = 18;
					break;
				case 18:
					// Appr Value
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ApprValue");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cApprValue = atoi(token);
					cReadModeB = 19;
					break;
				case 19:
					// m_cSpeed
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Speed");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cSpeed = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// m_sLevelLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - LevelLimit");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sLevelLimit = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// m_cGederLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - GenderLimit");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cGenderLimit = atoi(token);
					cReadModeB = 22;
					break;
				
				case 22:
					// m_sSpecialEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SM_HitRatio");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue1 = atoi(token);
					cReadModeB = 23;
					break;

				case 23:
					// m_sSpecialEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - L_HitRatio");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue2 = atoi(token);
					cReadModeB = 24;
					break;

				case 24:
					// m_sRelatedSkill
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - RelatedSkill");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sRelatedSkill = atoi(token);
					cReadModeB = 25;
					break;

				case 25:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB = 26;
					break;

				case 26:
					// m_cItemColor
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemColor = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Item", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}		
			if (memcmp(token, "[ENDITEMLIST]", 13) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto DICFC_STOPDECODING;
			}
		}
		token = pStrTok->pGet();
	}
	
DICFC_STOPDECODING:;

	delete pStrTok;
	delete pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file contents error!");
		return FALSE;
	}
	wsprintf(cTxt, "(!) ITEM(Total:%d) configuration - success!", iItemConfigListIndex);
	PutLogList(cTxt);
	m_bReceivedItemList = TRUE;
	return TRUE;
}

/*********************************************************************************************************************
**  BOOL CGame::_bInitItemAttr(class CItem * pItem, char * pItemName)												**
**  DESCRIPTION			:: initializes item variables - by ItemName													**
**  LAST_UPDATED		:: March 17, 2005; 2:10 PM; Hypnotoad														**
**	RETURN_VALUE		:: BOOL																						**
**  NOTES				::	- overloaded function - see other _bInitItemAttr										**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
BOOL CGame::_bInitItemAttr(class CItem * pItem, char * pItemName)
{
 int i;
 char cTmpName[22];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMTYPES; i++) 
	if (m_pItemConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pItemConfigList[i]->m_cName, 20) == 0) {
			ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
			strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
			pItem->m_cItemType         = m_pItemConfigList[i]->m_cItemType;
			pItem->m_cEquipPos         = m_pItemConfigList[i]->m_cEquipPos;
			pItem->m_sItemEffectType   = m_pItemConfigList[i]->m_sItemEffectType;
			pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
			pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
			pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
			pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
			pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
			pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
			pItem->m_wMaxLifeSpan      = m_pItemConfigList[i]->m_wMaxLifeSpan;
			pItem->m_wCurLifeSpan	   = pItem->m_wMaxLifeSpan;
			pItem->m_sSpecialEffect    = m_pItemConfigList[i]->m_sSpecialEffect;
			pItem->m_sSprite           = m_pItemConfigList[i]->m_sSprite;
			pItem->m_sSpriteFrame      = m_pItemConfigList[i]->m_sSpriteFrame;
			pItem->m_wPrice            = m_pItemConfigList[i]->m_wPrice;
			pItem->m_wWeight           = m_pItemConfigList[i]->m_wWeight;
			pItem->m_cApprValue        = m_pItemConfigList[i]->m_cApprValue;
			pItem->m_cSpeed            = m_pItemConfigList[i]->m_cSpeed;
			pItem->m_sLevelLimit       = m_pItemConfigList[i]->m_sLevelLimit;
			pItem->m_cGenderLimit      = m_pItemConfigList[i]->m_cGenderLimit;
			pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
			pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;
			pItem->m_sRelatedSkill     = m_pItemConfigList[i]->m_sRelatedSkill;
			pItem->m_cCategory         = m_pItemConfigList[i]->m_cCategory;
			pItem->m_sIDnum			   = m_pItemConfigList[i]->m_sIDnum;
			pItem->m_bIsForSale	       = m_pItemConfigList[i]->m_bIsForSale;
			pItem->m_cItemColor        = m_pItemConfigList[i]->m_cItemColor;
			return TRUE;
		}
	}
 	return FALSE;
}

/*********************************************************************************************************************
**  BOOL CGame::_bInitItemAttr(class CItem * pItem, char * pItemName)												**
**  DESCRIPTION			:: initializes item variables - by ItemID													**
**  LAST_UPDATED		:: March 17, 2005; 2:10 PM; Hypnotoad														**
**	RETURN_VALUE		:: BOOL																						**
**  NOTES				::	- overloaded function - see other _bInitItemAttr										**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
BOOL CGame::_bInitItemAttr(class CItem * pItem, int iItemID)
{
 int i;

	for (i = 0; i < DEF_MAXITEMTYPES; i++) 
	if (m_pItemConfigList[i] != NULL) {
		if (m_pItemConfigList[i]->m_sIDnum == iItemID) {
			ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
			strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
			pItem->m_cItemType         = m_pItemConfigList[i]->m_cItemType;
			pItem->m_cEquipPos         = m_pItemConfigList[i]->m_cEquipPos;
			pItem->m_sItemEffectType   = m_pItemConfigList[i]->m_sItemEffectType;
			pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
			pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
			pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
			pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
			pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
			pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
			pItem->m_wMaxLifeSpan      = m_pItemConfigList[i]->m_wMaxLifeSpan;
			pItem->m_wCurLifeSpan	   = pItem->m_wMaxLifeSpan;
			pItem->m_sSpecialEffect    = m_pItemConfigList[i]->m_sSpecialEffect;
			pItem->m_sSprite           = m_pItemConfigList[i]->m_sSprite;
			pItem->m_sSpriteFrame      = m_pItemConfigList[i]->m_sSpriteFrame;
			pItem->m_wPrice            = m_pItemConfigList[i]->m_wPrice;
			pItem->m_wWeight           = m_pItemConfigList[i]->m_wWeight;
			pItem->m_cApprValue        = m_pItemConfigList[i]->m_cApprValue;
			pItem->m_cSpeed            = m_pItemConfigList[i]->m_cSpeed;
			pItem->m_sLevelLimit       = m_pItemConfigList[i]->m_sLevelLimit;
			pItem->m_cGenderLimit      = m_pItemConfigList[i]->m_cGenderLimit;
			pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
			pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;
			pItem->m_sRelatedSkill     = m_pItemConfigList[i]->m_sRelatedSkill;
			pItem->m_cCategory         = m_pItemConfigList[i]->m_cCategory;
			pItem->m_sIDnum			   = m_pItemConfigList[i]->m_sIDnum;
			pItem->m_bIsForSale	       = m_pItemConfigList[i]->m_bIsForSale;
			pItem->m_cItemColor        = m_pItemConfigList[i]->m_cItemColor;
			return TRUE;
		}
	}
	return FALSE;
}

/*********************************************************************************************************************
**  BOOL CGame::_bGetIsStringIsNumber(char * pStr)																	**
**  DESCRIPTION			:: checks if valid ASCII value																**
**  LAST_UPDATED		:: March 17, 2005; 2:24 PM; Hypnotoad														**
**	RETURN_VALUE		:: BOOL																						**
**  NOTES				::	n/a																						**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
BOOL CGame::_bGetIsStringIsNumber(char * pStr)
{
 int i;
	for (i = 0; i < (int)strlen(pStr); i++)
	if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return FALSE;
	
	return TRUE;
}

/*********************************************************************************************************************
**  BOOL CGame::bSetNpcFollowMode(char * pName, char * pFollowName, char cFollowOwnerType)							**
**  DESCRIPTION			:: set npc follow mode																		**
**  LAST_UPDATED		:: March 18, 2005; 9:43 AM; Hypnotoad														**
**	RETURN_VALUE		:: BOOL																						**
**  NOTES				::	n/a																						**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
/*****************************************************************************************************
**							  Follower mode functions:												**
**	bSetNpcFollowMode:	After creating a mob, gives him a master...									**
**  RemoveFromTarget:   If target or master Killed/TP/deco/Invi, check follow mode					**
**  ReleaseFollowMode:  Check if a killed npc had followers, and free them							**
**  iRecoverFollowers:  Restore follow mode after a client has disconnected the connected again		**
**  iGetFollowerNumber: Counts the follower numbers to prevent too much summons						**
*****************************************************************************************************/
BOOL CGame::bSetNpcFollowMode(char * pName, char * pFollowName, char cFollowOwnerType)
{ int i, iIndex, iMapIndex, iFollowIndex;
 char cTmpName[11], cFollowSide;
	ZeroMemory(cTmpName, sizeof(cTmpName));// Snoopy: added m_cFollowOwnerCharName
	iIndex		 = -1;
	iMapIndex    = -1;
	iFollowIndex = -1;
	for (i = 1; i < DEF_MAXNPCS; i++)
	if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pName, 5) == 0) ) 
	{	iIndex = i;
		iMapIndex = m_pNpcList[i]->m_cMapIndex;
		goto NEXT_STEP_SNFM1;
	}
	if (iIndex == -1) return FALSE;

NEXT_STEP_SNFM1:;
	switch (cFollowOwnerType) {
	case DEF_OWNERTYPE_NPC:
		for (i = 1; i < DEF_MAXNPCS; i++)
		if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pFollowName, 5) == 0) ) 
		{	if (m_pNpcList[i]->m_cMapIndex != iMapIndex) return FALSE;
			m_pNpcList[iIndex]->m_cMoveType			= DEF_MOVETYPE_FOLLOW;
			m_pNpcList[iIndex]->m_cFollowOwnerType  = DEF_OWNERTYPE_NPC;
			m_pNpcList[iIndex]->m_iFollowOwnerIndex = i;
			ZeroMemory(m_pNpcList[i]->m_cFollowOwnerCharName,sizeof(m_pNpcList[i]->m_cFollowOwnerCharName));
			m_pNpcList[iIndex]->m_cSide             = m_pNpcList[i]->m_cSide;
			return TRUE;
		}
		break;
	
	case DEF_OWNERTYPE_PLAYER:
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pFollowName, 10) == 0) ) 
		{	if (m_pClientList[i]->m_cMapIndex != iMapIndex) return FALSE;
			iFollowIndex = i;
			cFollowSide = m_pClientList[i]->m_cSide;
			m_pNpcList[iIndex]->m_cMoveType			= DEF_MOVETYPE_FOLLOW;
			m_pNpcList[iIndex]->m_cFollowOwnerType  = DEF_OWNERTYPE_PLAYER;
			m_pNpcList[iIndex]->m_iFollowOwnerIndex = i;
			strcpy(m_pNpcList[iIndex]->m_cFollowOwnerCharName, m_pClientList[i]->m_cCharName);
			m_pNpcList[iIndex]->m_cSide             = m_pClientList[i]->m_cSide;
			return TRUE;
		}
		break;
	}
	return FALSE;
}

/*********************************************************************************************************************
**  int CGame::bCreateNewNpc(char * pNpcName, char * pName, char * pMapName, short sClass, char cSA, char cMoveType,**
** int * poX, int * poY, char * pWaypointList, RECT * pArea, int iSpotMobIndex, char cChangeSide, BOOL bHideGenMode,**
** BOOL bIsSummoned, BOOL bFirmBerserk, BOOL bIsMaster, int iGuildGUID)												**
**  DESCRIPTION			:: creates a npc																			**
**  LAST_UPDATED		:: March 18, 2005; 6:01 PM; Hypnotoad														**
**	RETURN_VALUE		:: int																						**
**  NOTES				::	- sends 1x1 monsters to a different position verifier than 2x2/3x3						**
**							- new - expmin and expmax x 2 if npc is bFirmBerserk									**
**							- creates blocked spaces below 1x1, 2x2, and 3x3 monsters								**
**	MODIFICATION		::	- ExpDice MIN/MAX and bFirmBerserk requires testing										**
**********************************************************************************************************************/
int CGame::bCreateNewNpc(char * pNpcName, char * pName, char * pMapName, short sClass, char cSA, char cMoveType, int * poX, int * poY, char * pWaypointList, RECT * pArea, int iSpotMobIndex, char cChangeSide, BOOL bHideGenMode, BOOL bIsSummoned, BOOL bFirmBerserk, BOOL bIsMaster, int iGuildGUID)
{
 int i, t, j, k, iMapIndex;
 char  cTmpName[11], cTxt[120];
 short sX, sY, sRange;
 BOOL  bFlag;
 SYSTEMTIME SysTime;

	if (strlen(pName) == 0)   return FALSE;
	if (strlen(pNpcName) == 0) return FALSE;
	GetLocalTime(&SysTime);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);
	iMapIndex = -1;

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {
		if (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0) 
			iMapIndex = i;
	}
	
	if (iMapIndex == -1) return FALSE;
	
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] == NULL) {
		m_pNpcList[i] = new class CNpc(pName);
		if (_bInitNpcAttr(m_pNpcList[i], pNpcName, sClass, cSA) == FALSE) {
			wsprintf(cTxt, "(!) Not existing NPC creation request! (%s) Ignored.", pNpcName);
			PutLogList(cTxt);
			
			delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;	
		}
		if (m_pNpcList[i]->m_cDayOfWeekLimit < 10) {
			if (m_pNpcList[i]->m_cDayOfWeekLimit != SysTime.wDayOfWeek)	{
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;	
			}
		}
		switch (cMoveType) {
		case DEF_MOVETYPE_GUARD:
		case DEF_MOVETYPE_RANDOM:
			if ( (poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL) ) {
				sX = *poX;
				sY = *poY;
			}
			else {
				for (j = 0; j <= 30; j++) {
					sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
					sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;
					bFlag = TRUE;
					for (k = 0; k < DEF_MAXMGAR; k++)
					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left != -1) {
						if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left) &&
							(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].right) &&
							(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].top) &&
							(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].bottom)) {
							bFlag = FALSE;
						}
					}
					if (bFlag == TRUE) goto GET_VALIDLOC_SUCCESS;
				}
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;

GET_VALIDLOC_SUCCESS:;
			}
			break;

		case DEF_MOVETYPE_RANDOMAREA:
			sRange = (short)(pArea->right - pArea->left);
			sX     = (short)((rand() % sRange) + pArea->left);
			sRange = (short)(pArea->bottom - pArea->top);
			sY     = (short)((rand() % sRange) + pArea->top);
			break;

		case DEF_MOVETYPE_RANDOMWAYPOINT:
			sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1,10) - 1]].x;
			sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1,10) - 1]].y;
			break;

		default:
			if ((poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL)) {
				sX = *poX;
				sY = *poY;
			}
			else {
				sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].x;
				sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].y;
			}
			break;
		}
		// new - sends 1x1 monsters to a different position checker than 2x2/3x3
		if (m_pNpcList[i]->m_sAreaSize == 0) {
			if (bGetEmptyPosition(&sX, &sY, iMapIndex) == FALSE) {
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;
			}
		}
		else {
			// new - checks if walk location is free for larger than 1x1 monsters
			if (bGetNpcMovementArea(i, sX, sY, iMapIndex, m_pNpcList[i]->m_sAreaSize) == FALSE) {
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;		
			}
		}

		if ((bHideGenMode == TRUE) && (_iGetPlayerNumberOnSpot(sX, sY, iMapIndex, 7) != 0)) {
			delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;	
		}

		if ((poX != NULL) && (poY != NULL)) {
			*poX = sX;
			*poY = sY;
		}

		m_pNpcList[i]->m_sX = sX;
		m_pNpcList[i]->m_sY = sY;
		m_pNpcList[i]->m_vX = sX;
		m_pNpcList[i]->m_vY = sY;
		for (t = 0; t < 10; t++) m_pNpcList[i]->m_iWayPointIndex[t] = pWaypointList[t];
		
		m_pNpcList[i]->m_cTotalWaypoint = 0;

		for (t = 0; t < 10; t++)
		if (m_pNpcList[i]->m_iWayPointIndex[t] != -1) m_pNpcList[i]->m_cTotalWaypoint++;

		if (pArea != NULL) {
			SetRect(&m_pNpcList[i]->m_rcRandomArea, pArea->left, pArea->top, pArea->right, pArea->bottom);
		}

		switch (cMoveType) {
		case DEF_MOVETYPE_GUARD:
			m_pNpcList[i]->m_dX = m_pNpcList[i]->m_sX;
			m_pNpcList[i]->m_dY = m_pNpcList[i]->m_sY;
			break;
		
		case DEF_MOVETYPE_SEQWAYPOINT: 
			m_pNpcList[i]->m_cCurWaypoint = 1;
			m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[m_pNpcList[i]->m_iWayPointIndex[m_pNpcList[i]->m_cCurWaypoint]].x;
			m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[m_pNpcList[i]->m_iWayPointIndex[m_pNpcList[i]->m_cCurWaypoint]].y;
			break;

		case DEF_MOVETYPE_RANDOMWAYPOINT:
			m_pNpcList[i]->m_cCurWaypoint = (rand() % (m_pNpcList[i]->m_cTotalWaypoint - 1)) + 1;
			m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[m_pNpcList[i]->m_iWayPointIndex[m_pNpcList[i]->m_cCurWaypoint]].x;
			m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[m_pNpcList[i]->m_iWayPointIndex[m_pNpcList[i]->m_cCurWaypoint]].y;
			break;

		case DEF_MOVETYPE_RANDOMAREA:
			m_pNpcList[i]->m_cCurWaypoint = 0;
			sRange = (short)(m_pNpcList[i]->m_rcRandomArea.right - m_pNpcList[i]->m_rcRandomArea.left);
			m_pNpcList[i]->m_dX = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.left);
			sRange = (short)(m_pNpcList[i]->m_rcRandomArea.bottom - m_pNpcList[i]->m_rcRandomArea.top);
			m_pNpcList[i]->m_dY = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.top);
			break;

		case DEF_MOVETYPE_RANDOM:
			m_pNpcList[i]->m_dX = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15);
			m_pNpcList[i]->m_dY = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15);
			break;
		}
		m_pNpcList[i]->m_tmp_iError  = 0;
		m_pNpcList[i]->m_cMoveType   = cMoveType;

		switch (m_pNpcList[i]->m_cActionLimit) {
		case 2:
		case 3:
		case 5:
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_STOP;			
			switch (m_pNpcList[i]->m_sType) {
			case 15: // ShopKeeper-W
			case 19: // Gandlf
			case 20: // Howard
			case 24: // Tom
			case 25: // William
			case 26: // Kennedy
				m_pNpcList[i]->m_cDir      = iDice(1,3) + 3;
				break;

			default:
				m_pNpcList[i]->m_cDir      = iDice(1,8);
				break;
			}
			break;

		case 8: // Heldenian gate
			m_pNpcList[i]->m_cDir      = 3;
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_STOP; 
			if (m_pNpcList[i]->m_cArea > 0)
			{	for(short sx1 = (sX - 1); sx1 <= sX + 1; sx1++)
				for(short sy1 = (sY - 1); sy1 <= sY + 1; sy1++)
				{	m_pMapList[iMapIndex]->SetTempMoveAllowedFlag(sx1, sy1, FALSE);  
			}	}
			break;

		default: 
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
			m_pNpcList[i]->m_cDir      = 5;
			break;
		}

		m_pNpcList[i]->m_iFollowOwnerIndex  = NULL;
		ZeroMemory(m_pNpcList[i]->m_cFollowOwnerCharName, sizeof(m_pNpcList[i]->m_cFollowOwnerCharName));
		m_pNpcList[i]->m_iTargetIndex	    = NULL;
		m_pNpcList[i]->m_cTurn              = (rand() % 2);

		switch (m_pNpcList[i]->m_sType) {
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
			case 6:
				m_pNpcList[i]->m_sAppr2 = 0xF000;
				m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | ((rand() % 13) << 4);
				m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | (rand() % 9);
				break;

			case 36: // AGT-Aresden/AGT-Elvine
			case 37: // CGT-Aresden/CGT-Elvine
			case 38: // MS-Aresden/MS-Elvine
			case 39: // DT-Aresden/DT-Elvine
				m_pNpcList[i]->m_sAppr2 = 3;
				break;
			
			case 64: // Crop
				m_pNpcList[i]->m_sAppr2 = 1; // 1 bud; 2 grown; 3 large 
				break;

			default:
				m_pNpcList[i]->m_sAppr2 = 0;
				break;
		}
		m_pNpcList[i]->m_cMapIndex          = (char)iMapIndex;
		m_pNpcList[i]->m_dwTime             = timeGetTime() + (rand() % 10000);
		m_pNpcList[i]->m_dwActionTime      += (rand() % 300);
		m_pNpcList[i]->m_dwMPupTime			= timeGetTime();
		m_pNpcList[i]->m_dwHPupTime			= m_pNpcList[i]->m_dwMPupTime;
		m_pNpcList[i]->m_sBehaviorTurnCount	= 0;
		m_pNpcList[i]->m_bIsSummoned        = bIsSummoned;
		m_pNpcList[i]->m_bIsMaster          = bIsMaster;
		if (bIsSummoned == TRUE) 
		{	m_pNpcList[i]->m_dwSummonedTime = timeGetTime();	
			m_pNpcList[i]->m_dwSummonWaitTime = 0;	
		}
		if (bFirmBerserk == TRUE) {
			m_pNpcList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = 1;
			m_pNpcList[i]->m_iStatus = m_pNpcList[i]->m_iStatus | 0x20;
			m_pNpcList[i]->m_iExpDiceMin = (m_pNpcList[i]->m_iExpDiceMin*2); // new - expmin x 2 if npc is bFirmBerserk
			m_pNpcList[i]->m_iExpDiceMax = (m_pNpcList[i]->m_iExpDiceMax*2); // new - expmax x 10 if npc is bFirmBerserk

		}
		if (cChangeSide != -1) m_pNpcList[i]->m_cSide = cChangeSide;
		m_pNpcList[i]->m_cBravery = (rand() % 3) + m_pNpcList[i]->m_iMinBravery;
		m_pNpcList[i]->m_iSpotMobIndex		= iSpotMobIndex;
		m_pNpcList[i]->m_iGuildGUID         = iGuildGUID;
		if (iGuildGUID != 0) {
			wsprintf(G_cTxt, "Summon War Unit(%d) GUID(%d)", m_pNpcList[i]->m_sType, iGuildGUID);
			PutLogList(G_cTxt);
		}
		// new - creates blocked spaces below 1x1, 2x2, and 3x3 monsters
		if (m_pNpcList[i]->m_sAreaSize == 0) {
			m_pMapList[iMapIndex]->SetOwner(i, DEF_OWNERTYPE_NPC, sX, sY);
		}
		else {
			m_pMapList[iMapIndex]->SetBigOwner(i, DEF_OWNERTYPE_NPC, sX, sY, m_pNpcList[i]->m_sAreaSize);
		}
		if (   (m_bIsHeldenianMode == TRUE) // If any mob created as Helnian war not started,, ensure it's Neutral...
			&& (m_bHeldenianWarInitiated == FALSE)
			&& (m_pMapList[iMapIndex]->m_bIsHeldenianMap == TRUE)
			&& (m_pNpcList[i]->m_cSide > 2))
		{	m_pNpcList[i]->m_cOriginalSide = m_pNpcList[i]->m_cSide;
			m_pNpcList[i]->m_cSide = 0;
		}
		m_pMapList[iMapIndex]->m_iTotalActiveObject++;
		m_pMapList[iMapIndex]->m_iTotalAliveObject++;
		switch (m_pNpcList[i]->m_sType) {
		case 36: // AGT-Aresden/AGT-Elvine
		case 37: // CGT-Aresden/CGT-Elvine
		case 38: // MS-Aresden/MS-Elvine
		case 39: // DT-Aresden/DT-Elvine
		case 42: // ManaStone
			m_pMapList[iMapIndex]->bAddCrusadeStructureInfo(m_pNpcList[i]->m_sType, sX, sY, m_pNpcList[i]->m_cSide);
			break;

		case 64:
			m_pMapList[iMapIndex]->bAddCropsTotalSum();
			break;
		}
		SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
		return TRUE;
	}
	return FALSE;
}

/*********************************************************************************************************************
**  void CGame::NpcProcess()																						**
**  DESCRIPTION			:: manages Npc variables																	**
**  LAST_UPDATED		:: March 18, 2005; 6:30 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- new Crop DeleteNpc after specific amount of time										**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
void CGame::NpcProcess()
{
 int i, iMaxHP;
 DWORD dwTime, dwActionTime;

	dwTime = timeGetTime();
	for (i = 1; i < DEF_MAXNPCS; i++) { 
		if (m_pNpcList[i] != NULL) {
			if (m_pNpcList[i]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
				switch (iDice(1,7)) {
				case 1: dwActionTime = m_pNpcList[i]->m_dwActionTime; break;
				case 2: dwActionTime = m_pNpcList[i]->m_dwActionTime - 100; break;
				case 3: dwActionTime = m_pNpcList[i]->m_dwActionTime - 200; break;
				case 4: dwActionTime = m_pNpcList[i]->m_dwActionTime - 300; break;
				case 5: dwActionTime = m_pNpcList[i]->m_dwActionTime - 400; break;
				case 6: dwActionTime = m_pNpcList[i]->m_dwActionTime - 600; break;
				case 7: dwActionTime = m_pNpcList[i]->m_dwActionTime - 700; break;
				}
				if (dwActionTime < 600) dwActionTime = 600;
			}
			else dwActionTime = m_pNpcList[i]->m_dwActionTime; 		
			if (m_pNpcList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] != 0) 
				dwActionTime += (dwActionTime/2);
		}	
		//SNOOPY Added here for ending Taming
		if (   (m_pNpcList[i] != NULL) 
			&& (m_pNpcList[i]->m_dwTamingTime != 0)
			&& (m_pNpcList[i]->m_cOriginalSide != m_pNpcList[i]->m_cSide)
			&& (dwTime > m_pNpcList[i]->m_dwTamingTime)) 
		{	m_pNpcList[i]->m_cSide = m_pNpcList[i]->m_cOriginalSide;
			m_pNpcList[i]->m_dwTamingTime = 0;
			m_pNpcList[i]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);		
		}
		if ((m_pNpcList[i] != NULL) && ((dwTime - m_pNpcList[i]->m_dwTime) > dwActionTime)) {
			m_pNpcList[i]->m_dwTime = dwTime;			
			if (abs(m_pNpcList[i]->m_cMagicLevel) > 0) {
				if ((dwTime - m_pNpcList[i]->m_dwMPupTime) > DEF_MPUPTIME) {
					m_pNpcList[i]->m_dwMPupTime = dwTime;	
					m_pNpcList[i]->m_iMana += iDice(1, (m_pNpcList[i]->m_iMaxMana/5));
					
					if (m_pNpcList[i]->m_iMana > m_pNpcList[i]->m_iMaxMana)
						m_pNpcList[i]->m_iMana = m_pNpcList[i]->m_iMaxMana;
				}
			}
			if (((dwTime - m_pNpcList[i]->m_dwHPupTime) > DEF_HPUPTIME) && (m_pNpcList[i]->m_bIsKilled == FALSE)) {
				m_pNpcList[i]->m_dwHPupTime = dwTime;	
				iMaxHP = iDice(m_pNpcList[i]->m_iHitDice, 8) + m_pNpcList[i]->m_iHitDice;
				if (m_pNpcList[i]->m_iHP < iMaxHP) {				
					if (m_pNpcList[i]->m_bIsSummoned == FALSE) m_pNpcList[i]->m_iHP += iDice(1, m_pNpcList[i]->m_iHitDice);
					if (m_pNpcList[i]->m_iHP > iMaxHP) m_pNpcList[i]->m_iHP = iMaxHP;
					if (m_pNpcList[i]->m_iHP <= 0) m_pNpcList[i]->m_iHP = 1;
				}
			}
			switch (m_pNpcList[i]->m_cBehavior) {
			case DEF_BEHAVIOR_DEAD:
				NpcBehavior_Dead(i);
				break;
			case DEF_BEHAVIOR_STOP:
				NpcBehavior_Stop(i);
				break;
			case DEF_BEHAVIOR_MOVE:
				NpcBehavior_Move(i);
				break;
			case DEF_BEHAVIOR_ATTACK:
				NpcBehavior_Attack(i);
				break;
			case DEF_BEHAVIOR_FLEE:
				NpcBehavior_Flee(i);
				break;
			}
			//SNOOPY Added here for ending waiting for Tamed mobs
			if (   (m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_iHP > 0) 
				&& (m_pNpcList[i]->m_dwTamingTime != 0)
				&& (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER_WAITING) 
				&& ((dwTime - m_pNpcList[i]->m_dwSummonWaitTime) > 1000*60)) // Wait 60sec for the character to connect again
			{	m_pNpcList[i]->m_cFollowOwnerType   = 0;	
				m_pNpcList[i]->m_iSummonControlMode = 0;
			}
			// !!! m_pNpcList
			if ((m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_iHP > 0) && (m_pNpcList[i]->m_bIsSummoned == TRUE)) 
			{	switch (m_pNpcList[i]->m_sType) {
				case 29: // Ogre summon popo:10 min
				case 33: // WW summon popo		
				case 31: // Demon summon popo
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > 1000*60*10) 
						NpcKilledHandler(NULL, NULL, i, 0);
					else if (   (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER_WAITING)
						&& ((dwTime - m_pNpcList[i]->m_dwSummonWaitTime) > 1000*60)) // Wait 60sec for the character to connect again
					{	m_pNpcList[i]->m_cFollowOwnerType   = 0;	
						m_pNpcList[i]->m_iSummonControlMode = 0;
					}
					break;	
				case 43: // LWB
				case 44: // GHK
				case 45: // GHKABS
				case 46: // TK
				case 47: // BG Crusade summons 10 min
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > 1000*60*10) 
						NpcKilledHandler(NULL, NULL, i, 0);
					else if (   (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER_WAITING)
						&& ((dwTime - m_pNpcList[i]->m_dwSummonWaitTime) > 1000*60)) // Wait 60sec for the character to connect again
					{	m_pNpcList[i]->m_cFollowOwnerType   = 0;		
						m_pNpcList[i]->m_iSummonControlMode = 0;
					}
					break;		
				case 82: // Sorceress	
				case 83: // ATK	
				case 84: // MasterElf	
				case 85: // DSK	
				case 86: // HBT		
				case 88: // Barbarian
					if (   (m_bIsHeldenianMode == TRUE)
						&& (m_pMapList[m_pNpcList[i]->m_cMapIndex] != NULL)
						&& (m_pMapList[m_pNpcList[i]->m_cMapIndex]->m_bIsHeldenianMap == 1))
					{	if (   (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER_WAITING)
							&& ((dwTime - m_pNpcList[i]->m_dwSummonWaitTime) > 1000*60)) // Wait 60sec for the character to connect again
						{	switch (m_cHeldenianSummonMode) {
							case 0: // Master has not connected again, remove summon
								NpcKilledHandler(NULL, NULL, i, 0);
								break;
							case 1: // Master has not connected again, wait forever			
								m_pNpcList[i]->m_iSummonControlMode = 0; // Un"/hold"
								break;
							case 2: // Master has not connected again, available for others to take over	
								m_pNpcList[i]->m_cFollowOwnerType   = DEF_OWNERTYPE_PLAYER_FREE;			
								m_pNpcList[i]->m_iSummonControlMode = 0; // Un"/hold"
								break;
							}
						}else break; // Keep them alive					
					}else if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > 1000*60*15) 
						NpcKilledHandler(NULL, NULL, i, 0);		// Heldenian soldiars limited to 15min if not Heldenian
					break;	
				case 36: // AGT         Those will last forever when summonned
				case 37: // AGC
				case 38: // MS
				case 39: // DT
				case 40: // ESG
				case 41: // ManaStone
				case 87: // CT
				case 89: // AGC
				case 91: // gates
					if (   (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER_WAITING)
						&& ((dwTime - m_pNpcList[i]->m_dwSummonWaitTime) > 1000*60)) // Wait 60sec for the character to connect again
					{	m_pNpcList[i]->m_cFollowOwnerType   = 0;		
						m_pNpcList[i]->m_iSummonControlMode = 0;
					}
					break;
				default: //other summons: 5 minutes
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > DEF_SUMMONTIME) 
						NpcKilledHandler(NULL, NULL, i, 0);
					else if (   (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER_WAITING)
						&& ((dwTime - m_pNpcList[i]->m_dwSummonWaitTime) > 1000*60)) // Wait 60sec for the character to connect again
					{	m_pNpcList[i]->m_cFollowOwnerType   = 0;		
						m_pNpcList[i]->m_iSummonControlMode = 0;
					}
					break;
				}
			}
		}
	}
}

/*********************************************************************************************************************
**  void CGame::ChatMsgHandler(int iClientH, char * pData, DWORD dwMsgSize)											**
**  DESCRIPTION			:: manages chatting																			**
**  LAST_UPDATED		:: March 18, 2005; 7:28 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- new Crop DeleteNpc after specific amount of time										**
**							- disabled /setobservermode																**
**							- "/gns " changed to 5 to work correctly !												**
**	MODIFICATION		::	- all chat is logged if enabled 														**
**							- /enableadmincreateitem is disabled													**
**							- REMOVED" /blueball, /redball, /yellowball, /weather, /time, /checkstatus, /summonguild**
**							/summondeath, /kill, /revive, /unsummondemon, /setserk, /setfreeze, /setstatus, /storm	**
**							- ADDED: /version, /clearnpc, /clearmap, /who, /checkrep, /send, /summonall				** 			
**********************************************************************************************************************/
void CGame::ChatMsgHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 int i, iRet;
 WORD * wp;
 int  * ip, iStX, iStY;
 char * cp, * cp2;
 char   cBuffer[256], cTemp[256], cSendMode = NULL;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (dwMsgSize > 113) return;
	if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) return;
	if (memcmp((pData + 10), m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) != 0) return;
	if ((m_pClientList[iClientH]->m_bIsObserverMode == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;
 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
	 
		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	cp = (char *)(pData + 21);
	m_pClientList[iClientH]->m_dwAFKCheckTime = timeGetTime();
	// Modification - chat logging
	switch (m_bLogChatOption) {
		// Chat Logs of only players
		case 1:
			if (m_pClientList[iClientH]->m_iAdminUserLevel == 0){
				ZeroMemory(cTemp,sizeof(cTemp));
				pData[dwMsgSize-1] = 0;
				wsprintf(cTemp,"Loc(%s) IP(%s) PC(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
			}
			break;
		// Chat Logs of only GM
		case 2:
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 0){
				ZeroMemory(cTemp,sizeof(cTemp));
				pData[dwMsgSize-1] = 0;
				wsprintf(cTemp,"Loc(%s) IP(%s) GM(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
			}
			break;
		// Chat logs of all
		case 3:
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 0){
				ZeroMemory(cTemp,sizeof(cTemp));
				pData[dwMsgSize-1] = 0;
				wsprintf(cTemp,"Loc(%s) IP(%s) GM(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
			}
			else{
				ZeroMemory(cTemp,sizeof(cTemp));
				pData[dwMsgSize-1] = 0;
				wsprintf(cTemp,"Loc(%s) IP(%s) PC(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
			}	
			break;
		// Chat logs of none
		case 4:		
			break;
	}

	switch (*cp) {
	case '@':
		*cp = 32;
		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iGuildRank == 0)) {
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 1;
			cp2++;
			ip = (int *)cp2;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}
				
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) && 
			 (m_pClientList[iClientH]->m_iSP >= 3) ) {
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 1;
		}
		else cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		break;

	case '$':
		*cp = 32;
		if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iSP >= 3)){
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL,iClientH,DEF_NOTIFY_SP,NULL,NULL,NULL,NULL);
			}
			cSendMode = 4;
		}
		else{
			cSendMode = NULL;
		}

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0){
			cSendMode = NULL;
		}
		break;

	case '^':
		*cp = 32;
		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) {
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 10;
			cp2++;
			ip = (int *)cp2;
			*ip = NULL;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}
		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 1;
			cp2++;
			ip = (int *)cp2;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}

		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) && 
			(m_pClientList[iClientH]->m_iSP > 5) && m_pClientList[iClientH]->m_iGuildRank != -1) {
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP -= 3;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
				}
				cSendMode = 1;
			}
		else cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iHP < 0) cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 10;
		break;

	case '!':
		*cp = 32;
		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) {
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 10;
			cp2++;
			ip = (int *)cp2;
			*ip = NULL;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) && 
			 (m_pClientList[iClientH]->m_iSP >= 5) ) {
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 5;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 2;
		}
		else cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 10;
		break;

	case '~':
		*cp = 32;
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) && 
			 (m_pClientList[iClientH]->m_iSP >= 3) ) {
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 3;
		}
		else cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;
		break;

	case '/':
		ZeroMemory(cBuffer, sizeof(cBuffer));
		memcpy(cBuffer, cp, dwMsgSize - 21);
		cp = (char *)(cBuffer);

		if (memcmp(cp, "/fi ", 4) == 0) {
			CheckAndNotifyPlayerConnection(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/to", 3) == 0) {
			ToggleWhisperPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/setpf ", 7) == 0) {
			SetPlayerProfile(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/pf ", 4) == 0) {
			GetPlayerProfile(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/shutup ", 8) == 0) {
			ShutUpPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/rep+ ", 6) == 0) {
			SetPlayerReputation(iClientH, cp, 1, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/rep- ", 6) == 0) {
			SetPlayerReputation(iClientH, cp, 0, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/hold", 5) == 0) {
			SetSummonMobAction(iClientH, 1, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/tgt ", 5) == 0) {
			SetSummonMobAction(iClientH, 2, dwMsgSize - 21, cp);
			return;
		}

		if (memcmp(cp, "/free", 5) == 0) {
			SetSummonMobAction(iClientH, 0, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/closeconn ", 11) == 0) {
			AdminOrder_CloseConn(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/ban", 4) == 0) {
			UserCommand_BanGuildsman(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/reservefightzone", 17) == 0) {
			AdminOrder_ReserveFightzone(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/attack ", 8) == 0) {
			AdminOrder_CallGuard(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/createfish ", 12) == 0) {
			AdminOrder_CreateFish(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/teleport ", 10) == 0 || memcmp(cp, "/tp ", 4) == 0) {
			AdminOrder_Teleport(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/goto ", 6) == 0) {
			AdminOrder_GoTo(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summondemon ", 13) == 0) {
			AdminOrder_SummonDemon(iClientH);
			return;
		}

		if (memcmp(cp, "/summonplayer ", 14) == 0) {
			AdminOrder_SummonPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/unsummonall ", 13) == 0) {
			AdminOrder_UnsummonAll(iClientH);
			return;			
		}

		if (memcmp(cp, "/unsummonboss", 13) == 0) {
			AdminOrder_UnsummonBoss(iClientH);
			return;
		}

		if (memcmp(cp, "/checkip ", 9) == 0) {
			AdminOrder_CheckIP(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/polymorph ", 11) == 0) {
			AdminOrder_Polymorph(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/setinvi ", 9) == 0) {
			AdminOrder_SetInvi(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/gns ", 5) == 0) { // changed to 5...
			AdminOrder_GetNpcStatus(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/setattackmode ", 15) == 0) {
			AdminOrder_SetAttackMode(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/setforcerecalltime ", 20) == 0) {
			AdminOrder_SetForceRecallTime(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summon ", 8) == 0) {
			AdminOrder_Summon(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/disconnectall", 14) == 0) {
			AdminOrder_DisconnectAll(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/createitem ", 12) == 0) {
			AdminOrder_CreateItem(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/enableadmincommand ", 20) == 0) {
			AdminOrder_EnableAdminCommand(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/monstercount", 13) == 0) {
			AdminOrder_MonsterCount(iClientH,cp,dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/energysphere ", 14) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelEnergySphere) EnergySphereProcessor(TRUE, iClientH);
			wsprintf(G_cTxt, "(%s) GM Order(%s): energysphere", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			return;
		}

		if (memcmp(cp, "/begincrusadetotalwar", 21) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) {
				GlobalStartCrusadeMode();
				wsprintf(cTemp, "(%s) GM Order(%s): begincrusadetotalwar", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			}
			return;
		}

#ifdef TEXTOUT
		if (memcmp(cp, "/textout", 8) == 0) {
			TextOut2();
			ShowClientMsg(iClientH, "Hello World");
			return;
		}
#endif
		
		if (memcmp(cp, "/endcrusadetotalwar", 19) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) {
				ManualEndCrusadeMode(0);
				wsprintf(cTemp, "(%s) GM Order(%s): endcrusadetotalwar", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			}
			return;
		}

		if (memcmp(cp, "/createparty", 12) == 0) {
			RequestCreatePartyHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/joinparty ", 11) == 0) {
			RequestJoinPartyHandler(iClientH,cp,dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/dismissparty", 13) == 0) {
			RequestDismissPartyHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/getpartyinfo", 13) == 0) {
			GetPartyInfoHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/deleteparty", 12) == 0) {
			RequestDeletePartyHandler(iClientH);
			return;
		}

		if ((memcmp(cp, "/shutdownthisserverrightnow ", 28) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelShutdown)) {
			m_cShutDownCode      = 2;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Admin-Command)!!!");
			bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
			return;
		}

		if ((memcmp(cp, "/getticket ", 11) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= 2)) {
			AdminOrder_GetFightzoneTicket(iClientH);
			return;
		}

		if (memcmp(cp, "/beginapocalypse ", 17) == 0) // SNOOPY reactivated these function
		{	if (   (m_pClientList[iClientH]->m_iAdminUserLevel >= 3)
				&& (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == TRUE)) 
			{	wsprintf(cTemp, "GM Order(%-10s): /beginapocalypse", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				GlobalStartApocalypseMode(iClientH, 0);
			}return;
		}
		if (memcmp(cp, "/openapocalypsegate ", 20) == 0)
		{	if (   (m_pClientList[iClientH]->m_iAdminUserLevel >= 3) 
				&& (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == TRUE)) 
			{	wsprintf(cTemp, "GM Order(%-10s): /openapocalypsegate", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				GlobalStartApocalypseMode(iClientH, 1);
			}return;
		}
		if (memcmp(cp, "/closeapocalypsegate ", 21) == 0)
		{	if (   (m_pClientList[iClientH]->m_iAdminUserLevel >= 3)
				&& (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == TRUE))  
			{	wsprintf(cTemp, "GM Order(%-10s): /closeapocalypsegate", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				GlobalStartApocalypseMode(iClientH, 2);
			}return;
		}
		if (memcmp(cp, "/endapocalypse", 14) == 0)
		{	if (   (m_pClientList[iClientH]->m_iAdminUserLevel >= 3) 	
				&& (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == TRUE)) 
			{	wsprintf(cTemp, "GM Order(%-10s): /endapocalypse", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				GlobalEndApocalypseMode(iClientH);
			}return;
		}	

		if (memcmp(cp, "/beginheldenian ", 16) == 0)	//m_iAdminLevelSpecialEvents
		{	wsprintf(cTemp, "GM Order(%-10s): /beginheldenian", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			ManualStartHeldenianMode(iClientH, cp, dwMsgSize - 21); 
			return;
		}		
		if (memcmp(cp, "/endheldenian ", 14) == 0)		//m_iAdminLevelSpecialEvents
		{	wsprintf(cTemp, "GM Order(%-10s): /endheldenian", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			ManualEndHeldenianMode(iClientH, cp, dwMsgSize - 21);
			return;
		}

		// Modification 
		// New 19/05/2004
		if (memcmp(cp, "/clearnpc", 9) == 0) {
			AdminOrder_ClearNpc(iClientH);
			return;
		}
		if (memcmp(cp, "/clearmap", 9) == 0) {
			AdminOrder_CleanMap(iClientH, cp, dwMsgSize);
			return;
		}

		if (memcmp(cp, "/who", 4) == 0) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TOTALUSERS, NULL, NULL, NULL, NULL);
			return;
		}

		
		if (memcmp(cp, "/deathmatch", 11) == 0) {
            if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) return;
			if (bDeathmatch) {
				bDeathmatch = FALSE;
				for (i = 1; i < DEF_MAXCLIENTS; i++) // Check all clients
				{
					if ((m_pClientList[i] != NULL)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_DEATHMATCHEND, NULL, NULL, NULL, NULL);
						if (memcmp(m_pClientList[i]->m_cMapName, "fightzone1", 10) == 0)
							RequestTeleportHandler(i, "1   ");
					}
				}
				PutLogList("DEATHMATCH MODE ON!");
			}
			else {
				bDeathmatch = TRUE;
				for (i = 1; i < DEF_MAXCLIENTS; i++) // Check all clients
				{
					if ((m_pClientList[i] != NULL)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_DEATHMATCHSTART, NULL, NULL, NULL, NULL); 					
					}
				}
				PutLogList("DEATHMATCH MODE OFF");
			}
			return;
		}
		
		if (memcmp(cp, "/onlines", 8) == 0) { // Centuu: /who modificado, muestra la cantidad total de Ares/Elv/Trav/GMs conectados.
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelWho) {
				char cMsg[120];
				int iAres = 0, iElv = 0, iTrav = 0, iGM = 0;
				for (int i = 0; i < DEF_MAXCLIENTS; i++) {
					if (m_pClientList[i] != NULL) {
						if (memcmp(m_pClientList[i]->m_cLocation, "are", 1) == 0 &&
							m_pClientList[i]->m_iAdminUserLevel == 0) iAres++;
						else if (memcmp(m_pClientList[i]->m_cLocation, "elv", 2) == 0 &&
							m_pClientList[i]->m_iAdminUserLevel == 0) iElv++;
						else if (memcmp(m_pClientList[i]->m_cLocation, "NONE", 3) == 0 &&
							m_pClientList[i]->m_iAdminUserLevel == 0) iTrav++;
						else if	(m_pClientList[i]->m_iAdminUserLevel > 0) iGM++;
					}
				}
				ZeroMemory(cMsg, sizeof(cMsg));
				wsprintf(cMsg, "Ares: %d | Elv: %d | Trav: %d | GM: %d", iAres, iElv, iTrav, iGM);
				ShowClientMsg(iClientH, cMsg);
			}
			return;
		}

		if (memcmp(cp, "/addmaster ", 11) == 0) {
            PlayerCommandAddMaster(iClientH, cp, dwMsgSize - 21);
            return;
        }
		if (memcmp(cp, "/deletemaster ", 13) == 0) {
            PlayerOrder_DeleteGuildMaster(iClientH, cp, dwMsgSize - 21);
            return;
        }

		// Centuu : EVENT CODE
        if (memcmp(cp, "/eventon ", 9) == 0) {    
            AdminOrder_Event(iClientH, 1, cp, dwMsgSize - 21);
            return;
        }
        if (memcmp(cp, "/eventoff", 9) == 0) {    
            AdminOrder_Event(iClientH, 2, cp, dwMsgSize - 21);
            return;
        }
        if (memcmp(cp, "/tpeventoff", 11) == 0) {    
            AdminOrder_Event(iClientH, 3, cp, dwMsgSize - 21);
            return;
        }
        if (memcmp(cp, "/tpevent", 8) == 0) {    
            EventTeleport(iClientH);
            return;
        }

		if (memcmp(cp, "/changecity", 11) == 0) { 
			return; 
		}

		if (memcmp(cp, "/save", 5) == 0) {
			if (bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH) == FALSE) LocalSavePlayerData(iClientH);
			ShowClientMsg(iClientH, "Data saved!.");
			return;
		}

		if (memcmp(cp, "/banpj ", 7) == 0) { // MORLA - 2.12 Cagar pc del player
			AdminOrder_BanPj(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/banip ", 7) == 0) {
			AdminOrder_BanIP(iClientH, cp, dwMsgSize - 21);
			return;
		}

		
		if (memcmp(cp, "/summonguild ", 13) == 0) {
			AdminOrder_SummonGuild(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/checkrep ", 10) == 0) {
			AdminOrder_CheckRep(iClientH,cp, dwMsgSize - 21);
			return;
		}		

        if (memcmp(cp, "/send ", 5) == 0) {
			AdminOrder_Pushplayer(iClientH, cp, dwMsgSize -21);
			return;
		}

		if (memcmp(cp, "/summonall ", 11) == 0) {
			AdminOrder_SummonAll(iClientH, cp, dwMsgSize - 21);
			return;
		}
		return;
	}
	pData[dwMsgSize-1] = NULL;
	
	// SNOOPY: designed non corean confuse language		
	if ((m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] == 1)) {
		// Confuse Language
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);		
		while (*cp != NULL) {
			if ((cp[0] != NULL) && (cp[1] != NULL)) 
			{	switch (iDice(1,12)) {
				case 1:	memcpy(cp, "ma", 2); break;
				case 2:	memcpy(cp, "fo", 2); break;
				case 3:	memcpy(cp, "ru", 2); break;
				case 4:	memcpy(cp, "be", 2); break;
				case 5:	memcpy(cp, "xy", 2); break;
				case 6:	memcpy(cp, "ce", 2); break;
				case 7:	memcpy(cp, "li", 2); break;
				case 8:	memcpy(cp, "re", 2); break;
				case 9:	memcpy(cp, "su", 2); break;
				case 10:memcpy(cp, "to", 2); break;
				case 11:memcpy(cp, "ju", 2); break;
				case 12:memcpy(cp, "de", 2); break;
				}
				if (cp[1] != ' ')
				switch (iDice(1,12)) {
				case 1:	
				case 2:	
				case 3:	
				case 4:	
				case 5:	break;
				case 6:	memcpy(cp, "a ", 2); break;
				case 7:	
				case 8:	memcpy(cp, "e ", 2); break;
				case 9:	memcpy(cp, "i ", 2); break;
				case 10:memcpy(cp, "o ", 2); break;
				case 11:memcpy(cp, "u ", 2); break;
				case 12:memcpy(cp, "y ", 2); break;
				}	
				if (cp[0] != ' ')
				switch (iDice(1,12)) {
				case 1:	
				case 2:	
				case 3:	
				case 4:	
				case 5:	break;
				case 6:	memcpy(cp, " c", 2); break;
				case 7:	
				case 8:	memcpy(cp, " s", 2); break;
				case 9:	memcpy(cp, " t", 2); break;
				case 10:memcpy(cp, " l", 2); break;
				case 11:memcpy(cp, " r", 2); break;
				case 12:memcpy(cp, " n", 2); break;
				}				
				cp += 2;
			}
			else cp++; 
		}
	}
		
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);
	if ((cSendMode == NULL) && (m_pClientList[iClientH]->m_iWhisperPlayerIndex != -1)) {
		cSendMode = 20;
 		if (*cp == '#') cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
	}
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	*wp = (WORD)iClientH;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 16);
	*cp = cSendMode;

	if (cSendMode != 20) {
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			switch (cSendMode) {
			case NULL:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				if ((m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) &&
					 (m_pClientList[i]->m_sX > m_pClientList[iClientH]->m_sX - 10) &&
					 (m_pClientList[i]->m_sX < m_pClientList[iClientH]->m_sX + 10) &&
					 (m_pClientList[i]->m_sY > m_pClientList[iClientH]->m_sY - 7) &&
					 (m_pClientList[i]->m_sY < m_pClientList[iClientH]->m_sY + 7)) {
					if (m_bIsCrusadeMode == TRUE) {
						if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
							(m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				break;
					
			case 1:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				if ((memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) &&
					(memcmp(m_pClientList[i]->m_cGuildName, "NONE", 4) != 0)) {					
					if (m_bIsCrusadeMode == TRUE) {
						if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
							(m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				break;
					
			case 2:
			case 10:
				if (m_bIsCrusadeMode == TRUE) {
					if ( (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
						 (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;
					
			case 3:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				if ( (m_pClientList[i]->m_cSide == m_pClientList[iClientH]->m_cSide) ) 
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;

			case 4:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				if ((m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == m_pClientList[iClientH]->m_iPartyID) ) 
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;
			}
		}
	}
	else {
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pData, dwMsgSize);	
		if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == 10000) {
			ZeroMemory(cBuffer, sizeof(cBuffer));
			cp = (char *)cBuffer;
			*cp = GSM_WHISFERMSG;
			cp++;
			memcpy(cp, m_pClientList[iClientH]->m_cWhisperPlayerName, 10);
			cp += 10;

			wp = (WORD *)cp;
			*wp = (WORD)dwMsgSize;
			cp += 2;
			memcpy(cp, pData, dwMsgSize);
			cp += dwMsgSize;
			bStockMsgToGateServer(cBuffer, dwMsgSize+13);
		}
		else{
			if (m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ] != NULL && strcmp(m_pClientList[iClientH]->m_cWhisperPlayerName, m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ]->m_cCharName) == 0){
				iRet = m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_pXSock->iSendMsg(pData, dwMsgSize);	
				switch (m_bLogChatOption){
					case 1:
						if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel == 0){
							ZeroMemory(cTemp,sizeof(cTemp));
							wsprintf(cTemp,"GM Whisper   (%s):\"%s\"\tto Player(%s)",m_pClientList[iClientH]->m_cCharName, pData+21, m_pClientList[iClientH]->m_cWhisperPlayerName);
							bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
						}
						break;
					case 2:
						if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel > 0){
							ZeroMemory(cTemp,sizeof(cTemp));
							wsprintf(cTemp,"GM Whisper   (%s):\"%s\"\tto GM(%s)",m_pClientList[iClientH]->m_cCharName, pData+21, m_pClientList[iClientH]->m_cWhisperPlayerName);
							bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
						}
						break;
						case 3:
						if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel > 0){
							ZeroMemory(cTemp,sizeof(cTemp));
							wsprintf(cTemp,"GM Whisper   (%s):\"%s\"\tto GM(%s)",m_pClientList[iClientH]->m_cCharName, pData+21, m_pClientList[iClientH]->m_cWhisperPlayerName);
							bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
						}
						else{
							ZeroMemory(cTemp,sizeof(cTemp));
							wsprintf(cTemp,"Player Whisper   (%s):\"%s\"\tto Player(%s)",m_pClientList[iClientH]->m_cCharName, pData+21, m_pClientList[iClientH]->m_cWhisperPlayerName);
							bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
						}
						break;
					case 4:
						break;
				}
			}
		}
	}
}

/*********************************************************************************************************************
**  void CGame::ChatMsgHandlerGSM(int iMsgType, int iV1, char * pName, char * pData, DWORD dwMsgSize)				**
**  DESCRIPTION			:: manages Npc variables																	**
**  LAST_UPDATED		:: March 18, 2005; 6:30 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- new Crop DeleteNpc after specific amount of time										**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
void CGame::ChatMsgHandlerGSM(int iMsgType, int iV1, char * pName, char * pData, DWORD dwMsgSize)
{
 int i, iRet;
 DWORD * dwp;
 WORD * wp;
 short * sp;
 char * cp, cTemp[256], cSendMode = NULL;

	ZeroMemory(cTemp, sizeof(cTemp));
	
	dwp = (DWORD *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;
	
	wp  = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;
	
	memcpy(cp, pName, 10);
	cp += 10;

	*cp = (char)iMsgType;
	cp++;

	memcpy(cp, pData, dwMsgSize);
	cp += dwMsgSize;

	switch (iMsgType) {
	case 1:
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
			if ( (m_pClientList[i]->m_iGuildGUID == iV1) && (m_pClientList[i]->m_iGuildGUID != 0)) {
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
			}
		}
		break;

	case 2:
	case 10:
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
		}
		break;
	}
}

/*********************************************************************************************************************
**  int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType,		**
**		char cDir, WORD wTargetObjectID, BOOL bResponse, BOOL bIsDash)												**
**  DESCRIPTION			:: controls player attack																	**
**  LAST_UPDATED		:: March 19, 2005; 1:21 PM; Hypnotoad														**
**	RETURN_VALUE		:: int																						**
**  NOTES				::	- added checks for Firebow and Directionbow to see if player is m_bIsInsideWarehouse,	**
**							m_bIsInsideWizardTower, m_bIsInCombatantOnlyZone										**
**							- added ability to attack moving object													**
**							- fixed attack unmoving object															**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, WORD wTargetObjectID, BOOL bResponse, BOOL bIsDash)
{
 char cData[100];
 DWORD * dwp, dwTime;
 WORD  * wp;
 int     iRet, tdX = 0, tdY = 0, i;
 short   sOwner, sAbsX, sAbsY;
 char    cOwnerType;
 BOOL    bNearAttack = FALSE, var_AC = FALSE;
 short sItemIndex;
 int tX, tY, iErr, iStX, iStY;
 unsigned long iExp;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;
	m_pClientList[iClientH]->m_iAttackMsgRecvCount++;
	if (m_pClientList[iClientH]->m_iAttackMsgRecvCount >= 7) {
		if (m_pClientList[iClientH]->m_dwAttackLAT != 0) {
			if ((dwTime - m_pClientList[iClientH]->m_dwAttackLAT) < (3500)) {		
				DeleteClient(iClientH, TRUE, TRUE, TRUE);
				return 0;
			}
		}
		m_pClientList[iClientH]->m_dwAttackLAT = dwTime;
		m_pClientList[iClientH]->m_iAttackMsgRecvCount = 0;
	}
	if ((wTargetObjectID != NULL) && (wType != 2)) {
		if (wTargetObjectID < DEF_MAXCLIENTS) {
			if (m_pClientList[wTargetObjectID] != NULL) {
				tdX = m_pClientList[wTargetObjectID]->m_sX;
				tdY = m_pClientList[wTargetObjectID]->m_sY;
			}
		}
		else if ((wTargetObjectID > 10000) && (wTargetObjectID < (10000 + DEF_MAXNPCS))) {
			if (m_pNpcList[wTargetObjectID - 10000] != NULL) {
				tdX = m_pNpcList[wTargetObjectID - 10000]->m_sX;
				tdY = m_pNpcList[wTargetObjectID - 10000]->m_sY;
			}
		}
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
		if (sOwner == (wTargetObjectID - 10000)) {
			tdX = m_pNpcList[sOwner]->m_sX;
			dX = tdX;
			tdY = m_pNpcList[sOwner]->m_sY;
			dY = tdY;
			bNearAttack = FALSE;
			var_AC = TRUE;
		}
		if (var_AC != TRUE) {
			if ((tdX == dX) && (tdY == dY)) {
				bNearAttack = FALSE;	
			}
			else if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
				dX = tdX;
				dY = tdY;
				bNearAttack = TRUE;
			}
		}
	}
	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) || (dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return 0;
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	sAbsX = abs(sX - dX);
	sAbsY = abs(sY - dY);
	if ((wType != 2) && (wType < 20)) {
		if (var_AC == FALSE) {
			sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
			if (sItemIndex != -1) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return 0;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) {
					if ((sAbsX > 4) || (sAbsY > 4)) wType = 0;
				}
				else{
					if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
				}
			}
			else{
				if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
			}
		}
		else{
			cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
			if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bCheckFlySpaceAvailable(sX, sY, cDir, sOwner)) != FALSE)
				wType = 0;
		}
	}
	ClearSkillUsingStatus(iClientH);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pClientList[iClientH]->m_cDir = cDir;
	iExp = 0;
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
	if (sOwner != NULL) {
		if ((wType != 0) && ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) > 100)) { 
			if ((m_pClientList[iClientH]->m_pIsProcessingAllowed == FALSE) && (m_pClientList[iClientH]->m_bIsInsideWarehouse == FALSE) 
				&& (m_pClientList[iClientH]->m_bIsInsideWizardTower == FALSE) && (m_pClientList[iClientH]->m_bIsInsideEnemyBuilding == FALSE)) {
				// Magic Weapons - Add Special Effect for Weapon
				short sType, sManaCost;
				DWORD dwType1, dwType2, dwValue1, dwValue2;

				if(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1){
					sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				}
				else if(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1){
					sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				}
				else sItemIndex = -1;

				if(sItemIndex != -1){
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
						dwType1  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
						dwValue1 = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
						dwType2  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
						dwValue2 = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
					}
					if(dwType1 == 15){
						sManaCost = dwValue2*2;
						if (m_pClientList[iClientH]->m_iMP >= sManaCost){
							switch(dwValue1){
								// Fire-Strike
								case 1:
									sType = 30; 
									break;
								// Lightning
								case 2:
									sType = 43; 
									break;
								// Chill-Wind
								case 3:
									sType = 45; 
									break;
								// Ice-Strike
								case 4:
									sType = 57; 
									break;
								// Energy-Strike
								case 5:
									sType = 60; 
									break;
								// Mass-Fire-Strike
								case 6:
									sType = 61; 
									break;
								// Mass-Chill-Wind
								case 7:
									sType = 63; 
									break;
								// Earthworm-Strike
								case 8:
									sType = 64; 
									break;
								// Bloody-Shock-Wave
								case 9:
									sType = 70; 
									break;
								// Mass-Ice-Strike
								case 10:
									sType = 72; 
									break;
								// Lightning-Strike
								case 11:
									sType = 74; 
									break;
								// Ice-Whirlwind
								case 12:
									sType = 75; 
									break;
								// Meteor-Strike
								case 13:
									sType = 81; 
									break;
								// Mass-Magic-Missile
								case 14:
									sType = 82; 
									break;
								// Blizzard
								case 15:
									sType = 91; 
									break;
								// Earth-Shock-Wave
								case 16:
									sType = 96; 
									break;
							}
							SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex, sX, sY, dX, dY, (sType+100), m_pClientList[iClientH]->m_sType);
						}
					}
				}
				// End of Magic Weapons
				sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if (sItemIndex != -1 && m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
					// Directional Bow. Fixed by juan249
					if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 874){ // Directional bow 
						iErr = 0; 
						for(i = 1; i < 6; i++){ 
							m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i); 
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, tX, tY); 
							iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, tX, tY, wType, bNearAttack, bIsDash, TRUE); // 1 
							if (((abs(tdX - dX) >= 1) && (abs(tdY - dY) >= 1)) || ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1))) { 
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY); 
								iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0 
								while (((tdX - dX) >= 1) && ((tdY - dY) >= 1)) { 
									dX += 4; dY += 4; tY += 4; tX += 4; 
								}
								while (((tdX - dX) >= 1) && ((tdY - dY) >= 1)) { 
									dX += 4; dY += 4; tY += 4; tX += 4; 
								} 
								while (((tdX - dX) >= 1) && ((tdY - dY) >= 1)) { 
									dX += 4; dY += 4; tY += 4; tX += 4; 
								} 
								while (((tdX - dX) >= 1) && ((tdY - dY) >= 1)) { 
									dX += 4; dY += 4; tY += 4; tX += 4; 
								} 
								while (((tdX - dX) >= 1) && ((tdY - dY) >= 1)) { 
									dX += 4; dY += 4; tY += 4; tX += 4; 
								} 
								while (((tdX - dX) >= 1) && ((tdY - dY) >= 1)) { 
									dX += 4; dY += 4; tY += 4; tX += 4; 
								} 
							} 
						} 
					}
					else if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 873){ // Firebow
						if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) != 0) {
							
							iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE3, m_pClientList[iClientH]->m_cMapIndex, dX, dY, (iDice(1,7)+3)*1000, 8);
							
							iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0
						}
					}
					else{
						iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0
					}
				}
				else{
					iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0
				}
			}
			else{
				iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0
			}
			if (m_pClientList[iClientH] == NULL) return 0;
			m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
		}
	}
	else _CheckMiningAction(iClientH, dX, dY);

	if (iExp != 0) {
		GetExp(iClientH, iExp, TRUE);
	}

	if (bResponse == TRUE) {
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOTION_ATTACK_CONFIRM;
	
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE, TRUE);
			return 0;
		}
	}

	return 1;
}

/*********************************************************************************************************************
**  char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn,				**
**		int * pError)																								**
**  DESCRIPTION			:: gets next direction																		**
**  LAST_UPDATED		:: March 19, 2005; 1:34 PM; Hypnotoad														**
**	RETURN_VALUE		:: char																						**
**  NOTES				::	n/a																						**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn, int * pError)
{
  char  cDir, cTmpDir;
 int   aX, aY, dX, dY;
  int   i, iResX, iResY;

	if ((sX == dstX) && (sY == dstY)) return 0;
	dX = sX;
	dY = sY;
	if ((abs(dX - dstX) <= 1) && (abs(dY - dstY) <= 1)) {
		iResX = dstX;
		iResY = dstY;
	}
	else m_Misc.GetPoint(dX, dY, dstX, dstY, &iResX, &iResY, pError);
	cDir = m_Misc.cGetNextMoveDir(dX, dY, iResX, iResY);
	if (cTurn == 0) {
		for (i = cDir; i <= cDir + 7;i++) {
			cTmpDir = i;
			if (cTmpDir > 8) cTmpDir -= 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
		}
	}
	if (cTurn == 1) {
		for (i = cDir; i >= cDir - 7;i--) {
			cTmpDir = i;
			if (cTmpDir < 1) cTmpDir += 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
		}
	}
	return 0;
}


char _tmp_cEmptyPosX[] = { 0, 1, 1, 0, -1, -1, -1, 0 ,1, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2 };
char _tmp_cEmptyPosY[] = { 0, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2 };
/*********************************************************************************************************************
**  BOOL CGame::bGetEmptyPosition(short * pX, short * pY, char cMapIndex)											**
**  DESCRIPTION			:: checks if next spot is available															**
**  LAST_UPDATED		:: March 19, 2005; 1:35 PM; Hypnotoad														**
**	RETURN_VALUE		:: BOOL																						**
**  NOTES				::	n/a																						**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
BOOL CGame::bGetEmptyPosition(short * pX, short * pY, char cMapIndex)
{
 int i;
 short sX, sY;	
	
	for (i = 0; i < 25; i++) 
	if ((m_pMapList[cMapIndex]->bGetMoveable(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == TRUE) &&
		(m_pMapList[cMapIndex]->bGetIsTeleport(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == FALSE) ) {
		sX = *pX + _tmp_cEmptyPosX[i];
		sY = *pY + _tmp_cEmptyPosY[i];	
		*pX = sX;
		*pY = sY;
		return TRUE;
	}	
	GetMapInitialPoint(cMapIndex, &sX, &sY);
	*pX = sX;
	*pY = sY;

	return FALSE;
}

/*********************************************************************************************************************
**  void CGame::NpcBehavior_Move(int iNpcH)																			**
**  DESCRIPTION			:: controls npc movement																	**
**  LAST_UPDATED		:: March 19, 2005; 1:50 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- added boss mob tracker																**
**							- new movement types for monsters which are 2x2, 3x3 (abaddon, wyvern)					**
**	MODIFICATION		::	n/a																						**
**********************************************************************************************************************/
void CGame::NpcBehavior_Move(int iNpcH)
{
 char  cDir;
 short sX, sY, dX, dY, absX, absY;
 short sTarget, sDistance;
 char  cTargetType;
	
	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;
	if ((m_pNpcList[iNpcH]->m_bIsSummoned == TRUE) && (m_pNpcList[iNpcH]->m_iSummonControlMode == 1)) return;
	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) return;
	// Taming
	if ((m_pNpcList[iNpcH]->m_dwTamingTime != 0) && (m_pNpcList[iNpcH]->m_iSummonControlMode == 1)) return;
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 2:
	case 3:
	case 5:
	case 8: // Heldenian gates
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_STOP;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		return;
	}
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) {
		iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;  
	}
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		absX = abs(m_pNpcList[iNpcH]->m_vX - m_pNpcList[iNpcH]->m_sX);
		absY = abs(m_pNpcList[iNpcH]->m_vY - m_pNpcList[iNpcH]->m_sY);
		if ((absX <= 2)	&& (absY <= 2)) {
			CalcNextWayPointDestination(iNpcH);
		}
		m_pNpcList[iNpcH]->m_vX = m_pNpcList[iNpcH]->m_sX;
		m_pNpcList[iNpcH]->m_vY = m_pNpcList[iNpcH]->m_sY;
	}
	TargetSearch(iNpcH, &sTarget, &cTargetType);				
	if (sTarget != NULL) {
		if (m_pNpcList[iNpcH]->m_dwActionTime < 1000) {
			if (iDice(1,3) == 3) {
				m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
				m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
				return;
			}
		}
		else {
			m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
			m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
			m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
			return;
		}
	}
	if ((m_pNpcList[iNpcH]->m_bIsMaster == TRUE) && (iDice(1,3) == 2)) return;	
	if (m_pNpcList[iNpcH]->m_cMoveType == DEF_MOVETYPE_FOLLOW) {
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
		switch (m_pNpcList[iNpcH]->m_cFollowOwnerType) {
		case DEF_OWNERTYPE_PLAYER_FREE: // Waiting for someone to control him
				m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
				m_pNpcList[iNpcH]->m_iFollowOwnerIndex = NULL;
				return;
		case DEF_OWNERTYPE_PLAYER_WAITING: // Waiting for a character de reconnect, should be useless, here for safety
				m_pNpcList[iNpcH]->m_iFollowOwnerIndex = NULL;
				m_pNpcList[iNpcH]->m_cMoveType		   = DEF_MOVETYPE_RANDOM;
				return;
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) // Should not happen, because removeFromTarget should be called before
			{	m_pNpcList[iNpcH]->m_cFollowOwnerType  = DEF_OWNERTYPE_PLAYER_WAITING;
				m_pNpcList[iNpcH]->m_iFollowOwnerIndex = NULL;
				m_pNpcList[iNpcH]->m_dwSummonWaitTime  = timeGetTime();
				m_pNpcList[iNpcH]->m_cMoveType		   = DEF_MOVETYPE_RANDOM;
				return;
			}
			dX = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
			dY = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) {
				m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
				m_pNpcList[iNpcH]->m_iFollowOwnerIndex = NULL;
				return;
			}
			dX = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
			dY = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
			break;
		}

		if (abs(sX - dX) >= abs(sY - dY)) 
			 sDistance = abs(sX - dX);
		else sDistance = abs(sY - dY);

		if (sDistance >= 3) {
			// new 1x1, 2x2, 3x3 monster move 
			if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
				cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			}
			else {
				cDir = cGetNextMoveArea(iNpcH, sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError, m_pNpcList[iNpcH]->m_sAreaSize);
			}
			if (cDir == 0) {

			}
			else {
				dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
				dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
				// new 1x1, 2x2, 3x3 npc move
				if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(3, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
				}
				else {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetBigOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY, m_pNpcList[iNpcH]->m_sAreaSize);
				}
				m_pNpcList[iNpcH]->m_sX   = dX;
				m_pNpcList[iNpcH]->m_sY   = dY;
				m_pNpcList[iNpcH]->m_cDir = cDir;
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
			}
		}
	}
	else  {
		// new 1x1, 2x2, 3x3 monster move 
		if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
			cDir = cGetNextMoveDir(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_dX, m_pNpcList[iNpcH]->m_dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
		}
		else {
			cDir = cGetNextMoveArea(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_dX, m_pNpcList[iNpcH]->m_dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError, m_pNpcList[iNpcH]->m_sAreaSize);
		}	
		if (cDir == 0) {
			if (iDice(1,10) == 3) CalcNextWayPointDestination(iNpcH);
		}
		else {
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			// new 1x1, 2x2, 3x3 npc move
			if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(4, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			}
			else {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetBigOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY, m_pNpcList[iNpcH]->m_sAreaSize);
			}
			m_pNpcList[iNpcH]->m_sX   = dX;
			m_pNpcList[iNpcH]->m_sY   = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
		// new
		if (m_pNpcList[iNpcH]->m_bIsBossMob == TRUE) {
			wsprintf(G_cTxt, "Boss Mob position x:%d y:%d", m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			PutLogList(G_cTxt);
		}
	}
}

void CGame::TargetSearch(int iNpcH, short * pTarget, char * pTargetType)
{
 int ix, iy, iPKCount;
  short sX, sY, rX, rY, dX, dY;
 short sOwner, sTargetOwner, sDistance, sTempDistance;
 char  cOwnerType, cTargetType, cTargetSide;
 int   iInv;

	sTargetOwner = NULL;
	cTargetType  = NULL;
	sDistance    = 100;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	//  iNpcH  NPC  . 
	rX = m_pNpcList[iNpcH]->m_sX - m_pNpcList[iNpcH]->m_cTargetSearchRange;
	rY = m_pNpcList[iNpcH]->m_sY - m_pNpcList[iNpcH]->m_cTargetSearchRange;
	
	for (ix = rX; ix < rX + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; ix++)
	for (iy = rY; iy < rY + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; iy++) {
		
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);
		if (sOwner != NULL) {
			//  . 
			if ((sOwner == iNpcH) && (cOwnerType == DEF_OWNERTYPE_NPC)) break; //    
			
			//  
			//  .
			iPKCount = 0;
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwner] == NULL) {
					//    . .	
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(5, sOwner, DEF_OWNERTYPE_PLAYER, ix, iy);
				}
				else {
					if (m_pClientList[sOwner]->m_iAdminUserLevel > 0) goto SKIP_SEARCH;

					dX = m_pClientList[sOwner]->m_sX;
					dY = m_pClientList[sOwner]->m_sY;
					cTargetSide = m_pClientList[sOwner]->m_cSide;
					iPKCount    = m_pClientList[sOwner]->m_iPKCount;
					iInv        = m_pClientList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwner] == NULL) {
					//    . .	
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(6, sOwner, DEF_OWNERTYPE_NPC, ix, iy);
				}
				else {
					dX = m_pNpcList[sOwner]->m_sX;
					dY = m_pNpcList[sOwner]->m_sY;
					cTargetSide = m_pNpcList[sOwner]->m_cSide;
					iPKCount    = 0;
					iInv        = m_pNpcList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];

					if (m_pNpcList[iNpcH]->m_sType == 21) {
						//   NPC    NPC     . 
						if (_iCalcPlayerNum(m_pNpcList[sOwner]->m_cMapIndex, dX, dY, 2) != 0) {
							sOwner     = NULL;
							cOwnerType = NULL;
						}
					}
				}
				break;
			}
			
			if (m_pNpcList[iNpcH]->m_cSide < 10) {
				// NPC Side 10   NPC    .  Ex: Guard    
				if (cTargetSide == 0) {
					//  . PK   . 
					if (iPKCount == 0) goto SKIP_SEARCH;
				}
				else {
					//   . Side  . v1.12
					if ((iPKCount == 0) && (cTargetSide == m_pNpcList[iNpcH]->m_cSide)) goto SKIP_SEARCH;
					//      . v1.12
					if (m_pNpcList[iNpcH]->m_cSide == 0) goto SKIP_SEARCH;
				}
			}
			else {
				//  .  Side  .
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (cTargetSide == 0)) goto SKIP_SEARCH;
				if (cTargetSide == m_pNpcList[iNpcH]->m_cSide) goto SKIP_SEARCH;
			}

			//  INVISIBILITY       
			if ((iInv != 0) && (m_pNpcList[iNpcH]->m_cSpecialAbility != 1)) goto SKIP_SEARCH;

			if (abs(sX - dX) >= abs(sY - dY)) 
				 sTempDistance = abs(sX - dX);
			else sTempDistance = abs(sY - dY);

			if (sTempDistance <	sDistance) {
				sDistance = sTempDistance;
				sTargetOwner = sOwner;
				cTargetType  = cOwnerType;
			}
SKIP_SEARCH:;
		}
	}

	*pTarget     = sTargetOwner;
	*pTargetType = cTargetType;
	return;
}

void CGame::NpcBehavior_Attack(int iNpcH)
{
 int   iMagicType;
 short sX, sY, dX, dY;
 char  cDir;
 DWORD dwTime = timeGetTime();
 BOOL bFly = FALSE;

	if (m_pNpcList[iNpcH] == NULL) return;
 	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 1:
	case 2:
	case 3:
	case 4:
	case 8: // Heldenian gate
		return;

	case 5:
		if (m_pNpcList[iNpcH]->m_iBuildCount > 0) return;
	}
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) {
		iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;  
	}
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount == 0) 
		m_pNpcList[iNpcH]->m_iAttackCount = 0;
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 20) {
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE))
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
		return;
	}
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) {
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
			return;
		}
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) {
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
			return;
		}
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}
	if ((iGetDangerValue(iNpcH, dX, dY) > m_pNpcList[iNpcH]->m_cBravery) && 
		(m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) &&
		(m_pNpcList[iNpcH]->m_cActionLimit != 5) &&
		(m_pNpcList[iNpcH]->m_cActionLimit != 8)) {
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
		return;
	}
	if ((m_pNpcList[iNpcH]->m_iHP <= 2) && (iDice(1,m_pNpcList[iNpcH]->m_cBravery) <= 3) &&
		(m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) &&
		(m_pNpcList[iNpcH]->m_cActionLimit != 5) &&
		(m_pNpcList[iNpcH]->m_cActionLimit != 8)) {
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
		return;
	}
	cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
	if (m_pNpcList[iNpcH]->m_sAreaSize != 0) {
		bFly = m_pMapList[m_pClientList[iNpcH]->m_cMapIndex]->bCheckFlySpaceAvailable(dX, dY, cDir, iNpcH);
	}
	if (((abs(sX - dX) <= 1) && (abs(sY - dY) <= 1)) && (m_pNpcList[iNpcH]->m_sAreaSize == 0)) {
		if (cDir == 0) return;
		m_pNpcList[iNpcH]->m_cDir = cDir;				  
		if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
			switch (m_pNpcList[iNpcH]->m_sType) {
			case 36: // Crossbow Guard Tower:
			case 53: // CT
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 2);
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2, FALSE, FALSE, FALSE);
				break;

			case 37: // Cannon Guard Tower: 
			case 51: // Catapault
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
				m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
				NpcMagicHandler(iNpcH, dX, dY, 61);
				break;
			}
		}
		else {
			// new ice golem special attack! (requries new server sided MAGIC.CFG)
			if (m_pNpcList[iNpcH]->m_cMagicLevel == 11) {
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1);
				m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
				NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 75);
			}
			else {
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1);
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 1, FALSE, FALSE);
			}
		}
		m_pNpcList[iNpcH]->m_iAttackCount++;
		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
			switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
			case DEF_ATTACKAI_EXCHANGEATTACK:
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				break;

			case DEF_ATTACKAI_TWOBYONEATTACK:
				if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				}
				break;
			}
		}
	}
	else {
		cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
		if (cDir == 0) return;
		m_pNpcList[iNpcH]->m_cDir = cDir;				  
		if ((m_pNpcList[iNpcH]->m_cMagicLevel > 0) && (iDice(1,2) == 1) &&
			(abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
			iMagicType = -1;
			switch (m_pNpcList[iNpcH]->m_cMagicLevel) {
			case 1:
				if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 0;
				break;

			case 2:
				if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 0;
				break;

			case 3: // Orc-Mage
				if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;

			case 4:
				if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37;
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;

			case 5: // Rudolph, Cannibal-Plant, Cyclops
				if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37;
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;

			case 6: // Tentocle, Liche
				if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51;
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37;
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;

			case 7: // Barlog, Fire-Wyvern, MasterMage-Orc , LightWarBeatle, GHK, GHKABS, TK, BG
				    // Sor, Gagoyle, Demon
				if ((m_pMagicConfigList[70]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,5) == 3)) 
					iMagicType = 70;
				else if (m_pMagicConfigList[61]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 61;
				else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 60;
				else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51;
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				break;

			case 8: // Unicorn, Centaurus
				if ((m_pMagicConfigList[35]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 35;
				else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 60;
				else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51;
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				break;

			case 9: // Tigerworm
				if ((m_pMagicConfigList[74]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 74; // Lightning-Strike
				break;
			
			case 10: // Frost, Nizie
				if ((m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 57; // Lightning-Strike
				break;

			case 11: // Ice-Golem
				break;

			case 12: // Wyvern
				if ((m_pMagicConfigList[91]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 91; // Blizzard
				else if (m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 57; // Ice-Strike
				break;

			case 13: // Abaddon
				if ((m_pMagicConfigList[96]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 96; // Earth Shock Wave
				else if ((m_pMagicConfigList[91]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2))
					iMagicType = 91; // Blizzard
				else if (m_pMagicConfigList[81]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 81; // Metoer Strike
				break;

			}
			if (iMagicType != -1) {
				if (m_pNpcList[iNpcH]->m_iAILevel >= 2) {
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						// npc dont waste magic on AMP targets
						if (((m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2) ||
							(m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5)) &&
							(iMagicType > 90)) {
							if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
								m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
								return;
							}
							else goto NBA_CHASE;
						}
						if ((iMagicType == 35) && (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) {
							if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
								m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
								return;
							}
							else goto NBA_CHASE;
						}
						if ((iMagicType == 35) && (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
						break;
					}
				}
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 :     
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000; 
				return;
			}
		}
		if ((m_pNpcList[iNpcH]->m_cMagicLevel < 0) && (iDice(1,2) == 1) &&
			(abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
			iMagicType = -1;
			if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 43;
			else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 37;
			else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 0;
			if (iMagicType != -1) {
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 :     
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000; 
				return;
			}
		}
		if ((m_pNpcList[iNpcH]->m_iAttackRange > 1) && (abs(sX - dX) <= m_pNpcList[iNpcH]->m_iAttackRange) && (abs(sY - dY) <= m_pNpcList[iNpcH]->m_iAttackRange)) {					
			cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
			if (cDir == 0) return;
			m_pNpcList[iNpcH]->m_cDir = cDir;				  	
			if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
				switch (m_pNpcList[iNpcH]->m_sType) {
				case 36: // Crossbow Guard Tower
				case 54: // CT
				case 89:
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
					break;

				case 37: // Cannon Guard Tower:    
				case 51:
				case 87:
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;
				}
			}
			else {
				switch (m_pNpcList[iNpcH]->m_sType) {
				case 51: // v2.05 Catapult:     
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;

				case 54: // Dark Elf:   .
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); // 2:  
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
					break;
				
				case 63: // Frost
				case 79: // Nizie
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						if ((m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
							NpcMagicHandler(iNpcH, dX, dY, 57);
						//      .
						if ((m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
							if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, TRUE);
								//       .
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
									                m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
								//    .
								SendNotifyMsg(NULL, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						if ((m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
						NpcMagicHandler(iNpcH, dX, dY, 57);
						if ((m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
							if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, TRUE);
								//       .
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
								                    m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					break;

				case 53: //Beholder:   .
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						//      .
						if ((m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
							if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, TRUE);
								//       .
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
									                m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
								//    .
								SendNotifyMsg(NULL, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						if ((m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
							if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, TRUE);
								//       .
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
								                    m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20);
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20);
				break;
NBA_BREAK1:;
						
			default:
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20);
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20);
				break;
			}
		}
		m_pNpcList[iNpcH]->m_iAttackCount++;
		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
			switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
			case DEF_ATTACKAI_EXCHANGEATTACK:
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				break;
		
			case DEF_ATTACKAI_TWOBYONEATTACK:
				if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
			}
			break;
		}
	}
	return;
}

NBA_CHASE:;		
		if (m_pNpcList[iNpcH]->m_cActionLimit != 0) return;
		m_pNpcList[iNpcH]->m_iAttackCount = 0;
		// new
		if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
			cDir = cGetNextMoveDir(sX, sY, dX, dY,m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
		}
		else {
			cDir = cGetNextMoveArea(iNpcH, sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError, m_pNpcList[iNpcH]->m_sAreaSize);
		}
		if (cDir == 0) return;
		dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
		dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
		// new 1x1, 2x2, 3x3 npc attack
		if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(9, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
		}
		else {
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetBigOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY, m_pNpcList[iNpcH]->m_sAreaSize);
		}
		m_pNpcList[iNpcH]->m_sX   = dX;
		m_pNpcList[iNpcH]->m_sY   = dY;
		m_pNpcList[iNpcH]->m_cDir = cDir;
		SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
	}
}


void CGame::RemoveFromTarget(short sTargetH, char cTargetType, int iCode, int iAttackerH, char cAttackerType)
// Used into deleteclient(), ClientKilled(), deleteNpc(), npcKilled(), invisibility, Teleport
{  int i;
	//renew crusade summons duration	
	// Somebody from guild invied => renew summon duration !
	//  "   "     "     "  killed/teleported/deco 
	if ((m_bIsCrusadeMode == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER))
	{	DWORD dwTime = timeGetTime();
		for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) 
		{	if (   (m_pNpcList[i]->m_iGuildGUID != NULL) 				 
				&& (m_pClientList[sTargetH]->m_iGuildGUID == m_pNpcList[i]->m_iGuildGUID)) 			
			{	if (m_pNpcList[i]->m_cActionLimit < 2)	
				{	m_pNpcList[i]->m_bIsSummoned = TRUE;		
					m_pNpcList[i]->m_dwSummonedTime = dwTime;	
	}	}	}	}

	// If master was killed or deco set follower mode
	if ((cTargetType  == DEF_OWNERTYPE_PLAYER) && (iCode == NULL))// not DEF_MAGICTYPE_INVISIBILITY neither DEF_MAGICTYPE_TELEPORT
	{	for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) 
		{	if (   (m_pNpcList[i]->m_bIsSummoned		== TRUE) 
				&& (m_pNpcList[i]->m_bIsKilled			== FALSE) 
				&& (m_pNpcList[i]->m_cFollowOwnerType	== DEF_OWNERTYPE_PLAYER) 
				&& (m_pNpcList[i]->m_iFollowOwnerIndex	== sTargetH))
			{	// Client suposed to be disconnected and not dead.
				if (   (m_pClientList[sTargetH] != NULL)
					&& (m_pClientList[sTargetH]->m_bIsKilled == FALSE))
				{	// All Summons will live only 1 minute in ths case
					// other summons will live for standard time				
					m_pNpcList[i]->m_cFollowOwnerType  = DEF_OWNERTYPE_PLAYER_WAITING;	
					m_pNpcList[i]->m_iFollowOwnerIndex = NULL;	
					m_pNpcList[i]->m_dwSummonWaitTime  = timeGetTime();
					m_pNpcList[i]->m_cMoveType		   = DEF_MOVETYPE_RANDOM;
				}
				// Client is dead
				else if ( (m_bIsHeldenianMode == TRUE)
						&& (m_pMapList[m_pNpcList[i]->m_cMapIndex] != NULL)
						&& (m_pMapList[m_pNpcList[i]->m_cMapIndex]->m_bIsHeldenianMap == 1))
				{	switch (m_cHeldenianSummonMode) {
					case 0: // Mode 0, default, Kill the summon
						NpcKilledHandler(NULL, NULL, i, 0);
						break;
					case 1: // Mode 1: Summon will wait for his own master	
						//SetSummonMobAction(iClientH, 2, dwMsgSize - 21, cp);
						m_pNpcList[i]->m_cFollowOwnerType  = DEF_OWNERTYPE_PLAYER_WAITING;	
						m_pNpcList[i]->m_iFollowOwnerIndex = NULL;
						m_pNpcList[i]->m_dwSummonWaitTime  = timeGetTime();
						m_pNpcList[i]->m_cMoveType		   = DEF_MOVETYPE_RANDOM;
						// Summon tries to avenge his master
						if ((iAttackerH != NULL) && (cAttackerType != NULL))
						{	m_pNpcList[i]->m_iSummonControlMode = 0;
							m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
							m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
							m_pNpcList[i]->m_iTargetIndex       = iAttackerH;
							m_pNpcList[i]->m_cTargetType        = cAttackerType;
							m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;
						}
						break;
					case 2: // Mode 3: Summon can be taken over by anybody else
						m_pNpcList[i]->m_cFollowOwnerType  = DEF_OWNERTYPE_PLAYER_FREE;	
						m_pNpcList[i]->m_iFollowOwnerIndex = NULL;			
						ZeroMemory(m_pNpcList[i]->m_cFollowOwnerCharName,sizeof(m_pNpcList[i]->m_cFollowOwnerCharName));
						// Summon tries to avenge his master
						if ((iAttackerH != NULL) && (cAttackerType != NULL))
						{	m_pNpcList[i]->m_iSummonControlMode = 0;
							m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
							m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
							m_pNpcList[i]->m_iTargetIndex       = iAttackerH;
							m_pNpcList[i]->m_cTargetType        = cAttackerType;
							m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;
						}
						break;
					}
				}else //Dead client, not Heldenian
				{	m_pNpcList[i]->m_cFollowOwnerType	= 0;	// No regain control possible
					m_pNpcList[i]->m_iFollowOwnerIndex	= NULL;
					m_pNpcList[i]->m_cMoveType		    = DEF_MOVETYPE_RANDOM;
					m_pNpcList[i]->m_cBehavior			= DEF_BEHAVIOR_MOVE;
					ZeroMemory(m_pNpcList[i]->m_cFollowOwnerCharName,sizeof(m_pNpcList[i]->m_cFollowOwnerCharName));
					// Summon tries to avenge his master
					if ((iAttackerH != NULL) && (cAttackerType != NULL))
					{	m_pNpcList[i]->m_iSummonControlMode = 0;
						m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[i]->m_iTargetIndex       = iAttackerH;
						m_pNpcList[i]->m_cTargetType        = cAttackerType;
						m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;				
				}	}
			}
			// Tamed mobs
			else if ( (m_pNpcList[i]->m_dwTamingTime != 0) // For tamed mobs
					&& (m_pNpcList[i]->m_bIsSummoned		== FALSE)
					&& (m_pNpcList[i]->m_bIsKilled			== FALSE) 
					&& (m_pNpcList[i]->m_cFollowOwnerType	== DEF_OWNERTYPE_PLAYER) 
					&& (m_pNpcList[i]->m_iFollowOwnerIndex	== sTargetH))
			{	// Client suposed to be disconnected and not dead.
				if (   (m_pClientList[sTargetH] != NULL)
					&& (m_pClientList[sTargetH]->m_bIsKilled == FALSE))
				{	// All Summons will live only 1 minute in ths case
					// other summons will live for standard time				
					m_pNpcList[i]->m_cFollowOwnerType  = DEF_OWNERTYPE_PLAYER_WAITING;	
					m_pNpcList[i]->m_iFollowOwnerIndex = NULL;	
					m_pNpcList[i]->m_dwSummonWaitTime  = timeGetTime();
					m_pNpcList[i]->m_cMoveType		   = DEF_MOVETYPE_RANDOM;
				}else// Client is dead
				{	m_pNpcList[i]->m_cFollowOwnerType	= 0;	// No regain control possible
					m_pNpcList[i]->m_iFollowOwnerIndex	= NULL;
					m_pNpcList[i]->m_cMoveType		    = DEF_MOVETYPE_RANDOM;
					m_pNpcList[i]->m_cBehavior			= DEF_BEHAVIOR_MOVE;
					ZeroMemory(m_pNpcList[i]->m_cFollowOwnerCharName,sizeof(m_pNpcList[i]->m_cFollowOwnerCharName));				
					// Summon tries to avenge his master
					if ((iAttackerH != NULL) && (cAttackerType != NULL))
					{	m_pNpcList[i]->m_iSummonControlMode = 0;
						m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[i]->m_iTargetIndex       = iAttackerH;
						m_pNpcList[i]->m_cTargetType        = cAttackerType;
						m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;
	}	}	}	}	}

	// Stop attack the disapeared/dead/teleported/deco target
	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) 
	{	if (   (m_pNpcList[i]->m_iTargetIndex == sTargetH)  
			&& (m_pNpcList[i]->m_cTargetType == cTargetType)) 			
		{	switch (iCode) { 
			case DEF_MAGICTYPE_INVISIBILITY:
				if (m_pNpcList[i]->m_cSpecialAbility != 1) 
				{	m_pNpcList[i]->m_cBehavior	  = DEF_BEHAVIOR_MOVE;
					m_pNpcList[i]->m_iTargetIndex = NULL;
					m_pNpcList[i]->m_cTargetType  = NULL;
				}
				break;
			case DEF_MAGICTYPE_TELEPORT:
			default:
				m_pNpcList[i]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
				m_pNpcList[i]->m_iTargetIndex = NULL;
				m_pNpcList[i]->m_cTargetType  = NULL;
				break;
	}	}	}
}

void CGame::NpcKilledHandler(short sAttackerH, char cAttackerType, int iNpcH, short sDamage)
{
 short  sAttackerWeapon;
 int    * ip, i, iQuestIndex, iConstructionPoint, iWarContribution, iMapIndex;
 double dTmp1, dTmp2, dTmp3;
 char   * cp, cData[120], cQuestRemain;
 unsigned long iExp;

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	m_pNpcList[iNpcH]->m_bIsKilled = TRUE;
	m_pNpcList[iNpcH]->m_iHP = 0;
	m_pNpcList[iNpcH]->m_iLastDamage = sDamage;

	//    . 
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--;

	//   NPC    .
	RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);

	//   NPC   NPC  . 
	ReleaseFollowMode(iNpcH); 

	m_pNpcList[iNpcH]->m_cFollowOwnerType  = NULL; // Snoopy's add
	m_pNpcList[iNpcH]->m_iFollowOwnerIndex = NULL; // Snoopy's add

	//      .
	m_pNpcList[iNpcH]->m_iTargetIndex = NULL;
	m_pNpcList[iNpcH]->m_cTargetType  = NULL;
	//   .
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);	
	}
	else sAttackerWeapon = 1;
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
	//   .
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	//    .
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	//  NPC   . 
	m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_DEAD;
	
	//   .
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	//    
	m_pNpcList[iNpcH]->m_dwDeadTime = timeGetTime();

	//      .
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;
	
	// v1.42   .
	NpcDeadItemGenerator(iNpcH, sAttackerH, cAttackerType);

	//    .
	// NPC           . 
	if ( (m_pNpcList[iNpcH]->m_bIsSummoned != TRUE) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && 
		 (m_pClientList[sAttackerH] != NULL) ) {
		// NPC    ExpStock . 
		//      .	   .
		iExp = (m_pNpcList[iNpcH]->m_iExp/3);
		if (m_pNpcList[iNpcH]->m_iNoDieRemainExp > 0)
			iExp += m_pNpcList[iNpcH]->m_iNoDieRemainExp;

		//v1.42   
		if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
			dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
			dTmp2 = (double)iExp;
			dTmp3 = (dTmp1/100.0f)*dTmp2;
			iExp += (int)dTmp3;
		}

		if (m_pNpcList[iNpcH]->m_sType == 81) {
			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] != NULL) {		
				SendNotifyMsg(sAttackerH, i, DEF_NOTIFY_ABADDONKILLED, NULL, NULL, NULL, NULL,NULL,NULL,NULL,NULL,NULL,NULL, NULL);		
				}
			}
		}

		//         1/3
		if (m_bIsCrusadeMode == TRUE) {
			if (iExp > 10) iExp = iExp/3;
		}

		// New 09/05/2004
		GetExp(sAttackerH, iExp, TRUE);

		// Quest  .
		iQuestIndex = m_pClientList[sAttackerH]->m_iQuest;
		if (iQuestIndex != NULL) {
			if (m_pQuestConfigList[iQuestIndex] != NULL) {
				switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
				case DEF_QUESTTYPE_MONSTERHUNT:
					if ( (m_pClientList[sAttackerH]->m_bQuestMatchFlag_Loc == TRUE) &&
						 (m_pQuestConfigList[iQuestIndex]->m_iTargetType == m_pNpcList[iNpcH]->m_sType) ) {
						//  .   .
						m_pClientList[sAttackerH]->m_iCurQuestCount++;
						cQuestRemain = (m_pQuestConfigList[m_pClientList[sAttackerH]->m_iQuest]->m_iMaxCount - m_pClientList[sAttackerH]->m_iCurQuestCount);
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);
						_bCheckIsQuestCompleted(sAttackerH);
					}
					break;
				}
			}
		}
	}

	// v1.41     
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		switch (m_pNpcList[iNpcH]->m_sType) {
		case 32:
			//  .    . 
			m_pClientList[sAttackerH]->m_iRating -= 5;
			// MORLA 2.4 - Actualizo la rep
			SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_REPDGDEATHS, m_pClientList[sAttackerH]->m_iDGPoints, m_pClientList[sAttackerH]->m_iDeaths, m_pClientList[sAttackerH]->m_iRating, NULL);
			break;

		case 33:
			break;
		}
	}

	if(m_pNpcList[iNpcH]->m_sType == 91) // Remove bloqued area
	{	for(short sx1 = (m_pNpcList[iNpcH]->m_sX - 1); sx1 <= m_pNpcList[iNpcH]->m_sX + 1; sx1++)
		for(short sy1 = (m_pNpcList[iNpcH]->m_sY - 1); sy1 <= m_pNpcList[iNpcH]->m_sY + 1; sy1++)
		{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetTempMoveAllowedFlag(sx1, sy1, TRUE);	
	}	}

	if (m_bIsCrusadeMode == TRUE){ 
	// Crusade
	iConstructionPoint = 0;
	switch (m_pNpcList[iNpcH]->m_sType) {
	//  .  ,   
	case 1:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 2:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 3:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 4:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 5:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 6:  iConstructionPoint = 50; iWarContribution = 100; break;	// 
	case 36: iConstructionPoint = 700; iWarContribution = 4000; break;	//    
	case 37: iConstructionPoint = 700; iWarContribution = 4000; break;	//   
	case 38: iConstructionPoint = 500; iWarContribution = 2000; break;	//  
	case 39: iConstructionPoint = 500; iWarContribution = 2000; break;	// 
	case 40: iConstructionPoint = 1500; iWarContribution = 5000; break;	//   
	case 41: iConstructionPoint = 5000; iWarContribution = 10000; break;	//   
	case 43: iConstructionPoint =  500; iWarContribution = 1000; break;	//   
	case 44: iConstructionPoint = 1000; iWarContribution = 2000; break;	//   
	case 45: iConstructionPoint = 1500; iWarContribution = 3000; break;	//   
	case 46: iConstructionPoint = 1000; iWarContribution = 2000; break;	//  
	case 47: iConstructionPoint = 1500; iWarContribution = 3000; break;	//  
	case 64: m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCropsTotalSum(); break;

	}
	
	// Crusade
	if (iConstructionPoint != NULL) {
		switch (cAttackerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
				//     .
				m_pClientList[sAttackerH]->m_iConstructionPoint += iConstructionPoint;

				if (m_pClientList[sAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[sAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				m_pClientList[sAttackerH]->m_iWarContribution   += iWarContribution;
				if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				//testcode
				wsprintf(G_cTxt, "Enemy Npc Killed by player! Construction: +%d WarContribution: +%d", iConstructionPoint, iWarContribution);
				PutLogList(G_cTxt);

				SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
			}
			else {
				//  NPC    2 .
				m_pClientList[sAttackerH]->m_iWarContribution   -= (iWarContribution*2);
				if (m_pClientList[sAttackerH]->m_iWarContribution < 0)
					m_pClientList[sAttackerH]->m_iWarContribution = 0;

				//testcode
				wsprintf(G_cTxt, "Friendly Npc Killed by player! WarContribution: -%d", iWarContribution);
				PutLogList(G_cTxt);

				SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
			}
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sAttackerH]->m_iGuildGUID != NULL) {
				if (m_pNpcList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
					//      NPC .  .
					//      .    .
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[sAttackerH]->m_iGuildGUID) &&
						(m_pClientList[i]->m_iCrusadeDuty == 3)) {
						
						m_pClientList[i]->m_iConstructionPoint += iConstructionPoint;
						if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
							m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

						//testcode
						wsprintf(G_cTxt, "Enemy Npc Killed by Npc! Construct point +%d", iConstructionPoint);
						PutLogList(G_cTxt);
						//   .
						SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
						goto NKH_GOTOPOINT1;
					}
				
					//   .     .
					ZeroMemory(cData, sizeof(cData));
					cp = (char *)cData;
					*cp = GSM_CONSTRUCTIONPOINT;
					cp++;
					ip = (int*)cp;
					*ip = m_pNpcList[sAttackerH]->m_iGuildGUID;
					cp += 4;
					ip = (int*)cp;
					*ip = iConstructionPoint;
					cp += 4;
					bStockMsgToGateServer(cData, 9);
				}
			}
			break;
		}
	}
	}

	// new - heldenian
	if ((m_bIsHeldenianMode == TRUE) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide)) {
		switch (m_pNpcList[iNpcH]->m_sType) {
			case 82:  iWarContribution = 1000; break;
			case 83:  iWarContribution = 1000; break;
			case 84:  iWarContribution = 1000; break;
			case 85:  iWarContribution = 1000; break;
			case 86:  iWarContribution = 1000; break;
			case 87:  iWarContribution = 1000; break;
			case 88:  iWarContribution = 1000; break;
			case 89:  iWarContribution = 1000; break;
		}
		if (iWarContribution > 0) m_pClientList[sAttackerH]->m_iWarContribution += iWarContribution;
		if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION) m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;
		SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, 0, m_pClientList[sAttackerH]->m_iWarContribution, 1, 0, 0, 0);
	}

NKH_GOTOPOINT1:;

	// v1.411  Explosive    Explosive
	if (m_pNpcList[iNpcH]->m_cSpecialAbility == 7) {
		m_pNpcList[iNpcH]->m_iMana = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 30); 
	}
	else if (m_pNpcList[iNpcH]->m_cSpecialAbility == 8) {
		m_pNpcList[iNpcH]->m_iMana = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 61); 
	}
	// new spawns boss when no monsters exist and apocalypse zone == 2
	if ((m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject == 0) && 
		(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType  == 2)) {
		MobBossGenerator(m_pNpcList[iNpcH]->m_cMapIndex);
	}
	// if boss mob is killed and zone is RecallImpossible, recall all people inside place
	if (m_pNpcList[iNpcH]->m_bIsBossMob == TRUE) {
		iMapIndex = NULL;
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		iMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (iMapIndex >= 0) && (iMapIndex < DEF_MAXMAPS) && (m_pMapList[iMapIndex] != NULL) && (m_pMapList[iMapIndex]->m_bIsRecallImpossible == TRUE)) {
				m_pClientList[i]->m_iTimeLeft_ForceRecall = 200;
				m_pClientList[i]->m_bIsImpossibleZone = TRUE;
				SendNotifyMsg(NULL, i, DEF_NOTIFY_FORCERECALLTIME,  m_pClientList[i]->m_iTimeLeft_ForceRecall , NULL, NULL, NULL);
		}
	}
	if (   (m_bIsHeldenianMode == TRUE) && (m_cHeldenianType == 1) 
		&& (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) ) 
	{	if ((m_pNpcList[iNpcH]->m_sType == 87) || (m_pNpcList[iNpcH]->m_sType == 89)) 
		{	if (m_pNpcList[iNpcH]->m_cSide == 1) 
			{	m_iHeldenianAresdenLeftTower--;
				if (m_cHeldenianFirstDestroyedTowerWinner == 0)  m_cHeldenianFirstDestroyedTowerWinner = 2;
				wsprintf(G_cTxt, "Aresden Tower Broken, Left TOWER %d", m_iHeldenianAresdenLeftTower);
				PutLogList(G_cTxt);
				UpdateHeldenianStatus(-1);
				if (m_iHeldenianAresdenLeftTower == 0)	HeldenianVictoryNow(2);				
			}else if (m_pNpcList[iNpcH]->m_cSide == 2) 
			{	m_iHeldenianElvineLeftTower--;
				if (m_cHeldenianFirstDestroyedTowerWinner == 0)  m_cHeldenianFirstDestroyedTowerWinner = 1;
				wsprintf(G_cTxt, "Elvine Tower Broken, Left TOWER %d", m_iHeldenianElvineLeftTower);
				PutLogList(G_cTxt);
				UpdateHeldenianStatus(-1);
				if (m_iHeldenianElvineLeftTower == 0)	HeldenianVictoryNow(1);	
	}	}	}
}

int CGame::iGetDangerValue(int iNpcH, short dX, short dY)
{
 int ix, iy, iDangerValue;
 short sOwner, sDOType;
 char  cOwnerType;
 DWORD dwRegisterTime;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;

	iDangerValue = 0;

	for (ix = dX - 2; ix <= dX + 2; ix++)
	for (iy = dY - 2; iy <= dY + 2; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);	
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bGetDynamicObject( ix, iy, &sDOType, &dwRegisterTime );
		
		if (sDOType == 1) iDangerValue++;

		switch (cOwnerType) {
		case NULL:
			break;
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwner] == NULL) break;
			if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[sOwner]->m_cSide) 
				 iDangerValue++;
			else iDangerValue--;
			break;
		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwner] == NULL) break;
			if (m_pNpcList[iNpcH]->m_cSide != m_pNpcList[sOwner]->m_cSide) 
				 iDangerValue++;
			else iDangerValue--;
			break;
		}
	}

	return iDangerValue;
}

void CGame::NpcBehavior_Flee(int iNpcH)
{
 char cDir;
 short sX, sY, dX, dY;
 short sTarget;
 char  cTargetType;

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	//   . 
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;

	//    .
	switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
	case DEF_ATTACKAI_EXCHANGEATTACK: //  ->  -> ... 
	case DEF_ATTACKAI_TWOBYONEATTACK: //  ->  ->  -> ...
		if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 2) {
			//    .
			m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			return;
		}
		break;
	
	default:
		if (iDice(1,2) == 1) NpcRequestAssistance(iNpcH);
		break;
	}

	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 10) {
		// 10      .
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
		m_pNpcList[iNpcH]->m_tmp_iError         = 0;
		if (m_pNpcList[iNpcH]->m_iHP <= 3) {
			m_pNpcList[iNpcH]->m_iHP += iDice(1, m_pNpcList[iNpcH]->m_iHitDice); // !       .
			if (m_pNpcList[iNpcH]->m_iHP <= 0) m_pNpcList[iNpcH]->m_iHP = 1;
		}
		return;
	}

	//      .
	TargetSearch(iNpcH, &sTarget, &cTargetType);				
	if (sTarget != NULL) {
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
	}

	//    .   .
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	case DEF_OWNERTYPE_NPC:
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}
	dX = sX - (dX - sX);
	dY = sY - (dY - sY);

	cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
	if (cDir == 0) {
		//   . 
	}
	else {
		dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
		dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
		//   . 
		//   . 
		// new 1x1, 2x2, 3x3 npc flee
		if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
		}
		else {
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetBigOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY, m_pNpcList[iNpcH]->m_sAreaSize);
		}
		m_pNpcList[iNpcH]->m_sX   = dX;
		m_pNpcList[iNpcH]->m_sY   = dY;
		m_pNpcList[iNpcH]->m_cDir = cDir;
		SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
	}
}

void CGame::MsgProcess()
{
 char   * pData, cFrom, cKey;
 char cGSReg[200];
 DWORD    dwMsgSize, * dwpMsgID;
 WORD   * wpMsgType, * wp;
 int      i, iClientH;
 char   m_msgBuff[1000];

 char *cp, cData[120];
DWORD dwTime = timeGetTime();
DWORD * dwp, dwTimeRcv;
	char cBuffer[256];
	int iRet;

	ZeroMemory(cBuffer, 256);
	
	if ((m_bF5pressed == TRUE) && (m_bF1pressed == TRUE)) {
		PutLogList("(XXX) RELOADING CONFIGS MANUALY...");
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i);
				}
				bInit();
		}

	if ((m_bF1pressed == TRUE) && (m_bF4pressed == TRUE) && (m_bOnExitProcess == FALSE)) {
		//        . 
		m_cShutDownCode      = 2;
		m_bOnExitProcess     = TRUE;
		m_dwExitProcessTime  = timeGetTime();
		//        . 
		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Local command)!!!");
		//       . 
		bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
		// OccupyFlag   

		
		return;
	}
	
	ZeroMemory(m_pMsgBuffer, DEF_MSGBUFFERSIZE+1);
	pData = (char *)m_pMsgBuffer;

	m_iCurMsgs = 0;
	while (bGetMsgQuene(&cFrom, pData, &dwMsgSize, &iClientH, &cKey) == TRUE) {
		
		m_iCurMsgs++;
		if (m_iCurMsgs > m_iMaxMsgs) m_iMaxMsgs = m_iCurMsgs;

		switch (cFrom) {
#ifdef DEF_DBGAMESERVER
		case DEF_MSGFROM_LOGSERVER:
			dwpMsgID   = (DWORD *)(pData + DEF_INDEX4_MSGID);
			wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

			switch (*dwpMsgID) {
			
			
			
			case MSGID_SERVERSTOCKMSG:
				ServerStockMsgHandler(pData);
				break;

			case MSGID_PARTYOPERATION:
				PartyOperationResultHandler(pData);
				break;

			case MSGID_SENDSERVERSHUTDOWNMSG:
				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
				switch (*wp) {
				case 1:
					PutLogList("(!) Send server shutdown announcement - 1.");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
					}
					break;

				case 2:
					PutLogList("(!) Send server shutdown announcement - 2.");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
					}
					break;
				}

				bSendMsgToLS(MSGID_SENDSERVERSHUTDOWNMSG, NULL, NULL);
				break;

			case MSGID_GAMESERVERSHUTDOWNED:
				m_cShutDownCode      = 1;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Global command)!!!");
				bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
				
				break;

			case MSGID_TOTALGAMESERVERCLIENTS:
				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
				m_iTotalClients = (int)*wp;
				if (m_iTotalClients > m_iMaxClients)
					m_iMaxClients = m_iTotalClients;
				break;
			
			case MSGID_REQUEST_CHECKACCOUNTPASSWORD:
				RequestCheckAccountPasswordHandler(pData, dwMsgSize);
				break;
			
			case MSGID_REQUEST_FORCEDISCONECTACCOUNT:
				wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
				ForceDisconnectAccount((char *)(pData + DEF_INDEX2_MSGTYPE + 2), *wpMsgType);
				break;
			
			case MSGID_RESPONSE_SAVEPLAYERDATA_REPLY:
				ResponseSavePlayerDataReplyHandler(pData, dwMsgSize);
				break;
			
			case MSGID_GUILDNOTIFY:
				GuildNotifyHandler(pData, dwMsgSize);
				break;
			
			case MSGID_RESPONSE_DISBANDGUILD:
				ResponseDisbandGuildHandler(pData, dwMsgSize);
				break;

			case MSGID_RESPONSE_CREATENEWGUILD:
				ResponseCreateNewGuildHandler(pData, dwMsgSize);
				break;
			
			case MSGID_RESPONSE_REGISTERGAMESERVER:
				switch (*wpMsgType) {
				case DEF_MSGTYPE_CONFIRM:
                    GSID = bGetOffsetValue(pData, 6);
                    ZeroMemory(cGSReg, sizeof(cGSReg));
					wsprintf(cGSReg,"(!) Game Server registration to Log Server - Success! GSID[%u]",GSID);
				    PutLogList(cGSReg);
					m_bIsGameServerRegistered = TRUE;
					break;

				case DEF_MSGTYPE_REJECT:
					PutLogList("(!) Game Server registration to Log Server - Fail!");
					break;
				}
				if(ReceivedAllConfig) break;

				if (m_bIsBuildItemAvailable == FALSE) {
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Build-Item configuration error.");
				}

				if (m_bIsItemAvailable == FALSE) {
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Item configuration error.");
				}

				if (m_bIsNpcAvailable == FALSE) {
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Npc configuration error.");
				}

				if (m_bIsMagicAvailable == FALSE) {
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! MAGIC configuration error.");
				}

				if (m_bIsSkillAvailable == FALSE) {
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! SKILL configuration error.");
				}

				if (m_bIsQuestAvailable == FALSE) {
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! QUEST configuration error.");
				}

				if (m_bIsPotionAvailable == FALSE) {
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! POTION configuration error.");
				}

				ReceivedAllConfig = TRUE;

				break;

			case MSGID_RESPONSE_PLAYERDATA:
				ResponsePlayerDataHandler(pData, dwMsgSize);
				break;

			case MSGID_BUILDITEMCONFIGURATIONCONTENTS:
				PutLogList("(!) BUILD-ITEM configuration contents received. Now decoding...");
				m_bIsBuildItemAvailable = _bDecodeBuildItemConfigFileContents((char *)(pData + 6), dwMsgSize-6);
				break;
			
			case MSGID_ITEMCONFIGURATIONCONTENTS:
				PutLogList("(!) ITEM configuration contents received. Now decoding...");
				m_bIsItemAvailable = _bDecodeItemConfigFileContents((char *)(pData + 6), dwMsgSize-6);
				break;

			case MSGID_NPCCONFIGURATIONCONTENTS:
				PutLogList("(!) NPC configuration contents received. Now decoding...");
				m_bIsNpcAvailable = _bDecodeNpcConfigFileContents((char *)(pData + 6), dwMsgSize-6);
				break;
			
			case MSGID_MAGICCONFIGURATIONCONTENTS:
				PutLogList("(!) MAGIC configuration contents received. Now decoding...");
				m_bIsMagicAvailable = _bDecodeMagicConfigFileContents((char *)(pData + 6), dwMsgSize-6);
				break;

			case MSGID_SKILLCONFIGURATIONCONTENTS:
				PutLogList("(!) SKILL configuration contents received. Now decoding...");
				m_bIsSkillAvailable = _bDecodeSkillConfigFileContents((char *)(pData + 6), dwMsgSize-6);
				break;

			case MSGID_QUESTCONFIGURATIONCONTENTS:
				PutLogList("(!) QUEST configuration contents received. Now decoding...");
				m_bIsQuestAvailable = _bDecodeQuestConfigFileContents((char *)(pData + 6), dwMsgSize-6);
				break;

			case MSGID_POTIONCONFIGURATIONCONTENTS:
				PutLogList("(!) POTION configuration contents received. Now decoding...");
				m_bIsPotionAvailable = _bDecodePotionConfigFileContents((char *)(pData + 6), dwMsgSize-6);
				break;

			case MSGID_DUPITEMIDFILECONTENTS:
				PutLogList("(!) DupItemID file contents received. Now decoding...");
				_bDecodeDupItemIDFileContents((char *)(pData + 6), dwMsgSize-6);
				break;

			case MSGID_NOTICEMENTFILECONTENTS:
				PutLogList("(!) Noticement file contents received. Now decoding...");
				_bDecodeNoticementFileContents((char *)(pData + 6), dwMsgSize-6);
				break;

			// v2.17 2002-8-7 // 2002-09-06 #1
			case MSGID_NPCITEMCONFIGCONTENTS:
				PutLogList("(!) NpcItemConfig file contents received. Now decoding...");
				_bDecodeNpcItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize-6);
				break;

			}
			break;
#else
		case DEF_MSGFROM_GATESERVER:
			dwpMsgID   = (DWORD *)(pData + DEF_INDEX4_MSGID);
			wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
			switch (*dwpMsgID) {
			case MSGID_PARTYOPERATION:
				PartyOperationResultHandler(pData);
				break;

			case MSGID_SERVERSTOCKMSG:
				ServerStockMsgHandler(pData);
				break;
									
			case MSGID_SENDSERVERSHUTDOWNMSG:
				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
				switch (*wp) {
				case 1:
					PutLogList("(!) Send server shutdown announcement - 1.");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
					}
					break;
				case 2:
					PutLogList("(!) Send server shutdown announcement - 2.");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
					}
					break;
				}
				bSendMsgToLS(MSGID_SENDSERVERSHUTDOWNMSG, NULL, NULL); 
				break;
			
			case MSGID_GAMESERVERSHUTDOWNED:
				m_cShutDownCode      = 1;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Global command)!!!");
				bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
				
				break;
			
			case MSGID_TOTALGAMESERVERCLIENTS:
				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
				m_iTotalGameServerClients = (int)*wp;
				if (m_iTotalGameServerClients > m_iTotalGameServerMaxClients) 
					m_iTotalGameServerMaxClients = m_iTotalGameServerClients;
				break;
			
			case MSGID_RESPONSE_REGISTERGAMESERVER:
				switch (*wpMsgType) {
				case DEF_MSGTYPE_CONFIRM:
					PutLogList("(!) Game Server registration to Gate Server - Success!");
					m_bIsGateSockAvailable = TRUE;
					//50Cent - HG start process fix
                    bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
					break;

				case DEF_MSGTYPE_REJECT:
					PutLogList("(!) Game Server registration to Gate Server - Fail!");
					PutLogList(" ");
					PutLogList("(!!!) STOPPED!");
					break;
				}
				break;
			}
			break;

		case DEF_MSGFROM_LOGSERVER:
			dwpMsgID   = (DWORD *)(pData + DEF_INDEX4_MSGID);
			wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

			switch (*dwpMsgID) {
			case MSGID_REQUEST_CHECKACCOUNTPASSWORD:
				//    
				RequestCheckAccountPasswordHandler(pData, dwMsgSize);
				break;
			
			case MSGID_REQUEST_FORCEDISCONECTACCOUNT:
				//    .    . 
				wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
				ForceDisconnectAccount((char *)(pData + DEF_INDEX2_MSGTYPE + 2), *wpMsgType);
				break;
			
			case MSGID_RESPONSE_SAVEPLAYERDATA_REPLY:
				//      
				ResponseSavePlayerDataReplyHandler(pData, dwMsgSize);
				break;
			
			case MSGID_GUILDNOTIFY:
				//       ( ,  ,   )
				GuildNotifyHandler(pData, dwMsgSize);
				break;
			
			case MSGID_RESPONSE_DISBANDGUILD:
				//     
				ResponseDisbandGuildHandler(pData, dwMsgSize);
				break;

			case MSGID_RESPONSE_CREATENEWGUILD:
				//     . 
				ResponseCreateNewGuildHandler(pData, dwMsgSize);
				break;
			
			case MSGID_RESPONSE_REGISTERGAMESERVER:
				switch (*wpMsgType) {
				case DEF_MSGTYPE_CONFIRM:
					PutLogList("(!) Game Server registration to Log Server - Success!");
					m_bIsLogSockAvailable = TRUE;
					break;

				case DEF_MSGTYPE_REJECT:
					PutLogList("(!) Game Server registration to Log Server - Fail!");
					break;
				}
		
				if (m_bIsBuildItemAvailable == FALSE) {
					//           .
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Build-Item configuration error.");
				}
								
				if (m_bIsItemAvailable == FALSE) {
					//           .
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Item configuration error.");
				}
				
				if (m_bIsNpcAvailable == FALSE) {
					//           .
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Npc configuration error.");
				}

				if (m_bIsMagicAvailable == FALSE) {
					//  MAGIC         .
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! MAGIC configuration error.");
				}

				if (m_bIsSkillAvailable == FALSE) {
					//  SKILL         .
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! SKILL configuration error.");
				}

				if (m_bIsQuestAvailable == FALSE) {
					//  SKILL         .
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! QUEST configuration error.");
				}

				if (m_bIsPotionAvailable == FALSE) {
					//  Potion         .
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! POTION configuration error.");
				}
				break;

			case MSGID_RESPONSE_PLAYERDATA:
				//   . 
				ResponsePlayerDataHandler(pData, dwMsgSize);
				break;

			case MSGID_BUILDITEMCONFIGURATIONCONTENTS:
				// Build Item contents
				PutLogList("(!) BUILD-ITEM configuration contents received. Now decoding...");
				m_bIsBuildItemAvailable = _bDecodeBuildItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			
			case MSGID_ITEMCONFIGURATIONCONTENTS:
				//     .
				PutLogList("(!) ITEM configuration contents received. Now decoding...");
				m_bIsItemAvailable = _bDecodeItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NPCCONFIGURATIONCONTENTS:
				// NPC   . 
				PutLogList("(!) NPC configuration contents received. Now decoding...");
				m_bIsNpcAvailable = _bDecodeNpcConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			
			case MSGID_MAGICCONFIGURATIONCONTENTS:
				PutLogList("(!) MAGIC configuration contents received. Now decoding...");
				m_bIsMagicAvailable = _bDecodeMagicConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_SKILLCONFIGURATIONCONTENTS:
				PutLogList("(!) SKILL configuration contents received. Now decoding...");
				m_bIsSkillAvailable = _bDecodeSkillConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_QUESTCONFIGURATIONCONTENTS:
				PutLogList("(!) QUEST configuration contents received. Now decoding...");
				m_bIsQuestAvailable = _bDecodeQuestConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_POTIONCONFIGURATIONCONTENTS:
				PutLogList("(!) POTION configuration contents received. Now decoding...");
				m_bIsPotionAvailable = _bDecodePotionConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			

			case MSGID_DUPITEMIDFILECONTENTS:
				PutLogList("(!) DupItemID file contents received. Now decoding...");
				_bDecodeDupItemIDFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NOTICEMENTFILECONTENTS:
				PutLogList("(!) Noticement file contents received. Now decoding...");
				_bDecodeNoticementFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			// v2.17 2002-8-7 // 2002-09-06 #1
			case MSGID_NPCITEMCONFIGCONTENTS:
				PutLogList("(!) NpcItemConfig file contents received. Now decoding...");
				_bDecodeNpcItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			}
			break;
#endif
		
		case DEF_MSGFROM_CLIENT:

			dwpMsgID = (DWORD *)(pData + DEF_INDEX4_MSGID);
			switch (*dwpMsgID) { // 84148741

			case MSGID_REQUEST_ONLINE:
				
				if (m_pClientList[iClientH])
					RequestOnlines(m_pClientList[iClientH]); //no necesitamos la data
				break;

			case MSGID_REQUEST_PING:
				
				//Change ping response

				if (m_pClientList[iClientH] == NULL) return;

				cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
				dwp = (DWORD *)cp;
				dwTimeRcv = *dwp;

				dwp = (DWORD *)(cBuffer + DEF_INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_PING;
				wp  = (WORD *)(cBuffer + DEF_INDEX2_MSGTYPE);
				*wp = NULL;

				cp = (char *)(cBuffer + DEF_INDEX2_MSGTYPE + 2);
				dwp = (DWORD *)cp;
				*dwp = dwTimeRcv;
				cp += 4;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cBuffer, 10);
				break;

			case DEF_REQUEST_ANGEL: // Angels by Snoopy...
				GetAngelHandler(iClientH, pData, dwMsgSize);
				break;
						
			case MSGID_REQUEST_INITPLAYER:
				RequestInitPlayerHandler(iClientH, pData, cKey);
				break;

			case MSGID_REQUEST_INITDATA:
				// Anti Bump 
                if (m_pClientList[iClientH]->m_bIsClientConnected == TRUE) {
                    if (m_pClientList[iClientH] == NULL) break;
                    wsprintf(G_cTxt, "(!!!) Client (%s) connection closed!. Sniffer suspect!.", m_pClientList[iClientH]->m_cCharName);
                    PutLogList(G_cTxt);
                    ZeroMemory(cData, sizeof(cData));
                    cp  = (char *)cData;
                    *cp = GSM_DISCONNECT;
                    cp++;
                    memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
                    cp += 10;
                    bStockMsgToGateServer(cData, 11);
                    m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
                    bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, NULL);
                    bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, FALSE);
                    if ((dwTime - m_dwGameTime2) > 3000) { // 3 segs
                        m_pClientList[iClientH]->m_bIsClientConnected = FALSE;
                        m_iTotalClients--;
                        delete m_pClientList[iClientH];
                        m_pClientList[iClientH] = NULL;
                    }
                    break;
				}
                else {
                    m_pClientList[iClientH]->m_bIsClientConnected = TRUE;
                    RequestInitDataHandler(iClientH, pData, cKey, FALSE);
                }
				break;

			case MSGID_COMMAND_CHECKCONNECTION:
				CheckConnectionHandler(iClientH, pData);
				break;

			case DEF_REQUEST_RESURRECTPLAYER_YES:
				RequestResurrectPlayer(iClientH, TRUE);
				break;

			case DEF_REQUEST_RESURRECTPLAYER_NO:
				RequestResurrectPlayer(iClientH, FALSE);
				break;

			case MSGID_REQUEST_SELLITEMLIST:
				RequestSellItemListHandler(iClientH, pData);
				break;
			
			case MSGID_REQUEST_RESTART:
				RequestRestartHandler(iClientH);
				break;

			case MSGID_REQUEST_PANNING:
				iRequestPanningMapDataRequest(iClientH, pData);
				break;

			case MSGID_REQUEST_NOTICEMENT:
				RequestNoticementHandler(iClientH, pData);
				break;
			
			case MSGID_BWM_COMMAND_SHUTUP:
				_BWM_Command_Shutup(pData);
				break;
			
			case MSGID_BWM_INIT:
				_BWM_Init(iClientH, pData);
				break;
			
			case MSGID_REQUEST_SETITEMPOS:
				_SetItemPos(iClientH, pData);
				break;
			
			case MSGID_ADMINUSER:
				break;
			
			case MSGID_REQUEST_FULLOBJECTDATA:
				RequestFullObjectData(iClientH, pData);
				break;
			
			case MSGID_REQUEST_RETRIEVEITEM:
				RequestRetrieveItemHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_CIVILRIGHT:
				RequestCivilRightHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_TELEPORT:
				RequestTeleportHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_COMMON:
				ClientCommonHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_MOTION:
				ClientMotionHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_CHATMSG:
				ChatMsgHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_CREATENEWGUILD:
				RequestCreateNewGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_DISBANDGUILD:
				RequestDisbandGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_FIGHTZONE_RESERVE:
				FightzoneReserveHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_LEVELUPSETTINGS:
				LevelUpSettingsHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_STATECHANGEPOINT:
				StateChangeHandler(iClientH, pData, dwMsgSize);
				break;



			case MSGID_REQUEST_HELDENIAN_TP_LIST:	// 0x0EA03206
				
				RequestHeldenianTeleportList(iClientH, pData, dwMsgSize);
				break;
			case MSGID_REQUEST_HELDENIAN_TP:		// 0x0EA03208
				
				RequestHeldenianTeleportNow(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_HELDENIAN_SCROLL:
				
				RequestHeldenianScroll(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_TELEPORT_LIST:
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden",7) == 0 ) {
					  RequestTeleportHandler(iClientH, "2   ", "dglv2", 263, 258);
				}
				else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine",6) == 0 ) {
				  RequestTeleportHandler(iClientH, "2   ", "dglv2", 209, 258);
				}
				break;
				
			// Centuu: "Do you really wanna change city?"
			case DEF_REQUEST_CHANGECITY_YES:
				PlayerOrder_ChangeCity(iClientH, TRUE);
				break;
			

			default:
				wsprintf(m_msgBuff,"Unknown message received! (0x%.8X) Delete Client",*dwpMsgID);
				PutLogList(m_msgBuff);
				DeleteClient(iClientH, TRUE, TRUE); // v1.4
				break;
			}	
			break;

		
		}
	}

}


BOOL CGame::bPutMsgQuene(char cFrom, char * pData, DWORD dwMsgSize, int iIndex, char cKey)
{
	
	//      
	if (m_pMsgQuene[m_iQueneTail] != NULL) return FALSE;

	//     
	m_pMsgQuene[m_iQueneTail] = new class CMsg;
	if (m_pMsgQuene[m_iQueneTail] == NULL) return FALSE;

	if (m_pMsgQuene[m_iQueneTail]->bPut(cFrom, pData, dwMsgSize, iIndex, cKey) == FALSE) return FALSE;

	m_iQueneTail++;
	if (m_iQueneTail >= DEF_MSGQUENESIZE) m_iQueneTail = 0;

	

	return TRUE;
}


BOOL CGame::bGetMsgQuene(char * pFrom, char * pData, DWORD * pMsgSize, int * pIndex, char * pKey)
{
	
	//      
	if (m_pMsgQuene[m_iQueneHead] == NULL) return FALSE;

	m_pMsgQuene[m_iQueneHead]->Get(pFrom, pData, pMsgSize, pIndex, pKey);

	delete m_pMsgQuene[m_iQueneHead];
	m_pMsgQuene[m_iQueneHead] = NULL;

	m_iQueneHead++;
	if (m_iQueneHead >= DEF_MSGQUENESIZE) m_iQueneHead = 0;


	return TRUE;
}


void CGame::ClientCommonHandler(int iClientH, char * pData)
{
 WORD * wp, wCommand;
 short * sp, sX, sY; 
 int   * ip, iV1, iV2, iV3, iV4;
 char  * cp, cDir, * pString;
 BOOL bUnused;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;
 
	ip = (int *)cp;
	iV1 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV2 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV3 = *ip;
	cp += 4;

	pString = cp;
	cp += 30;
	
	ip = (int *)cp;
	iV4 = *ip;
	cp += 4;
	
	switch (wCommand) {



	//ZeroEoyPnk - NewMessage
	case DEF_RESQUEST_PARTYHP:
		RefreshPartyStatus(iClientH);
		RefreshPartyCoords(iClientH);
		break;

	// Crafting
	case DEF_COMMONTYPE_CRAFTITEM:
		ReqCreateCraftingHandler(iClientH, pData);
		break;

	case DEF_COMMONTYPE_REQDKSET: // MORLA 2.5 - DK Set
		GetDkSet(iClientH);
		break;

	// New 15/05/2004
	case DEF_COMMONTYPE_REQ_CREATESLATE:
		ReqCreateSlateHandler(iClientH, pData);
		break;

// 2.06 - by KLKS
	case DEF_COMMONTYPE_REQ_CHANGEPLAYMODE:
		RequestChangePlayMode(iClientH);
		break;
//

	case DEF_COMMONTYPE_SETGUILDTELEPORTLOC:
		RequestSetGuildTeleportLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, "middleland");
		break;

	case DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC:
		RequestSetGuildConstructLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;
	
	case DEF_COMMONTYPE_GUILDTELEPORT:
		RequestGuildTeleportHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_SUMMONWARUNIT:
		RequestSummonWarUnitHandler(iClientH, sX, sY, iV1, iV2, iV3);
		break;
	
	case DEF_COMMONTYPE_REQUEST_HELP:
		RequestHelpHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_MAPSTATUS:
		MapStatusHandler(iClientH, iV1, pString);
		break;

	case DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY:
		SelectCrusadeDutyHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQUEST_CANCELQUEST:
		CancelQuestHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY:
		ActivateSpecialAbilityHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_JOINPARTY:
		JoinPartyHandler(iClientH, iV1, pString);
		break;
	
	case DEF_COMMONTYPE_GETMAGICABILITY:
		GetMagicAbilityHandler(iClientH);
		break;

	case DEF_COMMONTYPE_BUILDITEM:
		BuildItemHandler(iClientH, pData);
		break;
	
	case DEF_COMMONTYPE_QUESTACCEPTED:
		QuestAcceptedHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_CANCELEXCHANGEITEM:
		CancelExchangeItem(iClientH);
		break;
	
	case DEF_COMMONTYPE_CONFIRMEXCHANGEITEM:
		ConfirmExchangeItem(iClientH);
		break;
	
	case DEF_COMMONTYPE_SETEXCHANGEITEM:
		SetExchangeItem(iClientH, iV1, iV2);
		break;
	
	case DEF_COMMONTYPE_REQ_GETHEROMANTLE:
		GetHeroMantleHandler(iClientH, iV1, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_GETOCCUPYFLAG:
		GetOccupyFlagHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX:
		SetDownSkillIndexHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_TALKTONPC:
		NpcTalkHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQ_CREATEPOTION:
		ReqCreatePotionHandler(iClientH, pData);
		break;
	
	case DEF_COMMONTYPE_REQ_GETFISHTHISTIME:
		ReqGetFishThisTimeHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM:
		ReqRepairItemCofirmHandler(iClientH, iV1, pString);
		break;

	//50Cent - Repair All
    case DEF_COMMONTYPE_REQ_REPAIRALL:
        RequestRepairAllItemsHandler(iClientH);
        break;
    case DEF_COMMONTYPE_REQ_REPAIRALLDELETE:
        RequestRepairAllItemsDeleteHandler(iClientH, iV1);
        break;
    case DEF_COMMONTYPE_REQ_REPAIRALLCONFIRM:
        RequestRepairAllItemsConfirmHandler(iClientH);
        break;
	
	case DEF_COMMONTYPE_REQ_REPAIRITEM:
		ReqRepairItemHandler(iClientH, iV1, iV2, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_SELLITEMCONFIRM:
		ReqSellItemConfirmHandler(iClientH, iV1, iV2, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_SELLITEM:
		ReqSellItemHandler(iClientH, iV1, iV2, iV3, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_USESKILL:
		UseSkillHandler(iClientH, iV1, iV2, iV3);
		break;
	
	case DEF_COMMONTYPE_REQ_USEITEM:
		UseItemHandler(iClientH, iV1, iV2, iV3, iV4);
		break;
	
	case DEF_COMMONTYPE_REQ_GETREWARDMONEY:
		GetRewardMoneyHandler(iClientH);
		break;

	case DEF_COMMONTYPE_ITEMDROP:
		DropItemHandler(iClientH, iV1, iV2, pString, TRUE);
		break;
	
	case DEF_COMMONTYPE_EQUIPITEM:
		//    .
		bEquipItemHandler(iClientH, iV1);
		//      .
		// .....
		break;

	case DEF_COMMONTYPE_REQ_PURCHASEITEM:
		//   .        .
		RequestPurchaseItemHandler(iClientH, pString, iV1);
		break;

	case DEF_COMMONTYPE_REQ_PURCHASEITEM2:
		RequestPurchaseItemHandler2(iClientH, pString, iV1);
		break;

	case DEF_COMMONTYPE_REQ_STUDYMAGIC:
		//   
		RequestStudyMagicHandler(iClientH, pString, bUnused);
		break;

	case DEF_COMMONTYPE_REQ_TRAINSKILL:
		break;

	case DEF_COMMONTYPE_GIVEITEMTOCHAR:
		//    .
		GiveItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_EXCHANGEITEMTOCHAR:
		ExchangeItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		JoinGuildApproveHandler(iClientH, pString);
		break;
	
	case DEF_COMMONTYPE_JOINGUILDREJECT:
		JoinGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
		DismissGuildApproveHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		DismissGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_RELEASEITEM:
		//    .
		ReleaseItemHandler(iClientH, iV1, TRUE);
		break;

	case DEF_COMMONTYPE_TOGGLECOMBATMODE:
		ToggleCombatModeHandler(iClientH);
		break;

	case DEF_COMMONTYPE_MAGIC:
		PlayerMagicHandler(iClientH, iV1, iV2, (iV3 - 100));
		break;

	case DEF_COMMONTYPE_TOGGLESAFEATTACKMODE:
		ToggleSafeAttackModeHandler(iClientH);
		break;

	// v1.4311-3     
	case DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
		GetFightzoneTicketHandler(iClientH);
		break;

	// Upgrade Item
	case DEF_COMMONTYPE_UPGRADEITEM:
		RequestItemUpgradeHandler(iClientH,iV1);
		break;

	case DEF_COMMONTYPE_REQGUILDNAME:
		RequestGuildNameHandler(iClientH, iV1, iV2);
		break;

	case DEF_COMMONTYPE_REQRANGO: // MORLA 2.2 - Llama al rango del pj
		RequestRango(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_REQTPDG: // MORLA 2.3 - TP Deathmach Game
		if (m_pClientList[iClientH]->m_iLevel > 80) {
			if (bDeathmatch) {
				RequestTeleportHandler(iClientH, "2   ", "fightzone1", -1, -1);
				RefreshDeathmatch(iClientH); // Morla 2.3 - actualiza el deathmach
				m_pClientList[iClientH]->m_iDGKills = 0;
				m_pClientList[iClientH]->m_iDGDeaths = 0;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPDGDEATHS, m_pClientList[iClientH]->m_iDGPoints, m_pClientList[iClientH]->m_iDeaths, m_pClientList[iClientH]->m_iRating, NULL);
			}
			else ShowClientMsg(iClientH, " Deathmatch event is offline.");
		}
		else ShowClientMsg(iClientH, " You need to be higher to level 80.");
		break;

	//50Cent - HP Bar
	case DEF_COMMONTYPE_REQ_GETNPCHP:
		if ((iV1 - 10000 == 0) || (iV1 - 10000 >= DEF_MAXNPCS)) return;
        if (m_pNpcList[iV1 - 10000] == NULL) return;
		if(m_pNpcList[iV1 - 10000]->m_iHP > m_pNpcList[iV1 - 10000]->m_iMaxHP) m_pNpcList[iV1 - 10000]->m_iMaxHP = m_pNpcList[iV1 - 10000]->m_iHP;
		SendNotifyMsg(NULL, iClientH, DEF_SEND_NPCHP, m_pNpcList[iV1 - 10000]->m_iHP, m_pNpcList[iV1 - 10000]->m_iMaxHP, NULL, NULL);
		break;

	case DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY:
		RequestAcceptJoinPartyHandler(iClientH, iV1);
		break;

	default:
		wsprintf(G_cTxt,"Unknown message received! (0x%.8X)",wCommand);
		PutLogList(G_cTxt);
		break;
	}
}

void CGame::RefreshDeathmatch(int iClientH) // MORLA 2.3 - Actualiza los pjs del Deathmach
{
	if (m_pClientList[iClientH] != NULL) {
		if (iClientH == iDGtop1) { iDGtop1 = iDGtop2; m_pClientList[iClientH]->m_iDGKills = 0; m_pClientList[iClientH]->m_iDGDeaths = 0; }
		if (iClientH == iDGtop2) { iDGtop2 = iDGtop3; m_pClientList[iClientH]->m_iDGKills = 0; m_pClientList[iClientH]->m_iDGDeaths = 0; }
		if (iClientH == iDGtop3) { iDGtop3 = iDGtop4; m_pClientList[iClientH]->m_iDGKills = 0; m_pClientList[iClientH]->m_iDGDeaths = 0; }
		if (iClientH == iDGtop4) { iDGtop4 = iDGtop5; m_pClientList[iClientH]->m_iDGKills = 0; m_pClientList[iClientH]->m_iDGDeaths = 0; }
		if (iClientH == iDGtop5) { iDGtop5 = iDGtop6; m_pClientList[iClientH]->m_iDGKills = 0; m_pClientList[iClientH]->m_iDGDeaths = 0; }
		if (iClientH == iDGtop6) { iDGtop6 = iDGtop7; m_pClientList[iClientH]->m_iDGKills = 0; m_pClientList[iClientH]->m_iDGDeaths = 0; }
		if (iClientH == iDGtop7) { iDGtop7 = iDGtop8; m_pClientList[iClientH]->m_iDGKills = 0; m_pClientList[iClientH]->m_iDGDeaths = 0; }
		if (iClientH == iDGtop8) { iDGtop8 = iDGtop9; m_pClientList[iClientH]->m_iDGKills = 0; m_pClientList[iClientH]->m_iDGDeaths = 0; }
		if (iClientH == iDGtop9) { iDGtop9 = iDGtop10; m_pClientList[iClientH]->m_iDGKills = 0; m_pClientList[iClientH]->m_iDGDeaths = 0; }
		if (iClientH == iDGtop10) { iDGtop10 = 0; m_pClientList[iClientH]->m_iDGKills = 0; m_pClientList[iClientH]->m_iDGDeaths = 0; }
	}
	if (iDGtop1 == iDGtop2)
	{iDGtop2 = iDGtop3; iDGtop3 = iDGtop4; iDGtop4 = iDGtop5; iDGtop5 = iDGtop6; iDGtop6 = iDGtop7; iDGtop7 = iDGtop8; iDGtop8 = iDGtop9; iDGtop9 = iDGtop10; iDGtop10 = 0;}
	if (iDGtop2 == iDGtop3)
	{iDGtop3 = iDGtop4; iDGtop4 = iDGtop5; iDGtop5 = iDGtop6; iDGtop6 = iDGtop7; iDGtop7 = iDGtop8; iDGtop8 = iDGtop9; iDGtop9 = iDGtop10; iDGtop10 = 0;}
	if (iDGtop3 == iDGtop4)
	{iDGtop4 = iDGtop5; iDGtop5 = iDGtop6; iDGtop6 = iDGtop7; iDGtop7 = iDGtop8; iDGtop8 = iDGtop9; iDGtop9 = iDGtop10; iDGtop10 = 0;}
	if (iDGtop4 == iDGtop5)
	{iDGtop5 = iDGtop6; iDGtop6 = iDGtop7; iDGtop7 = iDGtop8; iDGtop8 = iDGtop9; iDGtop9 = iDGtop10; iDGtop10 = 0;}
	if (iDGtop5 == iDGtop6)
	{iDGtop6 = iDGtop7; iDGtop7 = iDGtop8; iDGtop8 = iDGtop9; iDGtop9 = iDGtop10; iDGtop10 = 0;}
	if (iDGtop6 == iDGtop7)
	{iDGtop7 = iDGtop8; iDGtop8 = iDGtop9; iDGtop9 = iDGtop10; iDGtop10 = 0;}
	if (iDGtop7 == iDGtop8)
	{iDGtop8 = iDGtop9; iDGtop9 = iDGtop10; iDGtop10 = 0;}
	if (iDGtop8 == iDGtop9)
	{iDGtop9 = iDGtop10; iDGtop10 = 0;
	}

	int i;
	for (i = 1; i < DEF_MAXCLIENTS; i++) // Check all clients
	{
		if (m_pClientList[i] != NULL) {
		
			if (m_pClientList[iDGtop1]!=NULL)SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 1, m_pClientList[iDGtop1]->m_iDGKills, m_pClientList[iDGtop1]->m_iDGDeaths, m_pClientList[iDGtop1]->m_cCharName);
			else SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 1, 0, 0, m_pClientList[i]->m_cCharName);
			if (m_pClientList[iDGtop2]!=NULL)SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 2, m_pClientList[iDGtop2]->m_iDGKills, m_pClientList[iDGtop2]->m_iDGDeaths, m_pClientList[iDGtop2]->m_cCharName);
			else SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 2, 0, 0, m_pClientList[i]->m_cCharName);
			if (m_pClientList[iDGtop3]!=NULL)SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 3, m_pClientList[iDGtop3]->m_iDGKills, m_pClientList[iDGtop3]->m_iDGDeaths, m_pClientList[iDGtop3]->m_cCharName);
			else SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 3, 0, 0, m_pClientList[i]->m_cCharName);
			if (m_pClientList[iDGtop4]!=NULL)SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 4, m_pClientList[iDGtop4]->m_iDGKills, m_pClientList[iDGtop4]->m_iDGDeaths, m_pClientList[iDGtop4]->m_cCharName);
			else SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 4, 0, 0, m_pClientList[i]->m_cCharName);
			if (m_pClientList[iDGtop5]!=NULL)SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 5, m_pClientList[iDGtop5]->m_iDGKills, m_pClientList[iDGtop5]->m_iDGDeaths, m_pClientList[iDGtop5]->m_cCharName);
			else SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 5, 0, 0, m_pClientList[i]->m_cCharName);
			if (m_pClientList[iDGtop6]!=NULL)SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 6, m_pClientList[iDGtop6]->m_iDGKills, m_pClientList[iDGtop6]->m_iDGDeaths, m_pClientList[iDGtop6]->m_cCharName);
			else SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 6, 0, 0, m_pClientList[i]->m_cCharName);
			if (m_pClientList[iDGtop7]!=NULL)SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 7, m_pClientList[iDGtop7]->m_iDGKills, m_pClientList[iDGtop7]->m_iDGDeaths, m_pClientList[iDGtop7]->m_cCharName);
			else SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 7, 0, 0, m_pClientList[i]->m_cCharName);
			if (m_pClientList[iDGtop8]!=NULL)SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 8, m_pClientList[iDGtop8]->m_iDGKills, m_pClientList[iDGtop8]->m_iDGDeaths, m_pClientList[iDGtop8]->m_cCharName);
			else SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 8, 0, 0, m_pClientList[i]->m_cCharName);
			if (m_pClientList[iDGtop9]!=NULL)SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 9, m_pClientList[iDGtop9]->m_iDGKills, m_pClientList[iDGtop9]->m_iDGDeaths, m_pClientList[iDGtop9]->m_cCharName);
			else SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 9, 0, 0, m_pClientList[i]->m_cCharName);
			if (m_pClientList[iDGtop10]!=NULL)SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 10, m_pClientList[iDGtop10]->m_iDGKills, m_pClientList[iDGtop10]->m_iDGDeaths, m_pClientList[iDGtop10]->m_cCharName);
			else SendNotifyMsg(NULL, i, DEF_NOTIFY_DGKILL, 10, 0, 0, m_pClientList[i]->m_cCharName);

		}
	}
}

// New 07/05/2004
void CGame::DropItemHandler(int iClientH, short sItemIndex, int iAmount, char * pItemName, BOOL bByPlayer)
{
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((iAmount != -1) && (iAmount < 0)) return;

	// Amount -1    .
	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		(iAmount == -1) ) 
		iAmount = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount;


	//      
	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) return;

	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		(((int)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount - iAmount) > 0) ) {
			//        
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) {
				//      .      
				delete pItem;
				return;
			}
			else {
				if (iAmount <= 0) {
					//   0  .  
					delete pItem;
					return;
				}
				pItem->m_dwCount = (DWORD)iAmount;
			}

			//   

			// .     . 
			if ((DWORD)iAmount > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount) {
				delete pItem;
				return;
			}

			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;

			//    .
			// v1.41 !!!
			SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);

			//    . 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY, pItem);

			// v1.411       
			// v2.17 2002-7-31      . 
			if ( bByPlayer == TRUE )
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);
			else 
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem, TRUE);

			//      . 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, NULL);
		}
	else {
		//      .

		//    .

		ReleaseItemHandler(iClientH, sItemIndex, TRUE);

		// v2.17    .
		if ( m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);

		// v1.432
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) && 
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0)) {
				//     0   .
				delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
				m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
			}
		else {
			//    . 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY, 
				m_pClientList[iClientH]->m_pItemList[sItemIndex]);

			// v1.41      . 
			// v2.17 2002-7-31      . 
			if ( bByPlayer == TRUE )
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			else 
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex], TRUE);

			//      . 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); //v1.4 color
		}

		//  delete  NULL . delete        
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;

		//     .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);

		//   
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	//      
	iCalcTotalWeight(iClientH);
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: check if player is dropping item or picking up item
//  last updated		:: October 29, 2004; 7:12 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp, sRemainItemSprite, sRemainItemSpriteFrame;
 char  cRemainItemColor, cData[100];
 int   iRet, iEraseReq;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	ClearSkillUsingStatus(iClientH);

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(sX, sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
	if (pItem != NULL) {
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {

			_bItemLog(DEF_ITEMLOG_GET, iClientH, NULL, pItem);

			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;
			
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

			*cp = 1;
			cp++;

			memcpy(cp, pItem->m_cName, 20);
			cp += 20;

			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char)0;
			cp++;

			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;
			 
			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor;
			cp++;

			*cp = (char)pItem->m_sItemSpecEffectValue2;
			cp++;
			
			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			if (iEraseReq == 1) delete pItem;

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				                        sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);						
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}
		else 
		{
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(sX, sY, pItem);
			
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}
	}

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

BOOL CGame::_bAddClientItemList(int iClientH, class CItem * pItem, int * pDelReq)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (pItem == NULL) return FALSE;
	
	//     
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		//    
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
	}
	else {
		//     
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, 1)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
  	}
	
	//       . 
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		for (i = 0; i < DEF_MAXITEMS; i++)
		if ( (m_pClientList[iClientH]->m_pItemList[i] != NULL) && 
			 (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, pItem->m_cName, 20) == 0) ) {
			//   . 
			m_pClientList[iClientH]->m_pItemList[i]->m_dwCount += pItem->m_dwCount;
			
			*pDelReq = 1;
			
			//      
			iCalcTotalWeight(iClientH);
			
			return TRUE;
		}
	}
	
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
		
		m_pClientList[iClientH]->m_pItemList[i] = pItem;
		// v1.3    100, 100
		m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
		m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

		*pDelReq = 0;

		//     . 
		if (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)
			m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

		//      
		iCalcTotalWeight(iClientH);
		
		return TRUE;
	}

	//     .
	return FALSE;
}

BOOL CGame::bEquipItemHandler(int iClientH, short sItemIndex, BOOL bNotify)
{
	char  cEquipPos, cHeroArmorType;
	short   sSpeed;
	short sTemp;
	int iTemp;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return FALSE;

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0) return FALSE;

	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) == NULL)  &&
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sLevelLimit > m_pClientList[iClientH]->m_iLevel)) return FALSE;


	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 0) {
		switch (m_pClientList[iClientH]->m_sType) {
		case 1:
		case 2:
		case 3:
			// .
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 1) return FALSE;
			break;
		case 4:
		case 5:
		case 6:
			// .
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 2) return FALSE;
			break;
		}
	}

	if (iGetItemWeight(m_pClientList[iClientH]->m_pItemList[sItemIndex], 1) > (m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr)*100) return FALSE;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

	if ((cEquipPos == DEF_EQUIPPOS_BODY) || (cEquipPos == DEF_EQUIPPOS_LEGGINGS) ||
		(cEquipPos == DEF_EQUIPPOS_ARMS) || (cEquipPos == DEF_EQUIPPOS_HEAD)) {
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4) {
				case 10: // Str  
					if ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						//      .  .
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						//     .
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
						return FALSE;
					}
					break;
				case 11: // Dex
					if ((m_pClientList[iClientH]->m_iDex+m_pClientList[iClientH]->m_iAngelicDex) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						//      .  .
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						//     .
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
						return FALSE;
					}
					break;
				case 12: // Vit
					if (m_pClientList[iClientH]->m_iVit < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						//      .  .
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						//     .
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
						return FALSE;
					}
					break;
				case 13: // Int
					if ((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						//      .  .
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						//     .
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
						return FALSE;
					}
					break;
				case 14: // Mag
					if ((m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						//      .  .
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						//     .
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
						return FALSE;
					}
					break;
				case 15: // Chr
					if (m_pClientList[iClientH]->m_iCharisma < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						//      .  .
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						//     .
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
						return FALSE;
					}
					break;
			}
		}

		if (cEquipPos == DEF_EQUIPPOS_TWOHAND) {
			// Stormbringer
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) {
				if((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt) <= 65){
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, sItemIndex, NULL, NULL);
					ReleaseItemHandler(iClientH, sItemIndex , TRUE);
					return FALSE;
				}
			}
		}

		if (cEquipPos == DEF_EQUIPPOS_RHAND) {
			// Resurrection wand(MS.10) or Resurrection wand(MS.20)
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
				if(((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt) > 99) && ((m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag) > 99) && (m_pClientList[iClientH]->m_iSpecialAbilityTime < 1)){
					m_pClientList[iClientH]->m_cMagicMastery[94] = TRUE;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RESUR_ON, NULL, NULL, NULL, NULL);
				}
			}
		}

		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) || 
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) {

				if ((m_pClientList[iClientH]->m_iSpecialAbilityType != 0)) {
					//    .      :
					// ,       .
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos != m_pClientList[iClientH]->m_iSpecialAbilityEquipPos) {
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], NULL, NULL);
						//     .
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], TRUE);
					}
				}
			}


		if (cEquipPos == DEF_EQUIPPOS_NONE) return FALSE;

		if (cEquipPos == DEF_EQUIPPOS_TWOHAND) {
			//       
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
			else {
				// ,       
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) 
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ], FALSE);
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ] != -1) 
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ], FALSE);
			}
		}
		else {
			//     .
			if ((cEquipPos == DEF_EQUIPPOS_LHAND) || (cEquipPos == DEF_EQUIPPOS_RHAND)) {
				//     
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) 
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ], FALSE);
			}

			//     .
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
		}


		if (cEquipPos == DEF_EQUIPPOS_RELEASEALL) {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) {
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_HEAD ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_HEAD ], FALSE);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BODY ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BODY ], FALSE);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_ARMS ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_ARMS ], FALSE);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LEGGINGS ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LEGGINGS ], FALSE);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_PANTS ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_PANTS ], FALSE);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BACK ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BACK ], FALSE);
			}
		}
		else{
			if (cEquipPos == DEF_EQUIPPOS_HEAD || cEquipPos == DEF_EQUIPPOS_BODY || cEquipPos == DEF_EQUIPPOS_ARMS ||
				cEquipPos == DEF_EQUIPPOS_LEGGINGS || cEquipPos == DEF_EQUIPPOS_PANTS || cEquipPos == DEF_EQUIPPOS_BACK) {
					if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RELEASEALL ] != -1) {
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RELEASEALL ], FALSE);
					}
			}
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
		}


		m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = sItemIndex;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = TRUE;

		switch (cEquipPos) {

			case DEF_EQUIPPOS_HEAD:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0xFF0F;	//    .
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr  . 
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
				iTemp = iTemp & 0xFFFFFFF0; //    .				
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor));
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_PANTS:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0xF0FF;	//    .
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); // Appr  . 
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
				iTemp = iTemp & 0xFFFFF0FF; //    .
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 8);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_LEGGINGS:
				sTemp = m_pClientList[iClientH]->m_sAppr4;
				sTemp = sTemp & 0x0FFF;	//    .
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr  . 
				m_pClientList[iClientH]->m_sAppr4 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
				iTemp = iTemp & 0xFFFFFF0F; //    .
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 4);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_BODY:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0x0FFF;	//    .

				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue < 100) {
					//  100 .   
					sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr  . 
					m_pClientList[iClientH]->m_sAppr3 = sTemp;
				}
				else {
					//  100    . 
					sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue - 100) << 12); // Appr  . 
					m_pClientList[iClientH]->m_sAppr3 = sTemp;
					//     .
					sTemp = m_pClientList[iClientH]->m_sAppr4;
					sTemp = sTemp | 0x080;	
					m_pClientList[iClientH]->m_sAppr4 = sTemp;
				}

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
				iTemp = iTemp & 0xFF0FFFFF; // ()   .
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 20);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;
			
			case DEF_EQUIPPOS_ARMS:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0xFFF0;	//    .
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr  . 
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
				iTemp = iTemp & 0xFFFFFFFF; //    . // New 09/05/2004
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 12);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_LHAND:
				//   . . 
				sTemp = m_pClientList[iClientH]->m_sAppr2;
				sTemp = sTemp & 0xFFF0;	//    .
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr  . 
				m_pClientList[iClientH]->m_sAppr2 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
				iTemp = iTemp & 0xF0FFFFFF; //    .
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 24);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_RHAND:
				//   . . 
				sTemp = m_pClientList[iClientH]->m_sAppr2;
				sTemp = sTemp & 0xF00F;	//    .
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr  . 
				m_pClientList[iClientH]->m_sAppr2 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
				iTemp = iTemp & 0xFFFFFFF; //    .
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				//    Status  .
				iTemp = m_pClientList[iClientH]->m_iStatus;
				iTemp = iTemp & 0xFFFFFFF0;
				sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
				// Str    . 
				sSpeed -= ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr) / 13);
				if (sSpeed < 0) sSpeed = 0;
				iTemp = iTemp | (int)sSpeed;
				m_pClientList[iClientH]->m_iStatus = iTemp;
				m_pClientList[iClientH]->m_iComboAttackCount = 0;
				break;

			case DEF_EQUIPPOS_TWOHAND:
				//    . 
				sTemp = m_pClientList[iClientH]->m_sAppr2;
				sTemp = sTemp & 0xF00F;	//    .
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr  . 
				m_pClientList[iClientH]->m_sAppr2 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
				iTemp = iTemp & 0xFFFFFFF; //    .
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				//    Status  .
				iTemp = m_pClientList[iClientH]->m_iStatus;
				iTemp = iTemp & 0xFFFFFFF0;
				sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
				// Str    . 
				sSpeed -= ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr) / 13);
				if (sSpeed < 0) sSpeed = 0;
				iTemp = iTemp | (int)sSpeed;
				m_pClientList[iClientH]->m_iStatus = iTemp;
				m_pClientList[iClientH]->m_iComboAttackCount = 0;
				break;

			case DEF_EQUIPPOS_BACK:
				sTemp = m_pClientList[iClientH]->m_sAppr4;
				sTemp = sTemp & 0xF0FF;	//    .
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); // Appr  . 
				m_pClientList[iClientH]->m_sAppr4 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
				iTemp = iTemp & 0xFFF0FFFF; //    .
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 16);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_RELEASEALL:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0x0FFF;	//    .
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr  . 
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
				iTemp = iTemp & 0xFFF0FFFF; //    .
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;
		}

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
			//     
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
				case 0: break;
				case 1: //  50% HP 
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0004;	
					break;

				case 2: //   
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x000C;	
					break;

				case 3: //   
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0008;	
					break;
			}
		}

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
			switch(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect){
				case 0:
					break;
				case 50:
				case 51:
				case 52:
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0002;
					break;
				default:
					if(m_pClientList[iClientH]->m_iAdminUserLevel > 0)
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0001;
					
					break;
			}
		}
		
	cHeroArmorType = _cCheckHeroItemEquipped(iClientH);
	if (cHeroArmorType != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroArmourBonus = cHeroArmorType;
		
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	CalcTotalItemEffect(iClientH, sItemIndex, bNotify);
	return TRUE;

}

void CGame::SendEventToNearClient_TypeB(DWORD dwMsgID, WORD wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, short sV4)
{
 int i, iRet, iShortCutIndex;
 char  * cp, cData[100];
 DWORD * dwp, dwTime;
 WORD * wp;
 short * sp;
 BOOL bFlag;

	ZeroMemory(cData, sizeof(cData));
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	sp  = (short *)cp;
	*sp = sX;
	cp += 2;

	sp  = (short *)cp;
	*sp = sY;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV1;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV2;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV3;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV4;
	cp += 2;

	dwTime = timeGetTime();

	bFlag = TRUE;
	iShortCutIndex = 0;
	while (bFlag == TRUE) {
		// DEF_MAXCLIENTS      .    0  .
		i = m_iClientShortCut[iShortCutIndex];
		iShortCutIndex++;
		if (i == 0) bFlag = FALSE;

		if ((bFlag == TRUE) && (m_pClientList[i] != NULL)) {
			if ( (m_pClientList[i]->m_cMapIndex == cMapIndex) &&
				 (m_pClientList[i]->m_sX >= sX - 10) &&
				 (m_pClientList[i]->m_sX <= sX + 10) &&
				 (m_pClientList[i]->m_sY >= sY - 8 ) &&
				 (m_pClientList[i]->m_sY <= sY + 8 ) ) {

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 18);
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: checks if player is stopped
//  last updated		:: October 29, 2004; 6:46 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
{
 char cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 short   sOwnerH;
 char    cOwnerType;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, sX, sY);		
		if (sOwnerH != NULL) {
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}

	ClearSkillUsingStatus(iClientH);

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	m_pClientList[iClientH]->m_cDir = cDir;
	
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

void CGame::ResponseCreateNewGuildHandler(char * pData, DWORD dwMsgSize)
{
 int i;
 WORD  * wp, wResult;
 DWORD * dwp;
 char  * cp, cCharName[11], cData[100], cTxt[120];
 int iRet;
	
	//        . 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;
	
	//    .
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) &&
		(m_pClientList[i]->m_iLevel >= 20) && (m_pClientList[i]->m_iCharisma >= 20)) {
		
		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		switch (*wp) {
		case DEF_LOGRESMSGTYPE_CONFIRM:
			//     . 
			wResult = DEF_MSGTYPE_CONFIRM;
			//       0   .
			m_pClientList[i]->m_iGuildRank = 0;	//   0.  
			wsprintf(cTxt, "(!) New guild(%s) creation success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;

		case DEF_LOGRESMSGTYPE_REJECT:
			//     .
			//     "NONE".
			wResult = DEF_MSGTYPE_REJECT;
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
			m_pClientList[i]->m_iGuildRank = -1;  
			m_pClientList[i]->m_iGuildGUID = -1;
			wsprintf(cTxt, "(!) New guild(%s) creation Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
		}				
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_CREATENEWGUILD;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wResult;

		//       
		iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			//     .
			DeleteClient(i, TRUE, TRUE);
			return;
		}

		return;
	}

	//      .
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::RequestCreateNewGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cGuildName[21], cTxt[120], cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_bIsCrusadeMode == TRUE) return;
	if (m_bIsHeldenianMode == TRUE) return;
	if (m_bIsApocalypseMode == TRUE) return;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	cp += 30;
	
	ZeroMemory(cGuildName, sizeof(cGuildName));
	memcpy(cGuildName, cp, 20);
	cp += 20;

	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		//          .
		wsprintf(cTxt, "(!)Cannot create guild! Already guild member.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
		if ( (m_pClientList[iClientH]->m_iLevel < 20) || (m_pClientList[iClientH]->m_iCharisma < 20) ||
			 (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) ||
			 (memcmp(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) != 0) ) { // v1.4
			//   .          
			ZeroMemory(cData, sizeof(cData));

			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_CREATENEWGUILD;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_MSGTYPE_REJECT;

			//       
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				//     .
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
		else {
	   		//    . ->    Rank -1  .
			ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy(m_pClientList[iClientH]->m_cGuildName, cGuildName);
			//     .
			ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
			strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
			//  GUID  . 
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iGuildGUID = (int)(SysTime.wYear + SysTime.wMonth + SysTime.wDay + SysTime.wHour + SysTime.wMinute + timeGetTime());
			
			//     .
			bSendMsgToLS(MSGID_REQUEST_CREATENEWGUILD, iClientH);
		}
	}
}


void CGame::RequestDisbandGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cGuildName[21], cTxt[120];

	if (m_bIsCrusadeMode == TRUE) return;
	if (m_bIsHeldenianMode == TRUE) return;
	if (m_bIsApocalypseMode == TRUE) return;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cGuildName, sizeof(cGuildName));
	
	cp += 10;
	cp += 10;
	cp += 10;
	
	memcpy(cGuildName, cp, 20);
	cp += 20;

	if ((m_pClientList[iClientH]->m_iGuildRank != 0) || (memcmp(m_pClientList[iClientH]->m_cGuildName, cGuildName, 20) != 0)) {
		//        .
		wsprintf(cTxt, "(!)Cannot Disband guild! Not guildmaster.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
		//     .
		bSendMsgToLS(MSGID_REQUEST_DISBANDGUILD, iClientH);
	}
}

void CGame::ResponseDisbandGuildHandler(char * pData, DWORD dwMsgSize)
{
 int i;
 WORD  * wp, wResult;
 DWORD * dwp;
 char  * cp, cCharName[11], cData[100], cTxt[120];
 int iRet;
	
	//        . 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;
	
	//    .
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {
		
		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		switch (*wp) {
		case DEF_LOGRESMSGTYPE_CONFIRM:
			//     . 
			wResult = DEF_MSGTYPE_CONFIRM;
			wsprintf(cTxt, "(!) Disband guild(%s) success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			
			//       . 
			SendGuildMsg(i,	DEF_NOTIFY_GUILDDISBANDED, NULL, NULL, NULL);
			
			//  
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
			m_pClientList[i]->m_iGuildRank = -1;		//   -1.  . 
			m_pClientList[i]->m_iGuildGUID = -1;
			break;

		case DEF_LOGRESMSGTYPE_REJECT:
			//     .
			wResult = DEF_MSGTYPE_REJECT;
			wsprintf(cTxt, "(!) Disband guild(%s) Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
		}				
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_DISBANDGUILD;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wResult;

		//       
		iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			//     .
			DeleteClient(i, TRUE, TRUE);
			return;
		}
		return;
	}

	//      .
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

// 05/29/2004 - Hypnotoad - Purchase Dicount updated to take charisma into consideration
void CGame::RequestPurchaseItemHandler(int iClientH, char * pItemName, int iNum)
{
 class CItem * pItem;
 char  * cp, cItemName[21], cData[100];
 short * sp;
 DWORD * dwp, dwGoldCount, dwItemCount;
 WORD  * wp, wTempPrice;
 int   i, iRet, iEraseReq, iGoldWeight;
 int   iCost, iCost2, iDiscountRatio, iDiscountCost;
 double dTmp1, dTmp2, dTmp3;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	//           . 
	
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) {
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) ||
				(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arefarm", 7) == 0)) {

			}
			else return;
		}

		if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) ||
				(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvfarm", 7) == 0)) {

			}
			else return;
		}
	}
	
	
	//  . 
	ZeroMemory(cData, sizeof(cData));	
	ZeroMemory(cItemName, sizeof(cItemName));
	

	// . 
	if (memcmp(pItemName, "10Arrows", 8) == 0) {
		strcpy(cItemName, "Arrow");
		dwItemCount = 10;
	}
	else if (memcmp(pItemName, "100Arrows", 9) == 0) {
		strcpy(cItemName, "Arrow");
		dwItemCount = 100;
	}
	else {
		memcpy(cItemName, pItemName, 20);
		dwItemCount = 1;
	}
	
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			//      .  .
			delete pItem;
		}
		else {
			
			if (pItem->m_bIsForSale == FALSE) {
				//   .   .
				delete pItem;
				return;
			}

			pItem->m_dwCount = dwItemCount;

			
           //Heldenian Price Fix Thing
           if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) {
				iCost = (int)((float)(pItem->m_wPrice) * 0.9f + 0.5f);
				iCost = iCost * pItem->m_dwCount;
				iCost2 = pItem->m_wPrice * pItem->m_dwCount;
			}
                        else {
				iCost2 = iCost = ((pItem->m_wPrice * pItem->m_dwCount)*2);
                        }

			//   Gold    .
			dwGoldCount = dwGetItemCount(iClientH, "Gold");
			
			// Charisma   . 
			// v2.14  10     
			iDiscountRatio = ((m_pClientList[iClientH]->m_iCharisma -10)/ 4) ;
			
			
			
			dTmp1 = (double)(iDiscountRatio);
			dTmp2 = dTmp1 / 100.0f;
			dTmp1 = (double)iCost;
			dTmp3 = dTmp1 * dTmp2;
			iDiscountCost = (int)dTmp3;
			
            //Fix For Heldenian Price =x	
			if ((iCost - iDiscountCost) <= (iCost2/2)) {
				iDiscountCost = iCost - (iCost2/2) + 1; 
			}

                        

			if ( dwGoldCount < (DWORD)(iCost - iDiscountCost) ) {
				//   Gold    .  .
				delete pItem;
				
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_NOTENOUGHGOLD;
				cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp  = -1; // -1 .
				cp++;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					//     .
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}
			
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				//   
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				//    .
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMPURCHASED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				// 1 .
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; //    .
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;
				
				wp  = (WORD *)cp;
				*wp = (iCost - iDiscountCost);
				wTempPrice = (iCost - iDiscountCost);
				cp += 2;
				
				if (iEraseReq == 1) delete pItem;
				
				//    
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
				
				// Gold  .      .
				iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - wTempPrice);
				//      
				iCalcTotalWeight(iClientH);

				//v1.4   . 
				m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += wTempPrice;
					
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					//     .
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
			else 
			{
				//      .
				delete pItem;

				//      
				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					//     .
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
 	}
}

void CGame::GiveItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char * pItemName)
{
 int iRet, iEraseReq;
 short * sp, sOwnerH;
 char  * cp, cOwnerType, cData[100], cCharName[21];
 DWORD * dwp;
 WORD  * wp;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (iAmount <= 0) return;

	//     .
	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) {
		PutLogList("GiveItemHandler - Not matching Item name");
		return;
	}

	ZeroMemory(cCharName, sizeof(cCharName));

	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount > (DWORD)iAmount) ) {
		//        
		
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) {
			//      .      
			delete pItem;
			return;
		}
		else {
			pItem->m_dwCount = iAmount;
		}

		//  : 0 .
		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;

		//    .
		// v1.41 !!!    . 
		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);
		
		// dX, dY     . 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		
		// v1.4     .
		if (wObjectID != NULL) { 
			if (wObjectID < 10000) {
				//  
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != NULL) {
						if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != NULL) {
						if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
					}
				}
			}
		}

		if (sOwnerH == NULL) {
			//     .
			//    . 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			
			// v1.411  
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
	
			//      . 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color
		}
		else {
			//  .
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				//  .
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);

				if (sOwnerH == iClientH) {
					//      .   .
					delete pItem;
					return;
				}
				
				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) {
					//  .
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

					// 1 . Amount !
					*cp = 1;
					cp++;

					memcpy(cp, pItem->m_cName, 20);
					cp += 20;

					dwp  = (DWORD *)cp;
					*dwp = pItem->m_dwCount;	//   
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)0; //    .
					cp++;

					sp  = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;
	
					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;
		
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					cp++;
					
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					

					if (iEraseReq == 1) delete pItem;

					//    
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 53);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						//     .
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}

					// v1.4     . 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, cCharName);
				}
				else {
					//         .
					//    . 
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     pItem);

					// v1.411  
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
	
					//      . 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color

					//     .
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						//     .
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}

					// v1.4     .
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTGIVEITEM, sItemIndex, iAmount, NULL, cCharName);
				}

			}
			else {
				// NPC  .
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					// NPC     . 
					if (bSetItemToBankItem(iClientH, pItem) == FALSE) {
						//   .	
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);

						//   .
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

						// v1.411  
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
	
						//      . 
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
								                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
									                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
					}
		   		}
				else {
					//  NPC       . 
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

					// v1.411  
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
	
					//      . 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
				}
			}
		}
	}
	else {
		//   .
		
		//       .
		ReleaseItemHandler(iClientH, sItemIndex, TRUE);

		//     -1  .
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) 
			m_pClientList[iClientH]->m_cArrowIndex = -1;
		
		// dX, dY     . 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY); //  dX, dY   .         .  
		
		// v1.4     .
		if (wObjectID != NULL) { 
			if (wObjectID < 10000) {
				//  
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != NULL) {
						if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != NULL) {
						if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
					}
				}
			}
		}
	
		if (sOwnerH == NULL) {
			//      . 
			//    . 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                             m_pClientList[iClientH]->m_sY, 
																	     m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			// v1.411  
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
	
			//      . 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
								        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
										m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color
		
			//      .
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);
		}
		else {
			//    . @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
					
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				//   .	
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);
				pItem = m_pClientList[iClientH]->m_pItemList[sItemIndex];
				
				// v2.03     .

				// v2.17 2002-7-31       .
				if (pItem->m_sIDnum == 88) {

					//  iClientH  sOwnerH   .  
					// sOwnerH         .
								// v2.17 2002-7-31       .
					if ((m_pClientList[iClientH]->m_iGuildRank == -1) && 
						(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
						(memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[sOwnerH]->m_cLocation, 10) == 0) &&
						(m_pClientList[sOwnerH]->m_iGuildRank == 0) ) {
						//  .	     .
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
						//         .
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);

						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH,(int) -1, pItem);
					
						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				// v2.17 2002-7-31       .
				if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {

					//  iClientH  sOwnerH   .  
					// sOwnerH  iClientH    iClientH  
					//        .
					if ( (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) && 
						 (m_pClientList[iClientH]->m_iGuildRank != -1) && 
						 (m_pClientList[sOwnerH]->m_iGuildRank == 0) ) {
						//  .	     .
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
						//         .
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);

						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH,(int) -1, pItem);
					
						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				//      ...
				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) {
					
					// v1.41      . 
					_bItemLog(DEF_ITEMLOG_GIVE, iClientH, sOwnerH, pItem);

					//  .
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

					// 1 .
					*cp = 1;
					cp++;

					memcpy(cp, pItem->m_cName, 20);
					cp += 20;

					dwp  = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)0; //    .
					cp++;

					sp  = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;
	
					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;
		
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					cp++;
					
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					

					if (iEraseReq == 1) delete pItem;

					//    
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 53);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						//     .
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}
				}
				else {
					//         .
					//    . 
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					// v1.41      . 
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
					//      . 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
										        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

					//     .
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						//     .
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}

					// v1.4      
					ZeroMemory(cCharName, sizeof(cCharName));
				}
			}
			else {
				// NPC  .
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					// NPC     . 
					if (bSetItemToBankItem(iClientH, sItemIndex) == FALSE) {
						//     .
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);
						
						//   .
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
						                                                         	 m_pClientList[iClientH]->m_sY, 
							                                                         m_pClientList[iClientH]->m_pItemList[sItemIndex]);
						
						// v1.41      . 
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
						
						//      . 
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
							                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
							                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
													m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color
					}
				}
				else if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Kennedy", 7) == 0) {
					//        . 
					if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {
						
						if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
							//       .
							SendNotifyMsg(iClientH, iClientH, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);
						
							//  . 
							ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
							memcpy(m_pClientList[iClientH]->m_cGuildName, "NONE", 4);
							m_pClientList[iClientH]->m_iGuildRank = -1;
							m_pClientList[iClientH]->m_iGuildGUID = -1;

							//     . 
							SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

							//   .
							m_pClientList[iClientH]->m_iExp -= 300;
							if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
						}

						//    . 
						delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
					} 
					else {
						//      .       
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						// v1.41      . 
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
						//      . 
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
										        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

						// v1.4      
						ZeroMemory(cCharName, sizeof(cCharName));

					}
				}
				else {
					//  NPC       . 

					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					// v1.41      . 
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
					//      . 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
										        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

					// v1.4      
					ZeroMemory(cCharName, sizeof(cCharName));
				}
			}

			//         .
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, cCharName);
		}

REMOVE_ITEM_PROCEDURE:;

		//         . 
		if (m_pClientList[iClientH] == NULL) return;

		//    . delete ! 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
		
		//    
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	//      
	iCalcTotalWeight(iClientH);
}

void CGame::JoinGuildApproveHandler(int iClientH, char * pName)
{
 int i;
 BOOL bIsExist = FALSE;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pName   iClientH    .
	
	// pName     .
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		// v1.4    .
		if (memcmp(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) != 0) return;
		
		//      .
		ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
		strcpy(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName);
		
		//  GUID.
		m_pClientList[i]->m_iGuildGUID = m_pClientList[iClientH]->m_iGuildGUID;

		//   .
		ZeroMemory(m_pClientList[i]->m_cLocation, sizeof(m_pClientList[i]->m_cLocation));
		strcpy(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation);

		m_pClientList[i]->m_iGuildRank = DEF_GUILDSTARTRANK; //@@@  GuildRank  DEF_GUILDSTARTRANK
		
		//       .
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDAPPROVE, NULL, NULL, NULL, NULL);

		//     . 
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		
		//      .
		SendGuildMsg(i, DEF_NOTIFY_NEWGUILDSMAN, NULL, NULL, NULL);

		//     .
		bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN, i);
		return;
	}

	//     .(  )  
}

void CGame::JoinGuildRejectHandler(int iClientH, char * pName)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pName   iClientH      .

	// pName     .
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		//       .
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDREJECT, NULL, NULL, NULL, NULL);
		return;
	}

	//     .(  )  
}

void CGame::DismissGuildApproveHandler(int iClientH, char * pName)
{
 int i;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);
		SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);
	
		ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
		strcpy(m_pClientList[i]->m_cGuildName, "NONE");
		m_pClientList[i]->m_iGuildRank = -1; 
		m_pClientList[i]->m_iGuildGUID = -1;

		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);
		
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		return;
	}

}

void CGame::DismissGuildRejectHandler(int iClientH, char * pName)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pName   iClientH      .

	// pName     .
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		//       .
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDREJECT, NULL, NULL, NULL, NULL);
		return;
	}

	//     .(  )  
}


DWORD CGame::dwGetItemCount(int iClientH, char * pName)
{
 int i;
 char cTmpName[21];

	if (m_pClientList[iClientH] == NULL) return NULL;
	
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
		
		return m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
	}

	return 0;
}

int CGame::SetItemCount(int iClientH, char * pItemName, DWORD dwCount)
{
 int i;
 char cTmpName[21];
 WORD wWeight;
	
	if (m_pClientList[iClientH] == NULL) return -1;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
		
		wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], 1);// m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;

		//  0     .
		if (dwCount == 0) {
			ItemDepleteHandler(iClientH, i, FALSE, TRUE);
		}
		else {
			//    . 
			m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = dwCount;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETITEMCOUNT, i, dwCount, (char)TRUE, NULL);
		}
		
		return wWeight;
	}

	return -1;
}


int CGame::SetItemCount(int iClientH, int iItemIndex, DWORD dwCount)
{
 WORD wWeight;
	
	if (m_pClientList[iClientH] == NULL) return -1;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return -1;
	
	wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], 1);//m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wWeight;

	//  0     .
	if (dwCount == 0) {
		ItemDepleteHandler(iClientH, iItemIndex, FALSE, TRUE);
	}
	else {
		//    . 
		m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = dwCount;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETITEMCOUNT, iItemIndex, dwCount, (char)TRUE, NULL);
	}
		
	return wWeight;	
}

void CGame::ClientKilledHandler(int iClientH, int iAttackerH, char cAttackerType, short sDamage)
{
 char  * cp, cAttackerName[21], cData[120];
 short sAttackerWeapon;
 int   * ip, i, iExH;
 BOOL  bIsSAattacked = FALSE;
 char KilledMessage1[45], KilledMessage2[45], KilledMessage3[45], KilledMessage4[45], KilledMessage5[45], KilledMessage6[45];
 int Killedi, KMRand;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
 	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	//    .
	// 2002-7-4      

	m_pClientList[iClientH]->m_bIsKilled = TRUE;
	// HP 0.
	m_pClientList[iClientH]->m_iHP = 0;

	if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
		m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
	}

	if ( m_pClientList[iClientH]->m_bIsPoisoned ) 
	{
		m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
		SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
	}

	if (m_pClientList[iClientH]->m_cExchangeMode != 0) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}
	//   NPC    .
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER, NULL, iAttackerH, cAttackerType);
	
	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER_INDIRECT:
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iAttackerH] != NULL)
			memcpy(cAttackerName, m_pClientList[iAttackerH]->m_cCharName, 10);
		break;
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iAttackerH] != NULL)
#ifdef DEF_LOCALNPCNAME     // v2.14 NPC     
			wsprintf(cAttackerName,"NPCNPCNPC@%d",m_pNpcList[iAttackerH]->m_sType);
#else 
			memcpy(cAttackerName, m_pNpcList[iAttackerH]->m_cNpcName, 20);
#endif
		break ;
	default:
		break;
	}

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_KILLED, NULL, NULL, NULL, cAttackerName);
	//     .
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[iAttackerH]->m_sAppr2 & 0x0FF0) >> 4);	
	}
	else sAttackerWeapon = 1;
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(12, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;
	if (   (m_bHeldenianWarInitiated == TRUE) 
		&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE)) 
	{	if (m_pClientList[iClientH]->m_cSide == 1) 
		{	m_iHeldenianAresdenDead++;
		}else if (m_pClientList[iClientH]->m_cSide == 2) 
		{	m_iHeldenianElvineDead++;
		}
		UpdateHeldenianStatus(-1);
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		// v1.432
		//      .
		switch (m_pClientList[iAttackerH]->m_iSpecialAbilityType) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			bIsSAattacked = TRUE;
			break;
		}
		
		if (iAttackerH == iClientH) return; // .
		//    PK     . 
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
			//  . 
			if (m_pClientList[iClientH]->m_iPKCount == 0) {


				//  .  PK  .
				ApplyPKpenalty(iAttackerH, iClientH);
			}
			else {

						//   .  PK    . 
				PK_KillRewardHandler(iAttackerH, iClientH);
			}
		} 
		else {
			//      . 
			if (m_pClientList[iClientH]->m_iGuildRank == -1) {
				//  .
				//  ,   ,    -> PK .   ,  ->  
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
					//  . 				
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						//    .  PK .
						ApplyPKpenalty(iAttackerH, iClientH);
					}
					else {
						//  PK    .

					}
				}
				else {
					//  ,   ->   PK,     
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iAttackerH]->m_cLocation, 10) == 0) {
						//         .  
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							//   . PK.
							ApplyPKpenalty(iAttackerH, iClientH);
						}
						else {
							//  . 
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {
						//    .  
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
			else {
				//  . 
				//   , ,   -> PK /   ->  
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
					//  .
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						//    .  PK .
						ApplyPKpenalty(iAttackerH, iClientH);
					}
					else {
						//  PK    .

					}
				}
				else {
					//     ->   PK,     
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iAttackerH]->m_cLocation, 10) == 0) {
						//         .  
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							//   . PK.
							ApplyPKpenalty(iAttackerH, iClientH);
						}
						else {
							//  . 
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {
						//    .  
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
		}

		//      . 
		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
				//  . 
				//PK   .
				m_pClientList[iClientH]->m_iExp -= iDice(1, 100000);
				if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
			}
			else {
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) == 0) {
					//     . 
					//PK   . 
					m_pClientList[iClientH]->m_iExp -= iDice(1, 120000000);
					if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
				}
				else {
					//      .     . 
					ApplyCombatKilledPenalty(iClientH, 2, bIsSAattacked);
				}
			}
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}

		memcpy(KilledMessage1, cAttackerName, strlen(cAttackerName));
		strcat(KilledMessage1, " whooped ");
		strcat(KilledMessage1, m_pClientList[iClientH]->m_cCharName);
		strcat(KilledMessage1, "'s ass!");

		memcpy(KilledMessage2, cAttackerName, strlen(cAttackerName));
		strcat(KilledMessage2, " smashed ");
		strcat(KilledMessage2, m_pClientList[iClientH]->m_cCharName);
		strcat(KilledMessage2, "'s face into the ground!");

		memcpy(KilledMessage3, m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName));
		strcat(KilledMessage3, " was sliced to pieces by ");
		strcat(KilledMessage3, cAttackerName);

		memcpy(KilledMessage4, m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName));
		strcat(KilledMessage4, " says LAG LAG!! but gets PWNED by ");
		strcat(KilledMessage4, cAttackerName);

		memcpy(KilledMessage5, cAttackerName, strlen(cAttackerName));
		strcat(KilledMessage5, " sent ");
		strcat(KilledMessage5, m_pClientList[iClientH]->m_cCharName);
		strcat(KilledMessage5, " off too pie heaven! ");

		memcpy(KilledMessage6, cAttackerName, strlen(cAttackerName));
		strcat(KilledMessage6, " got beat by ");
		strcat(KilledMessage6, m_pClientList[iClientH]->m_cCharName);
		strcat(KilledMessage6, "'s ugly stick!");

		for (Killedi = 1; Killedi < DEF_MAXCLIENTS; Killedi++){
			if ((m_pClientList[Killedi] != NULL)) {
				KMRand = rand()%6;
				if (KMRand == 0)
				{
					SendNotifyMsg(NULL, Killedi, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, KilledMessage1);
				}
				else if (KMRand == 1)
				{
					SendNotifyMsg(NULL, Killedi, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, KilledMessage2);
				}
				else if (KMRand == 2)
				{
					SendNotifyMsg(NULL, Killedi, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, KilledMessage3);
				}
				else if (KMRand == 3)
				{
					SendNotifyMsg(NULL, Killedi, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, KilledMessage4);
				}
				else if (KMRand == 4)
				{
					SendNotifyMsg(NULL, Killedi, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, KilledMessage5);
				}
				else if (KMRand == 5)
				{
					SendNotifyMsg(NULL, Killedi, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, KilledMessage6);
				}
				wsprintf(G_cTxt, "%s killed %s", cAttackerName, m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(G_cTxt);
			}
		}

		if  (memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone1", 10) == 0) { // MORLA2.2 - Revive en Deathmach Map
			m_pClientList[iClientH]->m_bIsBeingResurrected = TRUE;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RESURRECTPLAYER, NULL, NULL, NULL, NULL);
			if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
				m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = TRUE;
				m_pClientList[iClientH]->m_iSpecialAbilityLastSec = 0;
			}						
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, NULL);
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			
			char cScanMessage[50];
			int p;
									
			//MORLA 2.2 - Deathmach Game completo:
			m_pClientList[iAttackerH]->m_iDGKills++;
			m_pClientList[iClientH]->m_iDGDeaths++;
			m_pClientList[iAttackerH]->m_iTotalDGKills++;
			m_pClientList[iClientH]->m_iTotalDGDeaths++;									
			m_pClientList[iAttackerH]->m_iMP = iGetMaxMP(iAttackerH);
			SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL); 
			m_pClientList[iAttackerH]->m_iSuperAttackLeft = (m_pClientList[iAttackerH]->m_iLevel / 10)*2;
			SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);

			DWORD dwTimeThisKill = timeGetTime();
			if (iLastKill == iAttackerH) {
				if (dwTimeLastKill > dwTimeThisKill) {
					iTotalKills++;
					for (i = 1; i < DEF_MAXCLIENTS; i++) // Check all clients
					{
						if ((m_pClientList[i] != NULL)) {
							if ((iTotalKills == 1) && (memcmp(m_pClientList[i]->m_cMapName, "fightzone1", 10) == 0))
								SendNotifyMsg(NULL, i, DEF_NOTIFY_DOUBLEKILL, NULL, NULL, NULL, NULL);
							else if ((iTotalKills == 2) && (memcmp(m_pClientList[i]->m_cMapName, "fightzone1", 10) == 0))
								SendNotifyMsg(NULL, i, DEF_NOTIFY_KILLSPRING, NULL, NULL, NULL, NULL);
							else if ((iTotalKills == 3) && (memcmp(m_pClientList[i]->m_cMapName, "fightzone1", 10) == 0))
								SendNotifyMsg(NULL, i, DEF_NOTIFY_MONSTERKILL, NULL, NULL, NULL, NULL);
							else if ((iTotalKills >= 4) && (memcmp(m_pClientList[i]->m_cMapName, "fightzone1", 10) == 0))
								SendNotifyMsg(NULL, i, DEF_NOTIFY_HOLYSHIT, NULL, NULL, NULL, NULL); 
						}
						dwTimeLastKill = (timeGetTime()+ 30*1000);
					}
				}
				else {
					iTotalKills = 0;
					iLastKill = iAttackerH;
					dwTimeLastKill = (timeGetTime()+ 30*1000);
				}
			}
			else {
				iTotalKills = 0;
				iLastKill = iAttackerH;
				dwTimeLastKill = (timeGetTime()+ 30*1000);
			}
			for (i = 25; i < 5000; i += 25) {
				if (m_pClientList[iAttackerH]->m_iDGKills == i) {
					m_pClientList[iAttackerH]->m_iDGPoints++;
					ZeroMemory(cScanMessage, sizeof(cScanMessage));
					wsprintf(cScanMessage, "Get a Deathmatch Point! Total: %d", m_pClientList[iAttackerH]->m_iDGPoints);
					ShowClientMsg(iAttackerH, cScanMessage);
					SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_REPDGDEATHS, m_pClientList[iAttackerH]->m_iDGPoints, m_pClientList[iAttackerH]->m_iDeaths, m_pClientList[iAttackerH]->m_iRating, NULL);
					bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iAttackerH);
				}
			}
			if (m_pClientList[iDGtop1] != NULL) {	
				if (m_pClientList[iAttackerH]->m_iDGKills >= m_pClientList[iDGtop1]->m_iDGKills)
				{
					if(iDGtop1!=iAttackerH){
						iDGtop2 = iDGtop1;	
						iDGtop1 = iAttackerH;
					}
				}
				else
				{	
					if (m_pClientList[iDGtop2] != NULL)
					{ 
						if (m_pClientList[iAttackerH]->m_iDGKills >= m_pClientList[iDGtop2]->m_iDGKills)
						{ 
							if(iDGtop2!=iAttackerH){
								iDGtop3 = iDGtop2;	
								iDGtop2 = iAttackerH;
							}
						}
						else
						{	
							if (m_pClientList[iDGtop3] != NULL)
							{
								if (m_pClientList[iAttackerH]->m_iDGKills >= m_pClientList[iDGtop3]->m_iDGKills)
								{
									if(iDGtop3!=iAttackerH){
										iDGtop4 = iDGtop3;	
										iDGtop3 = iAttackerH;
									}
								}
								else
								{	
									if (m_pClientList[iDGtop4] != NULL)
									{
										if (m_pClientList[iAttackerH]->m_iDGKills >= m_pClientList[iDGtop4]->m_iDGKills)
										{
											if(iDGtop4!=iAttackerH){
												iDGtop5 = iDGtop4;	
												iDGtop4 = iAttackerH;
											}
										}
										else
										{	
											if (m_pClientList[iDGtop5] != NULL)
											{
												if (m_pClientList[iAttackerH]->m_iDGKills >= m_pClientList[iDGtop5]->m_iDGKills)
												{
													if(iDGtop5!=iAttackerH){
														iDGtop6 = iDGtop5;	
														iDGtop5 = iAttackerH;
													}
												} 
												else
												{	
													if (m_pClientList[iDGtop6] != NULL)
													{
														if (m_pClientList[iAttackerH]->m_iDGKills >= m_pClientList[iDGtop6]->m_iDGKills)
														{
															if(iDGtop6!=iAttackerH){
																iDGtop7 = iDGtop6;	
																iDGtop6 = iAttackerH;
															}
														}
														else
														{	
															if (m_pClientList[iDGtop7] != NULL)
															{
																if (m_pClientList[iAttackerH]->m_iDGKills >= m_pClientList[iDGtop7]->m_iDGKills)
																{
																	if(iDGtop7!=iAttackerH){
																		iDGtop8 = iDGtop7;	
																		iDGtop7 = iAttackerH;
																	}
																}
																else
																{	
																	if (m_pClientList[iDGtop8] != NULL)
																	{
																		if (m_pClientList[iAttackerH]->m_iDGKills >= m_pClientList[iDGtop8]->m_iDGKills)
																		{
																			if(iDGtop8!=iAttackerH){
																				iDGtop9 = iDGtop8;	
																				iDGtop8 = iAttackerH;
																			}
																		}
																		else
																		{	
																			if (m_pClientList[iDGtop9] != NULL)
																			{
																				if (m_pClientList[iAttackerH]->m_iDGKills >= m_pClientList[iDGtop9]->m_iDGKills)
																				{
																					if(iDGtop9!=iAttackerH){
																						iDGtop10 = iDGtop9;	
																						iDGtop9 = iAttackerH;
																					}
																				}
																				else
																				{	
																					if (m_pClientList[iDGtop10] != NULL)
																					{
																						if (m_pClientList[iAttackerH]->m_iDGKills >= m_pClientList[iDGtop10]->m_iDGKills)
																						{	
																							iDGtop10 = iAttackerH;
																						}
																					}
																					else {
																						iDGtop10 = iAttackerH;
																					}	
																				}
																			} 
																			else {
																				iDGtop9 = iAttackerH;
																			} 
																		}
																	} 
																	else {
																		iDGtop8 = iAttackerH;
																	} 
																}
															} 
															else {
																iDGtop7 = iAttackerH;
															} 
														}
													} 
													else {
														iDGtop6 = iAttackerH;
													} 
												}
											} 
											else {
												iDGtop5 = iAttackerH;
											}
										}
									} 
									else {
										iDGtop4 = iAttackerH;
									} 
								}
							} 
							else {
								iDGtop3 = iAttackerH;
							} 
						}
					} 
					else {
						iDGtop2 = iAttackerH;
					} 
				}
			} 
			else {
				iDGtop1 = iAttackerH;
			}
			RefreshDeathmatch(0);				
		}
	}
	else if (cAttackerType == DEF_OWNERTYPE_NPC) {

		_bPKLog(DEF_PKLOG_BYNPC,iClientH,NULL,cAttackerName) ;

		//   .      .
		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			ApplyCombatKilledPenalty(iClientH, 1, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}
		//   NPC      
		if (m_pNpcList[iAttackerH]->m_iGuildGUID != NULL) {
						
			if (m_pNpcList[iAttackerH]->m_cSide != m_pClientList[iClientH]->m_cSide) {
				//       .  .
				//      .    .
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[iAttackerH]->m_iGuildGUID) &&
					(m_pClientList[i]->m_iCrusadeDuty == 3)) {
					m_pClientList[i]->m_iConstructionPoint += (m_pClientList[iClientH]->m_iLevel / 2);

					if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
						m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

					//testcode
					wsprintf(G_cTxt, "Enemy Player Killed by Npc! Construction +%d", (m_pClientList[iClientH]->m_iLevel / 2));
					PutLogList(G_cTxt);
					//   .
					SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
					return;
				}
				
				//   .     .
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				*cp = GSM_CONSTRUCTIONPOINT;
				cp++;
				ip = (int*)cp;
				*ip = m_pNpcList[iAttackerH]->m_iGuildGUID;
				cp += 4;
				ip = (int*)cp;
				*ip = (m_pClientList[iClientH]->m_iLevel / 2);
				cp += 4;
				bStockMsgToGateServer(cData, 9);
			}
		}
	}
	else if (cAttackerType == DEF_OWNERTYPE_PLAYER_INDIRECT) {
		_bPKLog(DEF_PKLOG_BYOTHER,iClientH,NULL,NULL) ;
		//    .   .
		m_pClientList[iClientH]->m_iExp -= iDice(1, 120000000);
		if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	}
	else if (cAttackerType == DEF_MAGICTYPE_CREATE_DYNAMIC) {
		EnemyKillRewardHandler(iAttackerH, iClientH);
	}
}

void CGame::ReleaseItemHandler(int iClientH, short sItemIndex, BOOL bNotice)
{
 char cEquipPos, cHeroArmorType;
 short  sTemp;
 int   iTemp;

	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return;
	
	if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == FALSE) return;
	
	cHeroArmorType = _cCheckHeroItemEquipped(iClientH);
	if (cHeroArmorType != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroArmourBonus = 0;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;
	if (cEquipPos == DEF_EQUIPPOS_RHAND) {
		if(m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL){
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
				m_pClientList[iClientH]->m_cMagicMastery[94] = FALSE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RESUR_OFF, NULL, NULL, NULL, NULL);
			}
		}
	}

	//    Appr .
	switch (cEquipPos) {
	case DEF_EQUIPPOS_RHAND:
		//   . . 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	//    .
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
		iTemp = iTemp & 0x0FFFFFFF; //    .
		m_pClientList[iClientH]->m_iApprColor = iTemp;

		// V1.3   <-  0
		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		m_pClientList[iClientH]->m_iStatus = iTemp;
		break;

	case DEF_EQUIPPOS_LHAND:
		//   . . 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;	//    .
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
		iTemp = iTemp & 0xF0FFFFFF; //   .
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_TWOHAND:
		//      .   .
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	//    .
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
		iTemp = iTemp & 0x0FFFFFFF; //    .
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	//    .
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		//     .
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xFF7F;	
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
		iTemp = iTemp & 0xFF0FFFFF; //   .
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;	//    .
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
		iTemp = iTemp & 0xFFF0FFFF; //   .
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;	//    .
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
		iTemp = iTemp & 0xFFFF0FFF; //   .
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;	//    .
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
		iTemp = iTemp & 0xFFFFF0FF; //   .
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_LEGGINGS:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;	//    .
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
		iTemp = iTemp & 0xFFFFFF0F; //   .
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;	//    .
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
		iTemp = iTemp & 0xFFFFFFF0; //   .
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_RELEASEALL:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	//    .
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4   
		iTemp = iTemp & 0xFFF0FFFF; //    .
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
 	}

	//v1.432       
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
		//     
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;	
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		//     
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
	}
	
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = -1;
	
	//   .
	if (bNotice == TRUE)
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	//        . 
	CalcTotalItemEffect(iClientH, sItemIndex, TRUE);
}

BOOL CGame::_bInitNpcAttr(class CNpc * pNpc, char * pNpcName, short sClass, char cSA)
{
 int i, iTemp;
 char cTmpName[21];
 int sTemp;
 double dV1, dV2, dV3;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pNpcName);

	for (i = 0; i < DEF_MAXNPCTYPES; i++) 
	if (m_pNpcConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pNpcConfigList[i]->m_cNpcName, 20) == 0) {
			//    NPC  .  .
			ZeroMemory(pNpc->m_cNpcName, sizeof(pNpc->m_cNpcName));
			memcpy(pNpc->m_cNpcName, m_pNpcConfigList[i]->m_cNpcName, 20);
			
			pNpc->m_sType  = m_pNpcConfigList[i]->m_sType;
			
			// HitDice   .    .
			if (m_pNpcConfigList[i]->m_iHitDice <= 5)
				 pNpc->m_iHP  = abs(iDice(m_pNpcConfigList[i]->m_iHitDice, 4) + m_pNpcConfigList[i]->m_iHitDice);
			else pNpc->m_iHP  = abs((m_pNpcConfigList[i]->m_iHitDice * 4) + m_pNpcConfigList[i]->m_iHitDice + iDice(1, m_pNpcConfigList[i]->m_iHitDice));
			// v1.4 
			if (pNpc->m_iHP == 0) pNpc->m_iHP = 1; 

			//50Cent - HP Bar
			pNpc->m_iMaxHP = pNpc->m_iHP;

			pNpc->m_iExpDiceMin		 = m_pNpcConfigList[i]->m_iExpDiceMin;
			pNpc->m_iExpDiceMax		 = m_pNpcConfigList[i]->m_iExpDiceMax;
			pNpc->m_iGoldDiceMin	 = m_pNpcConfigList[i]->m_iGoldDiceMin;
			pNpc->m_iGoldDiceMax	 = m_pNpcConfigList[i]->m_iGoldDiceMax;
			pNpc->m_iExp			 = (iDice(1, (m_pNpcConfigList[i]->m_iExpDiceMax - m_pNpcConfigList[i]->m_iExpDiceMin)) + m_pNpcConfigList[i]->m_iExpDiceMin);

			pNpc->m_iHitDice           = m_pNpcConfigList[i]->m_iHitDice;   
			pNpc->m_iDefenseRatio      = m_pNpcConfigList[i]->m_iDefenseRatio;
			pNpc->m_iHitRatio          = m_pNpcConfigList[i]->m_iHitRatio;
			pNpc->m_iMinBravery        = m_pNpcConfigList[i]->m_iMinBravery;
			pNpc->m_cAttackDiceThrow   = m_pNpcConfigList[i]->m_cAttackDiceThrow;
			pNpc->m_cAttackDiceRange   = m_pNpcConfigList[i]->m_cAttackDiceRange;
			pNpc->m_cSize              = m_pNpcConfigList[i]->m_cSize;
			pNpc->m_cSide              = m_pNpcConfigList[i]->m_cSide;

			pNpc->m_dwTamingTime	   = 0; // Taming
			pNpc->m_cOriginalSide      = m_pNpcConfigList[i]->m_cSide;

			pNpc->m_cActionLimit       = m_pNpcConfigList[i]->m_cActionLimit;
			pNpc->m_dwActionTime       = m_pNpcConfigList[i]->m_dwActionTime;
			pNpc->m_dwRegenTime        = m_pNpcConfigList[i]->m_dwRegenTime;
			pNpc->m_cResistMagic       = m_pNpcConfigList[i]->m_cResistMagic;
			pNpc->m_cMagicLevel        = m_pNpcConfigList[i]->m_cMagicLevel;
			pNpc->m_iMaxMana           = m_pNpcConfigList[i]->m_iMaxMana; // v1.4
			pNpc->m_iMana              = m_pNpcConfigList[i]->m_iMaxMana;
			pNpc->m_cChatMsgPresence   = m_pNpcConfigList[i]->m_cChatMsgPresence;
			pNpc->m_cDayOfWeekLimit    = m_pNpcConfigList[i]->m_cDayOfWeekLimit;
			pNpc->m_cTargetSearchRange = m_pNpcConfigList[i]->m_cTargetSearchRange;
			pNpc->m_sAreaSize		   = m_pNpcConfigList[i]->m_sAreaSize;
			switch (sClass) {
			case 43:
			case 44:
			case 45:
			case 46:
			case 47: //        .
				pNpc->m_iAttackStrategy = DEF_ATTACKAI_NORMAL;
				break;

			default: 
				pNpc->m_iAttackStrategy = iDice(1,10); 
				break;
			}
	
			pNpc->m_iAILevel		   = iDice(1,3);
			pNpc->m_iAbsDamage         = m_pNpcConfigList[i]->m_iAbsDamage;
			pNpc->m_iMagicHitRatio     = m_pNpcConfigList[i]->m_iMagicHitRatio;
			pNpc->m_iAttackRange       = m_pNpcConfigList[i]->m_iAttackRange;
			pNpc->m_cSpecialAbility    = cSA;
			pNpc->m_iBuildCount		   = m_pNpcConfigList[i]->m_iMinBravery;

			// v1.411 NPC   .   
			switch (pNpc->m_cSpecialAbility) {
			case 1:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 25.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 2:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 30.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;
			
			case 3: // Absorbing Physical Damage
				if (pNpc->m_iAbsDamage > 0) {
					//            . 
					pNpc->m_cSpecialAbility = NULL;
					cSA = NULL;
				}
				else {
					iTemp = 20 + iDice(1, 60);
					pNpc->m_iAbsDamage -= iTemp;
					if (pNpc->m_iAbsDamage < -90) pNpc->m_iAbsDamage = -90;
				}

				dV2 = (double)pNpc->m_iExp;
				dV3 = (double)abs(pNpc->m_iAbsDamage)/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 4: // Absorbing Magical Damage
				if (pNpc->m_iAbsDamage < 0) {
					//            . 
					pNpc->m_cSpecialAbility = NULL;
					cSA = NULL;
				}
				else {
					iTemp = 20 + iDice(1, 60);
					pNpc->m_iAbsDamage += iTemp;
					if (pNpc->m_iAbsDamage > 90) pNpc->m_iAbsDamage = 90;
				}

				dV2 = (double)pNpc->m_iExp;
				dV3 = (double)(pNpc->m_iAbsDamage)/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 5:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 15.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 6:
			case 7:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 20.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 8:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 25.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;
			}

			// v1.411   
			pNpc->m_iNoDieRemainExp  = (pNpc->m_iExp) - (pNpc->m_iExp/3);

			// v1.411 NPC    
			pNpc->m_iStatus	= pNpc->m_iStatus & 0xFFFFF0FF;
			sTemp           = cSA;
			sTemp           = sTemp << 8;
			pNpc->m_iStatus = pNpc->m_iStatus | sTemp;
	
			// v1.41 NPC Class.
			pNpc->m_iStatus			   = pNpc->m_iStatus & 0xFFFFFFF0;
			pNpc->m_iStatus            = pNpc->m_iStatus | (sClass);
	
			return TRUE;
		}
	}

	// NPC    . 
	return FALSE;
}

/*********************************************************************************************************************
**  int CGame::iDice(int iThrow, int iRange)																		**
**  description			:: produces a random number between the throw and range										**
**  last updated		:: November 20, 2004; 10:24 PM; Hypnotoad													**
**	return value		:: int																						**
**********************************************************************************************************************/
int CGame::iDice(int iThrow, int iRange)
{
 int i, iRet;

	if (iRange <= 0) return 0;
	iRet = 0;
	for (i = 1; i <= iThrow; i++) {
		iRet += (rand() % iRange) + 1;
	}
	return iRet;
}

void CGame::TimeManaPointsUp(int iClientH)
{
 int iMaxMP, iTotal;
 double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;

	iMaxMP = iGetMaxMP(iClientH);// v1.4
	if (m_pClientList[iClientH]->m_iMP < iMaxMP) {
		iTotal = iDice(1, (m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag));
		if (m_pClientList[iClientH]->m_iAddMP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddMP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iMP += iTotal;
		
		if (m_pClientList[iClientH]->m_iMP > iMaxMP) 
			m_pClientList[iClientH]->m_iMP = iMaxMP;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
	}
}

// 05/29/2004 - Hypnotoad - fixed infinite sp bug
void CGame::TimeStaminarPointsUp(int iClientH)
{
 int iMaxSP, iTotal=0;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; // v1.4      .
	
	iMaxSP = iGetMaxSP(iClientH);
	if (m_pClientList[iClientH]->m_iSP < iMaxSP) {

		iTotal = iDice(1, (m_pClientList[iClientH]->m_iVit/3)); // Staminar Point 10 1D(Vit/3) .
		if (m_pClientList[iClientH]->m_iAddSP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddSP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}
	
		// v2.03  60     .
		if (m_pClientList[iClientH]->m_iLevel <= 20) {
			iTotal += 15;
		} else if ( m_pClientList[iClientH]->m_iLevel <= 40) {
			iTotal += 10;
		}  else if ( m_pClientList[iClientH]->m_iLevel <= 60) { 
			iTotal += 5;
		}

		m_pClientList[iClientH]->m_iSP += iTotal;
		if (m_pClientList[iClientH]->m_iSP > iMaxSP) 
			m_pClientList[iClientH]->m_iSP = iMaxSP;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
	}
}

void CGame::SendGuildMsg(int iClientH, WORD wNotifyMsgType, short sV1, short sV2, char * pString)
{
 char cData[500];
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 int i, iRet;
	
	//    
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ( (m_pClientList[i] != NULL) && 
		 (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) ) {

		// ### BUG POINT     . 
		ZeroMemory(cData, sizeof(cData));

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wNotifyMsgType;
	
		cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2);

		//       .
		switch (wNotifyMsgType) {
		case DEF_NOTIFY_GUILDDISBANDED:
			if (i == iClientH) break; // <--      .
			//        . 
			memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
			cp += 20;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 26);
			//    . @@@@@@@
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1;
			m_pClientList[i]->m_iGuildGUID = -1;
			break;

		case DEF_NOTIFY_EVENTMSGSTRING:
			//      
			strcpy(cp, pString);
			cp += strlen(pString);

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
			break;

		case DEF_NOTIFY_NEWGUILDSMAN:
		case DEF_NOTIFY_DISMISSGUILDSMAN:
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
			break;
		}
	
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			//     .
			DeleteClient(i, TRUE, TRUE);
			return;
		}
	}

}

void CGame::GuildNotifyHandler(char * pData, DWORD dwMsgSize)
{
 //     . 
 char * cp, cCharName[11], cGuildName[21];

	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	//   . 
}

void CGame::ToggleCombatModeHandler(int iClientH)
{
	short sAppr2;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	//      .
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;

	sAppr2 = (short)((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);

	m_pClientList[iClientH]->m_bIsAttackModeChange = TRUE; // v2.172


	if (sAppr2 == 0) {
		//  .  .
		m_pClientList[iClientH]->m_sAppr2 = (0xF000 | m_pClientList[iClientH]->m_sAppr2);
	}
	else {
		//  .  .
		m_pClientList[iClientH]->m_sAppr2 = (0x0FFF & m_pClientList[iClientH]->m_sAppr2);
	}

	//     .
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

}

void CGame::OnGateSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 int   iRet;
	
	if (m_pGateSock == NULL) return;

	iRet = m_pGateSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:
		PutLogList("(!!!) Gate-socket connected!");
		SendMsgToGateServer(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
		m_iGateSockConnRetryTimes = 0; // centuu
		break;

	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		//        .
		// v1.41 gate-socket     .    gate-socket     
		//             (4) . 
		m_iGateSockConnRetryTimes = 0;
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		//  .
		OnGateRead();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		//   .
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
		//      .	 .
	case DEF_XSOCKEVENT_SOCKETERROR:
		//   .
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		//  .
		delete m_pGateSock;
		m_pGateSock = NULL;
		PutLogList("(!!!) Gate-socket connection lost!");
		m_bIsGateSockAvailable = FALSE;

		// v1.41 Gate Server   
		m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
		m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
		// v1.41    
		m_iGateSockConnRetryTimes = 1;

		wsprintf(G_cTxt, "(!!!) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
		PutLogList(G_cTxt);

		
		break;
	}
}

void CGame::OnGateRead()
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pGateSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_GATESERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		//    .  .
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}

void CGame::SendMsgToGateServer(DWORD dwMsg, int iClientH, char * pData)
{
 DWORD * dwp;
 WORD  * wp;
 int     iRet, i;
 char    cData[1000], cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;

	if (m_pGateSock == NULL) {
		PutLogList("(!) SendMsgToGateServer fail - Socket to Gate-Server not available.");
		return;
	}

	ZeroMemory(cData, sizeof(cData));
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,  sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	switch (dwMsg) {
	// New 07/05/2004
	case MSGID_PARTYOPERATION:
		iRet = m_pGateSock->iSendMsg(pData, 50);
		break;

	case MSGID_SERVERSTOCKMSG:
		iRet = m_pGateSock->iSendMsg(pData, m_iIndexGSS+1);
		break;
	
	case MSGID_ITEMLOG:
		//   .  .
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_ITEMLOG;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cp, pData, 47);
		cp += 47;

		iRet = m_pGateSock->iSendMsg(cData, 53);
		break;
	
	case MSGID_REQUEST_REGISTERGAMESERVER:
		//     .
		wsprintf(cTxt, "(!) Try to register game server(%s) - GateServer", m_cServerName);
		PutLogList(cTxt);
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cAccountName, m_cServerName, 10);
		if (m_iGameServerMode == 1)
		{
			memcpy(cAddress, m_cGameServerAddrInternal, strlen(m_cGameServerAddrInternal));
		}
		if (m_iGameServerMode == 2)
		{
			memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));
		}

		memcpy(cp, cAccountName, 10);
		cp += 10;

		memcpy(cp, cAddress, 16);
		cp += 16;

		wp  = (WORD *)cp;
		*wp = m_iGameServerPort;
		cp += 2;

		*cp = m_iTotalMaps;
		cp++;

		for (i = 0; i < m_iTotalMaps; i++) {
			memcpy(cp, m_pMapList[i]->m_cName, 11);
			cp += 11;
		}
		
		dwp = (DWORD *)cp;
		*dwp = (DWORD)GetCurrentProcessId();	 //   .

		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = DEF_BUILDDATE;

		iRet = m_pGateSock->iSendMsg(cData, 43 + m_iTotalMaps*11);
		break;

	case MSGID_GAMESERVERALIVE:
		//      
		//              .
		if (m_bIsLogSockAvailable == FALSE) return;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERALIVE;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp  = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		wp  = (WORD *)cp;
		*wp = m_iTotalClients;
		cp += 2;
		
		iRet = m_pGateSock->iSendMsg(cData, 8);
		break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		//      .
		PutLogList("(***) Socket to Gate-Server crashed! Critical error!");
		delete m_pGateSock;
		m_pGateSock = NULL;
		m_bIsGateSockAvailable = FALSE;

		// v1.41 Gate Server  :     . 
		m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
		m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
		// v1.41    
		m_iGateSockConnRetryTimes = 1;	

		wsprintf(G_cTxt, "(!) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
		PutLogList(G_cTxt);

		
		return;
	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: checks if player is casting magic
//  last updated		:: October 29, 2004; 6:51 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
{
 char  cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 		
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	
	ClearSkillUsingStatus(iClientH);

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	if ( (m_pClientList[iClientH]->m_iStatus & 0x10) != 0 )	{
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);		
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
	}

	m_pClientList[iClientH]->m_cDir = cDir;
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

/*********************************************************************************************************************
**  void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, BOOL bItemEffect, int iV1)			**
**  description			:: handles all magic related items/spells													**
**  last updated		:: November 22, 2004; 5:45 PM; Hypnotoad													**
**	return value		:: void																						**
**  commentary			::	-	added 3.51 casting detection														**
**							-	updated it so civilians can only cast certain spells on players and vice versa		**
**							-	fixed bug causing spell to be cast when mana is below required amount				**
**********************************************************************************************************************/
int  _tmp_iMCProb[]        = {0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40};
int  _tmp_iMLevelPenalty[] = {0,   5,   5,   8,   8,  10, 14, 28, 32, 36, 40};
void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, BOOL bItemEffect, int iV1)
{
	short  * sp, sX, sY, sOwnerH, sMagicCircle, rx, ry, sRemainItemSprite, sRemainItemSpriteFrame, sLevelMagic, sTemp;
	char   * cp, cData[120], cDir, cOwnerType, cName[11], cItemName[21], cNpcWaypoint[11], cName_Master[11], cNpcName[21], cRemainItemColor, cScanMessage[256];
	double dV1, dV2, dV3, dV4;
	int    i, iErr, iRet, ix, iy, iResult, iDiceRes, iNamingValue, iFollowersNum, iEraseReq, iWhetherBonus;
	int    tX, tY, iManaCost, iMagicAttr;
	class  CItem * pItem;
	DWORD * dwp, dwTime;
	WORD  * wp, wWeaponType;
	short sEqStatus;

	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_bMagicConfirm = TRUE;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
		(dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return;

	if (((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) < 800) && (bItemEffect == 0)) { // 1000 -> 800
		wsprintf(G_cTxt, "3.51 Detection: (%s) Player: (%s) - Magic casting speed is too fast! Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
	m_pClientList[iClientH]->m_dwLastActionTime = m_pClientList[iClientH]->m_dwAFKCheckTime = dwTime;

	if (m_pClientList[iClientH]->m_cMapIndex < 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] == NULL) return;

	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == NULL) return;

	if ((bItemEffect == FALSE) && (m_pClientList[iClientH]->m_cMagicMastery[sType] != 1)) return;

	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;
	
	if (((m_pClientList[iClientH]->m_iStatus & 0x100000) != 0) && (bItemEffect != TRUE)) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, NULL, -1, NULL);
			return;
	}

	if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);		
		if ((wWeaponType >= 34) && (wWeaponType <= 39)) {
		}
		else return;
	}

	if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND]   != -1) ||
		(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)) return;

	if ((m_pClientList[iClientH]->m_iSpellCount > 1) && (bItemEffect == FALSE)) {
		wsprintf(G_cTxt, "TSearch Spell Hack: (%s) Player: (%s) - casting magic without precasting.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	if (m_pClientList[iClientH]->m_bInhibition == TRUE) {
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
		return;
	}

	
	
	if (m_pMagicConfigList[sType]->m_sType == 32) { // Invisiblity
		sEqStatus = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		if ((sEqStatus != -1) && (m_pClientList[iClientH]->m_pItemList[sEqStatus] != NULL)) {
			if((m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum == 866)) {
				bItemEffect = TRUE;
			}
		}
	}

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	sMagicCircle = (sType / 10) + 1;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] == 0)
		dV1 = 1.0f;
	else dV1 = (double)m_pClientList[iClientH]->m_cSkillMastery[4];

	if (bItemEffect == TRUE) dV1 = (double)100.0f;
	dV2 = (double)(dV1 / 100.0f);
	dV3 = (double)_tmp_iMCProb[sMagicCircle];
	dV1 = dV2 * dV3;
	iResult = (int)dV1;

	if ((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt) > 50)
		iResult += ((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt) - 50)/2;

	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;
			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			iResult += 5*abs(sMagicCircle - sLevelMagic);
		}
	}

	switch (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus) {
	case 0: break;
	case 1: iResult = iResult - (iResult / 24); break;
	case 2:	iResult = iResult - (iResult / 12); break;
	case 3: iResult = iResult - (iResult / 5);  break;
	}

	if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == 10) {
		dV1 = (double)iResult;
		dV2 = (double)(m_pClientList[iClientH]->m_iSpecialWeaponEffectValue * 3);
		dV3 = dV1 + dV2;
		iResult = (int)dV3;
	}

	if (iResult <= 0) iResult = 1;

	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus);

	iManaCost = m_pMagicConfigList[sType]->m_sValue1;
	if ((m_pClientList[iClientH]->m_bIsSafeAttackMode == TRUE) && 
		(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)) {
		//SNOOPY: Spell in safe mode only cost 10% more	
			iManaCost += (iManaCost / 10);
		}
		
		if (m_pClientList[iClientH]->m_iManaSaveRatio > 0) {
			dV1 = (double)m_pClientList[iClientH]->m_iManaSaveRatio;
			dV2 = (double)(dV1 / 100.0f);
			dV3 = (double)iManaCost;
			dV1 = dV2 * dV3;	
			dV2 = dV3 - dV1; 
			iManaCost = (int)dV2;

			if (iManaCost <= 0) iManaCost = 1;
		}

		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 34) {
			iManaCost += 20;
		}

		if (iResult < 100) {
			iDiceRes = iDice(1,100);
			if (iResult < iDiceRes) {
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
				return;
			}
		}

		if (((m_pClientList[iClientH]->m_iHungerStatus <= 10) || (m_pClientList[iClientH]->m_iSP <= 0)) && (iDice(1,1000) <= 100)) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
			return;	
		}

		if (m_pClientList[iClientH]->m_iMP < iManaCost) {
			return;
		}

		iResult = m_pClientList[iClientH]->m_cSkillMastery[4];
		if ((m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag) > 50) iResult += ((m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag) - 50); 	

		sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
		if (sMagicCircle != sLevelMagic) {
			if (sMagicCircle > sLevelMagic) {
				dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic*10);
				dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
				dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
				dV4 = (dV1 / dV3)*dV2;

				iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
			}
			else {
				iResult += 5*abs(sMagicCircle - sLevelMagic);
			}
		}

		iResult += m_pClientList[iClientH]->m_iMagicHitRatio_ItemEffect; // snoopy
		iResult += m_pClientList[iClientH]->m_iAddAR;
		if (iResult <= 0) iResult = 1;

		if (sType >= 80) iResult += 10000;

		if (m_pMagicConfigList[sType]->m_sType == 28) {
			iResult += 10000;
		}
		
		if (m_pMagicConfigList[sType]->m_cCategory == 1) {
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000005) != 0) return;
		}

		iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;
		if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
			SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
			m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
		}

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		if ((m_bIsCrusadeMode == FALSE) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
			if ((m_pClientList[iClientH]->m_bIsPlayerCivil != TRUE) && (m_pClientList[sOwnerH]->m_bIsPlayerCivil == TRUE)) {
				if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) return;
			}
			else if ((m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE) && (m_pClientList[sOwnerH]->m_bIsPlayerCivil == FALSE)) {
				switch (m_pMagicConfigList[sType]->m_sType) {
					case 1:  // DEF_MAGICTYPE_DAMAGE_SPOT
					case 4:  // DEF_MAGICTYPE_SPDOWN_SPOT 4
					case 8:  // DEF_MAGICTYPE_TELEPORT 8
					case 10: // DEF_MAGICTYPE_CREATE 10
					case 11: // DEF_MAGICTYPE_PROTECT 11
					case 12: // DEF_MAGICTYPE_HOLDOBJECT 12
					case 16: // DEF_MAGICTYPE_CONFUSE
					case 17: // DEF_MAGICTYPE_POISON
					case 24: // DEF_MAGICTYPE_RESURRECTION
						goto MAGIC_NOEFFECT; 
						return;
				}
			}
		}

		if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
			switch (m_pMagicConfigList[sType]->m_sType) {
				
				case DEF_MAGICTYPE_DAMAGE_SPOT:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					}
					break;
				
				case DEF_MAGICTYPE_HPUP_SPOT:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
					break;

				case DEF_MAGICTYPE_DAMAGE_AREA:

					// Central point strike (harder to resist this attack)
					if (m_pMagicConfigList[sType]->m_sType >= 80) iResult += 100; // Hard to resist MS

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);

					//Dead Owner central strike
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					}

					// Fly from targeted point with no double strike/fly...
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy < dY; iy++)// up left
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix < dX; ix++) 
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
					for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY; iy--)// down left
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix < dX; ix++) 
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy < dY; iy++)
					for (ix = dX + m_pMagicConfigList[sType]->m_sValue2 ; ix >= dX; ix--) // up right
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
					for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY; iy--) // down right
					for (ix = dX + m_pMagicConfigList[sType]->m_sValue2; ix >= dX; ix--) 
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
					// Dead owner will not fly
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);				
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) 
						{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}	}
					break;				
				
				case DEF_MAGICTYPE_SPDOWN_SPOT:
					break;

				case DEF_MAGICTYPE_SPDOWN_AREA:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}
					break;
				
				case DEF_MAGICTYPE_POLYMORPH:
					//  . 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (1) { 
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								//    .
								m_pClientList[sOwnerH]->m_sOriginalType = m_pClientList[sOwnerH]->m_sType;
								//    .
								m_pClientList[sOwnerH]->m_sType = 18;
								SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								//    .
								m_pNpcList[sOwnerH]->m_sOriginalType = m_pNpcList[sOwnerH]->m_sType;
								//    .
								m_pNpcList[sOwnerH]->m_sType = 18;
								SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
								break;
						}

						//        .
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_POLYMORPH, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						//   .
						if (cOwnerType == DEF_OWNERTYPE_PLAYER)
						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POLYMORPH, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
					}
					break;

				// 05/20/2004 - Hypnotoad - Cancellation
				case DEF_MAGICTYPE_CANCELLATION:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) && (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)) {

						// Removes Invisibility Flag 0x0010
						SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);

						// Removes Illusion Flag 0x01000000
						SetIllusionFlag(sOwnerH, cOwnerType, FALSE);

						// Removes Defense Shield Flag 0x02000000
						// Removes Great Defense Shield Flag 0x02000000
						SetDefenseShieldFlag(sOwnerH, cOwnerType, FALSE);

						// Removes Absolute Magic Protection Flag 0x04000000	
						// Removes Protection From Magic Flag 0x04000000
						SetMagicProtectionFlag(sOwnerH, cOwnerType, FALSE);

						// Removes Protection From Arrow Flag 0x08000000
						SetProtectionFromArrowFlag(sOwnerH, cOwnerType, FALSE);

						// Removes Illusion Movement Flag 0x00200000
						SetIllusionMovementFlag(sOwnerH, cOwnerType, FALSE);

						// Removes Berserk Flag 0x0020
						SetBerserkFlag(sOwnerH, cOwnerType, FALSE);

						if (m_pClientList[iClientH]->m_bInhibition == TRUE)
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INHIBITION);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						if (m_pClientList[iClientH]->m_iStatus & 0x0010)
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						if (m_pClientList[iClientH]->m_iStatus & 0x0020)
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_BERSERK);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						if ( (m_pClientList[iClientH]->m_iStatus & 0x08000000) || (m_pClientList[iClientH]->m_iStatus & 0x04000000) || (m_pClientList[iClientH]->m_iStatus & 0x02000000))
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						if ((m_pClientList[iClientH]->m_iStatus & 0x01000000) || (m_pClientList[iClientH]->m_iStatus & 0x00200000))
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_CONFUSE);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						// Update Client
						SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}
					break;

				case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT_SPDOWN: //25 // EWS (will fly in random position)
					// 1st remove SP and raise PretentCorpse characters
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
					{	// SNOOPY: Damage is on 456, Special SPdown on 789
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iMagicAttr + 10200) == FALSE) 
						{	// SP down effect will pass PFM and attack as +200
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						}
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
								 && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
						{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iMagicAttr+ 10200) == FALSE) 
							{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, 10 + m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, 10 + m_pMagicConfigList[sType]->m_sValue9);
					}	}	}
					// Then damage (may Fly pcs/mobs) // No chance to MR this spell
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					// Fly from targeted point with not double strike/fly...
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy < dY; iy++)// up left
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix < dX; ix++) 
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, -1) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
					for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY; iy--)// down left
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix < dX; ix++) 
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, -1) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy < dY; iy++)
					for (ix = dX + m_pMagicConfigList[sType]->m_sValue2 ; ix >= dX; ix--) // up right
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, -1) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
					for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY; iy--) // down right
					for (ix = dX + m_pMagicConfigList[sType]->m_sValue2; ix >= dX; ix--) 
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, -1) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}					
					break;

				case DEF_MAGICTYPE_DAMAGE_LINEAR: //19 BSW & LightBolt for players
					// m_sValue456 = Spot damage
					// m_sValue789 = Linear damage
					// m_sValue789 = Area damage		
					for (i = 2; i < 10; i++) { // Max range is 10
						iErr = 0; // Bigger would change to a less linear line (more concave)
						// Linear damage: (1 on Target and Caster)
						//   1 1 1 1 1 1  
						// M 2 3 3 3 3 2 T
						//   1 1 1 1 1 1 
						m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
						// tx, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
						{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
						// tx-1, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
						{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
						// tx+1, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
						{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
						// tx, ty-1
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) )
						{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
						// tx, ty+1
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
						{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
						//  Break if we reach the target point
						if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
					}
					// Area damage around target: m_sValue789, Deadowner
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
						{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
					}	
					// Area damage around target: m_sValue789: Alive owner									
					if ((dX >= sX) && (dY >= sY))
					{	for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
						for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						}					
					}else if ((dX >= sX) && (dY < sY)) 
					{	for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
						for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY - m_pMagicConfigList[sType]->m_sValue3; iy--)
						{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						}	
					}else if((dX < sX) && (dY >= sY))  
					{	for (ix = dX + m_pMagicConfigList[sType]->m_sValue2; ix >= dX - m_pMagicConfigList[sType]->m_sValue2; ix--) 
						for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						}	
					}else  
					{	for (ix = dX + m_pMagicConfigList[sType]->m_sValue2; ix >= dX - m_pMagicConfigList[sType]->m_sValue2; ix--) 
						for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY - m_pMagicConfigList[sType]->m_sValue3; iy--)
						{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						}
					}
					// Spot damage over Target m_sValue456
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
					}
					break;

				// v2.16 2002-5-23  
				case DEF_MAGICTYPE_ICE_LINEAR:
					//       .
					sX = m_pClientList[iClientH]->m_sX;
					sY = m_pClientList[iClientH]->m_sY;

					for (i = 2; i < 10; i++) {
						iErr = 0;
						m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

						// tx, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							//    
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (m_pClientList[sOwnerH]->m_iHP < 0) goto MAGIC_NOEFFECT;
									//      .
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											//       .
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											//    .
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											//       .
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								//    .
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									//    
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											//      .
											if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													//       .
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													//    .
													SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													//       .
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												}
											}
											break;
									}
									//
								}
							}

							// tx-1, ty
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								//    
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										//      .
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												//       .
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												//    .
												SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
											}
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												//       .
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											}
										}
										break;
								}
								//
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									//    .
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										//    
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												//      .
												if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
													if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, TRUE);
														//       .
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
														//    .
														SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
													}
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
													if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, TRUE);
														//       .
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													}
												}
												break;
										}
										//
									}
								}

								// tx+1, ty
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									//    
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											//      .
											if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													//       .
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													//    .
													SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													//       .
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												}
											}
											break;
									}
									//
								}

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
									(m_pClientList[sOwnerH]->m_iHP > 0) ) {
										//    .
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
											//    
											switch (cOwnerType) {
												case DEF_OWNERTYPE_PLAYER:
													if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													//      .
													if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
														if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
															m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
															SetIceFlag(sOwnerH, cOwnerType, TRUE);
															//       .
															bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
															//    .
															SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
														}
													}
													break;

												case DEF_OWNERTYPE_NPC:
													if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
														if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
															m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
															SetIceFlag(sOwnerH, cOwnerType, TRUE);
															//       .
															bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
														}
													}
													break;
											}
											//
										}
									}

									// tx, ty-1
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										//    
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												//      .
												if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
													if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, TRUE);
														//       .
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
														//    .
														SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
													}
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
													if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, TRUE);
														//       .
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													}
												}
												break;
										}
										//
									}

									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
										(m_pClientList[sOwnerH]->m_iHP > 0) ) {
											//    .
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
												//    
												switch (cOwnerType) {
													case DEF_OWNERTYPE_PLAYER:
														if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
														//      .
														if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
															if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
																m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
																SetIceFlag(sOwnerH, cOwnerType, TRUE);
																//       .
																bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																	sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
																//    .
																SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
															}
														}
														break;

													case DEF_OWNERTYPE_NPC:
														if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
														if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
															if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
																m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
																SetIceFlag(sOwnerH, cOwnerType, TRUE);
																//       .
																bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																	sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
															}
														}
														break;
												}
												//
											}
										}

										// tx, ty+1
										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
											//    
											switch (cOwnerType) {
												case DEF_OWNERTYPE_PLAYER:
													if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													//      .
													if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
														if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
															m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
															SetIceFlag(sOwnerH, cOwnerType, TRUE);
															//       .
															bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
															//    .
															SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
														}
													}
													break;

												case DEF_OWNERTYPE_NPC:
													if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
														if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
															m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
															SetIceFlag(sOwnerH, cOwnerType, TRUE);
															//       .
															bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
														}
													}
													break;
											}
											//
										}

										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
											(m_pClientList[sOwnerH]->m_iHP > 0) ) {
												//    .
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
													//    
													switch (cOwnerType) {
														case DEF_OWNERTYPE_PLAYER:
															if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
															//      .
															if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
																if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
																	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
																	SetIceFlag(sOwnerH, cOwnerType, TRUE);
																	//       .
																	bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																		sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
																	//    .
																	SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
																}
															}
															break;

														case DEF_OWNERTYPE_NPC:
															if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
															if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
																if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
																	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
																	SetIceFlag(sOwnerH, cOwnerType, TRUE);
																	//       .
																	bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																		sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
																}
															}
															break;
													}
													//
												}
											}

											if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
					}

					//    
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							//     .
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								//    
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										//      .
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												//       .
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												//    .
												SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
											}
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												//       .
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											}
										}
										break;
								}
								//
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									//    .
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										//    
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												//      .
												if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
													if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, TRUE);
														//       .
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
														//    .
														SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
													}
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
													if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, TRUE);
														//       .
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													}
												}
												break;
										}
										//
									}
								}
						}

						// dX, dY
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
							//    
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									//      .
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											//       .
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											//    .
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											//       .
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
							//
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								//    .
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
									//    
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											//      .
											if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													//       .
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													//    .
													SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													//       .
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												}
											}
											break;
									}
									//
								}
							}
							break;


				case DEF_MAGICTYPE_INHIBITION:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if ((m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5) || (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)) goto MAGIC_NOEFFECT; // juan - ic fix para que no pegue si tiene AMP o PFM .
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INHIBITION ] != 0) goto MAGIC_NOEFFECT;
						if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT ;
						m_pClientList[sOwnerH]->m_bInhibition = TRUE;
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
						break;
					}
					break;
	
				
				case DEF_MAGICTYPE_TREMOR: // 22 TREMOR is same than DamageArea but will not Fly you 
					// Standing character have no chance to resist Tremor	
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingTremorSuccess(sOwnerH, cOwnerType) == FALSE) 
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
						&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (bCheckResistingTremorSuccess(sOwnerH, cOwnerType) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					}
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingTremorSuccess(sOwnerH, cOwnerType) == FALSE) 
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL)
							&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
						{	if (bCheckResistingTremorSuccess(sOwnerH, cOwnerType) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
					}
					break;

				case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT: //21 (fly from caster, and possibly multiple fly/strike !)
					if ((dX >= sX) && (dY >= sY))
					{	for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
						for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						}					
					}else if ((dX >= sX) && (dY < sY)) 
					{	for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
						for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY - m_pMagicConfigList[sType]->m_sValue3; iy--)
						{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						}	
					}else if((dX < sX) && (dY >= sY))  
					{	for (ix = dX + m_pMagicConfigList[sType]->m_sValue2; ix >= dX - m_pMagicConfigList[sType]->m_sValue2; ix--) 
						for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						}	
					}else 
					{	for (ix = dX + m_pMagicConfigList[sType]->m_sValue2; ix >= dX - m_pMagicConfigList[sType]->m_sValue2; ix--) 
						for (iy = dY + m_pMagicConfigList[sType]->m_sValue3; iy >= dY - m_pMagicConfigList[sType]->m_sValue3; iy--)
						{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						}
					}
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
							&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
						{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						}
					}
					break;

				case DEF_MAGICTYPE_SPUP_AREA:
					// Sp .
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					//   . 
					Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
					//    
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							//     .
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							//   .
							Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						}
						break;

				case DEF_MAGICTYPE_DAMAGE_LINEAR_SPDOWN: //30 ESW
					//  m_sValue4 5 6 used for damage target
					//  m_sValue7 8 9 used for damage Linear, Area 
					//  m_sValue10 11 12 used for SP down
					for (i = 2; i < 10; i++) 
					{	iErr = 0;
						m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
						// tx, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE) 
						{	switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) break;
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
								break;
							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) break;
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
								break;						
						}	}
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
						{	if (m_pClientList[sOwnerH] == NULL) continue;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE) 
							{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						}	}

						// tx-1, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE) 
						{	switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) break;
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
								break;
							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) break;
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
								break;							
						}	}
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) )
						{	if (m_pClientList[sOwnerH] == NULL) continue;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE)
							{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						}	}

						// tx+1, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE) 
						{	switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) break;
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
								break;
							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) break;
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
								break;							
						}	}
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
						{	if (m_pClientList[sOwnerH] == NULL) continue;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType+100, iResult) == FALSE) 
							{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						}	}

						// tx, ty-1
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE) 
						{	switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) break;
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
									break;
							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) break;
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
								break;						
						}	}
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
						{	if (m_pClientList[sOwnerH] == NULL) continue;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE) 
							{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						}	}

						// tx, ty+1
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE) 
						{	switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) break;
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
								break;
							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) break;
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
								break;
						}	}
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
						{	if (m_pClientList[sOwnerH] == NULL) continue;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE) 
							{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						}	}
						// Do not strike again if target is close to caster
						if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
					}
					// Area Damage
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					{	for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
						{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE) 
							{	switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) break;
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
									break;
								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) break;
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
									break;							
							}	}
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
							{	if (m_pClientList[sOwnerH] == NULL) break;
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE) 
								{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
					}	}	}	}

					// Damage on Target m_sValue456
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+50) == FALSE) 
					{	switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
							break;
					}	}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (m_pClientList[sOwnerH] == NULL) break;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult+100) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
					}	}					
					break;

				case DEF_MAGICTYPE_TELEPORT:
					//  . sValue 4    .
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1:
					//    . Recall.
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH == iClientH) ) {
						//  Recall  .
						RequestTeleportHandler(iClientH, "1   ");
					}
					break;
					}
					break;

				case DEF_MAGICTYPE_SUMMON:
					//  

					//    .
					if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) return;

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					//  Owner Master . 
					if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
						// Master       . 
						iFollowersNum = iGetFollowerNumber(sOwnerH, cOwnerType);

						//  Casting  Magery/20     .
						if (iFollowersNum >= (m_pClientList[iClientH]->m_cSkillMastery[4]/20)) break;

						iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
						if (iNamingValue == -1) {
							//    NPC  .     .
						}
						else {
							// NPC .
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = '_';
							cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;

							// Magery     .
							ZeroMemory(cNpcName, sizeof(cNpcName));

							switch (iV1) {
								case NULL: //   
									iResult = iDice(1, m_pClientList[iClientH]->m_cSkillMastery[4] / 10);

									// v1.42     
									if (iResult < m_pClientList[iClientH]->m_cSkillMastery[4] / 20) 
										iResult = m_pClientList[iClientH]->m_cSkillMastery[4] / 20;

									switch (iResult) {
										case 1: strcpy(cNpcName, "Slime"); break;
										case 2: strcpy(cNpcName, "Giant-Ant"); break;
										case 3: strcpy(cNpcName, "Amphis"); break;
										case 4: strcpy(cNpcName, "Orc"); break;
										case 5: strcpy(cNpcName, "Skeleton"); break;
										case 6:	strcpy(cNpcName, "Clay-Golem"); break;
										case 7:	strcpy(cNpcName, "Stone-Golem"); break;
										case 8: strcpy(cNpcName, "Orc-Mage"); break;
										case 9:	strcpy(cNpcName, "Hellbound"); break;
										case 10:strcpy(cNpcName, "Cyclops"); break;
									}
									break;

								case 1:	strcpy(cNpcName, "Orc"); break;
								case 2: strcpy(cNpcName, "Skeleton"); break;
								case 3: strcpy(cNpcName, "Clay-Golem"); break;
								case 4: strcpy(cNpcName, "Stone-Golem"); break;
								case 5: strcpy(cNpcName, "Hellbound"); break;
								case 6: strcpy(cNpcName, "Cyclops"); break;
								case 7: strcpy(cNpcName, "Troll"); break;
								case 8: strcpy(cNpcName, "Orge"); break;
							case 9: // SummonScroll(SOR)
							switch (m_pClientList[iClientH]->m_cSide) {
								case 1:  strcpy(cNpcName, "Sor-Aresden"); break;
								case 2:  strcpy(cNpcName, "Sor-Elvine"); break;
								default: strcpy(cNpcName, "Evil-Sorceress"); break;
							} 
							break;
						case 10: // SummonScroll(ATK)
							switch (m_pClientList[iClientH]->m_cSide) {
								case 1:  strcpy(cNpcName, "ATK-Aresden"); break;
								case 2:  strcpy(cNpcName, "ATK-Elvine"); break;
								default: strcpy(cNpcName, "Evil-ATK"); break;
							}
							break;
						case 11: // SummonScroll(ELF)
							switch (m_pClientList[iClientH]->m_cSide) {
								case 1:  strcpy(cNpcName, "Elf-Aresden"); break;
								case 2:  strcpy(cNpcName, "Elf-Elvine"); break;
								default: strcpy(cNpcName, "Evil-Elf"); break;
							}
							break;
						case 12: // SummonScroll(DSK)	
							switch (m_pClientList[iClientH]->m_cSide) {
								case 1:  strcpy(cNpcName, "DSK-Aresden"); break;
								case 2:  strcpy(cNpcName, "DSK-Elvine"); break;
								default: strcpy(cNpcName, "Evil-DSK"); break;
							}
							break;
						case 13: // SummonScroll(HBT)
							switch (m_pClientList[iClientH]->m_cSide) {
								case 1:  strcpy(cNpcName, "HBT-Aresden"); break;
								case 2:  strcpy(cNpcName, "HBT-Elvine"); break;
								default: break;
							}
							break;
						case 14: // SummonScroll(BAR)
							switch (m_pClientList[iClientH]->m_cSide) {
								case 1:  strcpy(cNpcName, "Bar-Aresden"); break;
								case 2:  strcpy(cNpcName, "Bar-Elvine"); break;
								default: strcpy(cNpcName, "Evil-Barbarian"); break;
								}
							break;
							}

							if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypoint, NULL, NULL, m_pClientList[iClientH]->m_cSide, FALSE, TRUE) == FALSE) {
								//   NameValue .
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
							}
							else {
								ZeroMemory(cName_Master, sizeof(cName_Master));
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										memcpy(cName_Master, m_pClientList[sOwnerH]->m_cCharName, 10);
										break;
									case DEF_OWNERTYPE_NPC:
										memcpy(cName_Master, m_pNpcList[sOwnerH]->m_cName, 5);
										break;
								}
								bSetNpcFollowMode(cName, cName_Master, cOwnerType);
							}
						}
					}
					break;

				case DEF_MAGICTYPE_CREATE:
					//    

					//      . 
					if ( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsMoveAllowedTile(dX, dY) == FALSE )
						goto MAGIC_NOEFFECT;

					pItem = new class CItem;

					switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1:
					// Food
					if (iDice(1,2) == 1)
						wsprintf(cItemName, "Meat");
					else wsprintf(cItemName, "Baguette");
					break;
					}

					_bInitItemAttr(pItem, cItemName);

					// v2.15      
					pItem->m_sTouchEffectType   = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = iDice(1,100000);
					pItem->m_sTouchEffectValue2 = iDice(1,100000);
					pItem->m_sTouchEffectValue3 = (short)timeGetTime();

					//    . 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);

					// v1.41      . 
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);

					//      . 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						dX, dY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
					break;

				case DEF_MAGICTYPE_PROTECT:
					//   
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					//             . 
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
							// v1.4334     
							if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
							switch (m_pMagicConfigList[sType]->m_sValue4){
							case 1:
								SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
								break;
							case 2:
							case 5:
								SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
								break;
							case 3:
							case 4:
								SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
								break;
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
							//  NPC    .				
							if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
							m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;

							switch (m_pMagicConfigList[sType]->m_sValue4){
							case 1:
								SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
								break;
							case 2:
							case 5:
								SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
								break;
							case 3:
							case 4:
								SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
								break;
							}
							break;
					}

					//        .
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
						sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

					//   .
					if (cOwnerType == DEF_OWNERTYPE_PLAYER)
						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_PROTECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
					break;
					

				case DEF_MAGICTYPE_SCAN:
					ZeroMemory(cScanMessage, sizeof(cScanMessage));
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								wsprintf(cScanMessage, " Player: %s HP:%d MP:%d.", m_pClientList[sOwnerH]->m_cCharName, m_pClientList[sOwnerH]->m_iHP, m_pClientList[sOwnerH]->m_iMP);
								ShowClientMsg(iClientH, cScanMessage);
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								wsprintf(cScanMessage, " NPC: %s HP:%d MP:%d", m_pNpcList[sOwnerH]->m_cNpcName, m_pNpcList[sOwnerH]->m_iHP, m_pNpcList[sOwnerH]->m_iMana);
								ShowClientMsg(iClientH, cScanMessage);
								break;
						}
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, 10, 10);
					}
					break;

				case DEF_MAGICTYPE_HOLDOBJECT:
					//   . 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto MAGIC_NOEFFECT;
								// v1.4334     
								if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;
								// 2002-09-10 #2 (No-Attack-Area)    
								if (  cOwnerType == DEF_OWNERTYPE_PLAYER )  {

									if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
									if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
								}

								// 2002-09-10 #3       
								if( strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "middleland") != 0 &&
									m_bIsCrusadeMode == FALSE &&
									m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide )
									goto MAGIC_NOEFFECT;

								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto MAGIC_NOEFFECT; // v1.4   6        .
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								break;
						}

						//        .
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						//   .
						if (cOwnerType == DEF_OWNERTYPE_PLAYER)
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
					}
					break;

				case DEF_MAGICTYPE_INVISIBILITY:
					switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;
							if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT ;

							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
							SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
							RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;

							if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) {
								//   NPC     .
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
								//  NPC    .
								RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);	
							}
							break;
							}

							//       .
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

							if (cOwnerType == DEF_OWNERTYPE_PLAYER)
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
							break;

						case 2:
							// v1.4334     
							if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

							// dX, dY  8  Invisibility  Object   .
							for (ix = dX - 8; ix <= dX + 8; ix++)
								for (iy = dY - 8; iy <= dY + 8; iy++) {
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
									if (sOwnerH != NULL) {
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
													SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
													bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
													SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
													bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
												}
												break;
										}
									}
								}
								break;
					}
					break;

				case DEF_MAGICTYPE_CREATE_DYNAMIC:
					// Dynamic Object    .

					// v2.1     ( )
					if (m_bIsCrusadeMode == FALSE) {
						if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) return;
						if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) return;
						// v2.14
						if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) return;
						if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0) return;
					}

					switch (m_pMagicConfigList[sType]->m_sValue10) {
				case DEF_DYNAMICOBJECT_PCLOUD_BEGIN: // 

				case DEF_DYNAMICOBJECT_FIRE:   // Fire .
				case DEF_DYNAMICOBJECT_SPIKE:  // Spike

					switch (m_pMagicConfigList[sType]->m_sValue11) {
				case 1: 
					// wall - type
					cDir = m_Misc.cGetNextMoveDir(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY);
					switch (cDir) {
				case 1:	rx = 1; ry = 0;   break;
				case 2: rx = 1; ry = 1;   break;
				case 3: rx = 0; ry = 1;   break;
				case 4: rx = -1; ry = 1;  break;
				case 5: rx = 1; ry = 0;   break;
				case 6: rx = -1; ry = -1; break;
				case 7: rx = 0; ry = -1;  break;
				case 8: rx = 1; ry = -1;  break;
					}

					iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
						dX, dY, m_pMagicConfigList[sType]->m_dwLastTime*1000);	

					bAnalyzeCriminalAction(iClientH, dX, dY);

					for (i = 1; i <= m_pMagicConfigList[sType]->m_sValue12; i++) {
						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
							dX + i*rx, dY + i*ry, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
						bAnalyzeCriminalAction(iClientH, dX + i*rx, dY + i*ry);

						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
							dX - i*rx, dY - i*ry, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
						bAnalyzeCriminalAction(iClientH, dX - i*rx, dY - i*ry);
					}
					break;

				case 2:
					// Field - Type
					BOOL bFlag = FALSE;
					int cx, cy;
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue12; ix <= dX + m_pMagicConfigList[sType]->m_sValue12; ix++)
						for (iy = dY - m_pMagicConfigList[sType]->m_sValue12; iy <= dY + m_pMagicConfigList[sType]->m_sValue12; iy++) {
							iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
								ix, iy, m_pMagicConfigList[sType]->m_dwLastTime*1000, m_pMagicConfigList[sType]->m_sValue5);	

							//             . 
							if (bAnalyzeCriminalAction(iClientH, ix, iy, TRUE) == TRUE) {
								bFlag = TRUE;
								cx = ix;
								cy = iy;
							}
						}
						//    1  .
						if (bFlag == TRUE) bAnalyzeCriminalAction(iClientH, cx, cy);
						break;
					}
					//
					break;

				case DEF_DYNAMICOBJECT_ICESTORM:
					// Ice-Storm Dynamic Object 
					iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
						dX, dY, m_pMagicConfigList[sType]->m_dwLastTime*1000,
						m_pClientList[iClientH]->m_cSkillMastery[4]);	
					break;

				default:
					break;
					}
					break;

				case DEF_MAGICTYPE_POSSESSION:
					//      . 
					// v2.12      
					if (m_pClientList[iClientH]->m_cSide == NULL) goto MAGIC_NOEFFECT;

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (sOwnerH != NULL) break; // v1.41        . 

					pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(dX, dY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
					if (pItem != NULL) {
						//   . 
						if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
							//  .

							// v1.411  .
							_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);

							dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
							*dwp = MSGID_NOTIFY;
							wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
							*wp  = DEF_NOTIFY_ITEMOBTAINED;

							cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

							// 1 . <-  1    
							*cp = 1;
							cp++;

							memcpy(cp, pItem->m_cName, 20);
							cp += 20;

							dwp  = (DWORD *)cp;
							*dwp = pItem->m_dwCount;
							cp += 4;

							*cp = pItem->m_cItemType;
							cp++;

							*cp = pItem->m_cEquipPos;
							cp++;

							*cp = (char)0; //    .
							cp++;

							sp  = (short *)cp;
							*sp = pItem->m_sLevelLimit;
							cp += 2;

							*cp = pItem->m_cGenderLimit;
							cp++;

							wp = (WORD *)cp;
							*wp = pItem->m_wCurLifeSpan;
							cp += 2;

							wp = (WORD *)cp;
							*wp = pItem->m_wWeight;
							cp += 2;

							sp  = (short *)cp;
							*sp = pItem->m_sSprite;
							cp += 2;

							sp  = (short *)cp;
							*sp = pItem->m_sSpriteFrame;
							cp += 2;

							*cp = pItem->m_cItemColor;
							cp++;

							*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
							cp++;

							dwp = (DWORD *)cp;
							*dwp = pItem->m_dwAttribute;
							cp += 4;
							

							if (iEraseReq == 1) delete pItem;

							//        . 
							SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
								dX, dY,	sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor); // v1.4

							//    
							iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);

							switch (iRet) {
								case DEF_XSOCKEVENT_QUENEFULL:
								case DEF_XSOCKEVENT_SOCKETERROR:
								case DEF_XSOCKEVENT_CRITICALERROR:
								case DEF_XSOCKEVENT_SOCKETCLOSED:
									//     .
									DeleteClient(iClientH, TRUE, TRUE);
									return;
							}
						}
						else 
						{
							//    .    .

							//   . 
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);

							dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
							*dwp = MSGID_NOTIFY;
							wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
							*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;

							iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
							switch (iRet) {
								case DEF_XSOCKEVENT_QUENEFULL:
								case DEF_XSOCKEVENT_SOCKETERROR:
								case DEF_XSOCKEVENT_CRITICALERROR:
								case DEF_XSOCKEVENT_SOCKETCLOSED:
									//     .
									DeleteClient(iClientH, TRUE, TRUE);
									return;
							}
						}
					}
					//
					break;

				case DEF_MAGICTYPE_CONFUSE:
					// if the caster side is the same as the targets side, no effect occurs
						switch (m_pMagicConfigList[sType]->m_sValue4) {
						case 1: // confuse Language. 
						case 2: // Confusion, Mass Confusion 	
							for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
								for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
									//     .
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
									if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
										//    .
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											//    .
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break; //  Confuse  .
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;

											//       .
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

											//   .
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
										}
									}
								}	
								break;

						case 3: // Ilusion, Mass-Ilusion
							for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
								for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
									//     .
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
									if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
										//    .
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											//    .
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break; //  Confuse  .
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;

											switch (m_pMagicConfigList[sType]->m_sValue4) {
												case 3:
													SetIllusionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
													break;
											}

											//       .
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

											//   .
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, NULL);
										}
									}
								}	
								break;

						case 4: // Ilusion Movement
							if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) break;
							for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
							for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break;
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;
											switch (m_pMagicConfigList[sType]->m_sValue4) {
												case 4:
													SetIllusionMovementFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
													break;
											}

											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, NULL);
										}
									}
								}	
					}
					break;


				case DEF_MAGICTYPE_POISON:
					//  .         . 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					if (m_pMagicConfigList[sType]->m_sValue4 == 1) {
						//    
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								// v1.4334     
								if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT ;

								//  
								bAnalyzeCriminalAction(iClientH, dX, dY);

								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									//   .  .
									if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {
										// .
										m_pClientList[sOwnerH]->m_bIsPoisoned  = TRUE;
										m_pClientList[sOwnerH]->m_iPoisonLevel = m_pMagicConfigList[sType]->m_sValue5;
										m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
										// 05/06/2004 - Hypnotoad - poison aura appears when cast Poison
										SetPoisonFlag(sOwnerH, cOwnerType, TRUE);
										//  . 
										SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pMagicConfigList[sType]->m_sValue5, NULL, NULL);
					#ifdef DEF_TAIWANLOG
										_bItemLog(DEF_ITEMLOG_POISONED,sOwnerH,(char *) NULL,NULL) ;
					#endif
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_iHP > 0) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									//   .  .
									if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {
										// .

									}
								}
								break;
						}
					}
					else if (m_pMagicConfigList[sType]->m_sValue4 == 0) {
						//    
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;

								if (m_pClientList[sOwnerH]->m_bIsPoisoned == TRUE) {
									//    .
									m_pClientList[sOwnerH]->m_bIsPoisoned = FALSE;
									// 05/06/2004 - Hypnotoad - poison aura removed when cure cast
									SetPoisonFlag(sOwnerH, cOwnerType, FALSE);
									//   . 
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								break;
						}
					}
					break;

				case DEF_MAGICTYPE_BERSERK:
					switch (m_pMagicConfigList[sType]->m_sValue4) {
						case 1:
							//   .
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[sType]->m_sValue4;
									SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;
									//  NPC  				
									if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
									// 2002-09-11 #3    
									if ( m_pClientList[iClientH]->m_cSide != m_pNpcList[sOwnerH]->m_cSide ) goto MAGIC_NOEFFECT;

									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[sType]->m_sValue4;
									SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
									break;
							}

							//       .
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

							if (cOwnerType == DEF_OWNERTYPE_PLAYER)
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
							break;
					}
					break;

				case DEF_MAGICTYPE_DAMAGE_AREA_ARMOR_BREAK: //28 m_sValue10 is used for armor decrement					
					if (m_pMagicConfigList[sType]->m_sType == 28) 
					{	iResult += 10000; // ArmorBreak effect overcomes PFM.
					}		
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
					{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (   (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
							&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
						{	if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) 
							{	Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
						}
					}
					break;

				// Resurrection Magic. 
				case DEF_MAGICTYPE_RESURRECTION: 
					// 10 Mins once
					if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) goto MAGIC_NOEFFECT;
					m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC/2;
					// Get the ID of the dead Player/NPC on coords dX, dY. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY); 
					switch (cOwnerType) { 
						// For Player. 
						case DEF_OWNERTYPE_PLAYER: 
							// The Player has to exist. 
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT; 
							// Resurrection is not for alive Players. 
							if (m_pClientList[sOwnerH]->m_bIsKilled == FALSE) goto MAGIC_NOEFFECT; 
							// Set Deadflag to Alive. 
							m_pClientList[sOwnerH]->m_bIsKilled = FALSE; 
							// Player's HP becomes half of the Max HP. 
							m_pClientList[sOwnerH]->m_iHP = iGetMaxHP(sOwnerH, FALSE) / 2; 
							// Send new HP to Player. 
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL); 
							// Make Player stand up. (Currently, by a fake damage). 
							m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->ClearDeadOwner(dX, dY); 
							m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->SetOwner(sOwnerH, DEF_OWNERTYPE_PLAYER, dX, dY); 
							SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, NULL, NULL, NULL); 
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL); 
							break; 
						// Resurrection is not for NPC's. 
						case DEF_OWNERTYPE_NPC: 
							goto MAGIC_NOEFFECT; 
							break; 
					} 
					break;

				case DEF_MAGICTYPE_ICE:
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								//  
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
								//    
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										//      .
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												//       .
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												//    .
												SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
											}
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												//       .
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											}
										}
										break;
								}

							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									//    .
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										//    .    
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												//       .
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

												SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
											}
										}
									}
								}
						}
						break;

				default:
					break;
			}
		}
		else {
			// Casting    
			// Resurrection wand(MS.10) or Resurrection wand(MS.20)

				if (m_pMagicConfigList[sType]->m_sType == DEF_MAGICTYPE_RESURRECTION) {
					//Check if player has resurrection wand
					if (m_pClientList[iClientH] != NULL && m_pClientList[iClientH]->m_iSpecialAbilityTime == 0 &&
						m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == FALSE) {
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
							if(m_pClientList[sOwnerH] != NULL){

							if ((m_pClientList[iClientH]->m_iAdminUserLevel < 1) &&
								(m_pClientList[sOwnerH]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
								return;
							}
							if (cOwnerType == DEF_OWNERTYPE_PLAYER && m_pClientList[sOwnerH] != NULL &&
								m_pClientList[sOwnerH]->m_iHP <= 0){
								m_pClientList[sOwnerH]->m_bIsBeingResurrected = TRUE;
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_RESURRECTPLAYER, NULL, NULL, NULL, NULL);
									if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
										m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = TRUE;
										m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;
										m_pClientList[iClientH]->m_iSpecialAbilityLastSec = 0;
										m_pClientList[iClientH]->m_iSpecialAbilityTime = m_pMagicConfigList[sType]->m_dwDelayTime;

										sTemp = m_pClientList[iClientH]->m_sAppr4;
										sTemp = 0xFF0F & sTemp;
										sTemp = sTemp | 0x40;
										m_pClientList[iClientH]->m_sAppr4 = sTemp;
									}
								SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, NULL);
								SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
							}
						}
					}
				}
			}

MAGIC_NOEFFECT:;

		if (m_pClientList[iClientH] == NULL) return;
		
		//Mana Slate
		if ((m_pClientList[iClientH]->m_iStatus & 0x800000) != 0) {
			iManaCost = 0;
		}

		// Mana  .
		m_pClientList[iClientH]->m_iMP -= iManaCost; // sValue1 Mana Cost
		if (m_pClientList[iClientH]->m_iMP < 0) 
			m_pClientList[iClientH]->m_iMP = 0;

		CalculateSSN_SkillIndex(iClientH, 4, 1 );

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);

		//     .  + 100   
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, (sType+100), m_pClientList[iClientH]->m_sType);

}


void CGame::NpcMagicHandler(int iNpcH, short dX, short dY, short sType)
{
 short  sOwnerH;
 char   cOwnerType;
  int i, iErr, ix, iy, sX, sY, tX, tY;
 int iResult, iIceAtkRatio, iWhetherBonus, iMagicAttr;
 DWORD  dwTime = timeGetTime();

	if (m_pNpcList[iNpcH] == NULL) return;
	if ((dX < 0) || (dX >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeX) ||
        (dY < 0) || (dY >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeY)) return;
									   
	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == NULL) return;
	
	if (m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
	
	iResult = m_pNpcList[iNpcH]->m_iMagicHitRatio;
	iIceAtkRatio = iResult/8;
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cWhetherStatus);
	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;

	// sX, sY is Caster position
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) 
	{	switch (m_pMagicConfigList[sType]->m_sType) {
		
		case DEF_MAGICTYPE_DAMAGE_SPOT: // 1
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult+50) == FALSE)
				Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
			 	 && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
			{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			}
			break;

		case DEF_MAGICTYPE_HPUP_SPOT: // 2
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_HpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA: // 3 (will fly from spell center point)
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
			 	 && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
			{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			}			
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
			{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
			 	     && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			   	}
			}
			break;

		case DEF_MAGICTYPE_SPDOWN_AREA: // 5
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		case DEF_MAGICTYPE_SPUP_AREA: // 7
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		case DEF_MAGICTYPE_HOLDOBJECT: // 12
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 				
			{	switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
					// Give a chance anti-Para if very good PR... 
					if (   ((m_pClientList[sOwnerH]->m_cSkillMastery[23] + m_pClientList[sOwnerH]->m_iAddPR + iDice(1,100)) >= 250) 
							&& (m_pClientList[sOwnerH]->m_iSpecialAbilityType != 3)) goto NMH_NOEFFECT;		 
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
					
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto NMH_NOEFFECT; 
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
				}
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
				{	char cParaLevel = m_pMagicConfigList[sType]->m_sValue4; 					
					if (cParaLevel >1) cParaLevel = 2;
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, cParaLevel, NULL, NULL);
			}	}
			break;

		case DEF_MAGICTYPE_INVISIBILITY: //13
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:	// Invisibility
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
					break;
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);
					break;
				}			
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				break;
			case 2:	// Detect Invisibility
				for (ix = dX - 8; ix <= dX + 8; ix++)
				for (iy = dY - 8; iy <= dY + 8; iy++) {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != NULL) {
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) continue;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) 
							{	if (m_pClientList[sOwnerH]->m_sType != 66) 
								{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
									SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
									bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
								}
							}
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) continue;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) 
							{	if (m_pClientList[sOwnerH]->m_sType != 66) 
								{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
									SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
									bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);							
							}	}
							break;
				}	}	}
				break;
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_LINEAR: // 19 BloodyShockWave, LightningBolt
			for (i = 2; i < 10; i++) 
			{	iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);			
				// tx, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				// tx-1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				// tx+1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				// tx, ty-1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				// tx, ty+1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}
			// Damage Area
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
			{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}
			// Target damage dX, dY
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
			{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:  //21 (fly from caster)
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
			 	     && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			   	}
			}
			break;

		case DEF_MAGICTYPE_ICE:  //23 (don't fly target) Added by Snoopy
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
			{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) continue; // Snoopy: replaced goto MAGIC_NOEFFECT by continue...
					if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
					{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
						{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}
					}
					break;
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) continue; // Snoopy: replaced goto MAGIC_NOEFFECT by continue...
					if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
					{	if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
						{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}
					}
					break;
				}
				// Will not ice is not discovered pretencorpse		
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
			 	     && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			   		if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
					{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
						{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}
					}								
				}
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT_SPDOWN: //25 // EWS (will fly in random position)
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
			{	// SNOOPY: Damage is on 456, Special SPdown on 789
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	if ((iy == dY) && (ix == dX))
					{	// Will fly random direction // 10 more damage if targetted.
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, ix, iy, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, 10 + m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, 10 + m_pMagicConfigList[sType]->m_sValue9);
					}else
					{	// Will fly random direction
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, ix, iy, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}
				}
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (    (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
						 && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, ix, iy, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, 10 + m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, 10 + m_pMagicConfigList[sType]->m_sValue9);
					}
				}
			}
			break;	

		case DEF_MAGICTYPE_ICE_LINEAR: //26 Added by Snoopy
			// SNOOPY: used iMagicAttr, to send info to damage procedures, not to add bonus for Berzerk Liche Wands
			iMagicAttr +=100;
			for (i = 2; i < 10; i++) 
			{	iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
				// tx, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;
				}	} 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
				}	}	}	}

				// tx-1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;
				}	} 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
				}	}	}	}
				
				// tx+1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;
				}	} 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
				}	}	}	}
				
				// tx, ty-1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;
				}	} 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
				}	}	}	}

				// tx, ty+1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;
				}	} 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE))
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
				}	}	}	}
				// Exit if reaching the Target
				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			// Area damage: depends on X/Y settings in the spell and m_sValue789, same as linear damge
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
			{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}	}
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) {
						if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
						{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}	}
						break;	
				}	}
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
						{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
							{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
				}	}	}	}
			}

			// Target Damage: depends on m_sValue456
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
			{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) break;
					if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
					{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
						{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
					}	}
					break;
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) break;
					if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
					{	if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
						{	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
					}	}
					break;				
			}	}
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
			{	if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
					if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(-1, sOwnerH, cOwnerType, iIceAtkRatio) == FALSE)) 
					{	if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) 
						{	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
			}	}	}	}
			break;

		case DEF_MAGICTYPE_DAMAGE_LINEAR_SPDOWN: //30 ESW
			//  m_sValue4 5 6 used for damage target
			//  m_sValue7 8 9 used for damage Linear, Area 
			//  m_sValue10 11 12 used for SP down
			// SNOOPY: used iMagicAttr, to send info to damage procedures, not to add bonus for Berzerk Liche Wands
			iMagicAttr +=100;			
			for (i = 2; i < 10; i++) 
			{	iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
				// tx, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						break;						
				}	}
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (m_pClientList[sOwnerH] == NULL) continue;
					if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
				}	}

				// tx-1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						break;						
				}	}
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (m_pClientList[sOwnerH] == NULL) continue;
					if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
				}	}
					
				// tx+1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						break;						
				}	}
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (m_pClientList[sOwnerH] == NULL) continue;
					if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
				}	}

				// tx, ty-1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						break;						
				}	}
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (m_pClientList[sOwnerH] == NULL) continue;
					if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
				}	}
					
				// tx, ty+1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue;
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						break;						
				}	}
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
				{	if (m_pClientList[sOwnerH] == NULL) continue;
					if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
				}	}				
				// Do not strike again if target is close to caster
				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}
			// Area Damage
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			{	for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) 
				{	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
					{	switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) continue;
							Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
							break;
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) continue;
							Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							break;							
					}	}
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (m_pClientList[sOwnerH] == NULL) break;
						if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
						{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
					}	}
				}
			}
			// Damage on Target m_sValue456
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
			{	switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
					break;
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) break;
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					break;
			}	}
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) ) 
			{	if (m_pClientList[sOwnerH] == NULL) break;
				if (bCheckResistingMagicSuccess(-1, sOwnerH, cOwnerType, iResult) == FALSE) 
				{	Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10, m_pMagicConfigList[sType]->m_sValue11, m_pMagicConfigList[sType]->m_sValue12);
			}	}					
			break;

		}
	}
NMH_NOEFFECT:;
	// Mana
	m_pNpcList[iNpcH]->m_iMana -= m_pMagicConfigList[sType]->m_sValue1; // sValue1 Mana Cost
	if (m_pNpcList[iNpcH]->m_iMana < 0) 
		m_pNpcList[iNpcH]->m_iMana = 0;
	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pNpcList[iNpcH]->m_cMapIndex,
		m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, dX, dY, (sType+100), m_pNpcList[iNpcH]->m_sType);
}

void CGame::ReleaseFollowMode(short sOwnerH)
{ int i;
	for (i = 0; i < DEF_MAXNPCS; i++)
	if ((i != sOwnerH) && (m_pNpcList[i] != NULL)) 
	{	if (   (m_pNpcList[i]->m_cMoveType         == DEF_MOVETYPE_FOLLOW)
			&& (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_NPC) 
			&& (m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH)) 			
		{	m_pNpcList[i]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
			m_pNpcList[i]->m_iFollowOwnerIndex = 0;
			m_pNpcList[i]->m_cFollowOwnerType  = 0;
}	}	}

BOOL CGame::_bDecodeMagicConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iMagicConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					//   
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pMagicConfigList[atoi(token)] != NULL) {
						//    . .
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[atoi(token)] = new class CMagic;
					iMagicConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					//   
					ZeroMemory(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, sizeof(m_pMagicConfigList[iMagicConfigListIndex]->m_cName));
					memcpy(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:
					//   m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					//    m_dwDelayTime
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwDelayTime = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					//   m_dwLastTime
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwLastTime = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 7;
					break;
				
				case 7:
					// m_sValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_sValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue5 = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// m_sValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue6 = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// m_sValue7
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue7 = atoi(token);
					cReadModeB = 13;
					break;
				
				case 13:
					// m_sValue8
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue8 = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// m_sValue9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue9 = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// m_sValue10
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue10 = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// m_sValue11
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue11 = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// m_sValue12
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue12 = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// m_sIntLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sIntLimit = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// m_iGoldCost
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iGoldCost = atoi(token);
					
					cReadModeB = 20;
					break;

				case 20:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// m_iAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iAttribute = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "magic", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
		
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) MAGIC(Total:%d) configuration - success!", iMagicConfigListIndex);
	PutLogList(cTxt);

	return TRUE;

}



BOOL CGame::_bDecodeSkillConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iSkillConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					//   
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pSkillConfigList[atoi(token)] != NULL) {
						//    . .
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[atoi(token)] = new class CSkill;
					iSkillConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					//   
					ZeroMemory(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, sizeof(m_pSkillConfigList[iSkillConfigListIndex]->m_cName));
					memcpy(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:
					//   m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// m_sValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 5;
					break;
				
				case 5:
					// m_sValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// m_sValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue5 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue6 = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "skill", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
		
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) SKILL(Total:%d) configuration - success!", iSkillConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

// 12-22        .
void CGame::RequestStudyMagicHandler(int iClientH, char * pName, BOOL & bSucces, BOOL bIsPurchase)
{char  * cp, cMagicName[31], cData[100];
 DWORD * dwp, dwGoldCount = 0;
 WORD  * wp;
 int   * ip, iReqInt, iCost, iRet, iTempInt;
 BOOL bMagic = TRUE ;
	// SNOOPY, added this to prevent esrasing a manual if not enough int.
	bSucces = FALSE;
	iTempInt = m_pClientList[iClientH]->m_iInt;
	// SNOOPY: Angelic allow to buy Spell but not to read manual.

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	ZeroMemory(cData, sizeof(cData));	
	ZeroMemory(cMagicName, sizeof(cMagicName));
	memcpy(cMagicName, pName, 30);	
	iRet = _iGetMagicNumber(cMagicName, &iReqInt, &iCost);
	if (iRet == -1) 
	{}else 
	{	if (bIsPurchase == TRUE) 
		{	if (m_pMagicConfigList[iRet]->m_iGoldCost < 0) bMagic = FALSE ; 
			dwGoldCount = dwGetItemCount(iClientH, "Gold");
			if ((DWORD)iCost > dwGoldCount)  bMagic = FALSE ; 	
			iTempInt += m_pClientList[iClientH]->m_iAngelicInt;
			// SNOOPY: Was Buggy couldn't leran a Spell Book outside Magic Tower !
			if (m_pClientList[iClientH]->m_bIsInsideWizardTower == FALSE) return;
		}		
		if (m_pClientList[iClientH]->m_cMagicMastery[iRet] != 0) return;

		if ((iReqInt <= iTempInt) && (bMagic == TRUE) ) 
		{	if (bIsPurchase == TRUE) SetItemCount(iClientH, "Gold", dwGoldCount - iCost);
			iCalcTotalWeight(iClientH);
			m_pClientList[iClientH]->m_cMagicMastery[iRet] = 1;
			// Snoopy: notify sender function off the succes.
			bSucces = TRUE;
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYSUCCESS;
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp = iRet;
			cp++;
			memcpy(cp, cMagicName, 30);
			cp += 30;
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 37);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}else 
		{	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYFAIL;
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp = 1;
			cp++;
			*cp = iRet;
			cp++;
			memcpy(cp, cMagicName, 30);
			cp += 30;
			ip = (int *)cp;
			*ip = iCost;
			cp += 4;
			ip = (int *)cp;
			*ip = iReqInt;
			cp += 4;
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 46);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return;
	}	}	}
}


int CGame::_iGetMagicNumber(char * pMagicName, int * pReqInt, int * pCost)
{
 int i;
 char cTmpName[31];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMagicName);

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) 
	if (m_pMagicConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pMagicConfigList[i]->m_cName, 30) == 0) {
			//      .   .
			*pReqInt = (int)m_pMagicConfigList[i]->m_sIntLimit;
			*pCost   = (int)m_pMagicConfigList[i]->m_iGoldCost;
			
			return i;
		}
	}
	
	return -1;
}

void CGame::TrainSkillResponse(BOOL bSuccess, int iClientH, int iSkillNum, int iSkillLevel)
{
 char  * cp, cData[100];
 DWORD * dwp;
 WORD  * wp;
 int   iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((iSkillNum < 0)	|| (iSkillNum > 100)) return;
	if ((iSkillLevel < 0) || (iSkillLevel > 100)) return;

	if (bSuccess == TRUE) {
		//      .
		if (m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] != 0) return;
		
		m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] = iSkillLevel;
		//     .
		bCheckTotalSkillMasteryPoints(iClientH, iSkillNum);

		//    .
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_SKILLTRAINSUCCESS;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 
		*cp = iSkillNum;
		cp++;
		
		//   .
		*cp = iSkillLevel;
		cp++;
	 
		if (m_pSkillConfigList[iSkillNum]->m_cName != NULL) 
			_bItemLog(DEF_ITEMLOG_SKILLLEARN,iClientH,m_pSkillConfigList[iSkillNum]->m_cName,NULL);

		//   
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 8);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			//     .
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}
	else {


	}
}


int CGame::_iGetSkillNumber(char * pSkillName)
{
 int i;
 char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pSkillName);

	for (i = 1; i < DEF_MAXSKILLTYPE; i++) 
	if (m_pSkillConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pSkillConfigList[i]->m_cName, 20) == 0) {
			//      .   .
			return i;
		}
	}
	
	return 0;
}

BOOL CGame::bPlayerItemToBank(int iClientH, short sItemIndex)
{
 int i, iIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
		iIndex = i;
		goto NEXT_STEP_PLTB;
	}
	//    . 
	return FALSE;

NEXT_STEP_PLTB:;

	//    . 
	//    .
	ReleaseItemHandler(iClientH, sItemIndex, TRUE);

	//    . 
	m_pClientList[iClientH]->m_pItemInBankList[iIndex] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
	//     
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;

	//     .
	for (i = 1; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i-1] == NULL) && (m_pClientList[iClientH]->m_pItemList[i] != NULL)) {
		m_pClientList[iClientH]->m_pItemList[i-1]       = m_pClientList[iClientH]->m_pItemList[i];	
		m_pClientList[iClientH]->m_bIsItemEquipped[i-1] = m_pClientList[iClientH]->m_bIsItemEquipped[i];	
		m_pClientList[iClientH]->m_pItemList[i]   = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
	}

	return TRUE;
}



BOOL CGame::bBankItemToPlayer(int iClientH, short sItemIndex)
{
 int i, iIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	
	if (m_pClientList[iClientH]->m_pItemInBankList[sItemIndex] == NULL) return FALSE;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
		iIndex = i;
		goto NEXT_STEP_PLTB;
	}
	//    . 
	return FALSE;

NEXT_STEP_PLTB:;

	//    . 
	
	//    . 
	m_pClientList[iClientH]->m_pItemList[iIndex] = m_pClientList[iClientH]->m_pItemInBankList[sItemIndex]; 
	
	m_pClientList[iClientH]->m_pItemInBankList[sItemIndex] = NULL;

	return TRUE;
}



BOOL CGame::__bReadMapInfo(int iMapIndex)
{
 char * pContents, * token,  cTxt[250], cFn[255];	 
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iTeleportLocIndex  = 0;
 int  iWayPointCfgIndex  = 0;
 int  iTotalNpcSetting   = 0;
 int  iMGARCfgIndex      = 0;
 int  iSMGRCfgIndex      = 0;
 int  iNMRCfgIndex       = 0;
 int  iFishPointIndex 	 = 0;
 int  iMineralPointIndex = 0;
 int  iStrategicPointIndex = 0;
 int  iIndex = 0, iIndexGD= 0, iIndexHT = 0;;
 int	i;

 int  iNamingValue;
 class CStrTok * pStrTok;
 HANDLE hFile;
 DWORD  dwFileSize, dwReadSize;
 FILE * pFile;

 char cName[6], cNpcName[21], cNpcMoveType, cNpcWaypointIndex[10], cNamePrefix;
 short sIPindex;

	m_pMapList[iMapIndex]->m_iApocalypseMobGenType = 0;		// 26 ApocalypseMobGenType
	m_pMapList[iMapIndex]->m_iApocalypseBossMobNpcID = 0;	// 27 ApocalypseBossMob
	m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.left   =  0;
	m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.top    =  0;
	m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.right  =  0;
	m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.bottom =  0;
	m_pMapList[iMapIndex]->m_cDynamicGateType = 0;			// 28 DynamicGateType
	m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 = 	0;	// 29 DynamicGateCoord 
	m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2 = 	0;	 
	m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 = 	0;	 
	m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2 = 	0;	 
	ZeroMemory(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap, sizeof(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap));
	m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtX = 0;
	m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtY = 0;
	m_pMapList[iMapIndex]->m_bIsRecallImpossible = FALSE;	// 30 Recal impossible
	m_pMapList[iMapIndex]->m_bIsApocalypseMap = FALSE;		// 31 ApocalypseMap 

	m_pMapList[iMapIndex]->m_bIsHeldenianMap = FALSE;		// 33 HeldenianMap	
	for (i = 0; i < DEF_MAXHELDENIANTOWER; i++)				// 34 HeldenianTower
	{	m_pMapList[iMapIndex]->m_stHeldenianTower[i].sTypeID = 0;
		m_pMapList[iMapIndex]->m_stHeldenianTower[i].dX = 0;
		m_pMapList[iMapIndex]->m_stHeldenianTower[i].dY = 0;
		m_pMapList[iMapIndex]->m_stHeldenianTower[i].cSide = 0;
	}
	m_pMapList[iMapIndex]->m_cHeldenianModeMap = 0;			// 35 HeldenianModeMap
	m_pMapList[iMapIndex]->m_sHeldenianWinningZoneX = -1;	// 36 HeldenianWinningZone
	m_pMapList[iMapIndex]->m_sHeldenianWinningZoneY = -1;	// 36 HeldenianWinningZone
	for (i = 0; i < DEF_MAXHELDENIANDOOR; i++) 				// 37 HeldenianGateDoor  
	{	m_pMapList[iMapIndex]->m_stHeldenianGateDoor[i].cDir = 0;
		m_pMapList[iMapIndex]->m_stHeldenianGateDoor[i].dX = 0;
		m_pMapList[iMapIndex]->m_stHeldenianGateDoor[i].dY = 0;
	}

	//  .
	if (memcmp(m_pMapList[iMapIndex]->m_cName, "fightzone", 9) == 0) 
		m_pMapList[iMapIndex]->m_bIsFightZone = TRUE;

	if (memcmp(m_pMapList[iMapIndex]->m_cName, "icebound", 8) == 0) 
		m_pMapList[iMapIndex]->m_bIsSnowEnabled = TRUE;

	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn, "mapdata\\");
	strcat(cFn, m_pMapList[iMapIndex]->m_cName);
	strcat(cFn, ".txt");
	
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return FALSE;
	dwFileSize = GetFileSize(hFile, NULL);
	CloseHandle(hFile);


	pContents = new char[dwFileSize+1];
	ZeroMemory(pContents, dwFileSize+1);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		//      .
		wsprintf(cTxt, "(!) Cannot open file : %s", cFn);
		PutLogList(cTxt);
		return FALSE;
	}
	else {
		wsprintf(cTxt, "(!) Reading Map info file : %s", cFn);
		PutLogList(cTxt);
		dwReadSize = fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					//    X  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 1 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcX = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					//    Y 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 2 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcY = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					//     
					ZeroMemory(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, 
						       sizeof(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName));
					strcpy(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, token);
					cReadModeB = 4;
					break;

				case 4:
					//    X 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 3 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestX = atoi(token);
					cReadModeB = 5;
					break;
				
				case 5:
					//    Y 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 4 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestY = atoi(token);
					cReadModeB = 6;
					break;
				
				case 6:
					//     
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 5 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDir = atoi(token);
					iTeleportLocIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 2:
				switch (cReadModeB) {
				case 1:
					// waypoint    
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 6 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iWayPointCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x != -1) {
						//   Waypoint .
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 7 - Duplicated waypoint");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;
				
				case 2:
					// waypoint   X  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 8 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// waypoint   Y  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 9 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 3:
				// Npc  .
				switch (cReadModeB) {
				case 1:
					// NPC . 
					ZeroMemory(cNpcName, sizeof(cNpcName));
					strcpy(cNpcName, token);
					cReadModeB = 2;
					break;
				case 2:
					// NpcMoveType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 10 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cNpcMoveType = atoi(token);
					cReadModeB = 3;
					break;
				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 11 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cNpcWaypointIndex[cReadModeB-3] = atoi(token);
					cReadModeB++;
					break;
				case 13:
					// cNamePrefix
					cNamePrefix = token[0];
					//   NPC . 
					
					iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
					if (iNamingValue == -1) {
						//    NPC  .     .
					}
					else {
						// NPC .
						ZeroMemory(cName, sizeof(cName));
						wsprintf(cName, "XX%d", iNamingValue);
						cName[0] = cNamePrefix;
						cName[1] = iMapIndex+65;
											
						if (bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 0, 0, cNpcMoveType, NULL, NULL, cNpcWaypointIndex, NULL, NULL, -1, FALSE) == FALSE) {
							//   NameValue .
							m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
						} 
					}
					cReadModeA = 0;
					cReadModeB = 0;
					iTotalNpcSetting++;
					break;
				}
				break;

			case 4:
				switch (cReadModeB) {
				case 1:
					// Random-Mob-Generator   
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 12 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bRandomMobGenerator = (BOOL)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					// Mob- Level
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 13 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 5:
				// Maximum object
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 14 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pMapList[iMapIndex]->m_iMaximumObject = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 6:
				//      :       
				switch (cReadModeB) {
				case 1:
					// Rect  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 15 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iMGARCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left != -1) {
						//   Waypoint .
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 16 - Duplicated Mob Gen Rect Number!");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					cReadModeB = 2;
					break;

				case 2:
					// left
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 17 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// top
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 18 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// right
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 19 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 20 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			
			case 7:
				//    
				switch (cReadModeB) {
				case 1:
					// Rect  m_stSpotMobGenerator[]
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 21 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iSMGRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined == TRUE) {
						//     .
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error - ");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined = TRUE;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 22 - Wrong Data format(SMGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 1)
						cReadModeB = 3;
					else if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 2)
						cReadModeB = 9;  // RECT  Waypoint  .
					break;

				case 3:
					// left
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 23 - Wrong Data format(SMGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.left = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// top
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 24 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.top = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// right
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 25 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.right = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 26 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.bottom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 27 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// Max Mobs
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 28 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 29 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cWaypoint[cReadModeB - 9] = atoi(token);
					cReadModeB++;
			   		break;

				case 19:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 30 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 31 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
			  	}
				break;

			case 8:
				//     
				ZeroMemory(m_pMapList[iMapIndex]->m_cLocationName, sizeof(m_pMapList[iMapIndex]->m_cLocationName));
				memcpy(m_pMapList[iMapIndex]->m_cLocationName, token, 10);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 9:
				switch (cReadModeB) {
				case 1:
					// Initial-Point Index
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32:1 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					sIPindex = atoi(token);
					if (m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Duplicate Initial Point Index!");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;
				
				case 2:
					// Initial-Point X
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Initial-Point Y
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 33 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
		
			case 10:
				//    RECT
				switch (cReadModeB) {
				case 1:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 34 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iNMRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top != -1) {
						//   No-Magic-Rect .
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 35 - Duplicate No-Magic-Rect number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 36 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 37 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 38 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 39 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 11:
				m_pMapList[iMapIndex]->m_bIsFixedDayMode = (BOOL)atoi(token);
				if (m_pMapList[iMapIndex]->m_bIsFixedDayMode == TRUE)
					m_pMapList[iMapIndex]->m_bIsSnowEnabled = FALSE;
				cReadModeA = 0;
				break;

			case 12:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 40 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iFishPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x != -1) {
						//   Fish Point .
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 41 - Duplicate FishPoint number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalFishPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 42 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 43 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 13:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 44 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaxFish = atoi(token);

				cReadModeA = 0;
				break;

			case 14:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 45 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cType = atoi(token);

				cReadModeA = 0;
				break;

			case 15:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 46 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 16:
				//     
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 47 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bMineralGenerator = (BOOL)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 48 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cMineralGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 17:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 49 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iMineralPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x != -1) {
						//   Mineral Point .
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 50 - Duplicate MineralPoint number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalMineralPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 51 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 52 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 18:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 53 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaxMineral = atoi(token);

				cReadModeA = 0;
				break;

			case 19:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 54 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iUpperLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 20:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 55 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iStrategicPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] != NULL) {
						//   Strategic Point .
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 56 - Duplicate Strategic Point number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] = new class CStrategicPoint;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 57 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iSide = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 58 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iValue = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 59 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iX = atoi(token);

					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 60 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 21:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 61 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType != NULL) {
						//   Energy-Sphere-Creation Point .
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 62 - Duplicate EnergySphereCreation number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint++;
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 63 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 64 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 65 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 22:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 66 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult != NULL) {
						//   Energy-Sphere-Goal Point .
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 67 - Duplicate EnergySphereGoal number(%d:%d)", iIndex, m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint++;
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 68 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 69 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 70 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenY = atoi(token);
					
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 71 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineX = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 72 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineY = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 23:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 73 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (strlen(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName) != NULL) {
						//    Point .
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 74 - Duplicate Strike Point number(%d)", iIndex);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 75 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dX = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 76 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dY = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iHP = atoi(token);
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iInitHP = atoi(token);
					cReadModeB = 5;
					break;


				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[0] = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[0] = atoi(token);
					
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[1] = atoi(token);
					
					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[1] = atoi(token);
					
					cReadModeB = 9;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[2] = atoi(token);
					
					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[2] = atoi(token);
					
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[3] = atoi(token);
					
					cReadModeB = 12;
					break;

				case 12:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[3] = atoi(token);
					
					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[4] = atoi(token);
					
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[4] = atoi(token);
					
					cReadModeB = 15;
					break;

				case 15:
					ZeroMemory(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, sizeof(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName));
					strcpy(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, token);
					
					m_pMapList[iMapIndex]->m_iTotalStrikePoints++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break; // end 23

			case 24:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (strlen(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName) != NULL) {
						//   Item-Event .
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 79 - Duplicate Item-Event number(%d:%s)", iIndex, m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalItemEvents++;
					cReadModeB = 2;
					break;
				
				case 2:
					strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName, token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 81 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iAmount = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 82 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iTotalNum = atoi(token);
					
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iMonth = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iDay = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 25: //mobevent-amount
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->sMobEventAmount = atoi(token);
					cReadModeB = 0;
					break;
				}
				break;

			case 26: // ApocalypseMobGenType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMobGenType - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iApocalypseMobGenType = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 27: // ApocalypseBossMob //SNOOPY replaced coord by RECT structure.
				switch (cReadModeB) {
				case 1: // 3CB6Ch m_pMapList[]->m_ApocalypseBossMobNpcID
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_iApocalypseBossMobNpcID = atoi(token);
					cReadModeB = 2;					
					break;
				case 2: // 3CB70h m_pMapList[]->ApocalypseBossMobRectX1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.left = atoi(token);
					cReadModeB = 3;					
					break;
				case 3: // 3CB74h m_pMapList[]->ApocalypseBossMobRectY1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					//m_pMapList[iMapIndex]->m_sApocalypseBossMobRectY1 = atoi(token);
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.top = atoi(token);
					cReadModeB = 4;					
					break;
				case 4: // 3CB78h m_pMapList[]->ApocalypseBossMobRectX2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.right = atoi(token);
					cReadModeB = 5;					
					break;
				case 5: // 3CB7Ch m_pMapList[]->ApocalypseBossMobRectY2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;					
					break;
				}
				break;

			case 28: //DynamicGateType // 28
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateType - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cDynamicGateType = atoi(token);
				// DynamicGateType = 1: Opens Gate when Apoc begins
				// DynamicGateType = 2: Open the gate when map is empty
				// DynamicGateType = 3: Gate stays closed will change to 4 value to open it, along with a boss spawn.
				// DynamicGateType = 4: Gate is openned. (set by server when Abaddon is spawning)
				// DynamicGateType = 5: Gate is used by GM command

				cReadModeA = 0;
				cReadModeB = 0;
				break;
								
			case 29: //DynamicGateCoord // 29
				// DynamicGateCoord	= 59 196 60 197        abaddon	   -1  -1
				switch (cReadModeB) {
				case 1: // 3CA20h
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 = atoi(token);
					cReadModeB = 2;
					break;

				case 2: // 3CA24h
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 = atoi(token);
					cReadModeB = 3;
					break;

				case 3: // 3CA28h
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2 = atoi(token);
					cReadModeB = 4;
					break;

				case 4: // 3CA2Ch
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5: // 3CA30h
					ZeroMemory(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap, sizeof(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap));
					memcpy(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap, token, strlen(token));
					cReadModeB = 6;
					break;

				case 6: // 3CA3Ch
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtX = atoi(token);
					cReadModeB = 7;
					break;

				case 7: // (ty = 3CB60h) unknown (3CA3Eh)
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtY = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			
			case 30: // RecallImpossible // 30
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error RecallImpossible -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsRecallImpossible = (BOOL) atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 31: // ApocalypseMap // 31
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMap -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsApocalypseMap = (BOOL) atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
			
			case 32: // CitizenLimit // 32
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsCitizenLimit = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
					
			case 33: // HeldenianMap
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsHeldenianMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 34: // HeldenianTower
				switch (cReadModeB) {
				case 1: // NpcID
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian tower type id - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndexHT].sTypeID = atoi(token);
					cReadModeB = 2;
					break;
				case 2: // side 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Side - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndexHT].cSide = atoi(token);
					cReadModeB = 3;
					break;
				case 3: // sX
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower X pos - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndexHT].dX = atoi(token);
					cReadModeB = 4;
					break;
				case 4: // sY
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Y pos - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndexHT].dY = atoi(token);
					iIndexHT++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 35: // HeldenianModeMap
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cHeldenianModeMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 36: // HeldenianWinningZone
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sHeldenianWinningZoneX = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sHeldenianWinningZoneY = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 37: // HeldenianGateDoor // 37
				switch (cReadModeB) {
				case 1: 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Direction - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndexGD].cDir = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door X pos - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndexGD].dX = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Y pos - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndexGD].dY = atoi(token);
					iIndexGD++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "teleport-loc", 12) == 0) {
				m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex] = new class CTeleportLoc;
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "waypoint", 8) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}

			if (memcmp(token, "npc", 3) == 0) {
				cReadModeA = 3;
				cReadModeB = 1;
			}

			if (memcmp(token, "random-mob-generator", 20) == 0) {
				cReadModeA = 4;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "maximum-object", 14) == 0) 
				cReadModeA = 5;

			if (memcmp(token, "npc-avoidrect", 13) == 0) {
				cReadModeA = 6;
				cReadModeB = 1;
			}

			if (memcmp(token, "spot-mob-generator", 18) == 0) {
				cReadModeA = 7;
				cReadModeB = 1;
			}

			if (memcmp(token, "map-location", 12) == 0)
				cReadModeA = 8;

			if (memcmp(token, "initial-point", 13) == 0) {
				cReadModeA = 9;
				cReadModeB = 1;
			}

			if (memcmp(token, "no-attack-area", 14) == 0) {
				cReadModeA = 10;
				cReadModeB = 1;
			}

			if (memcmp(token, "fixed-dayornight-mode", 21) == 0) cReadModeA = 11;

			if (memcmp(token, "fish-point", 10) == 0) {
				cReadModeA = 12;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-fish", 8) == 0)		cReadModeA = 13;	
			if (memcmp(token, "type", 4) == 0)			cReadModeA = 14;	
			if (memcmp(token, "level-limit", 11) == 0)	cReadModeA = 15;	

			if (memcmp(token, "mineral-generator", 17) == 0) {
				cReadModeA = 16;
				cReadModeB = 1;
			}

			if (memcmp(token, "mineral-point", 13) == 0) {
				cReadModeA = 17;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-mineral", 11) == 0)			cReadModeA = 18;	
			if (memcmp(token, "upper-level-limit", 17) == 0)	cReadModeA = 19;	// v1.4
			if (memcmp(token, "strategic-point", 15) == 0) {	// v1.41
				cReadModeA = 20;	
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-creation-point", 28) == 0) {
				cReadModeA = 21;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-goal-point", 24) == 0) {
				cReadModeA = 22;
				cReadModeB = 1;
			}

			if (memcmp(token, "strike-point", 12) == 0) {
				cReadModeA = 23;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "item-event", 10) == 0) {
				cReadModeA = 24;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "energy-sphere-auto-creation", 27) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				m_pMapList[iMapIndex]->m_bIsEnergySphereAutoCreation = TRUE;
			}

			if (memcmp(token, "mobevent-amount", 15) == 0) {
				cReadModeA = 25;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseMobGenType", 20) == 0) {
				cReadModeA = 26;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseBossMob", 17) == 0) {
				cReadModeA = 27;
				cReadModeB = 1;
			}

			if (memcmp(token, "DynamicGateType", 15) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
			}

			if (memcmp(token, "DynamicGateCoord", 16) == 0) {
				cReadModeA = 29;
				cReadModeB = 1;
			}

			if (memcmp(token, "RecallImpossible", 16) == 0) {
				cReadModeA = 30;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "ApocalypseMap", 13) == 0) {
				cReadModeA = 31;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "CitizenLimit", 12) == 0) {
				cReadModeA = 32;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianMap", 12) == 0) {
				cReadModeA = 33;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianTower", 14) == 0) {
				cReadModeA = 34;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianModeMap", 16) == 0) {
				cReadModeA = 35;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianWinningZone", 20) == 0) {
				cReadModeA = 36;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianGateDoor", 17) == 0) {
				cReadModeA = 37;
				cReadModeB = 1;
			}

			if (memcmp(token, "[END-MAP-INFO]", 14) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto RMI_SKIPDECODING;
			}
		}
		token = pStrTok->pGet();
	}	

RMI_SKIPDECODING:;

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! map info file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) Map info file decoding(%s) - success! TL(%d) WP(%d) LNPC(%d) MXO(%d) RMG(%d / %d)", cFn, iTeleportLocIndex, iWayPointCfgIndex, iTotalNpcSetting, m_pMapList[iMapIndex]->m_iMaximumObject, m_pMapList[iMapIndex]->m_bRandomMobGenerator, m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel);
	PutLogList(cTxt);
	m_pMapList[iMapIndex]->_SetupNoAttackArea();
	m_pMapList[iMapIndex]->bApocalypseGate();
	strncmp(m_cApocalypseMapName, m_pMapList[iMapIndex]->m_cName, 11);
	m_bIsApocalypseStarter = TRUE;
	strncmp(m_cHeldenianMapName, m_pMapList[iMapIndex]->m_cName ,11);
	strncmp(cEventMapName, m_pMapList[iMapIndex]->m_cName, 11);
	return TRUE;
}

void CGame::Quit()
{
 int i;	

	//  .
	G_bIsThread = FALSE;
	Sleep(300);
		
	if (m_pMainLogSock != NULL) delete m_pMainLogSock;
	if (m_pGateSock != NULL) delete m_pGateSock;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) delete m_pClientList[i];

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
	if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
	if (m_pNpcConfigList[i] != NULL) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
	if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
	if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
	if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
	if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
	if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
	if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
	if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
	if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPOTIONTYPES; i++) {
		if (m_pPotionConfigList[i] != NULL) delete m_pPotionConfigList[i];
		if (m_pCraftingConfigList[i] != NULL) delete m_pCraftingConfigList[i];	// Crafting
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
	if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
	if (m_pDupItemIDList[i] != NULL) delete m_pDupItemIDList[i];

	if (m_pNoticementData != NULL) delete m_pNoticementData;

}

long CGame::iGetLevelExp(int iLevel)
{
 unsigned long iRet;
	
	if (iLevel == 0) return 0;
	
	iRet = iGetLevelExp(iLevel - 1) + iLevel * ( 50 + (iLevel * (iLevel / 17) * (iLevel / 17) ) );

	return iRet;
}

int CGame::_iCalcSkillSSNpoint(int iLevel)
{
 int iRet;

	if (iLevel < 1) return 1;
	
	if (iLevel <= 50) 
		iRet = iLevel;
	else if (iLevel > 50) {
		iRet = ( iLevel * iLevel ) / 10;
	}

	return iRet;
}
// 2003-04-14      ...
/////////////////////////////////////////////////////////////////////////////////////
//  StateChangeHandler(int iClientH, char * pData, DWORD dwMsgSize)
//  desc		 ::    ...
//	return value :: void
//  date		 :: [2003-04-14]    stupid koreans
/////////////////////////////////////////////////////////////////////////////////////
void CGame::StateChangeHandler(int iClientH, char * pData, DWORD dwMsgSize)
{char * cp, cStateChange1, cStateChange2, cStateChange3;
 char cStr, cVit, cDex, cInt, cMag, cChar;
 char cStateTxt[512];
 int iOldStr, iOldVit, iOldDex, iOldInt, iOldMag, iOldChar;	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;
	cStr = cVit = cDex = cInt = cMag = cChar = 0;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cStateChange1 = *cp;
	cp++;
	cStateChange2 = *cp;
	cp++;
	cStateChange3 = *cp;
	cp++;
	iOldStr	= m_pClientList[iClientH]->m_iStr;
	iOldVit	= m_pClientList[iClientH]->m_iVit;
	iOldDex = m_pClientList[iClientH]->m_iDex;
	iOldInt = m_pClientList[iClientH]->m_iInt;
	iOldMag = m_pClientList[iClientH]->m_iMag;
	iOldChar = m_pClientList[iClientH]->m_iCharisma;	
	wsprintf(G_cTxt, "(*) Char(%s) Str(%d) Vit(%d) Dex(%d) Int(%d) Mag(%d) Chr(%d) ", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iStr, m_pClientList[iClientH]->m_iVit, m_pClientList[iClientH]->m_iDex, m_pClientList[iClientH]->m_iInt, m_pClientList[iClientH]->m_iMag, m_pClientList[iClientH]->m_iCharisma);
	PutLogList(G_cTxt);	
	if(!bChangeState(cStateChange1,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{	// SNOOPY: Stats order was wrong here !
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if(!bChangeState(cStateChange2,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{	// SNOOPY: Stats order was wrong here !
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if(!bChangeState(cStateChange3,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{	// SNOOPY: Stats order was wrong here !
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if(m_pClientList[iClientH]->m_iGuildRank == 0 )
	{	if(m_pClientList[iClientH]->m_iCharisma - cChar < 20)
		{	// gm cn't drop charisma below 20
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
	}	}
	if(iOldStr +iOldVit	+iOldDex +iOldInt +iOldMag +iOldChar != ((m_iPlayerMaxLevel-1)*3 + 70))
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if(cStr < 0 || cVit < 0 || cDex < 0 || cInt < 0 || cMag < 0 || cChar < 0
		|| cStr + cVit + cDex + cInt + cMag + cChar != 3)
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iStr - cStr > m_sCharStatLimit) 
		 || (m_pClientList[iClientH]->m_iStr - cStr < 10)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iVit - cVit > m_sCharStatLimit) 
		 || (m_pClientList[iClientH]->m_iVit - cVit < 10)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iDex - cDex > m_sCharStatLimit) 
		 || (m_pClientList[iClientH]->m_iDex - cDex < 10)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iInt - cInt > m_sCharStatLimit) 
		 || (m_pClientList[iClientH]->m_iInt - cInt < 10)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iMag - cMag > m_sCharStatLimit) 
		 || (m_pClientList[iClientH]->m_iMag - cMag < 10)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_iCharisma - cChar > m_sCharStatLimit)
		 || (m_pClientList[iClientH]->m_iCharisma - cChar < 10)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	m_pClientList[iClientH]->m_iLU_Pool += 3;
	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;
	m_pClientList[iClientH]->m_iStr  -= cStr;
	m_pClientList[iClientH]->m_iVit  -= cVit;
	m_pClientList[iClientH]->m_iDex  -= cDex;
	m_pClientList[iClientH]->m_iInt  -= cInt;
	m_pClientList[iClientH]->m_iMag  -= cMag;
	m_pClientList[iClientH]->m_iCharisma -= cChar;
	if (cInt > 0) bCheckMagicInt(iClientH);
	// Snoopy: Check max values here or character will be considered as hacker if reducing mana or vit
	if (m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH, FALSE);
	if (m_pClientList[iClientH]->m_iMP > iGetMaxMP(iClientH)) m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
	if (m_pClientList[iClientH]->m_iSP > iGetMaxSP(iClientH)) m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);
	ZeroMemory(cStateTxt,sizeof(cStateTxt));
	wsprintf(cStateTxt, "STR(%d->%d)VIT(%d->%d)DEX(%d->%d)INT(%d->%d)MAG(%d->%d)CHARISMA(%d->%d)",
		iOldStr, m_pClientList[iClientH]->m_iStr,
		iOldVit, m_pClientList[iClientH]->m_iVit,
		iOldDex, m_pClientList[iClientH]->m_iDex,
		iOldInt, m_pClientList[iClientH]->m_iInt,
		iOldMag, m_pClientList[iClientH]->m_iMag,
		iOldChar,m_pClientList[iClientH]->m_iCharisma);
	PutLogList(cStateTxt);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
}

// 2003-04-21     ...
/////////////////////////////////////////////////////////////////////////////////////
//  BOOL CGame::bCheckMagicInt(int iClientH)  //another retarded korean function
//  desc		 ::     ... ...
//	return value ::  TRUE   // ....dumbass koreans
//  date		 :: 2003-04-21
/////////////////////////////////////////////////////////////////////////////////////
void CGame::bCheckMagicInt(int iClientH)
{

	for(int i = 0;i < DEF_MAXMAGICTYPE ;i++)
	{
		if(m_pMagicConfigList[i] != NULL)
		if(m_pMagicConfigList[i]->m_sIntLimit > (m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt))
		{
			m_pClientList[iClientH]->m_cMagicMastery[i] = 0;	
		}
	}
}

// 2003-04-14      ...
/////////////////////////////////////////////////////////////////////////////////////
//  bChangeState(char cStateChange 
//  		  ,char* cStr, char *cVit,char *cDex,char *cInt,char *cMag,char *cChar)
//  desc		 ::      ...
//	return value :: BOOL 0(FASLE)    ...
//  date		 :: [2003-04-14] 
/////////////////////////////////////////////////////////////////////////////////////
BOOL CGame::bChangeState(char cStateChange, char* cStr, char *cVit,char *cDex,char *cInt,char *cMag,char *cChar)
{	// centu - fixed
	if(cStateChange == DEF_STR)
	{	++*cStr; 
	}else if(cStateChange == DEF_VIT)
	{	++*cVit; 
	}else if(cStateChange == DEF_DEX)
	{	++*cDex; 
	}else if(cStateChange == DEF_INT)
	{	++*cInt; 
	}else if(cStateChange == DEF_MAG)
	{	++*cMag; 
	}else if(cStateChange == DEF_CHR)
	{	++*cChar; 
	}else
	{	return 0;
	}
	return cStateChange;
}

void CGame::LevelUpSettingsHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char * cp, cStr, cVit, cDex, cInt, cMag, cChar;
	int iTotalSetting = 0;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iLU_Pool <= 0) 
	{
		//??
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return ;
	}
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	cStr = *cp;
	cp++;

	cVit = *cp;
	cp++;

	cDex = *cp;
	cp++;

	cInt = *cp;
	cp++;

	cMag = *cp;
	cp++;

	cChar = *cp;
	cp++;


	if ( (cStr + cVit + cDex + cInt + cMag + cChar) > m_pClientList[iClientH]->m_iLU_Pool) { // -3
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
			return;
	}

	// Level-Up Setting   .
	if ((m_pClientList[iClientH]->m_iStr + cStr > m_sCharStatLimit) || (cStr < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iDex + cDex > m_sCharStatLimit) || (cDex < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iInt + cInt > m_sCharStatLimit) || (cInt < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iVit + cVit > m_sCharStatLimit) || (cVit < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iMag + cMag > m_sCharStatLimit) || (cMag < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iCharisma + cChar > m_sCharStatLimit) || (cChar < 0)) 
		return;

	iTotalSetting = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit + 
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	//(  +   >   ) ..  ..      ..
	if (iTotalSetting + m_pClientList[iClientH]->m_iLU_Pool -3 > ((m_pClientList[iClientH]->m_iLevel-1)*3 + 70))
	{
		
		m_pClientList[iClientH]->m_iLU_Pool = 3 + (m_pClientList[iClientH]->m_iLevel-1)*3 + 70 - iTotalSetting;

		//iTotalSetting  ...
		if(m_pClientList[iClientH]->m_iLU_Pool < 3)
			m_pClientList[iClientH]->m_iLU_Pool = 3;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return ;
	}

	//(  +    D >   )  ..
	if (iTotalSetting + (cStr + cVit + cDex + cInt + cMag + cChar)
		>	((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLU_Pool - (cStr + cVit + cDex + cInt + cMag + cChar);

	//    .
	m_pClientList[iClientH]->m_iStr  += cStr;
	m_pClientList[iClientH]->m_iVit  += cVit;
	m_pClientList[iClientH]->m_iDex  += cDex;
	m_pClientList[iClientH]->m_iInt  += cInt;
	m_pClientList[iClientH]->m_iMag  += cMag;
	m_pClientList[iClientH]->m_iCharisma += cChar;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);

}

// v1.4311-3     FightzoneReserveHandler
void CGame::FightzoneReserveHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char cData[100];
 int iFightzoneNum ,* ip ,  iEnableReserveTime ;
 DWORD * dwp, dwGoldCount ;
 WORD  * wp, wResult;
 int     iRet, iResult=1, iCannotReserveDay;
 SYSTEMTIME SysTime;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
 
	GetLocalTime(&SysTime);
	
	//    :      5  .
	iEnableReserveTime  = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 5*20;
	
	dwGoldCount = dwGetItemCount(iClientH, "Gold");
		
	ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
	//     .
	iFightzoneNum = *ip;

	//  fightzone  .
	if ((iFightzoneNum < 1) || (iFightzoneNum > DEF_MAXFIGHTZONE)) return;

	iCannotReserveDay = (SysTime.wDay + m_pClientList[iClientH]->m_cSide + iFightzoneNum ) % 2 ;
	if (iEnableReserveTime <= 0 ){
		wResult = DEF_MSGTYPE_REJECT;
		iResult = 0 ;
	} else if (m_iFightZoneReserve[iFightzoneNum-1] != 0){
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -1 ;
	} else if ( dwGoldCount < 1500 ) {
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -2 ;	           //   -2   .
	} else if( iCannotReserveDay ) {
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -3 ;
	} else if( m_pClientList[iClientH]-> m_iFightzoneNumber != 0 ) {
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -4 ;
	} else {
		wResult = DEF_MSGTYPE_CONFIRM;

		SetItemCount(iClientH, "Gold", dwGoldCount - 1500);
		iCalcTotalWeight(iClientH);
		
		m_iFightZoneReserve[iFightzoneNum-1] = iClientH;
		
		m_pClientList[iClientH]->m_iFightzoneNumber  = iFightzoneNum ;
		m_pClientList[iClientH]->m_iReserveTime	 =  SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour ;  

		if (SysTime.wHour%2 )	m_pClientList[iClientH]->m_iReserveTime  ++  ;	//     .
		else					m_pClientList[iClientH]->m_iReserveTime  += 2  ;    //      .
		wsprintf(G_cTxt, "(*) Reserve FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iReserveTime);		
		PutLogFileList(G_cTxt);
		PutLogList(G_cTxt);

		m_pClientList[iClientH]->m_iFightZoneTicketNumber  = 50 ;  
		iResult = 1 ;
	}  

	ZeroMemory(cData, sizeof(cData));

	dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_FIGHTZONE_RESERVE;

	wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp =  wResult ;

	ip  = (int *)(cData + DEF_INDEX2_MSGTYPE+2) ; 
	*ip =  iResult ;
	ip+= 4;
	
	//       
		
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
 
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
		//     .
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}



BOOL CGame::bCheckLimitedUser(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return FALSE;
	
	if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && 
		 (m_pClientList[iClientH]->m_iExp >= m_iLevelExp20 ) ) {
		//   20   19 . 

		m_pClientList[iClientH]->m_iExp = m_iLevelExp20 - 1;	
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TRAVELERLIMITEDLEVEL, NULL, NULL, NULL, NULL);
		return TRUE;
	}


	return FALSE;
}

void CGame::RequestCivilRightHandler(int iClientH, char *pData)
{
 char * cp, cData[100];
 DWORD * dwp;
 WORD * wp, wResult;
 int  iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;

	// ?  ?? ? ? ?   . 
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) wResult = 0;
	else wResult = 1;

	// ? 5 ? ? ?  . 
	if (m_pClientList[iClientH]->m_iLevel < 5) wResult = 0;
	
	if (wResult == 1) {
		// ? ? ?? .
		ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
		strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
	}

	// Side 
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) 
		m_pClientList[iClientH]->m_cSide = 1;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) 
		m_pClientList[iClientH]->m_cSide = 2;

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_CIVILRIGHT;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wResult;

	// v1.41  ?  
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp += 10;

	// ??  ? ?
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		//     .
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	// ?  ?  . 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	// new
	if (m_pClientList[iClientH]->m_iPartyID != NULL) {
		RequestDeletePartyHandler(iClientH);
	}
	CheckSpecialEvent(iClientH); // new
	RequestChangePlayMode(iClientH); // new
}



void CGame::RequestRetrieveItemHandler(int iClientH, char *pData)
{
 char * cp, cBankItemIndex, cMsg[100];
 int i, j, iRet, iItemWeight;
 DWORD * dwp;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cBankItemIndex = *cp;
	
	if (m_pClientList[iClientH]->m_bIsInsideWarehouse == FALSE) return;

	if ((cBankItemIndex < 0) || (cBankItemIndex >= DEF_MAXBANKITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] == NULL) {
		// . 
		ZeroMemory(cMsg, sizeof(cMsg));
			
		dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_RETRIEVEITEM;
		wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_REJECT;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
	}
	else {
		//  
		iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		
		if ( (iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
			//  ,    . 
			//   .
			ZeroMemory(cMsg, sizeof(cMsg));
			
			//     .
			dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				//     .
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}
			return;
		}
		
		//!!!
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			//     .	
			for (i = 0; i < DEF_MAXITEMS; i++)
			if ( (m_pClientList[iClientH]->m_pItemList[i] != NULL) && 
				 (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType) && 
			 	 (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cName, 20) == 0) ) {
				//    .  .
				// v1.41 !!! 
				SetItemCount(iClientH, i, m_pClientList[iClientH]->m_pItemList[i]->m_dwCount + m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
				
				//    
				delete m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
				m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;

				//   . 
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
						m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];	
						
						m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
					}
				}
				
				//   .
				ZeroMemory(cMsg, sizeof(cMsg));
					
				dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_MSGTYPE_CONFIRM;
					
				cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
				*cp = cBankItemIndex;
				cp++;
				*cp = i;
				cp++;
			
				//      
				iCalcTotalWeight(iClientH);
				//  
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
								
				//   
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					//     .
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}

			//      .   . 
			goto RRIH_NOQUANTITY;
		} 
		else {
RRIH_NOQUANTITY:;
			//    
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
				//   . 
				//   . 
				m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
				// v1.3 1-27 12:22
				m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
				m_pClientList[iClientH]->m_ItemPosList[i].y = 30;
			
				m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
				
				m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;
				
				//   . 
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
						m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];	
						
						m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
					}
				}
								
				//   .
				ZeroMemory(cMsg, sizeof(cMsg));
					
				dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_MSGTYPE_CONFIRM;
					
				cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
				*cp = cBankItemIndex;
				cp++;
				*cp = i;
				cp++;
					
				//      
				iCalcTotalWeight(iClientH);
		
				//  
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
					
				//   
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					//     .
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}
			//    . 
			ZeroMemory(cMsg, sizeof(cMsg));
			
			dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_RETRIEVEITEM;
			wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_MSGTYPE_REJECT;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
		}
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		//     .
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}

BOOL CGame::bSetItemToBankItem(int iClientH, short sItemIndex)
{
 int i, iRet;
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 char cData[100];
 class CItem * pItem;
	
	//    .
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsInsideWarehouse == FALSE) return FALSE;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
		//   .
				
		m_pClientList[iClientH]->m_pItemInBankList[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
		pItem = m_pClientList[iClientH]->m_pItemInBankList[i];
		// !!!      NULL . 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		
		//      
		iCalcTotalWeight(iClientH);

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);			   
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);		       
		*wp  = DEF_NOTIFY_ITEMTOBANK;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		*cp = i; //   
		cp++;

		// 1.
		*cp = 1;
		cp++;						    

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; 
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
	
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		// v1.432
		sp = (short *)cp;
		*sp = pItem->m_sItemEffectValue2;
		cp += 2;

		// v1.42
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		//    
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			//     . v1.41  .
			return TRUE; // v1.41 FALSE    .
		}

		return TRUE;
	}

	//    .
	return FALSE;
}
// 05/21/2004 - Hypnotoad - send player to jail
void CGame::ApplyPKpenalty(short sAttackerH, short sVictumH)
{
	int iV1, iV2;

	if (m_pClientList[sAttackerH] == NULL) return;
	if (m_pClientList[sVictumH] == NULL) return;
	//               
	//     .
	if ((m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) && (m_pClientList[sAttackerH]->m_iPKCount == 0)) return; 

	// PK Count   
	m_pClientList[sAttackerH]->m_iPKCount++;

	_bPKLog(DEF_PKLOG_BYPK,sAttackerH,sVictumH,NULL) ;

	//   
	iV1 = iDice((m_pClientList[sVictumH]->m_iLevel/2)+1, 50); 
	iV2 = iDice((m_pClientList[sAttackerH]->m_iLevel/2)+1, 50);

	m_pClientList[sAttackerH]->m_iExp -= iV1; 
	m_pClientList[sAttackerH]->m_iExp -= iV2;
	if (m_pClientList[sAttackerH]->m_iExp < 0) m_pClientList[sAttackerH]->m_iExp = 0;

	//   .
	SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	

	//     . 
	SendEventToNearClient_TypeA(sAttackerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	// v1.4    
	m_stCityStatus[m_pClientList[sAttackerH]->m_cSide].iCrimes++;

	// v1.41 Rating  
	m_pClientList[sAttackerH]->m_iRating -= 10;
	
	// MORLA 2.4 - Actualizo la REP
	SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_REPDGDEATHS, m_pClientList[sAttackerH]->m_iDGPoints, m_pClientList[sAttackerH]->m_iDeaths, m_pClientList[sAttackerH]->m_iRating, NULL);

	if (strcmp(m_pClientList[sAttackerH]->m_cLocation, "aresden") == 0) {
		if ( (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk11") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk12") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk21") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk22") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "aresden") == 0)   ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone2") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "areuni") == 0)    ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arefarm") == 0)) {

				//   PK .   5
				// v2.16  
				ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
				strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "arejail");
				m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
				RequestTeleportHandler(sAttackerH, "2   ", "arejail", -1, -1);
				return;		
			}
	}

	if (strcmp(m_pClientList[sAttackerH]->m_cLocation, "elvine") == 0) {
		if ( (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk11") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk12") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk21") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk22") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvine") == 0)    ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone1") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvuni") == 0)    ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {

				//   PK .   5
				ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
				strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "elvjail");
				m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
				RequestTeleportHandler(sAttackerH, "2   ", "elvjail", -1, -1);
				return;		
			}
	}
}


// 05/17/2004 - Hypnotoad - register pk log
void CGame::PK_KillRewardHandler(short sAttackerH, short sVictumH)
{
	if (m_pClientList[sAttackerH] == NULL) return;
	if (m_pClientList[sVictumH] == NULL)   return;

	_bPKLog(DEF_PKLOG_BYPLAYER,sAttackerH,sVictumH,NULL) ;

	if (m_pClientList[sAttackerH]->m_iPKCount != 0) {
		// PK   PK   .

	}
	else {
		//  .   . 
		m_pClientList[sAttackerH]->m_iRewardGold += iGetExpLevel(m_pClientList[sVictumH]->m_iExp) * 3;


		if (m_pClientList[sAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
			m_pClientList[sAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[sAttackerH]->m_iRewardGold < 0) 
			m_pClientList[sAttackerH]->m_iRewardGold = 0;

		SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_PKCAPTURED, m_pClientList[sVictumH]->m_iPKCount, m_pClientList[sVictumH]->m_iLevel, NULL, m_pClientList[sVictumH]->m_cCharName);
	}
}

void CGame::EnemyKillRewardHandler(int iAttackerH, int iClientH)
{
	// enemy-kill-mode = 1 | 0
	// if m_bEnemyKillMode is true than death match mode

	// DEATHMATCH MODE:
	// Aresden kills Elvine in Aresden and gets EK
	// Elvine kills Aresden in Aresden and gets an EK 
	// Elvine kills Aresden in Elvine and gets an EK
	// Aresden kills Elvine in Elvine and gets an EK

	// CLASSIC MODE:
	// Aresden kills Elvine in Aresden and gets EK
	// Elvine kills Aresden in Aresden and doesnt get an EK 
	// Elvine kills Aresden in Elvine and gets an EK
	// Aresden kills Elvine in Elvine and doesnt get an EK

	int iEK_Level;
	unsigned long iRewardExp;

	int iRangoAttacker = 1;
	
	// if the attacker doesnt exist no result
	if (m_pClientList[iAttackerH] == NULL) return;
	// if the target doesnt exist no result
	if (m_pClientList[iClientH] == NULL)   return;

	// anti lammer
	if ((strcmp(m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cIP2) == 0) || (strcmp(m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cIPaddress) == 0)) return; 
	strcpy(m_pClientList[iAttackerH]->m_cIP2, m_pClientList[iClientH]->m_cIPaddress);

	// Log the EK (killed by enemy)
	_bPKLog(DEF_PKLOG_BYENERMY,iAttackerH,iClientH,NULL) ;

	// MORLA2.2 - EK y REP segun Rango
	if((m_pClientList[iClientH]->m_iEnemyKillCount >= 100) && (m_pClientList[iClientH]->m_iRating >= 20 ))
	{
		if(((m_pClientList[iClientH]->m_iEnemyKillCount >= 100) && (m_pClientList[iClientH]->m_iRating < 30 )) || ((m_pClientList[iClientH]->m_iEnemyKillCount < 200) && (m_pClientList[iClientH]->m_iRating >= 20 )))
		{	iRangoAttacker = 1;
		}				
		else if(((m_pClientList[iClientH]->m_iEnemyKillCount >= 200) && (m_pClientList[iClientH]->m_iRating < 40 )) || ((m_pClientList[iClientH]->m_iEnemyKillCount < 300) && (m_pClientList[iClientH]->m_iRating >= 30 )))
		{	iRangoAttacker = 2;
		}
		else if(((m_pClientList[iClientH]->m_iEnemyKillCount >= 300) && (m_pClientList[iClientH]->m_iRating < 50 )) || ((m_pClientList[iClientH]->m_iEnemyKillCount < 400) && (m_pClientList[iClientH]->m_iRating >= 40 )))
		{	iRangoAttacker = 3;
		}
		else if(((m_pClientList[iClientH]->m_iEnemyKillCount >= 400) && (m_pClientList[iClientH]->m_iRating < 60 )) || ((m_pClientList[iClientH]->m_iEnemyKillCount < 500) && (m_pClientList[iClientH]->m_iRating >= 50 )))
		{	iRangoAttacker = 4;
		}
		else if(((m_pClientList[iClientH]->m_iEnemyKillCount >= 500) && (m_pClientList[iClientH]->m_iRating < 70 )) || ((m_pClientList[iClientH]->m_iEnemyKillCount < 600) && (m_pClientList[iClientH]->m_iRating >= 60 )))
		{	iRangoAttacker = 5;
		}
		else if(((m_pClientList[iClientH]->m_iEnemyKillCount >= 600) && (m_pClientList[iClientH]->m_iRating < 80 )) || ((m_pClientList[iClientH]->m_iEnemyKillCount < 700) && (m_pClientList[iClientH]->m_iRating >= 70 )))
		{	iRangoAttacker = 6;
		}
		else if(((m_pClientList[iClientH]->m_iEnemyKillCount >= 700) && (m_pClientList[iClientH]->m_iRating < 90 )) || ((m_pClientList[iClientH]->m_iEnemyKillCount < 800) && (m_pClientList[iClientH]->m_iRating >= 80 )))
		{	iRangoAttacker = 7;
		}
		else if(((m_pClientList[iClientH]->m_iEnemyKillCount >= 800) && (m_pClientList[iClientH]->m_iRating < 100 )) || ((m_pClientList[iClientH]->m_iEnemyKillCount < 900) && (m_pClientList[iClientH]->m_iRating >= 90 )))
		{	iRangoAttacker = 8;
		}
		else if(((m_pClientList[iClientH]->m_iEnemyKillCount >= 900) && (m_pClientList[iClientH]->m_iRating < 200 )) || ((m_pClientList[iClientH]->m_iEnemyKillCount < 1000) && (m_pClientList[iClientH]->m_iRating >= 100 )))
		{	iRangoAttacker = 9;
		}
		else if( (m_pClientList[iClientH]->m_iEnemyKillCount >= 1000) &&  (m_pClientList[iClientH]->m_iRating >= 200 ))
		{	iRangoAttacker = 10;
		}
	}
	
	// set EK level to 30
	iEK_Level = 30;
	// if attacker's level is greater than 80, set ek level to 80
	if (m_pClientList[iAttackerH]->m_iLevel >= 80) iEK_Level = 80;
	// check if attacker level is less than or equal to max level
	if (m_pClientList[iAttackerH]->m_iLevel >= m_iPlayerMaxLevel) {
		// if the
		if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
			//   80
			if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) 
				&& (m_bEnemyKillMode == FALSE)) {
				
				//       EK  
				if (m_bIsCrusadeMode == TRUE || m_bIsHeldenianMode == TRUE) 
					 m_pClientList[iAttackerH]->m_iEnemyKillCount += (m_iEnemyKillAdjust * iRangoAttacker)*2; 
				else m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust*iRangoAttacker;

				m_pClientList[iClientH]->m_iDeaths++; // MORLA 2.2 - Le suma una muerte al pj
				 
				if (m_pClientList[iAttackerH]->m_iEnemyKillCount > m_pClientList[iAttackerH]->m_iMaxEK)
				{
					m_pClientList[iAttackerH]->m_iMaxEK = m_pClientList[iAttackerH]->m_iEnemyKillCount;
				}
			}
			
			if (m_bEnemyKillMode == TRUE) {
				
				//       EK  
				if (m_bIsCrusadeMode == TRUE || m_bIsHeldenianMode == TRUE) 
					 m_pClientList[iAttackerH]->m_iEnemyKillCount += (m_iEnemyKillAdjust * iRangoAttacker)*2; 
				else m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust*iRangoAttacker;

				m_pClientList[iClientH]->m_iDeaths++; // MORLA 2.2 - Le suma una muerte al pj

				if (m_pClientList[iAttackerH]->m_iEnemyKillCount > m_pClientList[iAttackerH]->m_iMaxEK)
				{
					m_pClientList[iAttackerH]->m_iMaxEK = m_pClientList[iAttackerH]->m_iEnemyKillCount;
				}
				
				
			}
		}
		//   
		m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
		if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
			m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
			m_pClientList[iAttackerH]->m_iRewardGold = 0;

		//     
		SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, NULL, NULL, NULL);
		return;
	}

	if (m_pClientList[iAttackerH]->m_iPKCount != 0) {
		//    PK   .
	}	
	else {
		//  ,     . 
		if (m_pClientList[iClientH]->m_iGuildRank == -1) {
			//   . (     )
			// v2.15     
			iRewardExp = (iDice(3, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp))/ 3 ;

			if (m_bIsCrusadeMode == TRUE) {
				//    (1/3)*3    6    
				m_pClientList[iAttackerH]->m_iExp += (iRewardExp/3)*4;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp - (iRewardExp/3))*12;

				if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				//testcode
				wsprintf(G_cTxt, "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp/3))*6);
				PutLogList(G_cTxt);

				// .
				SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);

				//   80   Enemy Kill count .
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					//   80
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) {
						//       EK  
						if (m_bIsCrusadeMode == TRUE || m_bIsHeldenianMode == TRUE) 
							 m_pClientList[iAttackerH]->m_iEnemyKillCount += (m_iEnemyKillAdjust * iRangoAttacker)*2; 
						else m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust*iRangoAttacker;

						m_pClientList[iClientH]->m_iDeaths++; // MORLA 2.2 - Le suma una muerte al pj

						if (m_pClientList[iAttackerH]->m_iEnemyKillCount > m_pClientList[iAttackerH]->m_iMaxEK)
						{
							m_pClientList[iAttackerH]->m_iMaxEK = m_pClientList[iAttackerH]->m_iEnemyKillCount;
						}
						
						
					}
					if (m_bEnemyKillMode == TRUE) {
						//       EK  
						if (m_bIsCrusadeMode == TRUE || m_bIsHeldenianMode == TRUE) 
							 m_pClientList[iAttackerH]->m_iEnemyKillCount += (m_iEnemyKillAdjust * iRangoAttacker)*2; 
						else m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust*iRangoAttacker;

						m_pClientList[iClientH]->m_iDeaths++; // MORLA 2.2 - Le suma una muerte al pj

						if (m_pClientList[iAttackerH]->m_iEnemyKillCount > m_pClientList[iAttackerH]->m_iMaxEK)
						{
							m_pClientList[iAttackerH]->m_iMaxEK = m_pClientList[iAttackerH]->m_iEnemyKillCount;
						}
						 
						
					}
				}
				//   
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				//  .
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				//   80   Enemy Kill count .
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					//   80
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) 
						&& (m_bEnemyKillMode == FALSE)) {
						//       EK  
						if (m_bIsCrusadeMode == TRUE || m_bIsHeldenianMode == TRUE) 
							 m_pClientList[iAttackerH]->m_iEnemyKillCount += (m_iEnemyKillAdjust * iRangoAttacker)*2; 
						else m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust*iRangoAttacker;

						m_pClientList[iClientH]->m_iDeaths++; // MORLA 2.2 - Le suma una muerte al pj
						
						if (m_pClientList[iAttackerH]->m_iEnemyKillCount > m_pClientList[iAttackerH]->m_iMaxEK)
						{
							m_pClientList[iAttackerH]->m_iMaxEK = m_pClientList[iAttackerH]->m_iEnemyKillCount;
						}
						
					}
					
					if (m_bEnemyKillMode == TRUE) {
						//       EK  
						if (m_bIsCrusadeMode == TRUE || m_bIsHeldenianMode == TRUE) 
							 m_pClientList[iAttackerH]->m_iEnemyKillCount += (m_iEnemyKillAdjust * iRangoAttacker)*2; 
						else m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust*iRangoAttacker;

						m_pClientList[iClientH]->m_iDeaths++; // MORLA 2.2 - Le suma una muerte al pj
						
						 if (m_pClientList[iAttackerH]->m_iEnemyKillCount > m_pClientList[iAttackerH]->m_iMaxEK)
						{
							m_pClientList[iAttackerH]->m_iMaxEK = m_pClientList[iAttackerH]->m_iEnemyKillCount;
						}
						
					}
				}
				//   
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}
		else {
			// v2.15     
			iRewardExp = (iDice(3, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp))/ 3 ;

			// .
			if (m_bIsCrusadeMode == TRUE) {
				//  .
				//    1/3    2    
				m_pClientList[iAttackerH]->m_iExp += (iRewardExp/3)*4;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp - (iRewardExp/3))*12;

				if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				//testcode
				wsprintf(G_cTxt, "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp/3))*6);
				PutLogList(G_cTxt);

				// .
				SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);

				//   80   Enemy Kill count .
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					//   80
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) 
						&& (m_bEnemyKillMode == FALSE)) {
						//       EK  
						if (m_bIsCrusadeMode == TRUE || m_bIsHeldenianMode == TRUE) 
							 m_pClientList[iAttackerH]->m_iEnemyKillCount += (m_iEnemyKillAdjust * iRangoAttacker)*2; 
						else m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust*iRangoAttacker;

						m_pClientList[iClientH]->m_iDeaths++; // MORLA 2.2 - Le suma una muerte al pj

						if (m_pClientList[iAttackerH]->m_iEnemyKillCount > m_pClientList[iAttackerH]->m_iMaxEK)
						{
							m_pClientList[iAttackerH]->m_iMaxEK = m_pClientList[iAttackerH]->m_iEnemyKillCount;
						}
						
					}
					
					if (m_bEnemyKillMode == TRUE) {
						//       EK  
						if (m_bIsCrusadeMode == TRUE || m_bIsHeldenianMode == TRUE) 
							 m_pClientList[iAttackerH]->m_iEnemyKillCount += (m_iEnemyKillAdjust * iRangoAttacker)*2; 
						else m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust*iRangoAttacker;

						m_pClientList[iClientH]->m_iDeaths++; // MORLA 2.2 - Le suma una muerte al pj

						if (m_pClientList[iAttackerH]->m_iEnemyKillCount > m_pClientList[iAttackerH]->m_iMaxEK)
						{
							m_pClientList[iAttackerH]->m_iMaxEK = m_pClientList[iAttackerH]->m_iEnemyKillCount;
						}
					}
				}
				//   
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				//  .
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				// Enemy Kill count .
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					//   80
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) 
						&& (m_bEnemyKillMode == FALSE)) {
						//       EK  
						if (m_bIsCrusadeMode == TRUE || m_bIsHeldenianMode == TRUE) 
							 m_pClientList[iAttackerH]->m_iEnemyKillCount += (m_iEnemyKillAdjust * iRangoAttacker)*2; 
						else m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust*iRangoAttacker;

						m_pClientList[iClientH]->m_iDeaths++; // MORLA 2.2 - Le suma una muerte al pj

						if (m_pClientList[iAttackerH]->m_iEnemyKillCount > m_pClientList[iAttackerH]->m_iMaxEK)
						{
							m_pClientList[iAttackerH]->m_iMaxEK = m_pClientList[iAttackerH]->m_iEnemyKillCount;
						}
						
					}
					
					if (m_bEnemyKillMode == TRUE) {
						//       EK  
						if (m_bIsCrusadeMode == TRUE || m_bIsHeldenianMode == TRUE) 
							 m_pClientList[iAttackerH]->m_iEnemyKillCount += (m_iEnemyKillAdjust * iRangoAttacker)*2; 
						else m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust*iRangoAttacker;

						m_pClientList[iClientH]->m_iDeaths++; // MORLA 2.2 - Le suma una muerte al pj

						if (m_pClientList[iAttackerH]->m_iEnemyKillCount > m_pClientList[iAttackerH]->m_iMaxEK)
						{
							m_pClientList[iAttackerH]->m_iMaxEK = m_pClientList[iAttackerH]->m_iEnemyKillCount;
						}
						
					}
				}	
				//   
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}

		//     
		SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, NULL, NULL, NULL);

		if (bCheckLimitedUser(iAttackerH) == FALSE) {
			//         .
			SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
		}
		//   .
		bCheckLevelUp(iAttackerH);

		//v1.4    .
		m_stCityStatus[m_pClientList[iAttackerH]->m_cSide].iWins++;
	}
}

// 05/22/2004 - Hypnotoad - register in pk log
void CGame::ApplyCombatKilledPenalty(int iClientH, int cPenaltyLevel, BOOL bIsSAattacked)
{  
	unsigned long iExp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// Crusade
	if (m_bIsCrusadeMode == TRUE) {
		//        .
		// PKcount  
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	
			// v2.15 
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL,NULL,iClientH,NULL) ;

		}
		return;
	}
	else {
		// PKcount  
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	
			// v2.15
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL,NULL,iClientH,NULL) ;
		}

		//     .
		iExp = iDice(1, (5*cPenaltyLevel*m_pClientList[iClientH]->m_iLevel));

		//       1/3
		if (m_pClientList[iClientH]->m_bIsNeutral == TRUE) iExp = iExp / 3;

		m_pClientList[iClientH]->m_iExp -= iExp;
		if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);

		// v1.41    .
		if (m_pClientList[iClientH]->m_bIsNeutral != TRUE) {
			if (m_pClientList[iClientH]->m_iLevel < 80) {
				//  80     .
				// v2.03 60 -> 80
				cPenaltyLevel--;
				if (cPenaltyLevel <= 0) cPenaltyLevel = 1;
				_PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
			}
				else _PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
		}
	}
}

// 05/29/2004 - Hypnotoad - Limits some items from not dropping
void CGame::_PenaltyItemDrop(int iClientH, int iTotal, BOOL bIsSAattacked)
{
 int i, j, iRemainItem;
 char cItemIndexList[DEF_MAXITEMS], cItemIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((m_pClientList[iClientH]->m_iAlterItemDropIndex != -1) && (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex] != NULL)) {
		// Testcode
		if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) {
			// v2.04     
			//           . 
			if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0)
				m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;

			DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);

			m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
		}
		else {
			// v2.04 testcode
			PutLogFileList("Alter Drop Item Index Error1");
			//   
			for (i = 0; i < DEF_MAXITEMS; i++) 
			if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
				m_pClientList[iClientH]->m_iAlterItemDropIndex = i;
				if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0)
					m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;

				DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);	
				m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
				return;
			}

			// !  . 
			goto PID_DROP;
		}
		return;
	}

PID_DROP:;

	for (i = 1; i <= iTotal; i++) {
		iRemainItem = 0;
		ZeroMemory(cItemIndexList, sizeof(cItemIndexList));
		
		for (j = 0; j < DEF_MAXITEMS; j++) 
		if (m_pClientList[iClientH]->m_pItemList[j] != NULL) {
			cItemIndexList[iRemainItem] = j;
			iRemainItem++;
		}
		
		if (iRemainItem == 0) return;
		cItemIndex = cItemIndexList[ iDice(1, iRemainItem) - 1 ];
		
	
		if ((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectType != 0) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
			//     .    
		}

		else if (
				 (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum >= 400) && 
				 (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum != 402) && 
				 (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum <= 428)) {
		}

		else if (((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) ||
			     (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) &&
			     (bIsSAattacked == FALSE)) {
			//          .
		}

		else if ((m_pClientList[iClientH]->m_bIsLuckyEffect == TRUE) && (iDice(1,10) == 5)) {
			//    10%    .
		}

		else DropItemHandler(iClientH, cItemIndex, -1, m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_cName);
	}
}

void CGame::GetRewardMoneyHandler(int iClientH)		    
{
 int iRet, iEraseReq, iWeightLeft, iRewardGoldLeft;
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cData[100], cItemName[21];
 class CItem * pItem;
 short * sp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	
	//   . 
	iWeightLeft = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
		
	if (iWeightLeft <= 0) return;
	//   . <-        .
	iWeightLeft = iWeightLeft / 2;
	if (iWeightLeft <= 0) return;

	pItem = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItem, cItemName);
	
	if ((iWeightLeft / iGetItemWeight(pItem, 1)) >= m_pClientList[iClientH]->m_iRewardGold) {
		//     . 
		pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
		iRewardGoldLeft = 0;
	}
	else {
		pItem->m_dwCount = (iWeightLeft / iGetItemWeight(pItem, 1));
		iRewardGoldLeft = m_pClientList[iClientH]->m_iRewardGold - (iWeightLeft / iGetItemWeight(pItem, 1));
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		//  .
		
		//    .
		m_pClientList[iClientH]->m_iRewardGold = iRewardGoldLeft;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		// 1 . <-  1    
		*cp = 1;
		cp++;

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; //    .
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;

		*cp = pItem->m_cGenderLimit;
		cp++;

		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		

		if (iEraseReq == 1) delete pItem;
		
		//    
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
						
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
			//     .
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}

		//     .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
	}
	else {
		//        . 

	}
}


int CGame::_iCalcMaxLoad(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return 0;

	return (((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr) * 500) + (m_pClientList[iClientH]->m_iLevel*500));
}

int CGame::iAddDynamicObjectList(short sOwner, char cOwnerType, short sType, char cMapIndex, short sX, short sY, DWORD dwLastTime, int iV1)
{
 int i;
 short sPreType;
 DWORD dwTime, dwRegisterTime;

	m_pMapList[cMapIndex]->bGetDynamicObject(sX, sY, &sPreType, &dwRegisterTime);
	if (sPreType != NULL) return NULL;

	switch (sType) {	
	case DEF_DYNAMICOBJECT_FIRE3:
	case DEF_DYNAMICOBJECT_FIRE:
		if (m_pMapList[cMapIndex]->bGetIsMoveAllowedTile(sX, sY) == FALSE)
			return NULL;
		if (dwLastTime != NULL)  {
			switch (m_pMapList[cMapIndex]->m_cWhetherStatus) {
			case 1:	dwLastTime = dwLastTime - (dwLastTime / 2);       break;
			case 2:	dwLastTime = (dwLastTime / 2) - (dwLastTime / 3); break;
			case 3:	dwLastTime = (dwLastTime / 3) - (dwLastTime / 4); break;
			// SNOOPY: Added reduced duration if snow whether
			case 4:	dwLastTime = dwLastTime - (dwLastTime / 6);       break;
			case 5:	dwLastTime = dwLastTime - (dwLastTime / 4);		  break;
			case 6:	dwLastTime = dwLastTime - (dwLastTime / 2);		  break;
			default:break;
			}
			if (dwLastTime == NULL) dwLastTime = 1000;
		}
		break;

	// SNOOPY: Increased duration if snow whether
	case DEF_DYNAMICOBJECT_ICESTORM:
		if (dwLastTime != NULL)  {
			switch (m_pMapList[cMapIndex]->m_cWhetherStatus) {
			case 1:	break;
			// Reduced duration if heavy rain
			case 2:	dwLastTime = dwLastTime  - (dwLastTime / 8); break;
			case 3:	dwLastTime = dwLastTime  - (dwLastTime / 4); break;
			// Increased duration if snow whether
			case 4:	dwLastTime = dwLastTime + (dwLastTime / 2);       break;
			case 5:	dwLastTime = dwLastTime *2;		  break;
			case 6:	dwLastTime = dwLastTime *4;		  break;
			default:break;
			}
			if (dwLastTime == NULL) dwLastTime = 1000;
		}
		break;
	
	case DEF_DYNAMICOBJECT_FISHOBJECT:
	case DEF_DYNAMICOBJECT_FISH:
		if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE)
			return NULL;
		break;

	case DEF_DYNAMICOBJECT_ARESDENFLAG1:
	case DEF_DYNAMICOBJECT_ELVINEFLAG1:
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		if (m_pMapList[cMapIndex]->bGetMoveable(sX, sY) == FALSE)
			return NULL;
		m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, FALSE);
		break;

	case DEF_DYNAMICOBJECT_FIRE2:
		break;

	}
   	
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] == NULL) {
		dwTime = timeGetTime();
		
		if (dwLastTime != NULL) 
			dwLastTime += (iDice(1,4)*1000);

		m_pDynamicObjectList[i] = new class CDynamicObject(sOwner, cOwnerType, sType, cMapIndex, sX, sY, dwTime, dwLastTime, iV1);
		m_pMapList[cMapIndex]->SetDynamicObject(i, sType, sX, sY, dwTime);
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_CONFIRM, cMapIndex, sX, sY, sType, i, NULL);

		return i;
	}
	return NULL;
}

void CGame::CheckDynamicObjectList()
{
 int i;
 DWORD dwTime = timeGetTime(), dwRegisterTime;
 short sType;

	//        . 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++)  
	{	if ( (m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL) ) 
		{	switch (m_pDynamicObjectList[i]->m_sType) {
			case DEF_DYNAMICOBJECT_FIRE3:
			case DEF_DYNAMICOBJECT_FIRE:
				switch (m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus) {
				case 0: break;
				case 1: 
				case 2:
				case 3:
					m_pDynamicObjectList[i]->m_dwLastTime = m_pDynamicObjectList[i]->m_dwLastTime - 
(m_pDynamicObjectList[i]->m_dwLastTime/10) * m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus;
					break;
				case 4: 	// SNOOPY: Added snow whether
				case 5:
				case 6:
					m_pDynamicObjectList[i]->m_dwLastTime = m_pDynamicObjectList[i]->m_dwLastTime - 
(m_pDynamicObjectList[i]->m_dwLastTime/20) * m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus;
				}
				break;
	}	}	}

	//    .  NULL    .
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) { 
		if ( (m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL) && 
			 ((dwTime - m_pDynamicObjectList[i]->m_dwRegisterTime) >= m_pDynamicObjectList[i]->m_dwLastTime) ) {
		
			//     .
			m_pMapList[ m_pDynamicObjectList[i]->m_cMapIndex ]->bGetDynamicObject( m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, &sType, &dwRegisterTime );
			//       .
			
			if (dwRegisterTime == m_pDynamicObjectList[i]->m_dwRegisterTime) {
				SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, NULL);
				//  .
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
			}

			switch (sType) {
			case DEF_DYNAMICOBJECT_FISHOBJECT:
			case DEF_DYNAMICOBJECT_FISH:
				//    .
				bDeleteFish(m_pDynamicObjectList[i]->m_sOwner, 2); //    .
				break;
			}
	
			//  .
			delete m_pDynamicObjectList[i];
			m_pDynamicObjectList[i] = NULL;
		}
	}
}

void CGame::CalculateSSN_ItemIndex(int iClientH, short sWeaponIndex, int iValue)
{
 short sSkillIndex;
 int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sWeaponIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	
	sSkillIndex = m_pClientList[iClientH]->m_pItemList[sWeaponIndex]->m_sRelatedSkill;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;
	
	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	if ( (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		 (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint) ) {
		
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++; 
		
		switch (sSkillIndex) {

		case 22: // Taming
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iCharisma * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 0:  // Mining
		case 5:  // Hand-Attack
		case 13: // Manufacturing
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3: // Magic-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:  // Magic
		case 18: // Crafting
		case 21: // Staff-Attack
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:  // Fishing
		case 6:  // Archery
		case 7:  // Short-Sword
		case 8:  // Long-Sword
		case 9:  // Fencing 
		case 10: // Axe-Attack
		case 11: // Shield        	
		case 14: // Hammer 
		case 20: // Dual-Wielding
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iDex+m_pClientList[iClientH]->m_iAngelicDex) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 2:	 // Farming
		case 12: // Alchemy
		case 15: // 
		case 19: // Pretend-Corpse
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // Poison-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
		
		//             1 . 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			//  0    . 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				//   . 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					//     .  1 . 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				//   . 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					//  Mace    .  1 . 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}
	 		
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKill  600     1 . 
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
			// Skill    .
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
		}
	}
}



void CGame::CalculateSSN_SkillIndex(int iClientH, short sSkillIndex, int iValue)
{
 int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	//   0   .
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;



	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;
	
	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	//  SkillSSN   Skill . 
	if ( (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		(m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint) ) {
		
		//  .
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++; 
		//    Skill .
		switch (sSkillIndex) {
		case 0:
		case 5:
		case 13:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr) * 2)) {
				//  .   .
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3:
			//    Level*2 .
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				//  .   .
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:
		case 18: // Crafting
		case 21:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag) * 2)) {
				//  .   .
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 20: // Dual-Wielding
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iDex+m_pClientList[iClientH]->m_iAngelicDex) * 2)) {
				//  .   .
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 2:
		case 12:
		case 14:
		case 15:
		case 19:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt) * 2)) {
				//  .   .
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: //   
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				//  .   .
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 22: // SNOOPY:Taming
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iCharisma * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
		
		//             1 . 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			//  0    . 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				//   . 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					//     .  1 . 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				//   . 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					//  Mace    .  1 . 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}
			
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKill  700     1 . 
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
		
			// Skill    .
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
		}
	}
}

void CGame::CalcNextWayPointDestination(int iNpcH)
{
 short sRange, sX, sY;
 int i, j, iMapIndex;
 BOOL bFlag;

	switch (m_pNpcList[iNpcH]->m_cMoveType) {
	case DEF_MOVETYPE_GUARD:
		//        .
		break;
	
	case DEF_MOVETYPE_SEQWAYPOINT: 

		m_pNpcList[iNpcH]->m_cCurWaypoint++;
		if (m_pNpcList[iNpcH]->m_cCurWaypoint >= m_pNpcList[iNpcH]->m_cTotalWaypoint)
			m_pNpcList[iNpcH]->m_cCurWaypoint = 1;
		m_pNpcList[iNpcH]->m_dX  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
		m_pNpcList[iNpcH]->m_dY  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
		break;

	case DEF_MOVETYPE_RANDOMWAYPOINT:
	
		m_pNpcList[iNpcH]->m_cCurWaypoint = (short)((rand() % (m_pNpcList[iNpcH]->m_cTotalWaypoint - 1)) + 1);
		m_pNpcList[iNpcH]->m_dX  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
		m_pNpcList[iNpcH]->m_dY  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
		break;

	case DEF_MOVETYPE_RANDOMAREA:
				
		sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.right - m_pNpcList[iNpcH]->m_rcRandomArea.left);
		m_pNpcList[iNpcH]->m_dX = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.left);
		sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.bottom - m_pNpcList[iNpcH]->m_rcRandomArea.top);
		m_pNpcList[iNpcH]->m_dY = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.top);
		break;

	case DEF_MOVETYPE_RANDOM:
		//   
		iMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;

		for ( i = 0; i <= 30; i++) {
		//       30  
			sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
			sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

			bFlag = TRUE;
			for (j = 0; j < DEF_MAXMGAR; j++)
			if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left != -1) {
				//    . 
				if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left) &&
					(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].right) &&
					(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].top) &&
					(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].bottom)) {
					// Avoid Rect     .	
					bFlag = FALSE;
				}
			}
			if (bFlag == TRUE) goto CNW_GET_VALIDLOC_SUCCESS;
		}
		// Fail! 
		m_pNpcList[iNpcH]->m_tmp_iError  = 0; 
		return;

CNW_GET_VALIDLOC_SUCCESS:;
		m_pNpcList[iNpcH]->m_dX = sX;
		m_pNpcList[iNpcH]->m_dY = sY;
		break;
	}

	m_pNpcList[iNpcH]->m_tmp_iError  = 0; // @@@ !!! @@@
}

void CGame::DeleteNpc(int iNpcH)
{
	int  i, iNamingValue, iNumItem, iItemID, iItemIDs[MAX_NPCITEMDROP], iSlateID;
	char cTmp[21], cItemName[21];
	class CItem * pItem, * pItem2;
	DWORD dwCount, dwTime;
    POINT ItemPositions[MAX_NPCITEMDROP];
	char cTemp[256];
	SYSTEMTIME SysTime;
	if (m_pNpcList[iNpcH] == NULL) return;

	dwTime = timeGetTime();

	//Init number of items to 1 unless its a multidrop;
	iNumItem = 0;
	iItemID = 0; // No current item

	//   
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);

	ZeroMemory(cTmp, sizeof(cTmp));
	strcpy(cTmp, (char *)(m_pNpcList[iNpcH]->m_cName + 2));
	// NPC NamigValue    .
	iNamingValue = atoi(cTmp);

	// NamingValue     .
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalActiveObject--;

	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalActiveObject == 0) 
	{	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType == 1)
		{	// See if we need to open a dynamic Gate, then tell clients
			Open_EmptyMap_Gate(m_pNpcList[iNpcH]->m_cMapIndex);
		}
		if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType == 2)
		{	// generate Abaddon and open Dynamic Gate
			GenerateApocalypseBoss(m_pNpcList[iNpcH]->m_cMapIndex);
			// Then change m_iApocalypseMobGenType to 1 for Gate openning when this boss is dead
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType = 1;	
	}	}

	// Spot-mob-generator 
	if ( m_pNpcList[iNpcH]->m_iSpotMobIndex != NULL )
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stSpotMobGenerator[m_pNpcList[iNpcH]->m_iSpotMobIndex].iCurMobs--;

	RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);

	//       
	switch (m_pNpcList[iNpcH]->m_sType) {
	case 36:
	case 37:
	case 38:
	case 39:
	case 42:
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCrusadeStructureInfo(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
		//     
		for (i = 0; i < DEF_MAXGUILDS; i++) 
			if (m_pGuildTeleportLoc[i].m_iV1 == m_pNpcList[iNpcH]->m_iGuildGUID) {
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				m_pGuildTeleportLoc[i].m_iV2--;
				if (m_pGuildTeleportLoc[i].m_iV2 < 0) m_pGuildTeleportLoc[i].m_iV2 = 0;
				break;	
			}
			break;
	case 64: m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCropsTotalSum(); break;

	}

	// DelayEvent  
	bRemoveFromDelayEventList(iNpcH, DEF_OWNERTYPE_NPC, NULL);
	if ((m_pNpcList[iNpcH]->m_bIsSummoned == FALSE) && (m_pNpcList[iNpcH]->m_bIsUnsummoned == FALSE)) {
		//     .
		pItem = new class CItem;
		ZeroMemory(cItemName, sizeof(cItemName));
		switch (m_pNpcList[iNpcH]->m_sType) {

		case 10: // Slime
			if (iDice(1,25) == 1) iItemID = 220; break; // SlimeJelly 
			break;

		case 11: // Skeleton
			switch(iDice(1,2))	{
			case 1:if (iDice(1,20) == 1) iItemID = 219; break; // SkeletonBones
			case 2: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;
			
		case 12: // Stone-Golem
		switch(iDice(1,2)){
			case 1:	if (iDice(1,30) == 1) iItemID = 221; break; // StoneGolemPiece
			case 2: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}	
			break;

		case 13: // Cyclops
			switch(iDice(1,6)){
			case 1:	if (iDice(1,36) == 1) iItemID = 194; break; // CyclopsEye
			case 2:	if (iDice(1,40) == 1) iItemID = 195; break; // CyclopsHandEdge
			case 3:	if (iDice(1,30) == 1) iItemID = 196; break; // CyclopsHeart
			case 4:	if (iDice(1,22) == 1) iItemID = 197; break; // CyclopsMeat
			case 5:	if (iDice(1,40) == 1) iItemID = 198; break; // CyclopsLeather
			case 6:	bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 14: // Orc, Orc-Mage
			switch(iDice(1,4)){
			case 1:	if (iDice(1,11) == 1) iItemID = 206; break; // OrcMeat
			case 2:	if (iDice(1,20) == 1) iItemID = 207; break; // OrcLeather
			case 3:	if (iDice(1,21) == 1) iItemID = 208; break; // OrcTeeth
			case 4: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;
			
		case 16: //Giant-Ant
			switch(iDice(1,3)){
			case 1:	if (iDice(1,9) == 1) iItemID = 192; break; // AntLeg
			case 2:	if (iDice(1,10) == 1) iItemID = 193; break; // AntFeeler
			case 3:	bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 17: //Scorpion
			switch(iDice(1,5)){
			case 1:	if (iDice(1,50) == 1) iItemID = 215; break; // ScorpionPincers
			case 2:	if (iDice(1,20) == 1) iItemID = 216; break; // ScorpionMeat
			case 3: if (iDice(1,50) == 1) iItemID = 217; break; // ScorpionSting
			case 4: if (iDice(1,40) == 1) iItemID = 218; break; // ScorpionSkin
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 18: //Zombie
			bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			break;

		case 22: //Amphis
			switch(iDice(1,5)){
			case 1: if (iDice(1,15) == 1) iItemID = 188; break; // SnakeMeat
			case 2:	if (iDice(1,16) == 1) iItemID = 189; break; // SnakeSkin
			case 3:	if (iDice(1,16) == 1) iItemID = 190; break; // SnakeTeeth
			case 4:	if (iDice(1,17) == 1) iItemID = 191; break; // SnakeTongue
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 23: //Clay-Golem
			switch(iDice(1,2)){
			case 1: if (iDice(1,30) == 1) iItemID = 205; break; // LumpofClay
			case 2: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;


		case 27: //Hellbound
			switch(iDice(1,7)){
			case 1:	if (iDice(1,40) == 1) iItemID = 199; break; // HelboundHeart
			case 2:	if (iDice(1,38) == 1) iItemID = 200; break; // HelboundLeather
			case 3:	if (iDice(1,38) == 1) iItemID = 201; break; // HelboundTail
			case 4:	if (iDice(1,36) == 1) iItemID = 202; break; // HelboundTeeth
			case 5:	if (iDice(1,36) == 1) iItemID = 203; break; // HelboundClaw
			case 6:	if (iDice(1,50) == 1) iItemID = 204; break; // HelboundTongue
			case 7: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 28: //Troll
			switch(iDice(1,5)){
			case 1:	if (iDice(1,35) == 1) iItemID = 222; break; // TrollHeart
			case 2:	if (iDice(1,23) == 1) iItemID = 223; break; // TrollMeat
			case 3:	if (iDice(1,25) == 1) iItemID = 224; break; // TrollLeather
			case 4:	if (iDice(1,27) == 1) iItemID = 225; break; // TrollClaw
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 29: //Orge
			switch(iDice(1,7)){
			case 1:	if (iDice(1,20) == 1) iItemID = 209; break; // OgreHair
			case 2:	if (iDice(1,22) == 1) iItemID = 210; break; // OgreHeart
			case 3:	if (iDice(1,25) == 1) iItemID = 211; break; // OgreMeat
			case 4:	if (iDice(1,25) == 1) iItemID = 212; break; // OgreLeather
			case 5:	if (iDice(1,28) == 1) iItemID = 213; break; // OgreTeeth
			case 6:	if (iDice(1,28) == 1) iItemID = 214; break; // OgreClaw
			case 7: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 30: //Liche
			bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			break;

		case 31: //Demon
			switch(iDice(1,5)){
			case 1:	if (iDice(1,400) == 123) iItemID = 541; break; // DemonHeart
			case 2:	if (iDice(1,1000) == 123) iItemID = 542; break; // DemonMeat
			case 3:	if (iDice(1,200) == 123) iItemID = 543; break; // DemonLeather
			case 4:	if (iDice(1,300) == 123) iItemID = 540; break; // DemonEye
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 32: //Unicorn
			switch(iDice(1,5)){
			case 1:	if (iDice(1,3000) == 396) iItemID = 544; break; // UnicornHeart
			case 2:	if (iDice(1,500) == 3) iItemID = 545; break; // UnicornHorn
			case 3:	if (iDice(1,100) == 3) iItemID = 546; break; // UnicornMeat
			case 4:	if (iDice(1,200) == 3) iItemID = 547; break; // UnicornLeather
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 33: //WereWolf
			switch(iDice(1,8)){
			case 1: if (iDice(1,30) == 3) iItemID = 551; break; // WerewolfTail
			case 2:	if (iDice(1,28) == 3) iItemID = 548; break; // WerewolfHeart
			case 3:	if (iDice(1,25) == 3) iItemID = 550; break; // WerewolfMeat
			case 4:	if (iDice(1,35) == 3) iItemID = 553; break; // WerewolfLeather
			case 5:	if (iDice(1,28) == 3) iItemID = 552; break; // WerewolfTeeth
			case 6:	if (iDice(1,28) == 3) iItemID = 554; break; // WerewolfClaw
			case 7:	if (iDice(1,38) == 3) iItemID = 549; break; // WerewolfNail
			case 8: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 48: //Stalker
		case 49: //Hellclaw
		case 50: //Tigerworm
		case 52: //Gagoyle
		case 53: //Beholder
		case 54: //Dark-Elf
		case 55: //Rabbit
		case 56: //Cat
		case 57: //Giant-Frog
		case 58: //Mountain-Giant
		case 59: //Ettin
		case 60: //Cannibal-Plant
		case 61: //Rudolph
		case 62: //DireBoar
		case 63: //Frost
		case 65: //Ice
			bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); 
			break;

		// new 05/10/2004
		case 66: // Wyvern
			bGetMultipleItemNamesWhenDeleteNpc( m_pNpcList[iNpcH]->m_sType,	// NPC Type
												50,							// (  ~      , 100     .)
												5,							//   Item  
												15,							//   Item  
												m_pNpcList[iNpcH]->m_sX,	//   X
												m_pNpcList[iNpcH]->m_sY,	//   Y
												DEF_ITEMSPREAD_FIXED,		//    (RANDOM, FIXED)
												4,							//   , DEF_ITEMSPREAD_RANDOM  
												iItemIDs,					//   Id
												ItemPositions,				//  
												&iNumItem);					//   
			break;

		case 73: // Fire-Wyvern
			bGetMultipleItemNamesWhenDeleteNpc( m_pNpcList[iNpcH]->m_sType,	// NPC Type
												50,							// (  ~      , 100     .)
												5,							//   Item  
												15,							//   Item  
												m_pNpcList[iNpcH]->m_sX,	//   X
												m_pNpcList[iNpcH]->m_sY,	//   Y
												2,		//    (RANDOM, FIXED)
												4,							//   , DEF_ITEMSPREAD_RANDOM  
												iItemIDs,					//   Id
												ItemPositions,				//  
												&iNumItem);					//   
			break;
		case 81:
			bGetMultipleItemNamesWhenDeleteNpc( m_pNpcList[iNpcH]->m_sType,	// NPC Type
												50,							// (  ~      , 100     .)
												12,							//   Item  
												20,							//   Item  
												m_pNpcList[iNpcH]->m_sX,	//   X
												m_pNpcList[iNpcH]->m_sY,	//   Y
												DEF_ITEMSPREAD_FIXED,		//    (RANDOM, FIXED)
												65,							//   , DEF_ITEMSPREAD_RANDOM  
												iItemIDs,					//   Id
												ItemPositions,				//  
												&iNumItem);
			break;
		}

		dwCount = 1;
		if (iNumItem > 0) {
			GetLocalTime(&SysTime);
			wsprintf(cTemp, "%d%02d%", SysTime.wMonth, SysTime.wDay);
			for(int j = 0; j < iNumItem; j++){
				if (pItem == NULL) {
					pItem = new class CItem;
				}
				if (_bInitItemAttr(pItem, iItemIDs[j]) == FALSE ||
					m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bGetIsMoveAllowedTile(ItemPositions[j].x, ItemPositions[j].y) == FALSE) {
					delete pItem;
					pItem = NULL;
				}
				else {
					if (iItemIDs[j] == 90) // Gold
						pItem->m_dwCount = iDice(10, 15000);
					else
						pItem->m_dwCount = dwCount;

					pItem->m_sTouchEffectType   = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = iDice(1,100000);
					pItem->m_sTouchEffectValue2 = iDice(1,100000);
					pItem->m_sTouchEffectValue3 = (short)timeGetTime();
					m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(ItemPositions[j].x, ItemPositions[j].y, pItem);
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
												ItemPositions[j].x, ItemPositions[j].y,	pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
					_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, m_pNpcList[iNpcH]->m_cNpcName, pItem);
					pItem = NULL;
				}
			}
		}
		else{
			if (_bInitItemAttr(pItem, iItemID) == FALSE) {
					delete pItem;
					pItem = NULL;
				}
			else {
					pItem->m_dwCount = dwCount;

				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				pItem->m_sTouchEffectValue3 = (short)timeGetTime();
				m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
					m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
				_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, m_pNpcList[iNpcH]->m_cNpcName, pItem);
			}
		}

		if (iDice(1, 100000) < 10) {
			pItem2 = new class CItem;
			switch(iDice(1,4)){
				case 1:	iSlateID = 868; break;
				case 2: iSlateID = 869; break;
				case 3: iSlateID = 870; break;
				case 4: iSlateID = 871; break;
			}
			if (_bInitItemAttr(pItem2, iSlateID) == FALSE) {
					delete pItem2;
					pItem2 = NULL;
				}
			else {
				pItem2->m_dwCount = 1;

				pItem2->m_sTouchEffectType   = DEF_ITET_ID;
				pItem2->m_sTouchEffectValue1 = iDice(1,100000);
				pItem2->m_sTouchEffectValue2 = iDice(1,100000);
				pItem2->m_sTouchEffectValue3 = (short)timeGetTime();

				m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem2);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
					m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem2->m_sSprite, pItem2->m_sSpriteFrame, pItem2->m_cItemColor);
				_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, m_pNpcList[iNpcH]->m_cNpcName, pItem2);
			}
		}
	}

    delete m_pNpcList[iNpcH];
	m_pNpcList[iNpcH] = NULL;
}

void CGame::RequestFullObjectData(int iClientH, char *pData)
{
 DWORD * dwp;
 WORD  * wp, wObjectID;
 char  * cp, cData[100];
 short * sp, sX, sY;
 int     sTemp, sTemp2;
 int   * ip, iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wObjectID = *wp;
	
	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_EVENT_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTSTOP;
	
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	if (wObjectID < 10000) {
		//   . 
		//      .
		if ( (wObjectID == 0) || (wObjectID >= DEF_MAXCLIENTS) ) return;
		if (m_pClientList[wObjectID] == NULL) return;
		
		wp  = (WORD *)cp;
		*wp = wObjectID;			// ObjectID
		cp += 2;
		sp  = (short *)cp;
		sX  = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;
		//v1.4 ApprColor
		ip = (int *)cp;
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp += 4;
		
		ip  = (int *)cp;
		
		// sStatus  4 FOE  . 
		sTemp = m_pClientList[wObjectID]->m_iStatus;
		sTemp = 0x0FFFFFFF & sTemp;//  4 
		sTemp2 = iGetPlayerABSStatus(wObjectID, iClientH); 
		sTemp  = (sTemp | (sTemp2 << 28));//Original : 12
		
		*ip = sTemp;
		
		cp += 4;//Original 2
		
		if (m_pClientList[wObjectID]->m_bIsKilled == TRUE) // v1.4
			 *cp = 1;
		else *cp = 0;
		cp++;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 41); // v1.4
	}
	else {
		// NPC  .
		//      NPC  
		if ( ((wObjectID - 10000) == 0) || ((wObjectID - 10000) >= DEF_MAXNPCS) ) return;
		if (m_pNpcList[wObjectID - 10000] == NULL) return;
		
		wp  = (WORD *)cp;
		*wp = wObjectID;			
		cp += 2;

		wObjectID -= 10000;

		sp  = (short *)cp;
		sX  = m_pNpcList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pNpcList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pNpcList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pNpcList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pNpcList[wObjectID]->m_cName, 5);
		cp += 5;
		sp  = (short *)cp;
		*sp = m_pNpcList[wObjectID]->m_sAppr2;
		cp += 2;
		
		ip  = (int *)cp;
	
		sTemp = m_pNpcList[wObjectID]->m_iStatus;
		sTemp = 0x0FFFFFFF & sTemp;//  4 
		
		sTemp2 = iGetNpcRelationship(wObjectID, iClientH);
		sTemp  = (sTemp | (sTemp2 << 28));//Original : 12	
		*ip = sTemp;
		
		cp += 4;//Original 2

		if (m_pNpcList[wObjectID]->m_bIsKilled == TRUE) // v1.4
			 *cp = 1;
		else *cp = 0;
		cp++;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 27); // v1.4 //Original : 25
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		//     .
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}

int CGame::_iGetArrowItemIndex(int iClientH)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return -1;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {

		// Arrow  1     .
		if ( (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_ARROW) &&
			 (m_pClientList[iClientH]->m_pItemList[i]->m_dwCount > 0) )
			return i;	
	}

	return -1;
}

void CGame::NpcBehavior_Stop(int iNpcH)
{
 char  cTargetType;
 short sTarget = NULL;
 BOOL  bFlag;

	if (m_pNpcList[iNpcH] == NULL) return; 

	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;

	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 5:		
		switch (m_pNpcList[iNpcH]->m_sType) {
		case 38:
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				bFlag = _bNpcBehavior_ManaCollector(iNpcH);
				if (bFlag == TRUE) {
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
				}
			}
			break;

		case 39: // Detector
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				bFlag = _bNpcBehavior_Detector(iNpcH);
				
				if (bFlag == TRUE) {
					//  .    .	
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
				}
			}
			break;

		case 40: // Energy Shield Generator
			break;

		case 41: // Grand Magic Generator
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				_NpcBehavior_GrandMagicGenerator(iNpcH);
			}
			break;

		case 42: // ManaStone: v2.05    5 .
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_iV1 += 5;
			if (m_pNpcList[iNpcH]->m_iV1 >= 5) m_pNpcList[iNpcH]->m_iV1 = 5;
			break;

		case 89: // AGC (Ancient Grand Cannon)	will turn as detectors	
			if (   (m_bIsHeldenianMode == TRUE) 
				&& (m_bHeldenianWarInitiated == FALSE))
			{	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) 
				{	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
					bFlag = _bNpcBehavior_Detector(iNpcH);				
					if (bFlag == TRUE) 
					{	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
			}	}	}
			break;

		default: 
			TargetSearch(iNpcH, &sTarget, &cTargetType);				
			break;
		}
		break;
	}
	
	if ((sTarget != NULL)) {

		//  . 
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
		//      . 
		return;
	}
}


void CGame::UseItemHandler(int iClientH, short sItemIndex, short dX, short dY, short sDestItemID)
{
 int iTemp, iMax, iV1, iV2, iV3, iSEV1, iEffectResult = 0;
 DWORD dwTime, dwGUID;
 short sTemp, sTmpType, sTmpAppr1;
 char cSlateType[20];
 BOOL bDepleteNow = TRUE;

	dwTime = timeGetTime();
	ZeroMemory(cSlateType,sizeof(cSlateType));

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;

	if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) || 
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) ) {
	}
	else return;
 	
	if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) ) {
				
		//     . 
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_WARM: // v2.172 2002-7-5  . 

			//       . 
			if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 1) {

				bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_ICE);

				//       .
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (1*1000), 
							                iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);

			}

			m_pClientList[iClientH]->m_dwWarmEffectTime = dwTime;
			break;

		case DEF_ITEMEFFECTTYPE_LOTTERY:
			//   EV1(:  100) EV2( ) EV3( )
			iTemp = iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1);
			if (iTemp == iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1)) {
				// !

			}
			else {
				// !
				
			}
			break;
		
		case DEF_ITEMEFFECTTYPE_SLATES:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
				// Full Ancient Slate ??
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 867) {
					// Slates dont work on Heldenian Map
					switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2){
						case 2: // Bezerk slate
							m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = TRUE;
							SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (1000 * 600),
								iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, 1, NULL, NULL);
							strcpy(cSlateType, "Berserk");
							break;

						case 1: // Invincible slate
							if (strlen(cSlateType) == 0) {
								strcpy(cSlateType, "Invincible");
							}
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_INVINCIBLE, NULL, NULL, NULL, NULL);
							break;
						case 3: // Mana slate
							if (strlen(cSlateType) == 0) {
								strcpy(cSlateType, "Mana");
							}
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_MANA, NULL, NULL, NULL, NULL);
							break;
						case 4: // Exp slate
							if (strlen(cSlateType) == 0) {
								strcpy(cSlateType, "Exp");
							}
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_EXP, NULL, NULL, NULL, NULL);
							break;
					}
					SetSlateFlag(iClientH, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, TRUE);
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_ANCIENT_TABLET, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, 
										dwTime + (1000 * 600), iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
						
				}
				if(strlen(cSlateType) > 0)
					_bItemLog(DEF_ITEMLOG_USE, iClientH, strlen(cSlateType), m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			}
			break;

		case DEF_ITEMEFFECTTYPE_HP:
			iMax = iGetMaxHP(iClientH);
			if (m_pClientList[iClientH]->m_iHP < iMax) {
				
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iHP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iHP > iMax) m_pClientList[iClientH]->m_iHP = iMax;
				if (m_pClientList[iClientH]->m_iHP <= 0)   m_pClientList[iClientH]->m_iHP = 1;

				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
			}
			break;

		case DEF_ITEMEFFECTTYPE_MP:
			iMax = iGetMaxMP(iClientH);
		
			if (m_pClientList[iClientH]->m_iMP < iMax) {
				
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else 
				{
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iMP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iMP > iMax) 
					m_pClientList[iClientH]->m_iMP = iMax;

				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
			}
			break;

		case DEF_ITEMEFFECTTYPE_SP:
			iMax = iGetMaxSP(iClientH);
		
			if (m_pClientList[iClientH]->m_iSP < iMax) {
				
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iSP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iSP > iMax) 
					m_pClientList[iClientH]->m_iSP = iMax;

				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}

			if (m_pClientList[iClientH]->m_bIsPoisoned == TRUE) {
				//    .
				m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
				//   . 
				SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE); // removes poison aura when using a revitalizing potion
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
			}
			break;

		case DEF_ITEMEFFECTTYPE_HPSTOCK:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
		
			m_pClientList[iClientH]->m_iHPstock += iDice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHPstock < 0)   m_pClientList[iClientH]->m_iHPstock = 0;
			if (m_pClientList[iClientH]->m_iHPstock > 500) m_pClientList[iClientH]->m_iHPstock = 500;

			//  . 
			m_pClientList[iClientH]->m_iHungerStatus += iDice(iV1, iV2) + iV3;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HUNGER, m_pClientList[iClientH]->m_iHungerStatus, NULL, NULL, NULL); // MORLA2 - Muestra nuevamente
			if (m_pClientList[iClientH]->m_iHungerStatus > 100) m_pClientList[iClientH]->m_iHungerStatus = 100;
			if (m_pClientList[iClientH]->m_iHungerStatus < 0)   m_pClientList[iClientH]->m_iHungerStatus = 0;
			break;


		case DEF_ITEMEFFECTTYPE_STUDYSKILL:
			//  .	
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iSEV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
			// iV1  Skill . iV2  , iSEV1    () 
			if (iSEV1 == 0) {
				//    0      . 
				TrainSkillResponse(TRUE, iClientH, iV1, iV2);
			}
			else {
		   		TrainSkillResponse(TRUE, iClientH, iV1, iSEV1);
			}
			break;

		case DEF_ITEMEFFECTTYPE_STUDYMAGIC:
			// iV1   .
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pMagicConfigList[iV1] != NULL) 
				RequestStudyMagicHandler(iClientH, m_pMagicConfigList[iV1]->m_cName, bDepleteNow, FALSE);
			break;

		// New 15/05/2004 Changed
		case DEF_ITEMEFFECTTYPE_MAGIC:
			//       .
			if ( (m_pClientList[iClientH]->m_iStatus & 0x10) != 0 ) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
					SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
				
					bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
					m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
				}
			}

			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// Recall    . 
				// testcode
				RequestTeleportHandler(iClientH, "1   ");
				break;

			case 2:
				//    . 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 32, TRUE);
				break;

			case 3:
				//   .   . 
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)
					PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 34, TRUE);
				break;

			case 4:
				// fixed location teleportation:  
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2) {
				case 1:
					//    
					if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) != 0) {
						//v1.42
						ItemDepleteHandler(iClientH, sItemIndex, TRUE, TRUE);
						RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1);
					}
					break;
				
				case 11:	
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
				case 18:
				case 19:
					//  . 
					SYSTEMTIME SysTime;

					GetLocalTime(&SysTime);
					// v1.4311-3    // . 
					//       .
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 != SysTime.wMonth) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 != SysTime.wDay) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 <= SysTime.wHour) ) {
						//   .     .
					}
					else {
						char cDestMapName[11];
						ZeroMemory(cDestMapName, sizeof(cDestMapName));
						wsprintf(cDestMapName, "fightzone%d", m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 - 10);
						if (memcmp(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10) != 0) {
							//v1.42
							ItemDepleteHandler(iClientH, sItemIndex, TRUE, TRUE);
							RequestTeleportHandler(iClientH, "2   ", cDestMapName, -1, -1);
						}
					}
					break;
				}
				break;

			case 5: // Heldenians scroll must be defined as DEF_ITEMTYPE_USE_PERM
					// Only Helnenian scrolls can be defined as DEF_ITEMTYPE_USE_PERM 
					// Scrolls not belonging to the user are depleted when entering function 
				if (   (m_bIsHeldenianMode == TRUE)
					&& (m_bHeldenianWarInitiated == TRUE)
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) 
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1)
					&& (strcmp(m_pClientList[iClientH]->m_cMapName, "GodH") != 0))
				{	memcpy(&dwGUID, &m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1, 4);					
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER)
					{	if (dwGUID == m_dwHeldenianGUID)
						{	// Scrolls from current Heldenian can summon
							if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6 == -1)// -1 allows using with weapon shield equiped
								PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
									m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2); 
							else 
								PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
									m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 * -1); 
							m_pClientList[iClientH]->m_iWarContribution   += 300;
							if (m_pClientList[iClientH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
								m_pClientList[iClientH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;
							if (m_pClientList[iClientH]->m_iWarContribution >= 256*128)
								SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, (m_pClientList[iClientH]->m_iWarContribution %(256*128)), 1, NULL);
						}
						// But older scrolls will be depleted without effect!
						ItemDepleteHandler(iClientH, sItemIndex, TRUE, TRUE);	
					}else
					{	// Not personal scrolls can summon and deplete scroll now
						if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6 == -1)// -1 allows using with weapon shield equiped
						PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2); 
						else 
						PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 * -1); 
						ItemDepleteHandler(iClientH, sItemIndex, TRUE, TRUE);	
						return;
					}
				}else // No permanent scroll outside Special Heldenian summon scrolls
				{	if (m_bIsHeldenianMode == FALSE) ItemDepleteHandler(iClientH, sItemIndex, TRUE, TRUE);	
					return;	
				}	 
				break;
			}
			break;

		case DEF_ITEMEFFECTTYPE_FIRMSTAMINAR:
			m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar > 20*30) m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = 20*30; //  30 
			break;

		case DEF_ITEMEFFECTTYPE_CHANGEATTR:
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				//   . 
				m_pClientList[iClientH]->m_cHairColor++;
				if (m_pClientList[iClientH]->m_cHairColor > 15) m_pClientList[iClientH]->m_cHairColor = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 2:
				//   .
				m_pClientList[iClientH]->m_cHairStyle++;
				if (m_pClientList[iClientH]->m_cHairStyle > 7) m_pClientList[iClientH]->m_cHairStyle = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 3:
				//  .
				//   Appearance , .
				m_pClientList[iClientH]->m_cSkin++;
				if (m_pClientList[iClientH]->m_cSkin > 3)
					m_pClientList[iClientH]->m_cSkin = 1;
				
				if (m_pClientList[iClientH]->m_cSex == 1)      sTemp = 1;
				else if (m_pClientList[iClientH]->m_cSex == 2) sTemp = 4; 
				
				switch (m_pClientList[iClientH]->m_cSkin) {
				case 2:	sTemp++; break;
				case 3:	sTemp += 2; break;
				}
				m_pClientList[iClientH]->m_sType  = sTemp;
				break;

			case 4:
				//  -     . 
				sTemp = m_pClientList[iClientH]->m_sAppr3 & 0xFF0F;
				if (sTemp == 0) {
					// sTemp 0  , ,     .    . 
					if (m_pClientList[iClientH]->m_cSex == 1) 
						 m_pClientList[iClientH]->m_cSex = 2;
					else m_pClientList[iClientH]->m_cSex = 1;

					//   Appearance , .
					if (m_pClientList[iClientH]->m_cSex == 1) {
						// . 
						sTmpType = 1;
					}
					else if (m_pClientList[iClientH]->m_cSex == 2) {
						// .
						sTmpType = 4; 
					}

					switch (m_pClientList[iClientH]->m_cSkin) {
					case 1:
						//  .
						break;
					case 2:
						sTmpType++;
						break;
					case 3:
						sTmpType += 2;
						break;
					}

					sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
					m_pClientList[iClientH]->m_sType  = sTmpType;
					m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1; 
					//
				}
				break;
			}

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
		}
		// *** Request Teleport Handler           . 
		//   .
		ItemDepleteHandler(iClientH, sItemIndex, TRUE, TRUE);
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) {
		//    .
		// dX, dY       .
		if (_bDepleteDestTypeItemUseEffect(iClientH, dX, dY, sItemIndex, sDestItemID) == TRUE) 
			ItemDepleteHandler(iClientH, sItemIndex, TRUE, TRUE); 
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) {
		//  . 
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) {
		//     .     . (ex: ) 
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_SHOWLOCATION:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			switch (iV1) {
			case 1:
				//    . 
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0)
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 1, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0)
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 2, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "middleland") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 3, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 4, NULL, NULL);	
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone2") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 5, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone1") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 6, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone4") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 7, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone3") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 8, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "arefarm") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 9, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvfarm") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 10, NULL, NULL);
				else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 0, NULL, NULL);
				break;
			}
			break;
		}
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) {
		//    .      . 
		
		if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) || 
			 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) ||
			 (m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] == TRUE) ) {
			//          
			return;
		}
		else {
			if ( m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan != 0 ) {
				//   0    .
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan--;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) {
					//    .
					//    <-     .
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMLIFESPANEND, DEF_EQUIPPOS_NONE, sItemIndex, NULL, NULL);
				}
				else {
					//    ID . v1.12
					int iSkillUsingTimeID = (int)timeGetTime();
					
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_USEITEM_SKILL, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill, 
			                     dwTime + m_pSkillConfigList[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]->m_sValue2*1000, 
								 iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_cMapIndex, dX, dY, 
								 m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ], iSkillUsingTimeID, NULL);
					
					//   
					m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = TRUE;
					m_pClientList[iClientH]->m_iSkillUsingTimeID[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = iSkillUsingTimeID; //v1.12
		 		}
			}
		}
	}
}

void CGame::Effect_Damage_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3, BOOL bExp, int iAttr)
{
 int iPartyID, iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack, iRepDamage;
 char cAttackerSide, cDamageMoveDir;
 DWORD dwTime;
 register double dTmp1, dTmp2, dTmp3;
 short sAtkX, sAtkY, sTgtX, sTgtY, dX, dY, sItemIndex;
 unsigned long iExp;

 	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == NULL) return;

	if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		&& (m_bIsHeldenianMode == TRUE)				// No spell work before war has begun
		&& (m_bHeldenianWarInitiated == FALSE)
		&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) 
		&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1)) return; 
	
	dwTime = timeGetTime();
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:	
		if ((m_bAdminSecurity == TRUE) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return;
		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) iDamage += 4;
		if ((m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND] == -1) || (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] == -1)) {
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 861 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 862) {
					float damageTemp = (float)iDamage;
					damageTemp *= 1.5f; // O el valor con punto flotante que ustedes dispongan... JustThink
					iDamage = (int)damageTemp;
				}
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864) {
					if (m_pClientList[sAttackerH]->m_iRating > 0) {
						iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
						iDamage += iRepDamage;
					}
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != NULL) {
							if (m_pClientList[sTargetH]->m_iRating <= 0) {
								iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
								iDamage += iRepDamage;
							}
						}
					}
				}
			}
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != NULL) {
							iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/20);
							iDamage += iRepDamage;
						}
					}
				}
			}
		}

		if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return;

		dTmp1 = (double)iDamage;
		if ((m_pClientList[sAttackerH]->m_iMag+m_pClientList[sAttackerH]->m_iAngelicMag) <= 0)
			 dTmp2 = 1.0f;
		else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag+m_pClientList[sAttackerH]->m_iAngelicMag);	
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);

		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;
		if (iDamage <= 0) iDamage = 0;

		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;

		if (bCheckHeldenianMap(sAttackerH, DEF_OWNERTYPE_PLAYER) == 1) {
			iDamage += iDamage/3;
		}

		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
			if (m_pClientList[sAttackerH]->m_iLevel <= 80) {
				iDamage += (iDamage*7)/10 ;
			} else if (m_pClientList[sAttackerH]->m_iLevel <= 100) {
				iDamage += iDamage/2;
			} else 
				iDamage += iDamage/3;
		}
		
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;

		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == FALSE) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsOwnLocation == TRUE)) return;
		
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		if ((m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) && (m_pClientList[sTargetH]->m_iAdminUserLevel == 0)) return;
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {

				}
				else {
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {

						}
						else return;
					}
					else return;
				}
			}

			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		ClearSkillUsingStatus(sTargetH);
		
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
						
			case 337:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;
			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) {
				ItemDepleteHandler(sTargetH, iIndex, TRUE, TRUE);
			}
			else {
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}

		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}
	
		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
			(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				return;
			}
		}
		
		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}
		else {
			if (iDamage > 0) {
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;

					iTemp = iGetMaxMP(sTargetH);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					if (iDice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
					}
				}

				m_pClientList[sTargetH]->m_dwRecentAttackTime = dwTime;
				
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}
			
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}

		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;
		
		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;

		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
			return;

		case 4:
			if (sTgtX == sAtkX) {
				if (sTgtY == sAtkY) return;
				else if (sTgtY > sAtkY) cDamageMoveDir = 5;
				else if (sTgtY < sAtkY) cDamageMoveDir = 1;
			}
			else if (sTgtX > sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 3;
				else if (sTgtY > sAtkY) cDamageMoveDir = 4;
				else if (sTgtY < sAtkY) cDamageMoveDir = 2;
			}
			else if (sTgtX < sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 7;
				else if (sTgtY > sAtkY) cDamageMoveDir = 6;
				else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
			}

			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
				cDamageMoveDir = iDice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];			
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
			}
						
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
				
			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
					
			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
				cDamageMoveDir = iDice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
			}
						
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

			if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) {
				DeleteNpc(sTargetH);
			}
			return;
		}

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}

		switch (m_pNpcList[sTargetH]->m_sType) {
				case 67: // McGaffin
				case 68: // Perry
				case 69: // Devlin
				return;
		}
		
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;
		
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return ;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}
			
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
						
			if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {
				if ((cAttackerType == DEF_OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;

				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					 (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						iExp = iDamage;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}
											
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE);
						else GetExp(sAttackerH, (iExp/2), TRUE);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}
						
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE);
						else GetExp(sAttackerH, (iExp/2), TRUE);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_Damage_Spot_Type2(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sAtkX, short sAtkY, short sV1, short sV2, short sV3, BOOL bExp, int iAttr)
{
 int iPartyID, iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack, iRepDamage;
 char cAttackerSide, cDamageMoveDir, cDamageMinimum;
 DWORD dwTime;
 register double dTmp1, dTmp2, dTmp3;
 short sTgtX, sTgtY, sItemIndex;
 unsigned long iExp;

	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] == NULL)) return;
	if ((cAttackerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sAttackerH] == NULL)) return;
	
	if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		&& (m_bIsHeldenianMode == TRUE)				// No spell work before war has begun
		&& (m_bHeldenianWarInitiated == FALSE)
		&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) 
		&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1)) return; 
	
	dwTime = timeGetTime();
	sTgtX = 0;
	sTgtY = 0;
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) iDamage += 4;
		if ((m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND] == -1) || (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] == -1)) {
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 861 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 862) {
					float damageTemp = (float)iDamage;
					damageTemp *= 1.5f; // O el valor con punto flotante que ustedes dispongan... JustThink
					iDamage = (int)damageTemp;
				}
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864) {
					if (m_pClientList[sAttackerH]->m_iRating > 0) {
						iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
						iDamage += iRepDamage;
					}
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != NULL) {
							if (m_pClientList[sTargetH]->m_iRating <= 0) {
								iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
								iDamage += iRepDamage;
							}
						}
					}
				}
			}
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != NULL) {
							iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/20);
							iDamage += iRepDamage;
						}
					}
				}
			}
		}

		if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return;

		dTmp1 = (double)iDamage;
		if ((m_pClientList[sAttackerH]->m_iMag+m_pClientList[sAttackerH]->m_iAngelicMag) <= 0)
			 dTmp2 = 1.0f;
		else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag+m_pClientList[sAttackerH]->m_iAngelicMag);	
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);
		if (iDamage <= 0) iDamage = 0;
		// order switched with above
		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;

		if (bCheckHeldenianMap(sAttackerH, DEF_OWNERTYPE_PLAYER) == 1) {
			iDamage += iDamage/3;
		}

		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
			if (m_pClientList[sAttackerH]->m_iLevel <= 80) {
				iDamage += (iDamage*7)/10 ;
			} else if (m_pClientList[sAttackerH]->m_iLevel <= 100) {
				iDamage += iDamage/2;
			} else 
				iDamage += iDamage/3;
		}
		
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		if (m_pClientList[sTargetH]->m_cMapIndex == -1) return;
		if ((m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) && (m_pClientList[sTargetH]->m_iAdminUserLevel == 0)) return;
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == FALSE) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsOwnLocation == TRUE)) return;
		
		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {

				}
				else {
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {

						}
						else return;
					}
					else return;
				}
			}

			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		ClearSkillUsingStatus(sTargetH);
		
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
						
			case 337:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;
			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) {
				ItemDepleteHandler(sTargetH, iIndex, TRUE, TRUE);
			}
			else {
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}

		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}
	
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;
		
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5) break;

		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
			(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				return;
			}
		}
		
		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}
		else {
			if (iDamage > 0) {
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;

					iTemp = iGetMaxMP(sTargetH);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					if (iDice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
					}
				}
				
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) {
					cDamageMinimum = 80;
				}
				else {
					cDamageMinimum = 50;
				}

				if (iDamage >= cDamageMinimum) {
					sTgtX = m_pClientList[sTargetH]->m_sX;
					sTgtY = m_pClientList[sTargetH]->m_sY;
					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY) return;
							else if (sTgtY > sAtkY) cDamageMoveDir = 5;
							else if (sTgtY < sAtkY) cDamageMoveDir = 1;
						}
						else if (sTgtX > sAtkX) {
							if (sTgtY == sAtkY)     cDamageMoveDir = 3;
							else if (sTgtY > sAtkY) cDamageMoveDir = 4;
							else if (sTgtY < sAtkY) cDamageMoveDir = 2;
						}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}
					m_pClientList[sTargetH]->m_iLastDamage = iDamage;
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, NULL, NULL);
				}

				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}
			
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;
		
		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 4:
		case 6:
			return;

		case 3:
		case 5:
			if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
				switch (m_pNpcList[sTargetH]->m_sType) {
				case 40:
				case 41:
					if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
					break;
				}
			}
		}
	
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;
		
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return ;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}
			
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);		
			if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {
				if ((cAttackerType == DEF_OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				if ((m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						iExp = iDamage;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}
											
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE);
						else GetExp(sAttackerH, (iExp/2), TRUE);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}
						
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE);
						else GetExp(sAttackerH, (iExp/2), TRUE);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_Damage_Spot_DamageMove(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sAtkX, short sAtkY, short sV1, short sV2, short sV3, BOOL bExp, int iAttr)
{
 int iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack;
 DWORD dwTime, wWeaponType;
 char cAttackerSide, cDamageMoveDir;
 register double dTmp1, dTmp2, dTmp3;
 int iPartyID, iMoveDamage;
 short sTgtX, sTgtY;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == NULL) return;

	if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		&& (m_bIsHeldenianMode == TRUE)				// No spell work before war has begun
		&& (m_bHeldenianWarInitiated == FALSE)
		&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) 
		&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1)) return; 

	dwTime = timeGetTime();
	sTgtX = 0;
	sTgtY = 0;
	
	//    . 
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	iPartyID = 0;

	//   Mag     
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:

		dTmp1 = (double)iDamage;
		if ((m_pClientList[sAttackerH]->m_iMag+m_pClientList[sAttackerH]->m_iAngelicMag) <= 0)
			 dTmp2 = 1.0f;
		else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag+m_pClientList[sAttackerH]->m_iAngelicMag);
			
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);
		if (iDamage <= 0) iDamage = 0;

		// v1.432 2001 4 7 13 7
		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

		// v1.44   1.33 
		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;

		// Crusade :     1.33 
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
		{
 			// v2.15    . 1.7  
			if (m_pClientList[sAttackerH]->m_iLevel <= 80)
			{
				iDamage += (iDamage* 7)/10 ;
			} // v2.15    . 1.5  
			else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
			{
				iDamage += iDamage/2;
			} else iDamage += iDamage/3;
		}

		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) {
			iDamage += 4;
		}

		wWeaponType = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 34) {
			iDamage += iDamage/3;
		}

		if (bCheckHeldenianMap(sAttackerH, DEF_OWNERTYPE_PLAYER) == 1) {
			iDamage += iDamage/3;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		//      
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
		//     .
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
		//      
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		//       
		// v2.03    
		if (m_pClientList[sTargetH]->m_cMapIndex == -1) return;
		if ((m_pMapList[ m_pClientList[sTargetH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) && (m_pClientList[sTargetH]->m_iAdminUserLevel == 0)) return;
		// v1.41     . 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

		// v2.172    .  NPC     
		if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return ;
		if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil == TRUE)) return ;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return;

		// 01-12-17     
		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;

		//          . 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
			
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
					//   .    
				}
				else {
					//          .
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {
							//    .  . 
						}
						else return;
					}
					else return;
				}
			}

			//         
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}
		
		//     .
		ClearSkillUsingStatus(sTargetH);

		// v1.432    
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}
		
		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			//      .
			
			//     . 
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335: //   20%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
						
			case 337: //   10%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;
			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) {
				//     . 
				ItemDepleteHandler(sTargetH, iIndex, TRUE, TRUE);
			}
			else {
				//      . 
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}

		// v1.42     
		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		// v1.4 VIT    
		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}

		//     1/2 
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;
	
		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
			(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			//   .
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		// v1.432             .
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				// 
				return;
			}
		}

		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			//  .
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}
		else {
			if (iDamage > 0) {
				// v2.04       
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;

					//   
					iTemp = iGetMaxMP(sTargetH);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				// v2.04       
				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					//     .
					if (iDice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						// v1.12             .
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
					}
				}

				// v1.44   80 .
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) 
					 iMoveDamage = 80;
				else iMoveDamage = 50;

				if (iDamage >= iMoveDamage) {
					//  50 .
			
					sTgtX = m_pClientList[sTargetH]->m_sX;
					sTgtY = m_pClientList[sTargetH]->m_sY;

					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto EDSD_SKIPDAMAGEMOVE;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}

					// v1.44   .
					m_pClientList[sTargetH]->m_iLastDamage = iDamage;
					//   . <- HP  .
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					//     	
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, NULL, NULL);
				}
				else {
EDSD_SKIPDAMAGEMOVE:;
					//   . <- HP  .
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					//     
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
				}

				// v1.4    Owner  . 
				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}
			
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold-Person    .     .
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;
		
		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 4:
			return;
		}
		
		//     ,         .
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}

		switch (m_pNpcList[sTargetH]->m_sType) {
			case 67: // McGaffin
			case 68: // Perry
			case 69: // Devlin
				iDamage = 0;
			break;
		}
		
		//     (AbsDamage 0 )    .
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		//     1/2 
		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;
		
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			// NPC .
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {
			//  . .

			//    .
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				// v2.15    .			
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}
			
			//    
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
			
			if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {

				//     .
				if ((cAttackerType == DEF_OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				// ActionLimit 1   .   .
				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
				
				//      .

				// Damage    .
				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold    . 	
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				//Crusade
				unsigned long iExp;

				// NPC           . 
				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					 (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
					// ExpStock .      .
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						// Crusade
						iExp = iDamage;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						//v2.03 918   
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}
						
						// v2.17 2002-8-6   100       .
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0 ;
							break ;
							default: break;
							}
						}

						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp); 
						else GetExp(sAttackerH, (iExp/2)); 
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						// Crusade
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						//v2.03 918   
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						// v2.17 2002-8-6   100       .
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0 ;
							break ;
							default: break;
							}
						}


						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp); 
						else GetExp(sAttackerH, (iExp/2)); 
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_HpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iHP, iMaxHP;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	iHP = iDice(sV1, sV2) + sV3;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
		iMaxHP = iGetMaxHP(sTargetH);
		if (m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown != 0) 
			iMaxHP = iMaxHP - (iMaxHP/m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown);
		if (m_pClientList[sTargetH]->m_iHP < iMaxHP) {
			m_pClientList[sTargetH]->m_iHP += iHP;
			if (m_pClientList[sTargetH]->m_iHP > iMaxHP) m_pClientList[sTargetH]->m_iHP = iMaxHP;
			if (m_pClientList[sTargetH]->m_iHP <= 0)     m_pClientList[sTargetH]->m_iHP = 1;
			SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if (m_pNpcList[sTargetH]->m_bIsKilled == TRUE) return;
		iMaxHP = m_pNpcList[sTargetH]->m_iHitDice*4;
		if (m_pNpcList[sTargetH]->m_iHP < iMaxHP) {
			m_pNpcList[sTargetH]->m_iHP += iHP;
			if (m_pNpcList[sTargetH]->m_iHP > iMaxHP) m_pNpcList[sTargetH]->m_iHP = iMaxHP;
			if (m_pNpcList[sTargetH]->m_iHP <= 0)     m_pNpcList[sTargetH]->m_iHP = 1;
		}
		break;
	}
}

void CGame::Effect_SpDown_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iSP, iMaxSP;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	//   Sp .
	iSP = iDice(sV1, sV2) + sV3;
	
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
	
		// New 19/05/2004
		// Is the user having an invincibility slate
		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return;

		iMaxSP = iGetMaxSP(sTargetH);
		if (m_pClientList[sTargetH]->m_iSP > 0) {
			
			//v1.42 
			if (m_pClientList[sTargetH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[sTargetH]->m_iSP -= iSP;
				if (m_pClientList[sTargetH]->m_iSP < 0) m_pClientList[sTargetH]->m_iSP = 0;
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		// NPC   .
		break;
	}
}


void CGame::Effect_SpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iSP, iMaxSP;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	//   Sp .
	iSP = iDice(sV1, sV2) + sV3;
	
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
	
		iMaxSP = iGetMaxSP(sTargetH);
		if (m_pClientList[sTargetH]->m_iSP < iMaxSP) {
			m_pClientList[sTargetH]->m_iSP += iSP;
			
			if (m_pClientList[sTargetH]->m_iSP > iMaxSP) 
				m_pClientList[sTargetH]->m_iSP = iMaxSP;

			SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		// NPC   .
		break;
	}
}

/*********************************************************************************************************************
**  int BOOL CGame::bCheckResistingMagicSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio) **
**  description			:: calculates if a player resists magic														**
**  last updated		:: November 20, 2004; 8:42 PM; Hypnotoad													**
**	return value		:: BOOL																						**
**  commentary			::	-	hero armor for target mages adds 50 magic resistance								**
**							-	10000 or more it ratio will deduct 10000 hit ratio									**
**							-	invincible tablet is 100% magic resistance											**
**********************************************************************************************************************/
BOOL CGame::bCheckResistingMagicSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
 double dTmp1, dTmp2, dTmp3;
 int    iTargetMagicResistRatio, iDestHitRatio, iResult;
 char   cTargetDir, cProtect;								 

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return FALSE;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) return FALSE;
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return TRUE; 
		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return TRUE;
		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pClientList[sTargetH]->m_cSkillMastery[3] + m_pClientList[sTargetH]->m_iAddMR;
		if ((m_pClientList[sTargetH]->m_iMag+m_pClientList[sTargetH]->m_iAngelicMag) > 50) 
			iTargetMagicResistRatio += ((m_pClientList[sTargetH]->m_iMag+m_pClientList[sTargetH]->m_iAngelicMag) - 50);
		iTargetMagicResistRatio += m_pClientList[sTargetH]->m_iAddResistMagic;
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]; 
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return FALSE;
		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pNpcList[sTargetH]->m_cResistMagic;
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]; 
		break;
	}

	if (cProtect == 5) return TRUE;
	if ((iHitRatio < 1000) && (cProtect == 2)) return TRUE;
	if (iHitRatio >= 10000) iHitRatio -= 10000;
	if (iTargetMagicResistRatio < 1) iTargetMagicResistRatio = 1;
	if ((cAttackerDir != 0) && (m_pClientList[sTargetH] != NULL) && (m_pClientList[sTargetH]->m_cHeroArmourBonus == 2)) {
		iHitRatio += 50;
	}
	
	dTmp1 = (double)(iHitRatio);
	dTmp2 = (double)(iTargetMagicResistRatio);
	dTmp3 = (dTmp1 / dTmp2)*50.0f;
	iDestHitRatio = (int)(dTmp3); 
	if (iDestHitRatio < DEF_MINIMUMHITRATIO) iDestHitRatio = DEF_MINIMUMHITRATIO;
	if (iDestHitRatio > DEF_MAXIMUMHITRATIO) iDestHitRatio = DEF_MAXIMUMHITRATIO;
	if (iDestHitRatio >= 100) return FALSE;
	
	iResult = iDice(1, 100);
	if (iResult <= iDestHitRatio) return FALSE;

	if (cTargetType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sTargetH, 3, 1);
	return TRUE;
}

BOOL CGame::bCheckResistingTremorSuccess(short sTargetH, char cTargetType)
{	int  iStability;
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return FALSE;
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return TRUE;
		// Max load is lvl150*500 + str250*500 = 200 000 (=>2000)
		iStability = 1300 - (m_pClientList[sTargetH]->m_iCurWeightLoad/100); 
		iStability += m_pClientList[sTargetH]->m_iAddAbsEarth;			
		if (iStability > 90)  iStability = 90;
		if (iStability < 10)  iStability = 10;
		if (iDice(1, 100) < iStability) return TRUE;
		else return FALSE;
		break;

	case DEF_OWNERTYPE_NPC:
		return FALSE;
		break;
	}
	return FALSE;
}
BOOL CGame::bCheckResistingIceSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
 int iTargetIceResistRatio, iResult;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return FALSE;
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return TRUE;
		iTargetIceResistRatio = m_pClientList[sTargetH]->m_iAddAbsWater*2; 
		if (m_pClientList[sTargetH]->m_dwWarmEffectTime == NULL) {
		
		}
		else if ((timeGetTime() - m_pClientList[sTargetH]->m_dwWarmEffectTime) < 30000) return TRUE;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return FALSE;
		if (m_pNpcList[sTargetH]->m_sType == 91) return TRUE; // new
		iTargetIceResistRatio = (m_pNpcList[sTargetH]->m_cResistMagic) - (m_pNpcList[sTargetH]->m_cResistMagic/3); //     . NPC    70%  
		break;
	}
	if (iTargetIceResistRatio < 1) iTargetIceResistRatio = 1;
	iResult = iDice(1, 100);
	if (iResult <= iTargetIceResistRatio) return TRUE;
	return FALSE;
}


BOOL CGame::bSetItemToBankItem(int iClientH, class CItem * pItem)
{
 int i, iRet;
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 char cData[100];		   
	
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (pItem == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsInsideWarehouse == FALSE) return FALSE;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
		
		m_pClientList[iClientH]->m_pItemInBankList[i] = pItem;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMTOBANK;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		*cp = i; //   
		cp++;

		// 1.
		*cp = 1;
		cp++;

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; 
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
	
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		// v1.432
		sp = (short *)cp;
		*sp = pItem->m_sItemEffectValue2;
		cp += 2;

		// v1.42
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		//    
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			//     . v1.41  .
			return TRUE; // v1.41 FALSE    .
		}

		return TRUE;
	}

	//    .
	return FALSE;
}

BOOL CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
 int i;
 int iRemainPoint, iTotalPoints, iWeaponIndex, iDownSkillSSN, iDownPoint;
 short sDownSkillIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	iRemainPoint = iTotalPoints - DEF_MAXSKILLPOINTS;

	if (iRemainPoint > 0) {
		//   .      SSN    .	
		while (iRemainPoint > 0) {
			
			sDownSkillIndex = -1; // v1.4
			if (m_pClientList[iClientH]->m_iDownSkillIndex != -1) { 
				//   . 
				switch (m_pClientList[iClientH]->m_iDownSkillIndex) {
				case 3: //  

				default:
					//  20    0  .
					if (m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_iDownSkillIndex] > 0) {
						sDownSkillIndex = m_pClientList[iClientH]->m_iDownSkillIndex;
					}
					else {
						//   .
						//   .
						iDownSkillSSN = 99999999;
						for (i = 0; i < DEF_MAXSKILLTYPE; i++)
						if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 21) && (i != iSkill) && 
							(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
							// V1.22     20    . 
							iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
							sDownSkillIndex = i;
						}
					}
					break;
				}
			}
			//  1      SSN   sDownSkillIndex 
			
			if (sDownSkillIndex != -1) {
				
				if (m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] <= 20) // v1.4
				 	 iDownPoint = m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex];
				else iDownPoint = 1;

				m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] -= iDownPoint; // v1.4
				m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex]+1] - 1;
				iRemainPoint -= iDownPoint; // v1.4
				
				//           . 
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
					//   . 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						//     .  . 
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}

				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], NULL, NULL);
			}
			else {
				return FALSE;
			}
		}
		return TRUE;
	}

	return FALSE;
}



void CGame::OnKeyDown(WPARAM wParam, LPARAM lParam)
{
	switch (wParam) {
	case VK_F1:
		m_bF1pressed = TRUE;
		break;
	case VK_F4:
		m_bF4pressed = TRUE;
		break;
	case VK_F5:
		m_bF5pressed = TRUE;
		break;
	case VK_F12:
		m_bF12pressed = TRUE;
		break;
	}
}

void CGame::OnKeyUp(WPARAM wParam, LPARAM lParam)
{
 int i;
 
	switch (wParam) {
	case VK_F2:
				
		break;
	
	case VK_F1:
		m_bF1pressed = FALSE;
		break;
	case VK_F4:
		m_bF4pressed = FALSE;
		break;
	case VK_F5:
		m_bF5pressed = FALSE;
		break;
	case VK_F12:
		m_bF12pressed = FALSE;
		break;
	
	case VK_F6:
		if (m_bF1pressed == TRUE) {
			PutLogList("(!) Send server shutdown announcement1...");
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
			}
		}
		break;

	case VK_F7:
		if (m_bF1pressed == TRUE) {
			PutLogList("(!) Send server shutdown announcement2...");
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
			}
		}
		break;

	case VK_F9:
		if ((m_bF1pressed == TRUE)) {
			PutLogList("(!!!) Resume Crusade Mode...");
			LocalStartCrusadeMode(NULL);
		}
		break;

	case VK_F11:
		if ((m_bF1pressed == TRUE)) {
			PutLogList("(!!!) ManualEndCrusadeMode: side 0");
			ManualEndCrusadeMode(0);
		}
		break;

	#define VK_1 0x31
	case VK_1:
		if ((m_bF1pressed == TRUE)) {
			GlobalUpdateConfigs(1);
		}
		break;

	#define VK_2 0x32
	case VK_2:
		if ((m_bF1pressed == TRUE)) {
			GlobalUpdateConfigs(2);
		}
		break;

	#define VK_3 0x33
	case VK_3:
		if ((m_bF1pressed == TRUE)) {
			GlobalUpdateConfigs(3);
		}
		break;

	#define VK_4 0x34
	case VK_4:
		if ((m_bF1pressed == TRUE)) {
			GlobalUpdateConfigs(1);
		}
		break;


		//Crusade Testcode
	case VK_HOME:
		if ((m_bF1pressed == TRUE)) {
			GlobalStartCrusadeMode();
		}
		break;

	case VK_INSERT:
		_GrandMagicLaunchMsgSend(1, 1);
		MeteorStrikeMsgHandler(1);
		break;

	case VK_DELETE:
		_GrandMagicLaunchMsgSend(1, 2);
		MeteorStrikeMsgHandler(2);
		break;
	}
}

int CGame::iGetFollowerNumber(short sOwnerH, char cOwnerType)
{
 int i, iTotal;

	iTotal = 0;

	for (i = 1; i < DEF_MAXNPCS; i++) 
	if ( (m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW) ) {

		if ((m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) && (m_pNpcList[i]->m_cFollowOwnerType == cOwnerType))
			iTotal++;
	}

	return iTotal;
}

/*********************************************************************************************************************
**  BOOL CGame::bRegisterDelayEvent(int iDelayType, int iEffectType, DWORD dwLastTime, int iTargetH,				**
**									   char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3) **
**  description			:: initiates the delayed event process														**
**  last updated		:: November 20, 2004; 9:30 PM; Hypnotoad													**
**	return value		:: BOOL																						**
**********************************************************************************************************************/
BOOL CGame::bRegisterDelayEvent(int iDelayType, int iEffectType, DWORD dwLastTime, int iTargetH, char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3)
{
 int i;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if (m_pDelayEventList[i] == NULL) {
		m_pDelayEventList[i] = new class CDelayEvent;
		m_pDelayEventList[i]->m_iDelayType	= iDelayType;
		m_pDelayEventList[i]->m_iEffectType = iEffectType;
		m_pDelayEventList[i]->m_cMapIndex	= cMapIndex;
		m_pDelayEventList[i]->m_dX			= dX;
		m_pDelayEventList[i]->m_dY			= dY;
		m_pDelayEventList[i]->m_iTargetH    = iTargetH;
		m_pDelayEventList[i]->m_cTargetType = cTargetType;
		m_pDelayEventList[i]->m_iV1         = iV1;
		m_pDelayEventList[i]->m_iV2         = iV2;
		m_pDelayEventList[i]->m_iV3         = iV3; 
		m_pDelayEventList[i]->m_dwTriggerTime = dwLastTime;
		return TRUE;
	}
	return FALSE;
}

void CGame::DelayEventProcessor()
{
 int i, iSkillNum, iResult;
 DWORD dwTime = timeGetTime();
 int iTemp;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if ((m_pDelayEventList[i] != NULL) && (m_pDelayEventList[i]->m_dwTriggerTime < dwTime)) {

		//    .  .
		switch (m_pDelayEventList[i]->m_iDelayType) {

		case DEF_DELAYEVENTTYPE_TAMING_SKILL: // Taming
			switch (m_pDelayEventList[i]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:				
				if (m_pClientList[m_pDelayEventList[i]->m_iTargetH] == NULL) break;
				// If not the right Taming usage exit
				if (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[22] == FALSE) break;
				if (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[22] != m_pDelayEventList[i]->m_iV2) break;
				_TamingHandler(m_pDelayEventList[i]->m_iTargetH
								, 22
								, m_pDelayEventList[i]->m_cMapIndex
								, m_pDelayEventList[i]->m_dX
								, m_pDelayEventList[i]->m_dY);
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[22] = FALSE;
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[22] = NULL;
				break;
			}
			break;

		case DEF_DELAYEVENTTYPE_ANCIENT_TABLET:
			if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & 0x400000) != 0) {
				iTemp = 1;
			}
			else if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & 0x800000) != 0) {
				iTemp = 3;
			}
			else if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & 0x10000) != 0) {
				iTemp = 4;
			}

			SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_SLATE_STATUS, iTemp, NULL, NULL, NULL);
			SetSlateFlag(m_pDelayEventList[i]->m_iTargetH, iTemp, FALSE);
			break;

		case DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT:
			CalcMeteorStrikeEffectHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;

		case DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE:
			DoMeteorStrikeDamageHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;
		
		case DEF_DELAYEVENTTYPE_METEORSTRIKE:
			MeteorStrikeHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;
		
		case DEF_DELAYEVENTTYPE_USEITEM_SKILL:
			//     ,  
			switch (m_pDelayEventList[i]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				iSkillNum = m_pDelayEventList[i]->m_iEffectType;
				
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH] == NULL ) break;
				//     . 
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] == FALSE ) break;
				//    ID   v1.12
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] != m_pDelayEventList[i]->m_iV2) break;
				
				//     
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] = FALSE;
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] = NULL;
				
				//  Skill    . 
				iResult = iCalculateUseSkillItemEffect(m_pDelayEventList[i]->m_iTargetH, m_pDelayEventList[i]->m_cTargetType,
				 	                                   m_pDelayEventList[i]->m_iV1, iSkillNum, m_pDelayEventList[i]->m_cMapIndex, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY);

				//     .
				SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_SKILLUSINGEND, iResult, NULL, NULL, NULL);
				break;
			}
			break;
		
		case DEF_DELAYEVENTTYPE_DAMAGEOBJECT:
			break;

		case DEF_DELAYEVENTTYPE_KILL_ABADDON:
			NpcKilledHandler(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, m_pDelayEventList[i]->m_iTargetH, 0);
			break;

		case DEF_DELAYEVENTTYPE_END_APOCALYPSE:
			GlobalEndApocalypseMode(0);	
			break;

		case DEF_DELAYEVENTTYPE_MAGICRELEASE: 
			// Removes the aura after time
			switch (m_pDelayEventList[i]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[ m_pDelayEventList[i]->m_iTargetH ] == NULL) break;
				
				SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_MAGICEFFECTOFF, 
					          m_pDelayEventList[i]->m_iEffectType, m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ], NULL, NULL);
				
				m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ] = NULL;
				
				// Inbitition casting 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INHIBITION)
					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bInhibition = FALSE;

				// Invisibility   
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
					SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);

				// Berserk  
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
					SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);

				// Confusion
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_CONFUSE)
					switch(m_pDelayEventList[i]->m_iV1){
						case 3: SetIllusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break;
						case 4: SetIllusionMovementFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break;
					}	

				// Protection Magic
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_PROTECT) {
					switch(m_pDelayEventList[i]->m_iV1){
						case 1:
							SetProtectionFromArrowFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
							break;
						case 2:
						case 5:
							SetMagicProtectionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
							break;
						case 3:
						case 4:
							SetDefenseShieldFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
							break;
					}
				}

				
				// polymorph   
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) {
					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
					SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				}

				// Ice   
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
					SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
				break;
			
			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[ m_pDelayEventList[i]->m_iTargetH ] == NULL) break;
				
				m_pNpcList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ] = NULL;
				
				// Invisibility   
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
					SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);

				// Berserk  
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
					SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);

				// polymorph   
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) {
					m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
					SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				}

				// Ice   
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
					SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
				
				// Illusion
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_CONFUSE)
					SetIllusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);

				// Protection Magic
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_PROTECT) {
					switch(m_pDelayEventList[i]->m_iV1){
						case 1:
							SetProtectionFromArrowFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
							break;
						case 2:
						case 5:
							SetMagicProtectionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
							break;
						case 3:
						case 4:
							SetDefenseShieldFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
							break;
					}
				}
				break;
			}
			break;
		}
		
		delete m_pDelayEventList[i];
		m_pDelayEventList[i] = NULL;
	}
}
BOOL CGame::bRemoveFromDelayEventList(int iH, char cType, int iEffectType)
{
 int i;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if (m_pDelayEventList[i] != NULL) {
		
		if (iEffectType == NULL) {
			// Effect     	
			if ( (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) ) {
				delete m_pDelayEventList[i];
				m_pDelayEventList[i] = NULL;
			}
		}
		else {
			//  Effect .
			if ( (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) &&
				 (m_pDelayEventList[i]->m_iEffectType == iEffectType) ) {
				delete m_pDelayEventList[i];
				m_pDelayEventList[i] = NULL;
			}
		}
	}
	
	return TRUE;
}

void CGame::SendObjectMotionRejectMsg(int iClientH)
{
 char  * cp, cData[30];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int     iRet;

	m_pClientList[iClientH]->m_bIsMoveBlocked = TRUE; // v2.171
	
	//  . 
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
 	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_REJECT;
	
	cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2); 
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX; 
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY; 
	cp += 2;
	
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		//     .
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	return;
}

int CGame::_iGetTotalClients()
{
 int i, iTotal;

	iTotal = 0;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) iTotal++;

	return iTotal;
}

void CGame::DynamicObjectEffectProcessor()
{
 int i, ix, iy, iIndex;
 short sOwnerH, iDamage, sType;
 char  cOwnerType;
 DWORD dwTime = timeGetTime(), dwRegisterTime;
	
	// 
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] != NULL) {
		switch (m_pDynamicObjectList[i]->m_sType) {

		case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:
			//  
			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					// Poison Damage .
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
						// v1.41      .
						//     
						// Snoopy: Increazed a bit ..because rain/snow will reduce it.
						if (m_pDynamicObjectList[i]->m_iV1 <= 20) // Was 20 or 40 in spells definition ....
							 iDamage = iDice(2,4); // 1..8 >> 2..8
						else iDamage = iDice(2,5); // 1..8 >> 2..10	

						// SNOOPY: Whether Bouns
						iDamage += iGetWhetherMagicBonusEffect(46, m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus);

						// New 17/05/2004 Changed
						if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
							m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							//  .
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								//   . <- HP  .
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
									//   .	
									// 1: Hold-Person 
									// 2: Paralize
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}

							// v1.42 Poison 
							if ( (bCheckResistingMagicSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, 100) == FALSE) &&
								 (m_pClientList[sOwnerH]->m_bIsPoisoned == FALSE) ) {
								
								m_pClientList[sOwnerH]->m_bIsPoisoned  = TRUE;
								m_pClientList[sOwnerH]->m_iPoisonLevel = m_pDynamicObjectList[i]->m_iV1;
								m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
								//  . 
								SetPoisonFlag(sOwnerH, cOwnerType, TRUE);// poison aura appears from dynamic objects
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sOwnerH]->m_iPoisonLevel, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						//     
						if (m_pNpcList[sOwnerH] == NULL) break;

						//     
						if (m_pDynamicObjectList[i]->m_iV1 < 20)
							 iDamage = iDice(2,4);
						else iDamage = iDice(2,5);	
						// SNOOPY: Whether Bouns
						iDamage += iGetWhetherMagicBonusEffect(46, m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus);

						if (iDamage < 1 ) iDamage = 1;				
						// HP

						//     ,        .
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40: // ESG
						case 41: // GMG
						case 67: // McGaffin
						case 68: // Perry
						case 69: // Devlin
							iDamage = 0;
							break;
						}
						
						// HP . Action Limit  .
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // 
						case 3: // 
						case 5: //  
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						case 8: // Heldenian gate.
							iDamage = 0;
							break;
						}
						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC .
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2     0.      .
						}
						else {
							// Damage    .
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold    . 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPC   .
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
						}
						break;
					}
				}
			}
			break;
						
		case DEF_DYNAMICOBJECT_ICESTORM:
			for (ix = m_pDynamicObjectList[i]->m_sX -2; ix <= m_pDynamicObjectList[i]->m_sX+2; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -2; iy <= m_pDynamicObjectList[i]->m_sY+2; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;

						// Increased damages a bit
						iDamage = iDice(3,4) + 5;

						// SNOOPY: Whether Bouns
						iDamage += iGetWhetherMagicBonusEffect(55, m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus);

						if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
						m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							//  .
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {

									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {

									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}

							if ( (bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, m_pDynamicObjectList[i]->m_iV1) == FALSE) &&
								 (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) ) {
								
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								//       .
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20*1000), 
									                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						
						iDamage = iDice(3,4) + 5;
						// SNOOPY: Whether Bouns
						iDamage += iGetWhetherMagicBonusEffect(55, m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus);

						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40: // ESG
						case 41: // GMG
						case 67: // McGaffin
						case 68: // Perry
						case 69: // Devlin
							iDamage = 0;
							break;
						}
						
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0:
						case 3:
						case 5:
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						case 8: // Heldenian gate.
							iDamage = iDamage/2;
							break;
						}

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC .
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2     0.      .
						}
						else {
							// Damage    .
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold    . 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPC   .
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);

							// v1.42 Ice 
							if ( (bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_NPC, m_pDynamicObjectList[i]->m_iV1) == FALSE) &&
								 (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) ) {
																
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								//       .
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20*1000), 
								                    sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
					   	break;
					}
				}

				//    
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					//    .
					iDamage = iDice(6,4) + 10; // Increased serioully.
					m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
					if (m_pClientList[sOwnerH]->m_iHP <= 0) {
						//  .
						ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  				}
					else {
						if (iDamage > 0) {
							m_pClientList[sOwnerH]->m_dwRecentAttackTime = dwTime;
							//   . <- HP  .
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
						}
					}
				}

				//  Fire Object   .
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
				if (((sType == DEF_DYNAMICOBJECT_FIRE) || (sType == DEF_DYNAMICOBJECT_FIRE3)) && (m_pDynamicObjectList[iIndex] != NULL)) 
					m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
			}
			break;
		
		case DEF_DYNAMICOBJECT_FIRE3:
		case DEF_DYNAMICOBJECT_FIRE2:
		case DEF_DYNAMICOBJECT_FIRE:
			// Fire-Wall  
			if (m_pDynamicObjectList[i]->m_iCount == 1) {
				//     . 
				CheckFireBluring(m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY);
			}
			m_pDynamicObjectList[i]->m_iCount++;
			if (m_pDynamicObjectList[i]->m_iCount > 10) m_pDynamicObjectList[i]->m_iCount = 10; 

				for (ix = m_pDynamicObjectList[i]->m_sX;    ix <= m_pDynamicObjectList[i]->m_sX;   ix++)
				for (iy = m_pDynamicObjectList[i]->m_sY;    iy <= m_pDynamicObjectList[i]->m_sY;   iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					// Fire Damage .
					switch (cOwnerType) {
					
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
						// v1.41      .
						// Snoopy: Increazed a bit ..because rain/snow will reduce it.	.
						iDamage = iDice(2,4);			
						// SNOOPY: Whether Bouns
						iDamage += iGetWhetherMagicBonusEffect(40, m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus);
						// New 17/05/2004
						if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
							m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							//  .
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								//   . <- HP  .
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
									// Hold-Person    . Fire Field   . 	
									// 1: Hold-Person 
									// 2: Paralize	
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						
						iDamage = iDice(2,4);	
						// SNOOPY: Whether Bouns
						iDamage += iGetWhetherMagicBonusEffect(40, m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus);
						if (iDamage < 1 ) iDamage=1;

						//     ,        .
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40: // ESG
						case 41: // GMG
						case 67: // McGaffin
						case 68: // Perry
						case 69: // Devlin
							iDamage = 0;
							break;
						}
												
						// HP . Action Limit  .
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // 
						case 3: // 
						case 5: //  
						case 8: // Heldenian gate.
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC .
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2     0.      .
						}
						else {
							// Damage    .
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold    . 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPC   .
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
						}
					   	break;
					}
				}

				//    
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					//    .
					iDamage = iDice(1,6);
					m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
					if (m_pClientList[sOwnerH]->m_iHP <= 0) {
						//  .
						ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  				}
					else {
						if (iDamage > 0) {
							m_pClientList[sOwnerH]->m_dwRecentAttackTime = dwTime;
							//   . <- HP  .
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
						}
					}
				}

				//  Ice Object   .
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
				if ((sType == DEF_DYNAMICOBJECT_ICESTORM) && (m_pDynamicObjectList[iIndex] != NULL)) 
					m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
			}
			break;
		}
	}
} 

char _tmp_cCorpseX[] = {  0,  1, 1, 1, 0, -1, -1, -1, 0, 0, 0, 0};
char _tmp_cCorpseY[] = { -1, -1, 0, 1, 1,  1,  0, -1, 0, 0, 0};

void CGame::ClearSkillUsingStatus(int iClientH)
{
 int i;
 short tX, fX, tY, fY;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) {
		tX = m_pClientList[iClientH]->m_sX;
		tY = m_pClientList[iClientH]->m_sY;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(tX, tY, NULL) == FALSE) {
			fX = m_pClientList[iClientH]->m_sX + _tmp_cCorpseX[m_pClientList[iClientH]->m_cDir];
			fY = m_pClientList[iClientH]->m_sY + _tmp_cCorpseY[m_pClientList[iClientH]->m_cDir];
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(fX, fY, NULL) == FALSE) {
				m_pClientList[iClientH]->m_cDir = iDice(1,8);
				fX = m_pClientList[iClientH]->m_sX + _tmp_cCorpseX[m_pClientList[iClientH]->m_cDir];
				fY = m_pClientList[iClientH]->m_sY + _tmp_cCorpseY[m_pClientList[iClientH]->m_cDir];
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(fX , fY, NULL) == FALSE) {
					return;
				}
			}
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DAMAGEMOVE, m_pClientList[iClientH]->m_cDir, NULL, NULL, NULL);
		}
	}
	// Taming
	else if (m_pClientList[iClientH]->m_bSkillUsingStatus[22] == TRUE) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_DELAYEVENTTYPE_TAMING_SKILL);
	}
	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		m_pClientList[iClientH]->m_bSkillUsingStatus[i] = FALSE;
		m_pClientList[iClientH]->m_iSkillUsingTimeID[i] = NULL;
	}
	
	if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) {
		if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		m_pClientList[iClientH]->m_iAllocatedFish = NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHCANCELED, NULL, NULL, NULL, NULL);
	}

}

int CGame::iCalculateUseSkillItemEffect(int iOwnerH, char cOwnerType, char cOwnerSkill, int iSkillNum, char cMapIndex, int dX, int dY)
{
 class CItem * pItem;
 char  cItemName[21];
 short lX, lY;
 int   iResult, iFish;

	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iOwnerH] == NULL) return 0;
		if (m_pClientList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pClientList[iOwnerH]->m_sX;
		lY = m_pClientList[iOwnerH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iOwnerH] == NULL) return 0;
		if (m_pNpcList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pNpcList[iOwnerH]->m_sX;
		lY = m_pNpcList[iOwnerH]->m_sY;
		break;
	}

	//     . 
	if (cOwnerSkill == 0) return 0;
	
	//  100       1D105 
	iResult = iDice(1, 105);
	if (cOwnerSkill <= iResult)	return 0;  // .

	//    
	if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == FALSE) return 0;

	//    .
	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(iOwnerH, iSkillNum, 1);

	switch (m_pSkillConfigList[iSkillNum]->m_sType) {
	case DEF_SKILLEFFECTTYPE_TAMING:
		//  : dX, dY   .
		_TamingHandler(iOwnerH, iSkillNum, cMapIndex, dX, dY);
		break;
	
	case DEF_SKILLEFFECTTYPE_GET: 
		//   . 
		ZeroMemory(cItemName, sizeof(cItemName));
		switch (m_pSkillConfigList[iSkillNum]->m_sValue1) {
		case 1:
			//  
			wsprintf(cItemName, "Meat");
			break;

		case 2:
			//        .
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				iFish = iCheckFish(iOwnerH, cMapIndex, dX, dY);
		   		if (iFish == NULL) wsprintf(cItemName, "Fish");
			}
			else wsprintf(cItemName, "Fish");
			break;
		}

		if (strlen(cItemName) != 0) {
			
			//    .
			if (memcmp(cItemName, "Fish", 6) == 0) {
				SendNotifyMsg(NULL, iOwnerH, DEF_NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
				// v1.41    
				GetExp(iOwnerH, iDice(1,2));
			}
			
			pItem = new class CItem;
			if (pItem == NULL) return 0;
			if (_bInitItemAttr(pItem, cItemName) == TRUE) {
				//  . 
				m_pMapList[cMapIndex]->bSetItem(lX, lY, pItem);
		
				//      . 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, cMapIndex,
					lX, lY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4
			}
		}
		break;
	}

	return 1;
}



void CGame::UseSkillHandler(int iClientH, int iV1, int iV2, int iV3)
{
 char  cOwnerType;
 short sAttackerWeapon, sOwnerH;
 int   iResult, iPlayerSkillLevel;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((iV1 < 0) || (iV1 >= DEF_MAXSKILLTYPE)) return;
	if (m_pSkillConfigList[iV1]	== NULL) return;
	//    .
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] == TRUE) return;

	

	//     . 
	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[iV1];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		// . 
		//     .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
		return;
	}

	// iV1   
	switch (m_pSkillConfigList[iV1]->m_sType) {

	case DEF_SKILLEFFECTTYPE_TAMING: // Taming
		if (   ((m_pClientList[iClientH]->m_iStatus & 0x00000010) == 0)      // Invi character can not tame !
			&& (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == FALSE)) // PretendCorpse character canot Tame
		{	m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] = TRUE;
			m_pClientList[iClientH]->m_iSkillUsingTimeID[iV1] = (int)timeGetTime();
			// Register delay to perform Taming
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_TAMING_SKILL // int iDelayType
								, 22 // int iEffectType
								, timeGetTime() + m_pSkillConfigList[22]->m_sValue2*100 // nbe of 1/10th seconds in Skill.cfg
								, iClientH // int iTargetH
								, DEF_OWNERTYPE_PLAYER // char cTargetType
								, m_pClientList[iClientH]->m_cMapIndex // char cMapIndex
								, m_pClientList[iClientH]->m_sX // int X
								, m_pClientList[iClientH]->m_sY // int Y
								, (int)m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] // int iV1
								, m_pClientList[iClientH]->m_iSkillUsingTimeID[iV1] // int iV2
								, NULL); // int iV3		
		}else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
		break;

	case DEF_SKILLEFFECTTYPE_PRETEND:
		switch (m_pSkillConfigList[iV1]->m_sValue1) {
		case 1:
			//  .	
			
			// v1.44   .
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}
			
			//        . 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetDeadOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			if (sOwnerH != NULL) {
				//           .
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}
			
			//         . 
			iResult = 0;
			if (m_pClientList[iClientH]->m_iAdminUserLevel <= 0) {
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;

				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
			}

			if (iResult != 0) {
				//           .
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}

			//   . <--        . 
			CalculateSSN_SkillIndex(iClientH, iV1, 1);
			
			//     .
			sAttackerWeapon = 1;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, 0, sAttackerWeapon, NULL);
			//   .
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(14, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			//    .
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			break;
		}
		break;

	}

	m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] = TRUE;
}

void CGame::ReqSellItemHandler(int iClientH, char cItemID, char cSellToWhom, int iNum, char * pItemName)
{
 char cItemCategory,cItemName[21];
 short sRemainLife;
 int   iPrice;
 double d1, d2, d3;
 BOOL   bNeutral;
 DWORD  dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2, dwMul1, dwMul2;
 CItem * m_pGold;

	//    .
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;

	iCalcTotalWeight(iClientH);

	m_pGold = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(m_pGold, cItemName);

	// v1.42
	bNeutral = FALSE;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) bNeutral = TRUE;
	// v2.13        NPC  . 
	//      .
	switch (cSellToWhom) {
	case 15: 		//   
	case 24:        //   
		cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;
		// 12-22       
		//  
		if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {

			// .   
			iPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2)*iNum;
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;


			//v1.42    .
			if (bNeutral == TRUE) iPrice = iPrice/2;
			if (iPrice <= 0)    iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;

			if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > (DWORD)_iCalcMaxLoad(iClientH)) {
				// v2.12       .
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}
			else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
		}
		//  
		else if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
			//       ,   .
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

			if (sRemainLife == 0) {
				//     
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}
			else {
				d1 = (double)sRemainLife;
				if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
					d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; //   
				d3 = d3 * d2; //   

				iPrice = (int)d3;
				iPrice = iPrice*iNum;

				dwAddPrice1 = 0;
				dwAddPrice2 = 0;
				//      
	if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != NULL) {
		dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;  
		dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;

	switch (dwSWEType) {
		case 6: dwMul1 = 2; break;  //  
		case 8: dwMul1 = 2; break;  // 
		case 5: dwMul1 = 3; break;  // 
		case 1: dwMul1 = 4; break;  //  
		case 7: dwMul1 = 5; break;  // 
		case 2: dwMul1 = 6; break;  // 
		case 3: dwMul1 = 15; break; //  
		case 9: dwMul1 = 20; break; //  
		default: dwMul1 = 1; break;
	}

	d1 = (double)iPrice*dwMul1;
	switch (dwSWEValue) {
		case 1: d2 = 10.0f; break;
		case 2: d2 = 20.0f; break;
		case 3: d2 = 30.0f; break;
		case 4: d2 = 35.0f; break;
		case 5: d2 = 40.0f; break;
		case 6: d2 = 50.0f; break;
		case 7: d2 = 100.0f; break;
		case 8: d2 = 200.0f; break;
		case 9: d2 = 300.0f; break;
		case 10: d2 = 400.0f; break;
		case 11: d2 = 500.0f; break;
		case 12: d2 = 700.0f; break;
		case 13: d2 = 900.0f; break;
		default: d2 = 0.0f; break;
	}
	d3 = d1*(d2/100.0f);

	dwAddPrice1 = (int)(d1 + d3);
	}

				// v1.42   Sub  .  1   .
	if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != NULL) {
		dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;  
		dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;

	switch (dwSWEType) {
		case 1: 
		case 12: dwMul2 = 2; break;

		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7: dwMul2 = 4; break;

		case 8:
		case 9:
		case 10:
		case 11: dwMul2 = 6; break;
	}

	d1 = (double)iPrice*dwMul2;
	switch (dwSWEValue) {
		case 1: d2 = 10.0f; break;
		case 2: d2 = 20.0f; break;
		case 3: d2 = 30.0f; break;
		case 4: d2 = 35.0f; break;
		case 5: d2 = 40.0f; break;
		case 6: d2 = 50.0f; break;
		case 7: d2 = 100.0f; break;
		case 8: d2 = 200.0f; break;
		case 9: d2 = 300.0f; break;
		case 10: d2 = 400.0f; break;
		case 11: d2 = 500.0f; break;
		case 12: d2 = 700.0f; break;
		case 13: d2 = 900.0f; break;
		default: d2 = 0.0f; break;
	}
	d3 = d1*(d2/100.0f);

	dwAddPrice2 = (int)(d1 + d3);
}

				// v2.03 925     77%  
				iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));

				//v1.42    .
				if (bNeutral == TRUE) iPrice = iPrice/2;
				if (iPrice <= 0)    iPrice = 1;
				if (iPrice > 1000000) iPrice = 1000000;

				if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > (DWORD)_iCalcMaxLoad(iClientH)) {
					// v2.12       .
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
				}
				else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
			}
		}
		else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
		break;


	default:
		break;
	}
	if (m_pGold != NULL) delete m_pGold;
}

void CGame::ReqSellItemConfirmHandler(int iClientH, char cItemID, int iNum, char * pString)
{
 class CItem * pItemGold;
 short sRemainLife;
 int   iPrice;
 double d1, d2, d3;
 char   * cp, cItemName[21], cData[120], cItemCategory;
 DWORD  * dwp, dwMul1, dwMul2, dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2;
 WORD   * wp;
 int    iEraseReq, iRet;
 short * sp;
 BOOL   bNeutral;


	//    .
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;

	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == FALSE) return;

	iCalcTotalWeight(iClientH);
	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// v1.42
	bNeutral = FALSE;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) bNeutral = TRUE;

	iPrice = 0;
	//     .
  	if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
		// 
  		//       ,   .
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		
		if (sRemainLife <= 0) {
			//    .	
			return;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; //   
			d3 = d3 * d2; //   
			
			iPrice = (short)d3;
			iPrice = iPrice*iNum;

			dwAddPrice1 = 0;
			dwAddPrice2 = 0;
			//      
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;
				
				//    : 
				// 0-None 1- 2- 3- 4- 
				// 5- 6- 7- 8- 9-
				switch (dwSWEType) {
				case 6: dwMul1 = 2; break;  //  
				case 8: dwMul1 = 2; break;  // 
				case 5: dwMul1 = 3; break;  // 
				case 1: dwMul1 = 4; break;  //  
				case 7: dwMul1 = 5; break;  // 
				case 2: dwMul1 = 6; break;  // 
				case 3: dwMul1 = 15; break; //  
				case 9: dwMul1 = 20; break; //  
				default: dwMul1 = 1; break;
				}

				d1 = (double)iPrice*dwMul1;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice1 = (int)(d1 + d3);
			}

			// v1.42   Sub  .  1   .
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;
				
				//    : 
				// (1),  (2),  (3), HP  (4), SP  (5)
				//MP  (6),  (7),   (8),   (9)
				//  (10),   (11),  Gold(12)
				switch (dwSWEType) {
				case 1: 
				case 12: dwMul2 = 2; break;
					
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7: dwMul2 = 4; break;
					
				case 8:
				case 9:
				case 10:
				case 11: dwMul2 = 6; break;
				}
					
				d1 = (double)iPrice*dwMul2;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice2 = (int)(d1 + d3);
			}

			iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));

			//v1.42    .
			if (bNeutral == TRUE) iPrice = iPrice/2;
			if (iPrice <= 0) iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000; // New 06/05/2004

			//     (  )
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

			_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[cItemID]) ;

			//    
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
				(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
				//     .
				// v1.41 !!!
				SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
			}
			else ItemDepleteHandler(iClientH, cItemID, FALSE, FALSE);
		}
	}
	else 
	if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {
		// ,   
		iPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice/2; 
		iPrice = iPrice*iNum;

		//v1.42    .
		if (bNeutral == TRUE) iPrice = iPrice/2;
		if (iPrice <= 0) iPrice = 1;
		if (iPrice > 1000000) iPrice = 1000000; // New 06/05/2004

		//     (  )
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

		_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[cItemID]) ;

		//      .
		if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
			//     .
			// v1.41 !!!
			SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
		}
		else ItemDepleteHandler(iClientH, cItemID, FALSE, TRUE);
	}

	// Gold .    0     .
	if (iPrice <= 0) return;

	pItemGold = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItemGold, cItemName);
	
	pItemGold->m_dwCount = iPrice;
	
	if (_bAddClientItemList(iClientH, pItemGold, &iEraseReq) == TRUE) {
		//  .
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1 . <-  1    
		*cp = 1;
		cp++;
		
		memcpy(cp, pItemGold->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItemGold->m_dwCount;
		cp += 4;
		
		*cp = pItemGold->m_cItemType;
		cp++;
		
		*cp = pItemGold->m_cEquipPos;
		cp++;
		
		*cp = (char)0; //    .
		cp++;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sLevelLimit;
		cp += 2;
		
		*cp = pItemGold->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItemGold->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItemGold->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sSpriteFrame;
		cp += 2;

		*cp = pItemGold->m_cItemColor;
		cp++;

		*cp = (char)pItemGold->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItemGold->m_dwAttribute;
		cp += 4;
		
		
		if (iEraseReq == 1)
			delete pItemGold;
		
		//    
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		
		//      
		iCalcTotalWeight(iClientH);

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			//     .
			DeleteClient(iClientH, TRUE, TRUE);
			break;
		}
	}
	else {
		//     .
		//    . 
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY, pItemGold);
		
		//      . 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			pItemGold->m_sSprite, pItemGold->m_sSpriteFrame, pItemGold->m_cItemColor); // v1.4 color

		//      
		iCalcTotalWeight(iClientH);
		
		//     .
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			//     .
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}
}

void CGame::ReqRepairItemHandler(int iClientH, char cItemID, char cRepairWhom, char * pString)
{
 char cItemCategory;
 short sRemainLife, sPrice;
 double d1, d2, d3;

	//   .
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	//     .
  	if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
		// 
  		
		//           . 
		if (cRepairWhom != 24) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}
		
		//       ,    .
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			//      . 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; //   
			d3 = d3 * d2; //   
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else if ( ((cItemCategory >= 43) && (cItemCategory <= 50)) || ((cItemCategory >= 11) && (cItemCategory <= 12))) {
		// ,      . , 
		
		//          . 
		if (cRepairWhom != 15) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}
		
		//       ,    .
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			//      . 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; //   
			d3 = d3 * d2; //   
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else {
		//   .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
}

void CGame::ReqRepairItemCofirmHandler(int iClientH, char cItemID, char * pString)
{
 short    sRemainLife, sPrice;
 char   * cp, cItemCategory, cData[120];
 double   d1, d2, d3;
 DWORD  * dwp, dwGoldCount;
 WORD   * wp;
 int      iRet, iGoldWeight;

	//    .
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;

	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == FALSE) return;

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	//     .
  	if ( ((cItemCategory >= 1) && (cItemCategory <= 10)) || ((cItemCategory >= 43) && (cItemCategory <= 50)) || 
		 ((cItemCategory >= 11) && (cItemCategory <= 12))) {
		//   ,   , ,  

  		//       ,    .
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			//      . 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)abs(sRemainLife);
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)abs(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan);
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; //   
			d3 = d3 * d2; //   
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}
		
		// sPrice         . 
		dwGoldCount = dwGetItemCount(iClientH, "Gold");
		
		if ( dwGoldCount < (DWORD)sPrice ) {
			//   Gold     .   .
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_NOTENOUGHGOLD;
			cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp  = cItemID;
			cp++;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				//     .
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
			return;
		}
		else {
			// .   . 
			
			//    . !BUG POINT  .      .
			m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
		 	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMREPAIRED, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan, NULL, NULL);
			
			iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - sPrice );
			
			//      
			iCalcTotalWeight(iClientH);

			//v1.4   . 
			m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += sPrice;
		}
	}
	else {
		//     
		//     
	}
}

int CGame::iCalcTotalWeight(int iClientH)
{
 int i, iWeight;
 short sItemIndex;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	
	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
	//      .       .
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
				//    .
				m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
			}
			break;
		}
	}

	iWeight = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		
		iWeight += iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], m_pClientList[iClientH]->m_pItemList[i]->m_dwCount);
	}

	m_pClientList[iClientH]->m_iCurWeightLoad = iWeight;

	return iWeight;	
}

void CGame::CheckAndNotifyPlayerConnection(int iClientH, char * pMsg, DWORD dwSize)
{
 char   seps[] = "= \t\n";
 char   * token, * cp, cName[11], cBuff[256], cPlayerLocation[120];
 class  CStrTok * pStrTok;
 int i;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwSize <= 0) return;

	ZeroMemory(cPlayerLocation,sizeof(cPlayerLocation));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	if (strlen(token) > 10) 
		 memcpy(cName, token, 10);	
	else memcpy(cName, token, strlen(token));

	// cName     . 
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(cName, m_pClientList[i]->m_cCharName, 10) == 0)) {
		//     . 
		if(m_pClientList[iClientH]->m_iAdminUserLevel > 0){ // GM's get more info
			cp = (char *)cPlayerLocation;

			memcpy(cp,m_pClientList[i]->m_cMapName,10);
			cp += 10;

			wp = (WORD *)cp;
			*wp = m_pClientList[i]->m_sX;
			cp += 2;

			wp = (WORD *)cp;
			*wp = m_pClientList[i]->m_sY;
			cp += 2;
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERONGAME, NULL, NULL, NULL, m_pClientList[i]->m_cCharName,NULL,NULL,NULL,NULL,NULL,NULL,cPlayerLocation);

		delete pStrTok;
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;

	wp = (WORD *)cp;
	*wp = m_wServerID_GSS;
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp, cName, 10);
	cp += 10;

	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;

	bStockMsgToGateServer(cBuff, 25);

	delete pStrTok;
}



void CGame::ToggleWhisperPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 int i;
 char *cp;
 WORD *wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwMsgSize <= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   
	if (token == NULL) {
		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
		ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
		m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = FALSE;
		// Whisper mode enabled
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, cName);
	}
	else {
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));

		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			if (i == iClientH) {
				delete pStrTok;
				// Whisper self XenX
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "You shouldnt talk to yourself!");
				return;
			}
			m_pClientList[iClientH]->m_iWhisperPlayerIndex = i;
			ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
			strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
			break;
		}

		if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == -1) {
			ZeroMemory(cBuff, sizeof(cBuff));
			cp = (char *)cBuff;
			*cp = GSM_REQUEST_FINDCHARACTER;
			cp++;

			wp = (WORD *)cp;
			*wp = m_wServerID_GSS;
			cp += 2;

			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;

			memcpy(cp, cName, 10);
			cp += 10;

			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			bStockMsgToGateServer(cBuff, 25);

			ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
			strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
			m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = TRUE;
		}
		else{
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[iClientH]->m_cWhisperPlayerName);
			return;
		}
		//player not online XenX
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "This player is not online!");
	}
	delete pStrTok;
}


void CGame::SetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char cTemp[256];
 int i;


	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize - 7) <= 0) return;

	ZeroMemory(cTemp, sizeof(cTemp));
	memcpy(cTemp, (pMsg + 7), dwMsgSize - 7);
	
	//   . 
	for (i = 0; i < 256; i++)
		if (cTemp[i] == ' ') cTemp[i] = '_';

	//    
	cTemp[255] = NULL;

	ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
	strcpy(m_pClientList[iClientH]->m_cProfile, cTemp);
}

void CGame::GetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256], cBuff2[500];
 class  CStrTok * pStrTok;
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token       
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
		
			ZeroMemory(cBuff2, sizeof(cBuff2));
			wsprintf(cBuff2, "%s Profile: %s", cName, m_pClientList[i]->m_cProfile);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERPROFILE, NULL, NULL, NULL, cBuff2);

			delete pStrTok;
			return;
		}
		//   .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}

	delete pStrTok;
	return;
}

void CGame::___RestorePlayerCharacteristics(int iClientH)
{
	int iStr, iDex, iInt, iVit, iMag, iCharisma;
	int iOriginalPoint, iCurPoint, iVerifyPoint, iToBeRestoredPoint;
	int iMax, iA, iB;
	BOOL bFlag;
	char cTxt[120];
	return;
		if (m_pClientList[iClientH] == NULL) return;

	//   . 
	iStr = m_pClientList[iClientH]->m_iStr;
	iDex = m_pClientList[iClientH]->m_iDex;
	iInt = m_pClientList[iClientH]->m_iInt;
	iVit = m_pClientList[iClientH]->m_iVit;
	iMag = m_pClientList[iClientH]->m_iMag;
	iCharisma = m_pClientList[iClientH]->m_iCharisma;


	iCurPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
		m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
		m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	iOriginalPoint = (m_pClientList[iClientH]->m_iLevel - 1)*3 + 70;

	iToBeRestoredPoint = iOriginalPoint - iCurPoint;

	//    .
	if (iToBeRestoredPoint == 0) return;

	if (iToBeRestoredPoint > 0) {
		//  iToBeRestoredPoint   . 
		//  10     . 
		while (1) {
			bFlag = FALSE;

			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < 10)) {
				m_pClientList[iClientH]->m_iStr++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < 10)) {
				m_pClientList[iClientH]->m_iMag++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < 10)) {
				m_pClientList[iClientH]->m_iInt++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < 10)) {
				m_pClientList[iClientH]->m_iDex++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iVit < 10)) {
				m_pClientList[iClientH]->m_iVit++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iCharisma < 10)) {
				m_pClientList[iClientH]->m_iCharisma++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}

			if (bFlag == FALSE)          break;
			if (iToBeRestoredPoint <= 0) break; 
		}

		//     iMax, Str iMax/2   . 
		iMax = m_pClientList[iClientH]->m_cSkillMastery[5];

		if ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr) < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr) < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}

				if ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr) == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		//     iMax, Dex iMax/2   . 
		iA = m_pClientList[iClientH]->m_cSkillMastery[7];
		iB = m_pClientList[iClientH]->m_cSkillMastery[8];
		if (iA > iB) 
			iMax = iA;
		else iMax = iB;
		iA = m_pClientList[iClientH]->m_cSkillMastery[9];
		if (iA > iMax) iMax = iA;
		iA = m_pClientList[iClientH]->m_cSkillMastery[6];
		if (iA > iMax) iMax = iA;


		if ((m_pClientList[iClientH]->m_iDex+m_pClientList[iClientH]->m_iAngelicDex) < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && ((m_pClientList[iClientH]->m_iDex+m_pClientList[iClientH]->m_iAngelicDex) < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}

				if ((m_pClientList[iClientH]->m_iDex+m_pClientList[iClientH]->m_iAngelicDex) == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		//    iMax, Int iMax/2   . 
		iMax = m_pClientList[iClientH]->m_cSkillMastery[19];

		if ((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt) < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && ((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt) < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}

				if ((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt) == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		//    iMax, Mag iMax/2   . 
		iA = m_pClientList[iClientH]->m_cSkillMastery[3];
		iB = m_pClientList[iClientH]->m_cSkillMastery[4];
		if (iA > iB) 
			iMax = iA;
		else iMax = iB;

		if ((m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag) < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && ((m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag) < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}

				if ((m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag) == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		//    .
		while (iToBeRestoredPoint != 0) {
			switch (iDice(1,6)) {
			case 1:
				if (m_pClientList[iClientH]->m_iStr < m_sCharStatLimit) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}
				break;
			case 2:
				if (m_pClientList[iClientH]->m_iVit < m_sCharStatLimit) {
					m_pClientList[iClientH]->m_iVit++;
					iToBeRestoredPoint--;
				}
				break;
			case 3:
				if (m_pClientList[iClientH]->m_iDex < m_sCharStatLimit) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}
				break;
			case 4:
				if (m_pClientList[iClientH]->m_iMag < m_sCharStatLimit) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}
				break;
			case 5:
				if (m_pClientList[iClientH]->m_iInt < m_sCharStatLimit) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}
				break;
			case 6:
				if (m_pClientList[iClientH]->m_iCharisma < m_sCharStatLimit) {
					m_pClientList[iClientH]->m_iCharisma++;
					iToBeRestoredPoint--;
				}
				break;
			}
		}

		//    . 
		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

		if (iVerifyPoint != iOriginalPoint)	{
			wsprintf(cTxt, "(T_T) RestorePlayerCharacteristics(Minor) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);

			// .   .
			m_pClientList[iClientH]->m_iStr = iStr;
			m_pClientList[iClientH]->m_iDex = iDex;
			m_pClientList[iClientH]->m_iInt = iInt;
			m_pClientList[iClientH]->m_iVit = iVit;
			m_pClientList[iClientH]->m_iMag = iMag;
			m_pClientList[iClientH]->m_iCharisma = iCharisma;
		}
		else {
			wsprintf(cTxt, "(^o^) RestorePlayerCharacteristics(Minor) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
	else {
		//      .   . iToBeRestoredPoint ! 

		//      .
		while (1) {
			bFlag = FALSE;
			if (m_pClientList[iClientH]->m_iStr > m_sCharStatLimit) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iStr--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iDex > m_sCharStatLimit) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iDex--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iVit > m_sCharStatLimit) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iVit--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iInt > m_sCharStatLimit) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iInt--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iMag > m_sCharStatLimit) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iMag--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iCharisma > m_sCharStatLimit) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iCharisma--;
				iToBeRestoredPoint++;
			}

			if (bFlag == FALSE)	break;
			if (iToBeRestoredPoint >= 0) break;
		}

		if (iToBeRestoredPoint < 0) {
			//        .
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1,6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr > 10) {
						m_pClientList[iClientH]->m_iStr--;
						iToBeRestoredPoint++;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit > 10) {
						m_pClientList[iClientH]->m_iVit--;
						iToBeRestoredPoint++;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex > 10) {
						m_pClientList[iClientH]->m_iDex--;
						iToBeRestoredPoint++;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag > 10) {
						m_pClientList[iClientH]->m_iMag--;
						iToBeRestoredPoint++;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt > 10) {
						m_pClientList[iClientH]->m_iInt--;
						iToBeRestoredPoint++;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma > 10) {
						m_pClientList[iClientH]->m_iCharisma--;
						iToBeRestoredPoint++;
					}
					break;
				}
			}
		}
		else {
			//     .  ?
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1,6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr < m_sCharStatLimit) {
						m_pClientList[iClientH]->m_iStr++;
						iToBeRestoredPoint--;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit < m_sCharStatLimit) {
						m_pClientList[iClientH]->m_iVit++;
						iToBeRestoredPoint--;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex < m_sCharStatLimit) {
						m_pClientList[iClientH]->m_iDex++;
						iToBeRestoredPoint--;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag < m_sCharStatLimit) {
						m_pClientList[iClientH]->m_iMag++;
						iToBeRestoredPoint--;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt < m_sCharStatLimit) {
						m_pClientList[iClientH]->m_iInt++;
						iToBeRestoredPoint--;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma < m_sCharStatLimit) {
						m_pClientList[iClientH]->m_iCharisma++;
						iToBeRestoredPoint--;
					}
					break;
				}
			}
		}

		//    . 
		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

		if (iVerifyPoint != iOriginalPoint)	{
			wsprintf(cTxt, "(T_T) RestorePlayerCharacteristics(Over) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);

			
		}
		else {
			wsprintf(cTxt, "(^o^) RestorePlayerCharacteristics(Over) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
}

void CGame::CalcTotalItemEffect(int iClientH, int iEquipItemID, BOOL bNotify)
{
short sItemIndex;
 int  i, iPrevSAType, iTemp;
 char cEquipPos;
 double dV1, dV2, dV3;
 DWORD  dwSWEType, dwSWEValue;
 short  sTemp;
 int iShieldHPrec, iShieldSPrec, iShieldMPrec, iTotalAngelicstatas;
 
	iTotalAngelicstatas = m_pClientList[iClientH]->m_iAngelicStr + (16 * m_pClientList[iClientH]->m_iAngelicInt)
		+ (256 * m_pClientList[iClientH]->m_iAngelicDex) + (16*256 * m_pClientList[iClientH]->m_iAngelicMag);

	iShieldHPrec = iShieldSPrec = iShieldMPrec = 0;

   	if (m_pClientList[iClientH] == NULL) return;

	if ( (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]   != -1) &&
		 (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) ) {
		
		//    .     . 
		if (m_pClientList[iClientH]->m_pItemList[ m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] ] != NULL) {
			//     . 
			m_pClientList[iClientH]->m_bIsItemEquipped[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]] = FALSE;
			m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] = -1;
		}
	}

	m_pClientList[iClientH]->m_iAngelicStr   = 0; // By Snoopy81
	m_pClientList[iClientH]->m_iAngelicInt   = 0; // By Snoopy81
	m_pClientList[iClientH]->m_iAngelicDex   = 0; // By Snoopy81
	m_pClientList[iClientH]->m_iAngelicMag   = 0; // By Snoopy81 
	SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 0, 0);

	m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
	m_pClientList[iClientH]->m_cAttackBonus_SM     = 0;  

	m_pClientList[iClientH]->m_cAttackDiceThrow_L  = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_L  = 0;
	m_pClientList[iClientH]->m_cAttackBonus_L      = 0;

	m_pClientList[iClientH]->m_iHitRatio = 0;

	// Snoopy: Bonus for Angels 
	m_pClientList[iClientH]->m_iDefenseRatio = m_pClientList[iClientH]->m_iDex * 2;

	m_pClientList[iClientH]->m_iDamageAbsorption_Shield = 0;
	
	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
	m_pClientList[iClientH]->m_iDamageAbsorption_Armor[i]  = 0;

	m_pClientList[iClientH]->m_iManaSaveRatio  = 0;
	m_pClientList[iClientH]->m_iAddResistMagic = 0;

	m_pClientList[iClientH]->m_iAddPhysicalDamage = 0;
	m_pClientList[iClientH]->m_iAddMagicalDamage  = 0;

	m_pClientList[iClientH]->m_bIsLuckyEffect  = FALSE;
	m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = -1;
	m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = 0;

	m_pClientList[iClientH]->m_iAddAbsAir   = 0;	//   
	m_pClientList[iClientH]->m_iAddAbsEarth = 0;
	m_pClientList[iClientH]->m_iAddAbsFire  = 0;
	m_pClientList[iClientH]->m_iAddAbsWater = 0;

	m_pClientList[iClientH]->m_iCustomItemValue_Attack  = 0;
	m_pClientList[iClientH]->m_iCustomItemValue_Defense = 0;

	m_pClientList[iClientH]->m_iMinAP_SM = 0;
	m_pClientList[iClientH]->m_iMinAP_L  = 0;

	m_pClientList[iClientH]->m_iMaxAP_SM = 0;
	m_pClientList[iClientH]->m_iMaxAP_L  = 0;

	m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = 0;	//    : 0-None 1- 2- 3- 4-
	m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = 0;	//    

	m_pClientList[iClientH]->m_iAddHP = m_pClientList[iClientH]->m_iAddSP = m_pClientList[iClientH]->m_iAddMP = 0; 
	m_pClientList[iClientH]->m_iAddAR = m_pClientList[iClientH]->m_iAddPR = m_pClientList[iClientH]->m_iAddDR = 0;
	m_pClientList[iClientH]->m_iAddMR = m_pClientList[iClientH]->m_iAddAbsPD = m_pClientList[iClientH]->m_iAddAbsMD = 0;
	m_pClientList[iClientH]->m_iAddCD = m_pClientList[iClientH]->m_iAddExp = m_pClientList[iClientH]->m_iAddGold = 0;	
	
	iPrevSAType = m_pClientList[iClientH]->m_iSpecialAbilityType;

	m_pClientList[iClientH]->m_iSpecialAbilityType     = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityLastSec  = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = 0;

	m_pClientList[iClientH]->m_iAddTransMana = 0;
	m_pClientList[iClientH]->m_iAddChargeCritical = 0;

	// re introduced by SNOOPY
	m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM = 0;
	m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  = 0;
	m_pClientList[iClientH]->m_iMagicHitRatio_ItemEffect = 0;
	
	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
	//     .
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
				//    .
				m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
			}
			break;
		}
	}

	// Hidden bonus to hit per weapon reintroduced by SNOOPY
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  ((m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) && 
		(m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)) 	
	{	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {			
		case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
		case DEF_ITEMEFFECTTYPE_ATTACK:		
		case DEF_ITEMEFFECTTYPE_ATTACK_ARROW:
		case DEF_ITEMEFFECTTYPE_DEFENSE:
			m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1;
			m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue2;
			break;	
		// Use same (L) value for both SM & L
		case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
		case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
			m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue2;
			m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue2;
			break;
	}	}
	
	//      
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  ((m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) && 
		 (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)) {

		cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		
		case DEF_ITEMEFFECTTYPE_MAGICDAMAGESAVE:
			//    .  .
			m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = sItemIndex;
			break;
		
		case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
		case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
		case DEF_ITEMEFFECTTYPE_ATTACK:
			m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
			m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
			m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
			m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;
			// Xelima Upgraded weapons
			iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
			m_pClientList[iClientH]->m_cAttackBonus_SM += iTemp;
			m_pClientList[iClientH]->m_cAttackBonus_L += iTemp;
			// Notice: +1 on Magic damage as well
			m_pClientList[iClientH]->m_iAddMagicalDamage  += iTemp;
						
			// Add skill to HitRatio
			m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]; 
			m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill;
			
			// v1.41 Custom-Made <==> Manuf items
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != NULL) 
			{	m_pClientList[iClientH]->m_iCustomItemValue_Attack += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 /2);
				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 100)
					m_pClientList[iClientH]->m_iCustomItemValue_Attack = 100;
				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < -100)
					m_pClientList[iClientH]->m_iCustomItemValue_Attack = -100;

				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 0) 
				{	// Completion >100%
					dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
					dV1 = (dV2/100.0f)*(5.0f);
					m_pClientList[iClientH]->m_iMinAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM + 
														   m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;					
					m_pClientList[iClientH]->m_iMinAP_L  = m_pClientList[iClientH]->m_cAttackDiceThrow_L + 
														   m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;
					if (m_pClientList[iClientH]->m_iMinAP_SM < 1) m_pClientList[iClientH]->m_iMinAP_SM = 1;
					if (m_pClientList[iClientH]->m_iMinAP_L < 1)  m_pClientList[iClientH]->m_iMinAP_L = 1;
					if (m_pClientList[iClientH]->m_iMinAP_SM > (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM)) 
						m_pClientList[iClientH]->m_iMinAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);
					if (m_pClientList[iClientH]->m_iMinAP_L > (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L)) 
						m_pClientList[iClientH]->m_iMinAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);
				}else if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < 0) 
				{	// Completion <100%
					dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
					dV1 = (dV2/100.0f)*(5.0f);
					m_pClientList[iClientH]->m_iMaxAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM 
														   + m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;
					m_pClientList[iClientH]->m_iMaxAP_L  = m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L 
														   + m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;
					if (m_pClientList[iClientH]->m_iMaxAP_SM < 1) m_pClientList[iClientH]->m_iMaxAP_SM = 1;
					if (m_pClientList[iClientH]->m_iMaxAP_L < 1)  m_pClientList[iClientH]->m_iMaxAP_L = 1;
					if (m_pClientList[iClientH]->m_iMaxAP_SM < (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM)) 
						m_pClientList[iClientH]->m_iMaxAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);
					if (m_pClientList[iClientH]->m_iMaxAP_L < (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L)) 
						m_pClientList[iClientH]->m_iMaxAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);
				}
			}
			// Enchanted weapons
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				switch (dwSWEType) {
				case 2:  // Poison			-> Increase effect of 1st item, or replace a different effect
					break;
				case 1:  // Crit +			-> Increase effect of 1st item, or replace a different effect
				case 10: // CP (as wand)	-> Increase effect of 1st item, or replace a different effect
					if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == dwSWEType)
					{	m_pClientList[iClientH]->m_iSpecialWeaponEffectValue += dwSWEValue;
					}else 
					{	m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = dwSWEType;
						m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = dwSWEValue;	
					}
					break;
				case 7:  // Sharp
					m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
					m_pClientList[iClientH]->m_cAttackDiceRange_L++;
					break;
				case 9:  // Ancient
					m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
					m_pClientList[iClientH]->m_cAttackDiceRange_L  += 2;
					break;
				case 11: // ManaConv 
					m_pClientList[iClientH]->m_iAddTransMana += dwSWEValue;	// SNOOPY changed to 20 as for Crit increase
					if (m_pClientList[iClientH]->m_iAddTransMana > 20) m_pClientList[iClientH]->m_iAddTransMana = 20;
					break;
				case 12: // Crit Increase 
					m_pClientList[iClientH]->m_iAddChargeCritical += dwSWEValue;
					if (m_pClientList[iClientH]->m_iAddChargeCritical > 20) m_pClientList[iClientH]->m_iAddChargeCritical = 20;
					break;
				case 4:  // Magic-using weapons
						
					break;
				default: // All others
					m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = dwSWEType;
					m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = dwSWEValue;	
					break;
				}	}

			// Enchanted weapon, compute stats
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;				
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break;
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break; // armes HitProba
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break;
				case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; break;
				case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; break;
				case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; break;
				case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; break;
				case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[cEquipPos] += (int)dwSWEValue*3; break;

				case 9:  
					m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3;
					if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; 
					break;

				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break;
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break;
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break;			
			}	}

			// Those Attack items where treated as a bundle above, see here special cases
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_ATTACK: // More combo for Flamberge
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue == 12) 
				{	m_pClientList[iClientH]->m_iAddCD +=5;
				}
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
				m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				// Xelima Upgraded weapons
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iSideEffect_MaxHPdown -= iTemp;
				if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown < 2) m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = 2;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
				// SNOOPY: For wands, ignore m_sItemEffectValue4/5/6 for damage{
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				// Compute Mana save, max=80%
				m_pClientList[iClientH]->m_iManaSaveRatio    += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
				if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
				//Snoopy: Reintroduced defence for staves
				m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;				
				//Snoopy: Added Magic ToHit Bonus for some wands.
				m_pClientList[iClientH]->m_iMagicHitRatio_ItemEffect += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;	
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE: // PA for some weapons
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
				// TYpe of special weapon, Duration of the effect
				m_pClientList[iClientH]->m_iSpecialAbilityType    = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1; 
				m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;
				// SNOOPY: put this here for Xelima / IceElemental Bows
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);	
				
				if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
				break;
			}
			break;

		case DEF_ITEMEFFECTTYPE_ADDEFFECT:
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:	// MR
				m_pClientList[iClientH]->m_iAddResistMagic += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				// Merien Upgraded items
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAddResistMagic += (iTemp*10);				
				break;

			case 2:	// MS
				m_pClientList[iClientH]->m_iManaSaveRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				// Merien Upgraded items
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iManaSaveRatio += iTemp;								
				// MS max = 80%
				if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
				break;

			case 3:	// Adds physical damage 
				m_pClientList[iClientH]->m_iAddPhysicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				// Merien Upgraded items
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAddPhysicalDamage += iTemp;					
				break;

			case 4:	// Rings Defence Ratio 
				m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				
				// Merien Upgraded items
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDefenseRatio += (iTemp*5);								
				break;

			case 5:	// Lucky Gold Ring
				// SNOOPY: changed to use m_sItemEffectValue2 as Lucky % value
				//         and cumulative betxeen items
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 > 0)
					 m_pClientList[iClientH]->m_bIsLuckyEffect += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				else m_pClientList[iClientH]->m_bIsLuckyEffect += 10;
				// Merien Upgraded items
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_bIsLuckyEffect += (iTemp*10);
				break;

			case 6:	// Add Magic Damage. 
				m_pClientList[iClientH]->m_iAddMagicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAddMagicalDamage += iTemp;					
				break;

			case 7: // Lightning protection
				m_pClientList[iClientH]->m_iAddAbsAir		+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2; 
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (m_pClientList[iClientH]->m_iAddAbsAir >=0)		m_pClientList[iClientH]->m_iAddAbsAir		+= (iTemp*5);						
				else												m_pClientList[iClientH]->m_iAddAbsAir		-= (iTemp*5);
				break;
			case 8: // Earth Protection
				m_pClientList[iClientH]->m_iAddAbsEarth		+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2; 
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;					
				if (m_pClientList[iClientH]->m_iAddAbsEarth >=0)	m_pClientList[iClientH]->m_iAddAbsEarth		+= (iTemp*5);						
				else												m_pClientList[iClientH]->m_iAddAbsEarth		-= (iTemp*5);				
				break;
			case 9: // Fire Protection
				m_pClientList[iClientH]->m_iAddAbsFire		+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (m_pClientList[iClientH]->m_iAddAbsFire >=0)		m_pClientList[iClientH]->m_iAddAbsFire		+= (iTemp*5);						
				else												m_pClientList[iClientH]->m_iAddAbsFire		-= (iTemp*5);
				break;
			case 10: // Ice Protection
				m_pClientList[iClientH]->m_iAddAbsWater		+= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (m_pClientList[iClientH]->m_iAddAbsWater >=0)	m_pClientList[iClientH]->m_iAddAbsWater		+= (iTemp*5);						
				else												m_pClientList[iClientH]->m_iAddAbsWater		-= (iTemp*5);		
				break;

			case 11: // Poison protection
				m_pClientList[iClientH]->m_iAddPR += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAddPR += (iTemp*10);				
				break;

			case 12: // Adds To Hit Bonus
				m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iHitRatio += (iTemp*5);	
				break;

			case 13: // Magin Ruby  Characters Hp recovery rate(% applied) added by the purity formula.
				m_pClientList[iClientH]->m_iAddHP += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 /5);
				break;

			case 14: // Magin Diamond Attack probability(physical&magic) added by the purity formula.
				m_pClientList[iClientH]->m_iAddAR += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 /5);
				break;

			case 15: // Magin Emerald Magical damage decreased(% applied) by the purity formula.    
				m_pClientList[iClientH]->m_iAddMagicalDamage += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 /10);
				break;

/*Functions rates confirm.
Magic Diamond: Completion rate / 5 = Functions rate. ? Maximum 20. (not%)
Magic Ruby: Completion rate / 5 = Functions rate.(%) ? Maximum 20%.
Magic Emerald: Completion rate / 10 = Functions rate.(%) ? Maximum 10%.
Magic Sapphire: Completion rate / 10 = Functions rate.(%) ? Maximum 10%.*/

			// ******* Angel Code - Begin ******* //   
			case 16: // Angel STR//AngelicPandent(STR)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicStr = iTemp +1;
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 1, iTemp);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
				break;
			case 17: // Angel DEX //AngelicPandent(DEX)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicDex = iTemp +1;
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 2, iTemp);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
				break;
			case 18: // Angel INT//AngelicPandent(INT)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicInt = iTemp +1;
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 3, iTemp);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
				break;
			case 19: // Angel MAG//AngelicPandent(MAG)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicMag = iTemp +1;
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 4, iTemp);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
				break;
			}
			if (cEquipPos == DEF_EQUIPPOS_BACK)
			{	// Snoopy Special effect capes/ mantles still have small DefRatio & PA
				m_pClientList[iClientH]->m_iDefenseRatio += 3;	// Standard DR
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BACK] ++;
				// Merien Upgraded diverse (capes?)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (iTemp !=0)
				{	m_pClientList[iClientH]->m_iDefenseRatio += (iTemp*5);
					m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BACK]  += iTemp;
			}	}
			break;
			
		case DEF_ITEMEFFECTTYPE_ATTACK_ARROW:
			if (   (m_pClientList[iClientH]->m_cArrowIndex != -1) 
				&& (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cArrowIndex] == NULL) ) 			
			{	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);	// ArrowIndex
			}else if (m_pClientList[iClientH]->m_cArrowIndex == -1) 
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
			
			if (m_pClientList[iClientH]->m_cArrowIndex == -1) 
			{	m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = 0;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = 0;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = 0;
				m_pClientList[iClientH]->m_cAttackBonus_L      = 0;
			}else 				
			{	m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
				m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;
			}
			// Xelima Upgraded bows
			iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
			m_pClientList[iClientH]->m_cAttackBonus_SM += iTemp;
			m_pClientList[iClientH]->m_cAttackBonus_L += iTemp;
			
			// Standard HitRatio uses Skill 
			m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]; 
			// iHitRatio3 discards skill
			// SNOOPY: Added support for enchanted bows. (1st stat)
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				switch (dwSWEType) {
				case 2:  // Poison			-> Increase effect of 1st item, or replace a different effect					
					break;
				case 1:  // Crit +			-> Increase effect of 1st item, or replace a different effect
				case 10: // CP (as wand)	-> Increase effect of 1st item, or replace a different effect
					if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == dwSWEType)
					{	m_pClientList[iClientH]->m_iSpecialWeaponEffectValue += dwSWEValue;
					}else 
					{	m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = dwSWEType;
						m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = dwSWEValue;	
					}
					break;
				case 7:  // Sharp
					m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
					m_pClientList[iClientH]->m_cAttackDiceRange_L++;
					break;
				case 9:  // Ancient
					m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
					m_pClientList[iClientH]->m_cAttackDiceRange_L  += 2;
					break;
				case 11: // ManaConv 
					m_pClientList[iClientH]->m_iAddTransMana += dwSWEValue;	// SNOOPY changed to 20 as for Crit increase
					if (m_pClientList[iClientH]->m_iAddTransMana > 20) m_pClientList[iClientH]->m_iAddTransMana = 20;
					break;
				case 12: // Crit Increase 
					m_pClientList[iClientH]->m_iAddChargeCritical += dwSWEValue;
					if (m_pClientList[iClientH]->m_iAddChargeCritical > 20) m_pClientList[iClientH]->m_iAddChargeCritical = 20;
					break;
				case 4:  // Magic-using weapons, don't overide a main weapon
										
					break;
				default: // All others
					m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = (int)dwSWEType;
					m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = (int)dwSWEValue;	
					break;
				}
			}

			// SNOOPY: Added support for enchanted bows. (2nd stat)
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;				
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break;
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break; // adds Hit Proba
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break;
				case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; break;
				case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; break;
				case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; break; 
				case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; break;
				case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[cEquipPos] += (int)dwSWEValue*3; break;
				case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3; 
					if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80;
					break;
				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break;
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break;
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break;
				}
			}
			break;
			
		case DEF_ITEMEFFECTTYPE_DEFENSE: // Notice that MainGauche is here as well .....			
		case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
			// SNOOPY: 2 values for Defence ratio fot PvP mode HIGH
			m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
			

			// Merien Upgraded armors, add DefRatio for all defence items
			iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
			m_pClientList[iClientH]->m_iDefenseRatio += (iTemp*5);

			// Manufs armors 
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != NULL) 
			{	m_pClientList[iClientH]->m_iCustomItemValue_Defense += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				dV2 = (double)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				dV3 = (double)m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
				dV1 = (double)(dV2 / 100.0f)*dV3;					
				dV1 = dV1 / 2.0f;
				m_pClientList[iClientH]->m_iDefenseRatio += (int)dV1;
				if (m_pClientList[iClientH]->m_iDefenseRatio <= 0) m_pClientList[iClientH]->m_iDefenseRatio = 1;
			}

			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				switch (dwSWEType) {
				case 1:  // Crit +			-> May increase effect of 1st item or give effect if no other effect present
				case 2:  // Poison			-> May Increase effect of 1st item or give effect if no other effect present
				case 10: // CP (as wand)	-> May Increase effect of 1st item or give effect if no other effect present				
					if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == dwSWEType)
					{	m_pClientList[iClientH]->m_iSpecialWeaponEffectValue += dwSWEValue;
					}else  
						if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == 0)
						{	m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = dwSWEType;
							m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = dwSWEValue;	
						}
					break;
				case 3: // Rite -> Give effect if no other effect present	
					if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == 0)
					{	m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = dwSWEType;
						m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = dwSWEValue;	
					} 
					break;
				case 7: // Sharp MG have effect in iCalculatteAttackEffect function
				case 9: // Ancient MG have effect in iCalculatteAttackEffect function
					break;				
				case 11: // ManaConv  Total max 20
					m_pClientList[iClientH]->m_iAddTransMana += dwSWEValue;	// SNOOPY changed to 20 as for Crit increase
					if (m_pClientList[iClientH]->m_iAddTransMana > 20) m_pClientList[iClientH]->m_iAddTransMana = 20;
					break;
				case 12: // Crit Increase Total max 20
					m_pClientList[iClientH]->m_iAddChargeCritical += dwSWEValue;
					if (m_pClientList[iClientH]->m_iAddChargeCritical > 20) m_pClientList[iClientH]->m_iAddChargeCritical = 20;
					break;
				case 4: // ???
					break;
				default:
					break;
				}
			}
			// stated armors/shields
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) 
			{	dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;				
				// HP or Rep+ will have effect on Armor or MainGauche !
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break;
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break; // Armes Hit Proba
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break;
				case 4:  // HPrec
					if (cEquipPos == DEF_EQUIPPOS_LHAND) 
						iShieldHPrec += (int)dwSWEValue*7; 
					else m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; 					
					break;
				case 5:  // SPrec
					if (cEquipPos == DEF_EQUIPPOS_LHAND) 
						iShieldSPrec += (int)dwSWEValue*7; 
					else m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; 
					break;
				case 6:   // MPrec
					if (cEquipPos == DEF_EQUIPPOS_LHAND) 
						iShieldMPrec += (int)dwSWEValue*7; 
					else m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; 
					break;  
				case 7:  
					m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; 
					break;
				case 8: // PA
					if (cEquipPos == DEF_EQUIPPOS_LHAND) 
						 m_pClientList[iClientH]->m_iDamageAbsorption_Shield += (int)dwSWEValue*3; 
					else m_pClientList[iClientH]->m_iDamageAbsorption_Armor[cEquipPos] += (int)dwSWEValue*3;
					break;
				case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3; break;
				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break;
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break;
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break;
				}
				switch (dwSWEType) {
				case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; break; //     80%
				}
			}
			switch ( cEquipPos ) { // Sub-cases of DEF_ITEMEFFECTTYPE_DEFENSE
			case DEF_EQUIPPOS_LHAND:
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 != 0)
				{	m_pClientList[iClientH]->m_iDamageAbsorption_Shield	= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				}else // Snoopy individual PA setting for shields...
				{	m_pClientList[iClientH]->m_iDamageAbsorption_Shield	= (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) - (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1)/3;
				}
				// Merien Upgraded shield +1 PA
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDamageAbsorption_Shield += iTemp;				
				
				break;
			case DEF_EQUIPPOS_TWOHAND:
				
			case DEF_EQUIPPOS_RHAND:
				
				break;
			case DEF_EQUIPPOS_HEAD:	// PA on Head
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				// Merien Upgraded helmet +1 PA
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD]  += iTemp;				
				break;
			case DEF_EQUIPPOS_BODY:
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				// Merien Upgraded armor +1 PA
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]  += iTemp;				
				switch ( m_pClientList[iClientH]->m_cSex ) {
				case 1: // Male  1:Leather, 5:Tunic
					switch(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue){
					case 1:  // Leather
						m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] = m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]/2;
											
						break;
					case 5:  // Tunic
						m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] = m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]/2;
						break;
					case 2:  // Chain
					case 3:  // Scale
						
						break;
					case 6: //  Robe(M)
					case 10: // eHeroRobe(M)
					case 11: // aHeroRobe(M) // Some all places PA with robes
						m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] = m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]/2;
						
						break;
					case 4: // Plate
					default:	// plate +				
						
						break;		
					}
					break;
				case 2: // Women 1,2:Bodice, 3:Leather
					switch(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue){
					case 1:  // Bodice
					case 2:  // Bodice
						m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] = m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]/2;
						break;
					case 3:  // Leather
						m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] = m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]/2;
						
						break;
					case 4:  // Chain
					case 5:  // Scale
						break;
					case 7: //  Robe(M)
					case 11: // eHeroRobe(M)
					case 12: // aHeroRobe(M) // Some all places PA with robes
						m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] = m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]/2;	
						break;
					case 6: // Plate
					default:					
						
						break;		
					}
					break;
				}	
				break;
			case DEF_EQUIPPOS_ARMS:
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				// Merien Upgraded hauberks +1 PA
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS]  += iTemp;				
				switch ( m_pClientList[iClientH]->m_cSex ) {
				case 1: // Male  1:Chemise 2:Hauberk
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue >1) 
					{ 	 	
					}else // PA for clothes vs hammers
					{	m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] = m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS]/2;
					}
					break;
				case 2: // Women 1,2:Chemise Shirt, 3:Hauberk
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue >2)  
					{ 	 	
					}else // PA for clothes vs hammers
					{	m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL] = m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS]/2;
					}
					break;	
				}
				break;
			case DEF_EQUIPPOS_PANTS:
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				// Merien Upgraded leggings +1 PA
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS]  += iTemp;	
				break;
			case DEF_EQUIPPOS_LEGGINGS:
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				// Merien Upgraded boots +1 PA
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]  += iTemp;				
				// Motemorphosed char is still affected by original boots
				m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
				break;
			case DEF_EQUIPPOS_BACK: // Cape
				// Motemorphosed char is still affected by original cape
				m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
				break;

			default:
				// SNOOPY: Kept this here so we can use Damage absorbtion for something else (ie: Cape)
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[cEquipPos] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				// Merien Upgraded diverse (capes?)
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[cEquipPos]  += iTemp;				
				break;
			}

			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
				m_pClientList[iClientH]->m_iSpecialAbilityType = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1; 
				m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;
				if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
				break;
			}
			break;
		}
	}

	//v1.432
	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) && (bNotify == TRUE)) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 4, NULL, NULL, NULL);
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) 
		{	m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = FALSE;
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	}	}	
	if (   (iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType != 0) 
		&& (iPrevSAType != m_pClientList[iClientH]->m_iSpecialAbilityType) && (bNotify == TRUE)) 
	{	if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) 
		{	SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL); // 20min
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = FALSE;
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	}	}

	// Snoopy! Limitation of HPrec, MPrec SPrec.100% max not counting shield			
	if (m_pClientList[iClientH]->m_iAddHP > 100 ) m_pClientList[iClientH]->m_iAddHP = 100;
	if (m_pClientList[iClientH]->m_iAddSP > 100 ) m_pClientList[iClientH]->m_iAddSP = 100;
	if (m_pClientList[iClientH]->m_iAddMP > 100 ) m_pClientList[iClientH]->m_iAddMP = 100;
	m_pClientList[iClientH]->m_iAddHP += iShieldHPrec;					
	m_pClientList[iClientH]->m_iAddSP += iShieldSPrec;
	m_pClientList[iClientH]->m_iAddMP += iShieldMPrec;
	m_pClientList[iClientH]->m_cHeroArmourBonus = _cCheckHeroItemEquipped(iClientH);

	// Snoopy: Bonus for Angels	
	m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_iAngelicDex * 2;

	if (m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH, FALSE);
	if (m_pClientList[iClientH]->m_iMP > iGetMaxMP(iClientH)) m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
	if (m_pClientList[iClientH]->m_iSP > iGetMaxSP(iClientH)) m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);

	// Maximum value for  PA, here instead of iCalculateAttackEffect
	if (m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]  > 60)	// Torse,  max 60
		m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY]  = 60;
	if (m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD]  > 60)	// Tte    max 60
		m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD]  = 60;
	if (m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS]  > 60)	// Membres max 60
		m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS]  = 60;
	if (m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] > 60)	// Membres max 60 
		m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] = 60;
	if (m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]  > 60)	// Pieds   max 60 
		m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]  = 60;
	if (m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BACK]  > 60)	// Dos     max 60
		m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BACK]  = 60;
	if (m_pClientList[iClientH]->m_iDamageAbsorption_Shield > 60)						// Shield  max 60
		m_pClientList[iClientH]->m_iDamageAbsorption_Shield = 60;

	// Ne dire aux clients que si ca a chang.
	if (iTotalAngelicstatas != (m_pClientList[iClientH]->m_iAngelicStr + (16 * m_pClientList[iClientH]->m_iAngelicInt)
		+ (256 * m_pClientList[iClientH]->m_iAngelicDex) + (16*256 * m_pClientList[iClientH]->m_iAngelicMag)))
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
	}
}

/*********************************************************************************************************************
** BOOL CGame::SetAngelFlag(short sOwnerH, char cOwnerType, int iStatus, iTemp)  Snoopy								** 
** description   :: Sets the staus to send or not Angels to every client											**
*********************************************************************************************************************/
void CGame::SetAngelFlag(short sOwnerH, char cOwnerType, int iStatus, int iTemp) 
{	if (cOwnerType != DEF_OWNERTYPE_PLAYER) return;
	if (m_pClientList[sOwnerH] == NULL) return;
	switch (iStatus) {
	case 1: // STR Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00001000;  
		break;
	case 2: // DEX Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00002000;
		break;
	case 3: // INT Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00004000;
		break;
	case 4: // MAG Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00008000;
		break;
	default:// Remove all Angels
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFF00FF;
		break;
	}
	if (iTemp > 4)
	{	m_pClientList[ sOwnerH ]->m_iStatus = m_pClientList[ sOwnerH ]->m_iStatus | (((iTemp/3)*(iTemp/5)) << 8);  // THe forum refuses the real C++ code !
	}
	SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}
/*********************************************************************************************************************
** BOOL CGame::GetAngelHandler(int iClientH, char * pData, DWORD dwMsgSize)											** 
** description   :: Reversed and coded by Snoopy																	**
*********************************************************************************************************************/
void CGame::GetAngelHandler(int iClientH, char * pData, DWORD dwMsgSize)
{char  *cp, cData[256], cTmpName[21];
 int   iAngel, iItemNbe;
 class CItem * pItem;
 int   iRet, iEraseReq;
 short * sp;
 WORD  * wp;
 int   * ip;
 DWORD * dwp;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (_iGetItemSpaceLeft(iClientH) == 0) 
	{	SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
		return;
	}
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	cp += 20;
	ip = (int *)cp;
	iAngel = (int) *ip; // 0x00 l a i
	cp += 2;
	wsprintf(G_cTxt, "PC(%s) obtained an Angel (%d).   %s(%d %d)"
		, m_pClientList[iClientH]->m_cCharName
		, iAngel
		, m_pClientList[iClientH]->m_cMapName
		, m_pClientList[iClientH]->m_sX
		, m_pClientList[iClientH]->m_sY); 
	PutLogList(G_cTxt); 
	switch (iAngel) {
	case 1: // STR
		iItemNbe = 908;
		break;
	case 2: // DEX
		iItemNbe = 909;
		break;
	case 3: // INT
		iItemNbe = 910;
		break;
	case 4: // MAG
		iItemNbe = 911;
		break;
	default:
		PutLogList("Gail asked to create a wrong item!"); 
		break;
	}
	pItem = NULL;
	pItem = new class CItem;
	if (pItem == NULL) return;
	if ((_bInitItemAttr(pItem, iItemNbe) == TRUE)) 
	{	pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
		{	ZeroMemory(cData, sizeof(cData));
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;    
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);    
			*cp = 1;
			cp++;    
			memcpy(cp, pItem->m_cName, 20);
			cp += 20;    
			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;    
			*cp = pItem->m_cItemType;
			cp++;    
			*cp = pItem->m_cEquipPos;
			cp++;    
			*cp = (char)0; 
			cp++;    
			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;    
			*cp = pItem->m_cGenderLimit;
			cp++;    
			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;    
			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;    
			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;    
			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;
			*cp = pItem->m_cItemColor;
			cp++;
			*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
			cp++;    
			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;
			if (iEraseReq == 1) delete pItem;    
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}
		}else 
		{	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);   
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4   
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;    
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
		}	}
	}else 
	{	delete pItem;
		pItem = NULL;
}	}

int CGame::_iGetPlayerNumberOnSpot(short dX, short dY, char cMapIndex, char cRange)
{
 int ix, iy, iSum = 0;
 short sOwnerH;
 char  cOwnerType;

	for (ix = dX - cRange; ix <= dX + cRange; ix++)
	for (iy = dY - cRange; iy <= dY + cRange; iy++) {
		m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER))
			iSum++;
	}

	return iSum;
}

BOOL CGame::bAnalyzeCriminalAction(int iClientH, short dX, short dY, BOOL bIsCheck)
{
 int   iNamingValue, tX, tY;
 short sOwnerH;
 char  cOwnerType, cName[11], cNpcName[21];
 char  cNpcWaypoint[11];

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return FALSE;
	if (m_bIsCrusadeMode == TRUE) return FALSE;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

	if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL)) {
		if (_bGetIsPlayerHostile(iClientH, sOwnerH) != TRUE) {
			if (bIsCheck == TRUE) return TRUE;

			ZeroMemory(cNpcName, sizeof(cNpcName));
			if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0) 
				strcpy(cNpcName, "Guard-Aresden");			
			else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0) 
				strcpy(cNpcName, "Guard-Elvine");
			else  if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0) 
				strcpy(cNpcName, "Guard-Neutral");

			iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {

			}
			else {
				ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
				ZeroMemory(cName, sizeof(cName));
			   	wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
				
				tX = (int)m_pClientList[iClientH]->m_sX;
				tY = (int)m_pClientList[iClientH]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					bSetNpcAttackMode(cName, iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
				}
			}
		}
	}
	return FALSE;
}

BOOL CGame::_bGetIsPlayerHostile(int iClientH, int sOwnerH)
{
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[sOwnerH]  == NULL) return FALSE;

	//        . 
	if (iClientH == sOwnerH) return TRUE;

	if (m_pClientList[iClientH]->m_cSide == 0) {
		//  .
		//      . 
		if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			 return TRUE;
		else return FALSE;
	}
	else {
		//     . 
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) {
			//   . 
			if (m_pClientList[sOwnerH]->m_cSide == 0) {
				if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
				 	 return TRUE;
				else return FALSE;
			}
			else return TRUE;
		}
		else {
			if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			 	 return TRUE;
			else return FALSE;
		}
	}

	return FALSE;
}

void CGame::bSetNpcAttackMode(char * cName, int iTargetH, char cTargetType, BOOL bIsPermAttack)
{
 int i, iIndex;
	
	for (i = 1; i < DEF_MAXNPCS; i++)
	if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, cName, 5) == 0) ) {
		iIndex = i;
		goto NEXT_STEP_SNAM1;

	}
	//    NPC .
	return;

NEXT_STEP_SNAM1:;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == NULL) return;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iTargetH] == NULL) return;
		break;
	}

	//  . 
	m_pNpcList[iIndex]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
	m_pNpcList[iIndex]->m_sBehaviorTurnCount = 0;		
	m_pNpcList[iIndex]->m_iTargetIndex = iTargetH;
	m_pNpcList[iIndex]->m_cTargetType  = cTargetType;

	//      
	m_pNpcList[iIndex]->m_bIsPermAttackMode = bIsPermAttack;

}


void CGame::PoisonEffect(int iClientH, int iV1)
{
 int iPoisonLevel, iDamage, iPrevHP, iProb;

	//   .      1 . 
	if (m_pClientList[iClientH] == NULL)     return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	iPoisonLevel = m_pClientList[iClientH]->m_iPoisonLevel;

	iDamage = iDice(1, iPoisonLevel);
	
	iPrevHP = m_pClientList[iClientH]->m_iHP;
	m_pClientList[iClientH]->m_iHP -= iDamage;
	if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 1;

	if (iPrevHP != m_pClientList[iClientH]->m_iHP)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
		

	//       .
	iProb = m_pClientList[iClientH]->m_cSkillMastery[23] -10 +m_pClientList[iClientH]->m_iAddPR;
	if (iProb <= 10) iProb = 10;
	if (iDice(1,100) <= iProb) {
		m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
		//   . 
		SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE); // remove poison aura after effect complete
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
	}
}
BOOL CGame::bCheckResistingPoisonSuccess(short sOwnerH, char cOwnerType)
{
 int iResist, iResult;
	
	//    . 
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return FALSE;
		iResist = m_pClientList[sOwnerH]->m_cSkillMastery[23] +m_pClientList[sOwnerH]->m_iAddPR;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return FALSE;
		iResist = 0;
		break;
	}

	iResult = iDice(1, 100);
  	if (iResult >= iResist) //   . .
		return FALSE;

	//   .   . 
	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sOwnerH, 23, 1);

	return TRUE;
}

BOOL CGame::bCheckBadWord(char * pString)
{
 char * cp;

	//     . 
	cp = pString;
	while (*cp != NULL) {
		
		cp++;
	}

	return FALSE;
}

void CGame::CheckDayOrNightMode()
{
 SYSTEMTIME SysTime;	
 int cPrevMode;
 int  i;

	//       . 
	// ,    
	cPrevMode = m_cDayOrNight;
 
	GetLocalTime(&SysTime);
	if (SysTime.wHour >= 20 || SysTime.wHour <= 5)
		 m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	if (cPrevMode != m_cDayOrNight) {
		// ,   . ,        . 
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			if ((m_pClientList[i]->m_cMapIndex >= 0) && 
				(m_pMapList[m_pClientList[i]->m_cMapIndex] != NULL) &&
				(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == FALSE))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_TIMECHANGE, m_cDayOrNight, NULL, NULL, NULL);	
		}
	}
}


void CGame::ShutUpPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 int i, iTime;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelShutup) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token       
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		//     . 
		token = pStrTok->pGet();
		if (token == NULL) 
			 iTime = 0;
		else iTime = atoi(token);
	
		if (iTime < 0) iTime = 0;
	 		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			
			m_pClientList[i]->m_iTimeLeft_ShutUp = iTime * 20; // 1 3. 20 1 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERSHUTUP, iTime, NULL, NULL, cName);
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, iTime, NULL, NULL, cName);

			// Admin Log
			wsprintf(G_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min", m_pClientList[iClientH]->m_cCharName, 
				     m_pClientList[i]->m_cCharName, iTime);
			PutAdminLogFileList(G_cTxt);

			delete pStrTok;
			return;
		}
		//   .
		ZeroMemory(cBuff, sizeof(cBuff));

		char *cp;
		WORD *wp;

		cp = (char *)cBuff;

		*cp = GSM_REQUEST_SHUTUPPLAYER;
		cp++;

		wp = (WORD *)cp;
		*wp = m_wServerID_GSS;
		cp += 2;

		wp = (WORD *)cp;
		*wp = (WORD)iClientH;
		cp += 2;

		memcpy(cp, cName, 10);
		cp += 10;

		wp = (WORD *)cp;
		*wp = iTime;
		cp += 2;

		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;

		bStockMsgToGateServer(cBuff, 27);
	}

	delete pStrTok;
	return;
}


void CGame::SetPlayerReputation(int iClientH, char * pMsg, char cValue, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iLevel < 40) return;

	if ((m_pClientList[iClientH]->m_iTimeLeft_Rating != 0) || (m_pClientList[iClientH]->m_iPKCount != 0)) {
		//          .    .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTRATING, m_pClientList[iClientH]->m_iTimeLeft_Rating, NULL, NULL, NULL);
		return;
	}
	else if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
		//        .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTRATING, 0, NULL, NULL, NULL);
		return;	
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token      
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			
			if (i != iClientH) {
				if(memcmp(m_pClientList[iClientH]->m_cIPaddress,  m_pClientList[i]->m_cIPaddress,  strlen(m_pClientList[iClientH]->m_cIPaddress)) == 0)
                {
                    ShowClientMsg(iClientH, "You can't send rep to a player with your same IP.");
                }
                else
                {
					//     .
					if (cValue == 0) 
						m_pClientList[i]->m_iRating--;
					else if (cValue == 1)
						m_pClientList[i]->m_iRating++;
					
					//      . 
					m_pClientList[iClientH]->m_iTimeLeft_Rating = 20*60;

					SendNotifyMsg(NULL, i, DEF_NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);

					SendNotifyMsg(NULL, i, DEF_NOTIFY_REPDGDEATHS, m_pClientList[i]->m_iDGPoints, m_pClientList[i]->m_iDeaths, m_pClientList[i]->m_iRating, NULL); // MORLA 2.4 - Actualiza la REP
					
					delete pStrTok;
					return;
				}
			}
		}
		//   .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}
	
	delete pStrTok;
	return;
}

BOOL CGame::bReadNotifyMsgListFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "=\t\n;";
 class CStrTok * pStrTok;
 int   i;

	cReadMode = 0;
	m_iTotalNoticeMsg = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		PutLogList("(!) Notify Message list file not found!...");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Notify Message list file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					for (i = 0; i < DEF_MAXNOTIFYMSGS; i++) 
					if (m_pNoticeMsgList[i] == NULL) {
						m_pNoticeMsgList[i] = new class CMsg;	
						m_pNoticeMsgList[i]->bPut(NULL, token, strlen(token), NULL, NULL);
						m_iTotalNoticeMsg++;
						goto LNML_NEXTSTEP1;
					}
LNML_NEXTSTEP1:;					
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "notify_msg", 10) == 0) cReadMode = 1;
			}
			
			token = pStrTok->pGet();
			
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}
void CGame::NoticeHandler()
{
 char  cTemp, cBuffer[1000], cKey;
 DWORD dwSize, dwTime = timeGetTime();
 int i, iMsgIndex, iTemp;

	//  1    .
	if (m_iTotalNoticeMsg <= 1) return;

	if ((dwTime - m_dwNoticeTime) > DEF_NOTICETIME) {
		//    . 
		m_dwNoticeTime = dwTime;	
		do {
			iMsgIndex = iDice(1, m_iTotalNoticeMsg) - 1;
		} while (iMsgIndex == m_iPrevSendNoticeMsg);

		m_iPrevSendNoticeMsg = iMsgIndex;
		
		ZeroMemory(cBuffer, sizeof(cBuffer));
		if (m_pNoticeMsgList[iMsgIndex] != NULL) {
			m_pNoticeMsgList[iMsgIndex]->Get(&cTemp, cBuffer, &dwSize, &iTemp, &cKey);
		}
		
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, cBuffer);
		}
	}
}


void CGame::ResponseSavePlayerDataReplyHandler(char * pData, DWORD dwMsgSize)
{
 char * cp, cCharName[11];
 int i;

	ZeroMemory(cCharName, sizeof(cCharName));
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);

	//           . 
	for (i = 0; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
			//     .    .
			SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERCHANGE, NULL, NULL, NULL, NULL);
		}
	}
}

void CGame::CalcExpStock(int iClientH)
{
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iExpStock <= 0) return;
	
	//          .
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) {
		m_pClientList[iClientH]->m_iExpStock = 0;
		return;
	}

	//     . 
	m_pClientList[iClientH]->m_iExp += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iAutoExpAmount += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iExpStock = 0;

	if (bCheckLimitedUser(iClientH) == FALSE) {
		//         .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	}

	if (bCheckLevelUp(iClientH)) {
		if (m_pClientList[iClientH]->m_iLevel <= 5) 
		{	pItem = new class CItem;
			if (_bInitItemAttr(pItem, "Gold") == FALSE) 
			{	delete pItem;	return;
			}else pItem->m_dwCount = (DWORD)100;
			bAddItem(iClientH, pItem, NULL);
		}
		if ((m_pClientList[iClientH]->m_iLevel > 5 ) &&  (m_pClientList[iClientH]->m_iLevel <= 20)) {
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, "Gold") == FALSE) 
			{	delete pItem;	return;
			}
			else pItem->m_dwCount = (DWORD)300;
			bAddItem(iClientH, pItem, NULL);
		}
	}
}


long CGame::iGetExpLevel(unsigned long iExp)
{
 int i;

	//      .
	for (i = 1; i < 1001; i++) 
	if ((m_iLevelExpTable[i] <= iExp) && (m_iLevelExpTable[i+1] > iExp)) return i;

	return 0;
}

void CGame::AdminOrder_CallGuard(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
 class  CStrTok * pStrTok;
 int i, iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCallGaurd) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token       
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
	 		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			//   . 	
			
			if (memcmp(m_pClientList[i]->m_cMapName, "aresden", 7) == 0) 
				strcpy(cNpcName, "Guard-Aresden");			
			else if (memcmp(m_pClientList[i]->m_cMapName, "elvine", 6) == 0) 
				strcpy(cNpcName, "Guard-Elvine");
			else strcpy(cNpcName, "Guard-Neutral");  // <-      .
			
			iNamingValue = m_pMapList[ m_pClientList[i]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				//    NPC  .     .
			}
			else {
				// NPC .
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[i]->m_cMapIndex+65;
				
				tX = (int)m_pClientList[i]->m_sX;
				tY = (int)m_pClientList[i]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[i]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
					//   NameValue .
					m_pMapList[ m_pClientList[i]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					//  .   .
					bSetNpcAttackMode(cName, i, DEF_OWNERTYPE_PLAYER, TRUE);
				}
			}

			delete pStrTok;
			return;
		}

		//   .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
}

void CGame::AdminOrder_SummonDemon(int iClientH)
{
 char cName[21], cNpcName[21], cNpcWaypoint[11];	
 int iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonDemon) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		//    NPC  .     .
	}
	else {
		// NPC .
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, "Demon");	
		
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)m_pClientList[iClientH]->m_sX;
		tY = (int)m_pClientList[iClientH]->m_sY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
			//   NameValue .
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		} 
		else {
			// Admin Log
			wsprintf(G_cTxt, "Admin Order(%s): Summon Demon", m_pClientList[iClientH]->m_cCharName);
			PutAdminLogFileList(G_cTxt);
		}
	}

}

// v1.4311-3    .
void CGame::AdminOrder_ReserveFightzone(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256];
 class  CStrTok * pStrTok;
 int iNum ;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;


	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelReserveFightzone) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if( m_iFightzoneNoForceRecall == 0 ) {
		m_iFightzoneNoForceRecall = 1 ; 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -5, NULL, NULL, NULL);
	} else {
		m_iFightzoneNoForceRecall = 0 ; 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -4, NULL, NULL, NULL);
	}

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	iNum = atoi(token) - 1;
			
	if ( m_iFightZoneReserve[iNum] != -1) {
		// Admin Log
		wsprintf(G_cTxt, "Admin Order(%s):  %d FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		PutAdminLogFileList(G_cTxt);
		
		m_iFightZoneReserve[iNum] = - 1 ;        //    -1  .
												 //      .
		//      
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, iNum+1, NULL, NULL, NULL);
		
	}  else {	//       .
		wsprintf(G_cTxt, "Admin Order(%s):  %d Cancel FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		PutAdminLogFileList(G_cTxt);

		m_iFightZoneReserve[iNum] = 0 ;       
		//            -3  .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -3, NULL, NULL, NULL);

	}
		
	return;
}


void CGame::AdminOrder_CloseConn(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGMCloseconn) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) {
		// token       
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			//   .   .	
			if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
				// v1.22       .
				DeleteClient(i, TRUE, TRUE, TRUE, TRUE);
			}

			// Admin Log
			wsprintf(G_cTxt, "Admin Order(%s): Close Conn", m_pClientList[iClientH]->m_cCharName);
			PutAdminLogFileList(G_cTxt);

			delete pStrTok;
			return;
		}
		//   .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
}



// v1.4311-3        void CGame::UserCommand_BanGuildsman
void CGame::UserCommand_BanGuildsman(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iGuildRank != 0 ) {
		//       .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOGUILDMASTERLEVEL, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token    
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) ) {
			//   .    . 

			if (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[i]->m_cGuildName, 20) != 0)  {
				//     .
				
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTBANGUILDMAN, NULL, NULL, NULL, NULL);
				delete pStrTok;
				return;
			}
			//       .
			bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);
		
			//     .
			SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);
	
			//    .
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1; 
			m_pClientList[i]->m_iGuildGUID = -1;

			//        .
		    SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SUCCESSBANGUILDMAN, NULL, NULL, NULL, NULL);
			
			//       .
			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_BANGUILD, NULL, NULL, NULL, NULL);
		
			//     . 
			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		
			delete pStrTok;
			return;
		}
		//   .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
}




int CGame::iCreateFish(char cMapIndex, short sX, short sY, short sType, class CItem * pItem, int iDifficulty, DWORD dwLastTime)
{
 int i, iDynamicHandle;

	//    . 
	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return NULL;
	if (m_pMapList[cMapIndex] == NULL) return NULL;
	if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE) return NULL;

	for (i = 1; i < DEF_MAXFISHS; i++) 
	if (m_pFish[i] == NULL) {
		//    .
		m_pFish[i] = new class CFish(cMapIndex, sX, sY, sType, pItem, iDifficulty);
		if (m_pFish[i] == NULL) return NULL;
 		
		// Dynamic Object . Owner Fish  .
		switch (pItem->m_sIDnum) {
		case 101: // 
		case 102: // 
		case 103: // 
		case 570:
		case 571:
		case 572:
		case 573:
		case 574:
		case 575:
		case 576:
		case 577:	
			iDynamicHandle = iAddDynamicObjectList(i, NULL, DEF_DYNAMICOBJECT_FISH, cMapIndex, sX, sY, dwLastTime);
			break;
		default: 
			//     
			iDynamicHandle = iAddDynamicObjectList(i, NULL, DEF_DYNAMICOBJECT_FISHOBJECT, cMapIndex, sX, sY, dwLastTime);
			break;
		}
		
		if (iDynamicHandle == NULL) {
			delete m_pFish[i];
			m_pFish[i] = NULL;
			return NULL;
		}
		m_pFish[i]->m_sDynamicObjectHandle = iDynamicHandle;
		m_pMapList[cMapIndex]->m_iCurFish++;

		return i;
	}

	return NULL;
}


BOOL CGame::bDeleteFish(int iHandle, int iDelMode)
{
 int i, iH;
 DWORD dwTime;
		
	if (m_pFish[iHandle] == NULL) return FALSE;
	
	dwTime = timeGetTime();

	//   DynamicObject .
	iH = m_pFish[iHandle]->m_sDynamicObjectHandle;
	
	if (m_pDynamicObjectList[iH] != NULL) {
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iH]->m_cMapIndex, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, m_pDynamicObjectList[iH]->m_sType, iH, NULL);
		//  .
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, dwTime);
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->m_iCurFish--;

		delete m_pDynamicObjectList[iH];
		m_pDynamicObjectList[iH] = NULL;
	}

	//          . 
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) &&
			(m_pClientList[i]->m_iAllocatedFish == iHandle)) {
			//   
			SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCANCELED, iDelMode, NULL, NULL, NULL);
			ClearSkillUsingStatus(i); // v1.4   .
 		}
	}
	
	// .
	delete m_pFish[iHandle];
	m_pFish[iHandle] = NULL;

	return TRUE;
}


int CGame::iCheckFish(int iClientH, char cMapIndex, short dX, short dY)
{
 int i;
 short sDistX, sDistY;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if ((cMapIndex < 0)	|| (cMapIndex >= DEF_MAXMAPS)) return 0;

	//         . 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] != NULL) {
		sDistX = abs(m_pDynamicObjectList[i]->m_sX - dX);
		sDistY = abs(m_pDynamicObjectList[i]->m_sY - dY);
		
		if ((m_pDynamicObjectList[i]->m_cMapIndex == cMapIndex) && 
			((m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISH) || (m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISHOBJECT)) &&
			(sDistX <= 2) && (sDistY <= 2)) {
			//    .       Fish  . 

			if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ] == NULL) return 0;
			if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount >= DEF_MAXENGAGINGFISH) return 0;

			//        .
			if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) return 0;
			if (m_pClientList[iClientH]->m_cMapIndex != cMapIndex) return 0;
			//       .
			m_pClientList[iClientH]->m_iAllocatedFish = m_pDynamicObjectList[i]->m_sOwner;
			m_pClientList[iClientH]->m_iFishChance = 1;
			//      .
			m_pClientList[iClientH]->m_bSkillUsingStatus[1] = TRUE;

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EVENTFISHMODE, (m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_wPrice/2), m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSprite,
				          m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSpriteFrame, m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_cName);

			//   
			m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount++;
			
			return i;
		}
	}

	return 0;
}

void CGame::FishProcessor()
{
 int i, iSkillLevel, iResult, iChangeValue;

	//      .
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && 
			(m_pClientList[i]->m_iAllocatedFish != NULL)) {
		
			if (m_pFish[ m_pClientList[i]->m_iAllocatedFish ] == NULL) break;	
	
			//     .     . 
			//    
			iSkillLevel  = m_pClientList[i]->m_cSkillMastery[1];
			//      . 
			iSkillLevel -= m_pFish[m_pClientList[i]->m_iAllocatedFish]->m_iDifficulty;
			if (iSkillLevel <= 0) iSkillLevel = 1;
			
			iChangeValue = iSkillLevel / 10;
			if (iChangeValue <= 0) iChangeValue = 1;
			iChangeValue = iDice(1, iChangeValue);

			iResult = iDice(1, 100);
			if (iSkillLevel > iResult)	{
				//    .   .
				m_pClientList[i]->m_iFishChance += iChangeValue;
				if (m_pClientList[i]->m_iFishChance > 99) m_pClientList[i]->m_iFishChance = 99;

				SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
			}
			else if (iSkillLevel < iResult) {
				//    .   .	
				m_pClientList[i]->m_iFishChance -= iChangeValue;
				if (m_pClientList[i]->m_iFishChance < 1) m_pClientList[i]->m_iFishChance = 1;

				SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
			}
		}
	}
}

void CGame::AdminOrder_CreateFish(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cItemName[21];
 class  CStrTok * pStrTok;
 class  CItem   * pItem;
 int tX, tY, iType;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCreateFish) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	tX = tY = iType = 0;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		tX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		tY = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		iType = atoi(token);
	}

	if ((tX != 0) && (tY != 0) && (iType != 0)) {
		//    .
		pItem = new class CItem;
		if (pItem == NULL) {
			delete pStrTok;
			return;
		}
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, "");
		if (_bInitItemAttr(pItem, cItemName) == TRUE) {
   			iCreateFish(m_pClientList[iClientH]->m_cMapIndex, tX, tY, iType, pItem, 1, 60000*20);
		}
		else delete pItem;
   	}

	delete pStrTok;
	return;
}

void CGame::AdminOrder_Teleport(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cMapName[256];
 class  CStrTok * pStrTok;
 int dX, dY;
 BOOL   bFlag;

	dX = dY = -1;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelTeleport) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dY = atoi(token);
	}

	bFlag = FALSE;
	if (strcmp("2ndmiddle", cMapName) == 0) bFlag = TRUE;
	if (strcmp("abaddon", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("arebrk11", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arebrk12", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arebrk21", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arebrk22", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arefarm", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arejail", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aremidl", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aremidr", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aresden", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aresdend1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("areuni", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arewrhus", cMapName) == 0) bFlag = TRUE;
	if (strcmp("bisle", cMapName) == 0)   bFlag = TRUE;
	if (strcmp("bsmith_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("bsmith_1f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("bsmith_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("bsmith_2f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("BtField", cMapName) == 0) bFlag = TRUE;
	if (strcmp("cath_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("cath_2", cMapName) == 0)      bFlag = TRUE;
	if (strcmp("cityhall_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("cityhall_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("CmdHall_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("CmdHall_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("default", cMapName) == 0) bFlag = TRUE;
	if (strcmp("dglv2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("dglv3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("dglv4", cMapName) == 0) bFlag = TRUE;
	if (strcmp("druncncity", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("elvbrk11", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvbrk12", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvbrk21", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvbrk22", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvfarm", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvine", cMapName) == 0)  bFlag = TRUE;
	if (strcmp("elvined1", cMapName) == 0)    bFlag = TRUE;
	if (strcmp("elvjail", cMapName) == 0)    bFlag = TRUE;
	if (strcmp("elvmidl", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvmidr", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvuni", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvwrhus", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gldhall_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gldhall_2", cMapName) == 0)   bFlag = TRUE;
	if (strcmp("GodH", cMapName) == 0)   bFlag = TRUE;
	if (strcmp("gshop_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gshop_1f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gshop_2", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("gshop_2f", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("HRampart", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("huntzone1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone4", cMapName) == 0) bFlag = TRUE;
	if (strcmp("icebound", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("inferniaA", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("inferniaB", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("maze", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("middled1n", cMapName) == 0) bFlag = TRUE;
	if (strcmp("middled1x", cMapName) == 0) bFlag = TRUE;
	if (strcmp("middleland", cMapName) == 0) bFlag = TRUE;
	if (strcmp("procella", cMapName) == 0) bFlag = TRUE;
	if (strcmp("resurr1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("resurr2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("toh1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("toh2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("toh3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wrhus_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wrhus_1f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wrhus_2", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("wrhus_2f", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wzdtwr_2", cMapName) == 0) bFlag = TRUE;

	if (bFlag == TRUE)
		RequestTeleportHandler(iClientH, "2   ", cMapName, dX, dY);
   	
	delete pStrTok;
	return;
}


void CGame::ReqGetFishThisTimeHandler(int iClientH)
{
 int iResult, iFishH;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iAllocatedFish == NULL) return;
	if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] == NULL) return;

	//    .
	m_pClientList[iClientH]->m_bSkillUsingStatus[1] = FALSE;

	iResult = iDice(1, 100);
	if (m_pClientList[iClientH]->m_iFishChance >= iResult) {
		//    !
		
		//   
		GetExp(iClientH, iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5)); //m_pClientList[iClientH]->m_iExpStock += iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5);
		//   
		CalculateSSN_SkillIndex(iClientH, 1, m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty);

		//   .
		pItem = m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem;
		m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem = NULL;

		//    .
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                       m_pClientList[iClientH]->m_sY, 
															       pItem);

		//      . 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

		//     
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
		iFishH = m_pClientList[iClientH]->m_iAllocatedFish;
		m_pClientList[iClientH]->m_iAllocatedFish = NULL;
				
		//    
		bDeleteFish(iFishH, 1); // <-      .
		return;
	}

	//  ! 
	m_pFish[ m_pClientList[iClientH]->m_iAllocatedFish ]->m_sEngagingCount--;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHFAIL, NULL, NULL, NULL, NULL);
	
	m_pClientList[iClientH]->m_iAllocatedFish = NULL;
}


void CGame::FishGenerator() 
{ 
 int i, iP, tX, tY, iRet; 
 char  cItemName[21]; 
 short sDifficulty; 
 DWORD dwLastTime; 
 class CItem * pItem; 

	for (i = 0; i < DEF_MAXMAPS; i++) { 
		if ((iDice(1,10) == 5) && (m_pMapList[i] != NULL) && 
			(m_pMapList[i]->m_iCurFish < m_pMapList[i]->m_iMaxFish)) { 
    
			iP = iDice(1, m_pMapList[i]->m_iTotalFishPoint) - 1; 
			if ((m_pMapList[i]->m_FishPointList[iP].x == -1) || (m_pMapList[i]->m_FishPointList[iP].y == -1)) break; 

			tX = m_pMapList[i]->m_FishPointList[iP].x + (iDice(1,3) - 2); 
			tY = m_pMapList[i]->m_FishPointList[iP].y + (iDice(1,3) - 2); 

			pItem = new class CItem; 
			if (pItem == NULL) break; 
                   
			//    ,   . 
			ZeroMemory(cItemName, sizeof(cItemName)); 
			switch (iDice(1,9)) { 
			case 1:   strcpy(cItemName, "RedCarp"); sDifficulty = iDice(1,10) + 20; break; 
			case 2:   strcpy(cItemName, "GreenCarp"); sDifficulty = iDice(1,5)  + 10; break; 
			case 3:   strcpy(cItemName, "GoldCarp"); sDifficulty = iDice(1,10) + 1;  break; 
			case 4:   strcpy(cItemName, "CrucianCarp"); sDifficulty = 1;  break;    
			case 5:   strcpy(cItemName, "BlueSeaBream"); sDifficulty = iDice(1,15) + 1;  break; 
			case 6:   strcpy(cItemName, "RedSeaBream"); sDifficulty = iDice(1,18) + 1;  break; 
			case 7:   strcpy(cItemName, "Salmon"); sDifficulty = iDice(1,12) + 1;  break; 
			case 8:   strcpy(cItemName, "GrayMullet"); sDifficulty = iDice(1,10) + 1;  break; 
			case 9: 
				//        
				switch (iDice(1,150)) { 
				case 1: 
				case 2: 
				case 3: 
					strcpy(cItemName, "PowerGreenPotion"); 
					sDifficulty = iDice(5,4) + 30; 
					break; 

				case 10: 
				case 11: 
					strcpy(cItemName, "SuperPowerGreenPotion"); 
					sDifficulty = iDice(5,4) + 50; 
					break; 

				case 20: 
					strcpy(cItemName, "Dagger+2"); 
					sDifficulty = iDice(5,4) + 30; 
					break; 

				case 30: 
					strcpy(cItemName, "LongSword+2"); 
					sDifficulty = iDice(5,4) + 40; 
					break; 

				case 40: 
					strcpy(cItemName, "Scimitar+2"); 
					sDifficulty = iDice(5,4) + 50; 
					break; 

				case 50: 
					strcpy(cItemName, "Rapier+2"); 
					sDifficulty = iDice(5,4) + 60; 
					break; 

				case 60: 
					strcpy(cItemName, "Flameberge+2"); 
					sDifficulty = iDice(5,4) + 60; 
					break; 

				case 70: 
					strcpy(cItemName, "WarAxe+2"); 
					sDifficulty = iDice(5,4) + 50; 
					break; 

				case 90: 
					strcpy(cItemName, "Ruby"); 
					sDifficulty = iDice(5,4) + 40; 
					break; 

				case 95: 
					strcpy(cItemName, "Diamond"); 
					sDifficulty = iDice(5,4) + 40; 
					break; 
				} 
			break; 
			} 
			dwLastTime  = (60000 * 10) + (iDice(1,3) - 1)*(60000 * 10); 

			if (_bInitItemAttr(pItem, cItemName) == TRUE) { 
				iRet = iCreateFish(i, tX, tY, 1, pItem, sDifficulty, dwLastTime); 
			} 
			else { 
				delete pItem; 
				pItem = NULL; 
			} 
		} 
	}                                         
}


int CGame::_iCalcPlayerNum(char cMapIndex, short dX, short dY, char cRadius)
{
 int ix, iy, iRet;
 class CTile * pTile;	

	//       .
	if ((cMapIndex < 0)	|| (cMapIndex > DEF_MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == NULL) return 0;

	iRet = 0;
	for (ix = dX - cRadius; ix <= dX + cRadius; ix++)
	for (iy = dY - cRadius; iy <= dY + cRadius; iy++) {
		if ( (ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
			 (iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY) ) {
			//    .	
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
			if ((pTile->m_sOwner != NULL) && (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER))
				iRet++;
		}
	}

	return iRet;
}


void CGame::WeatherProcessor()
{
char cPrevMode;
int i, j;
DWORD dwTime;
	dwTime = timeGetTime();
// SNOOPY for snow in winter / acomodado a estaciones de Argentina CENTU
SYSTEMTIME SysTime;

	for (i = 0; i < DEF_MAXMAPS; i++) 
	{
		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == FALSE)) 
		{	cPrevMode = m_pMapList[i]->m_cWhetherStatus;
			if (m_pMapList[i]->m_cWhetherStatus != NULL) 
			{	if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime) 
					m_pMapList[i]->m_cWhetherStatus = NULL;
			}else 
			{	GetLocalTime(&SysTime);
				switch((short)SysTime.wMonth) {
				case 6: 
				case 7:
				case 8: // Winter
					if (iDice(1,100) == 13) 
					{	m_pMapList[i]->m_cWhetherStatus = iDice(3,2);
						m_pMapList[i]->m_dwWhetherStartTime = dwTime;
						m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(2,7);					
					}
					break;
				case 12:
				case 1: 
				case 2:  // Summer weather: rare thunderstorms heavy rain
					// Chrismas
					if (((short)SysTime.wMonth == 12) && ((short)SysTime.wDay > 24)) 						
					{	m_pMapList[i]->m_cWhetherStatus = iDice(1,2)+4;
						m_pMapList[i]->m_dwWhetherStartTime = dwTime;
						m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(2,7);					
					}
					else
					{
						if (iDice(1,800) == 13) 
						{	m_pMapList[i]->m_cWhetherStatus = 3;
							m_pMapList[i]->m_dwWhetherStartTime = dwTime;
							m_pMapList[i]->m_dwWhetherLastTime  = 60000 + 60000*iDice(1,3);
						}
					}
					break;								
				default:   // Standard Weather
					if (iDice(1,300) == 13) 
					{	m_pMapList[i]->m_cWhetherStatus = iDice(1,3); 
						m_pMapList[i]->m_dwWhetherStartTime = dwTime;
						m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(1,7);
					}
					break;
				}
			}
			if (m_pMapList[i]->m_bIsSnowEnabled == TRUE) 
			{	m_pMapList[i]->m_cWhetherStatus = iDice(1,3)+3;
				m_pMapList[i]->m_dwWhetherStartTime = dwTime;
				m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(1,7);
			}

			if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) 
			{	m_pMapList[i]->m_cThunder = 0;
				for (j = 1; j < DEF_MAXCLIENTS; j++) 
				if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
					SendNotifyMsg(NULL, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, NULL, NULL, NULL);
			}else
			{	if (m_pMapList[i]->m_cThunder == 2) DoAbaddonThunderDamageHandler(i);			
			}
		} //If
	} //for Loop
}


/*********************************************************************************************************************
**  int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)										**
**  description			:: checks for a weather bonus when magic is cast											**
**  last updated		:: November 20, 2004; 10:34 PM; Hypnotoad													**
**	return value		:: int																						**
*********************************************************************************************************************/
int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)
{
 int iWheatherBonus;

	iWheatherBonus = 0;
	switch (cWheatherStatus) {
	case 0: break;
	case 1:
	case 2:
	case 3:
		switch (sType) {
		case 10:
		case 37:
		case 43:
		case 51:
			iWheatherBonus = 1;
			break;

		case 20:
		case 30:
			iWheatherBonus = -1;
			break;
		}
   		break;
	}
	return iWheatherBonus;
}


int CGame::iGetPlayerRelationship(int iClientH, int iOpponentH)
{
 int iRet;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pClientList[iOpponentH] == NULL) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		//       .   
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) && (memcmp(m_pClientList[iOpponentH]->m_cLocation, "NONE", 4) != 0)) {
			 iRet = 7; //  
		}
		else iRet = 2; //    
	}
	else if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		//  
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0)) 
			 iRet = 6; //   PK
		else iRet = 2; //    
	}
	else {
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[iOpponentH]->m_cSide != 0)) {
				//   0(Traveler)  .
				iRet = 2;
			}
			else {
				iRet = 0;
			}
		}	
		else {
			// .  .
			if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) ) {
				//   . 
				if (m_pClientList[iOpponentH]->m_iGuildRank == 0)
					 iRet = 5;	//   0. .
				else iRet = 3;	//  
			}
			else 
			if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iOpponentH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) != 0)) {
				//      .
				iRet = 4; //   
			}
			else iRet = 1; //   
		}
	}

	return iRet;
}

int CGame::iGetPlayerABSStatus(int iWhatH, int iRecvH)
{
	int iRet;

	if (m_pClientList[iWhatH] == NULL) return 0;
	if (m_pClientList[iRecvH] == NULL) return 0;

	iRet = 0;


		if (m_pClientList[iWhatH]->m_iPKCount != 0) {
			iRet = 8;
		}

		if (m_pClientList[iWhatH]->m_cSide != 0) {
			iRet = iRet | 4;
		}

		if (m_pClientList[iWhatH]->m_cSide == 1) {
			iRet = iRet | 2;
		}

		if (m_pClientList[iWhatH]->m_bIsPlayerCivil == TRUE)
			iRet = iRet | 1;

		return iRet;
}

int CGame::iGetNpcRelationship(int iWhatH, int iRecvH) 
{ 
	int iRet; 

	if (m_pClientList[iRecvH] == NULL) return 0; 
	if (m_pNpcList[iWhatH] == NULL) return 0; 

	iRet = 0; 
	switch (m_pNpcList[iWhatH]->m_cSide) { 
	case 10: iRet |= 8; //Fixed, Original 15 
	case 1:  iRet = (iRet | 4) | 2; //Fixed, Original 1 
	case 2:  iRet |= 4; //Fixed, Orignal 8 
	} 

	return iRet; 
}



int CGame::iGetNpcRelationship_SendEvent(int iNpcH, int iOpponentH)
{
 int iRet;
	
	//       . 
    // (NPC)           .
	if (m_pClientList[iOpponentH] == NULL) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pNpcList[iNpcH] == NULL) return 0;

	iRet = 0;

	if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		//       NPC  .
		if (m_pNpcList[iNpcH]->m_cSide == m_pClientList[iOpponentH]->m_cSide)
			 iRet = 7; 
		else iRet = 2;
	}
	else {
		if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			//     .
			if (m_pNpcList[iNpcH]->m_cSide == 10) 
				iRet = 2; //   .   .
			else 
			if (m_pNpcList[iNpcH]->m_cSide == 0) iRet = 0; //     	
			else 
			if (m_pClientList[iOpponentH]->m_cSide == 0) 
				 iRet = 0; //  .    . 
			else iRet = 2; //       
			
		}
		else iRet = 1; //   
	}

	return iRet;
}


int CGame::iGetMapIndex(char * pMapName)
{
 int i, iMapIndex;
 char cTmpName[256];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);

	iMapIndex = -1;
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {
		if (memcmp(m_pMapList[i]->m_cName, pMapName, 10) == 0) 
			iMapIndex = i;
	}

	return iMapIndex;
}



int CGame::_iForcePlayerDisconect(int iNum)
{
 int i, iCnt;

	iCnt = 0;
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) {
		if (m_pClientList[i]->m_bIsInitComplete == TRUE)
			 DeleteClient(i, TRUE, TRUE);
		else DeleteClient(i, FALSE, FALSE);
		iCnt++;
		if (iCnt >= iNum) break;
	}

	return iCnt;
}

void CGame::SpecialEventHandler()
{
 DWORD dwTime;
 
	//   . 
	dwTime = timeGetTime();

	if ((dwTime - m_dwSpecialEventTime) < DEF_SPECIALEVENTTIME) return; // DEF_SPECIALEVENTTIME
	m_dwSpecialEventTime  = dwTime;
	m_bIsSpecialEventTime = TRUE;
	
	switch (iDice(1,180)) {
	case 98: m_cSpecialEventType = 2; break; //      30 1 1/30
	default: m_cSpecialEventType = 1; break;
	}
}

void CGame::AdminOrder_CheckIP(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cIP[21], cInfoString[500];
 class  CStrTok * pStrTok;
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCheckIP) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if (token != NULL) {
		// token IP address. 
		ZeroMemory(cIP, sizeof(cIP));
		strcpy(cIP, token);

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cIPaddress, cIP, strlen(cIP)) == 0)) {
			//     . 
			ZeroMemory(cInfoString, sizeof(cInfoString));
			wsprintf(cInfoString, "Name(%s/%s) Loc(%s: %d %d) Level(%d:%d) Init(%d) IP(%s)", 
				     m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cMapName, 
					 m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 
					 m_pClientList[i]->m_iLevel, NULL,
					 m_pClientList[i]->m_bIsInitComplete, m_pClientList[i]->m_cIPaddress);

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		}
	}

	
	delete pStrTok;
}

void CGame::ToggleSafeAttackModeHandler(int iClientH) //v1.1
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	//    . 
	if (m_pClientList[iClientH]->m_bIsSafeAttackMode == TRUE) 
		 m_pClientList[iClientH]->m_bIsSafeAttackMode = FALSE;
	else m_pClientList[iClientH]->m_bIsSafeAttackMode = TRUE;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
}

void CGame::NpcRequestAssistance(int iNpcH)
{
 int ix, iy, sX, sY;
 short sOwnerH;
 char  cOwnerType;
	
	// iNpc     NPC  . 
	if (m_pNpcList[iNpcH] == NULL) return;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	for (ix = sX - 8; ix <= sX + 8; ix++)
	for (iy = sY - 8; iy <= sY + 8; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if ((sOwnerH != NULL) && (m_pNpcList[sOwnerH] != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) && 
			(iNpcH != sOwnerH) && (m_pNpcList[sOwnerH]->m_cSide == m_pNpcList[iNpcH]->m_cSide) &&
			(m_pNpcList[sOwnerH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[sOwnerH]->m_cBehavior == DEF_BEHAVIOR_MOVE)) {
			
			//   NPC . 
			m_pNpcList[sOwnerH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[sOwnerH]->m_sBehaviorTurnCount = 0;		
			m_pNpcList[sOwnerH]->m_iTargetIndex = m_pNpcList[iNpcH]->m_iTargetIndex;
			m_pNpcList[sOwnerH]->m_cTargetType  = m_pNpcList[iNpcH]->m_cTargetType;

			return;
		}
	}
}

void CGame::ForceDisconnectAccount(char *pAccountName, WORD wCount)
{
 int i;

	//     . 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cAccountName, pAccountName, 10) == 0)) {
		wsprintf(G_cTxt, "<%d> Force disconnect account: CharName(%s) AccntName(%s) Count(%d)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, wCount);
		PutLogList(G_cTxt);
		
		//v1.4312
		SendNotifyMsg(NULL, i, DEF_NOTIFY_FORCEDISCONN, wCount, NULL, NULL, NULL);
	}
}

void CGame::AdminOrder_Polymorph(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelPolymorph) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (memcmp(token, "off", 3) == 0)
			m_pClientList[iClientH]->m_sType = m_pClientList[iClientH]->m_sOriginalType;

		else if (memcmp(token, "Slime", 5) == 0)
			m_pClientList[iClientH]->m_sType = 10;

		else if (memcmp(token, "Skeleton", 8) == 0)
			m_pClientList[iClientH]->m_sType = 11;

		else if (memcmp(token, "Stone-Golem", 11) == 0)
			m_pClientList[iClientH]->m_sType = 12;

		else if (memcmp(token, "Cyclops", 7) == 0)
			m_pClientList[iClientH]->m_sType = 13;

		else if (memcmp(token, "Orc", 3) == 0)
			m_pClientList[iClientH]->m_sType = 14;

		else if (memcmp(token, "ShopKeeper", 10) == 0)
			m_pClientList[iClientH]->m_sType = 15;

		else if (memcmp(token, "Giant-Ant", 9) == 0)
			m_pClientList[iClientH]->m_sType = 16;

		else if (memcmp(token, "Scorpion", 8) == 0)
			m_pClientList[iClientH]->m_sType = 17;

		else if (memcmp(token, "Zombie", 6) == 0)
			m_pClientList[iClientH]->m_sType = 18;

		else if (memcmp(token, "Gandlf", 6) == 0)
			m_pClientList[iClientH]->m_sType = 19;

		else if (memcmp(token, "Howard", 6) == 0)
			m_pClientList[iClientH]->m_sType = 20;

		else if (memcmp(token, "Gaurd", 5) == 0)
			m_pClientList[iClientH]->m_sType = 21;

		else if (memcmp(token, "Amphis", 6) == 0)
			m_pClientList[iClientH]->m_sType = 22;

		else if (memcmp(token, "Clay-Golem", 10) == 0)
			m_pClientList[iClientH]->m_sType = 23;

		else if (memcmp(token, "Tom", 3) == 0)
			m_pClientList[iClientH]->m_sType = 24;

		else if (memcmp(token, "William", 7) == 0)
			m_pClientList[iClientH]->m_sType = 25;

		else if (memcmp(token, "Kennedy", 7) == 0)
			m_pClientList[iClientH]->m_sType = 26;

		else if (memcmp(token, "Hellbound", 9) == 0)
			m_pClientList[iClientH]->m_sType = 27;

		else if (memcmp(token, "Troll", 5) == 0)
			m_pClientList[iClientH]->m_sType = 28;

		else if (memcmp(token, "Orge", 4) == 0)
			m_pClientList[iClientH]->m_sType = 29;

		else if (memcmp(token, "Liche", 5) == 0)
			m_pClientList[iClientH]->m_sType = 30;

		else if (memcmp(token, "Demon", 5) == 0)
			m_pClientList[iClientH]->m_sType = 31;

		else if (memcmp(token, "Unicorn", 7) == 0)
			m_pClientList[iClientH]->m_sType = 32;

		else if (memcmp(token, "WereWolf", 8) == 0)
			m_pClientList[iClientH]->m_sType = 33;

		else if (memcmp(token, "Dummy", 5) == 0)
			m_pClientList[iClientH]->m_sType = 34;

		else if (memcmp(token, "Energy-Sphere", 13) == 0)
			m_pClientList[iClientH]->m_sType = 35;

		else if (memcmp(token, "AGT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 36;

		else if (memcmp(token, "CGT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 37;

		else if (memcmp(token, "MS", 2) == 0)
			m_pClientList[iClientH]->m_sType = 38;

		else if (memcmp(token, "DT", 2) == 0)
			m_pClientList[iClientH]->m_sType = 39;

		else if (memcmp(token, "ESG", 3) == 0)
			m_pClientList[iClientH]->m_sType = 40;

		else if (memcmp(token, "GMG", 3) == 0)
			m_pClientList[iClientH]->m_sType = 41;

		else if (memcmp(token, "ManaStone", 9) == 0)
			m_pClientList[iClientH]->m_sType = 42;

		else if (memcmp(token, "LWB", 3) == 0)
			m_pClientList[iClientH]->m_sType = 43;

		else if (memcmp(token, "GHK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 44;

		else if (memcmp(token, "GHC", 6) == 0)
			m_pClientList[iClientH]->m_sType = 45;

		else if (memcmp(token, "TK", 2) == 0)
			m_pClientList[iClientH]->m_sType = 46;

		else if (memcmp(token, "BG", 2) == 0)
			m_pClientList[iClientH]->m_sType = 47;

		else if (memcmp(token, "Stalker", 7) == 0)
			m_pClientList[iClientH]->m_sType = 48;

		else if (memcmp(token, "Hellclaw", 8) == 0)
			m_pClientList[iClientH]->m_sType = 49;

		else if (memcmp(token, "Tigerworm", 8) == 0)
			m_pClientList[iClientH]->m_sType = 50;

		else if (memcmp(token, "CP", 2) == 0)
			m_pClientList[iClientH]->m_sType = 51;

		else if (memcmp(token, "Gagoyle", 7) == 0)
			m_pClientList[iClientH]->m_sType = 52;

		else if (memcmp(token, "Beholder", 8) == 0)
			m_pClientList[iClientH]->m_sType = 53;

		else if (memcmp(token, "Dark-Elf", 8) == 0)
			m_pClientList[iClientH]->m_sType = 54;

		else if (memcmp(token, "Rabbit", 6) == 0)
			m_pClientList[iClientH]->m_sType = 55;

		else if (memcmp(token, "Cat", 3) == 0)
			m_pClientList[iClientH]->m_sType = 56;

		else if (memcmp(token, "Giant-Frog", 10) == 0)
			m_pClientList[iClientH]->m_sType = 57;

		else if (memcmp(token, "Mountain-Giant", 14) == 0)
			m_pClientList[iClientH]->m_sType = 58;

		else if (memcmp(token, "Ettin", 5) == 0)
			m_pClientList[iClientH]->m_sType = 59;

		else if (memcmp(token, "Cannibal-Plant", 13) == 0)
			m_pClientList[iClientH]->m_sType = 60;

		else if (memcmp(token, "Rudolph", 7) == 0)
			m_pClientList[iClientH]->m_sType = 61;

		else if (memcmp(token, "DireBoar", 8) == 0)
			m_pClientList[iClientH]->m_sType = 62;

		else if (memcmp(token, "Frost", 5) == 0)
			m_pClientList[iClientH]->m_sType = 63;

		else if (memcmp(token, "Crops", 5) == 0)
			m_pClientList[iClientH]->m_sType = 64;

		else if (memcmp(token, "Ice-Golem", 9) == 0)
			m_pClientList[iClientH]->m_sType = 65;

		else if (memcmp(token, "McGaffin", 8) == 0)
			m_pClientList[iClientH]->m_sType = 67;

		else if (memcmp(token, "Perry", 5) == 0)
			m_pClientList[iClientH]->m_sType = 68;

		else if (memcmp(token, "Devlin", 6) == 0)
			m_pClientList[iClientH]->m_sType = 69;

		else if (memcmp(token, "Barlog", 6) == 0)
			m_pClientList[iClientH]->m_sType = 70;

		else if (memcmp(token, "Centaurus", 9) == 0)
			m_pClientList[iClientH]->m_sType = 71;

		else if (memcmp(token, "Claw-Turtle", 11) == 0)
			m_pClientList[iClientH]->m_sType = 72;

		else if (memcmp(token, "Giant-Crayfish", 14) == 0)
			m_pClientList[iClientH]->m_sType = 74;

		else if (memcmp(token, "Giant-Lizard", 12) == 0)
			m_pClientList[iClientH]->m_sType = 75;

		else if (memcmp(token, "Giant-Plant", 11) == 0)
			m_pClientList[iClientH]->m_sType = 76;

		else if (memcmp(token, "MasterMage-Orc", 14) == 0)
			m_pClientList[iClientH]->m_sType = 77;

		else if (memcmp(token, "Minotaurs", 9) == 0)
			m_pClientList[iClientH]->m_sType = 78;

		else if (memcmp(token, "Nizie", 5) == 0)
			m_pClientList[iClientH]->m_sType = 79;

		else if (memcmp(token, "Tentocle", 8) == 0)
			m_pClientList[iClientH]->m_sType = 80;

		else if (memcmp(token, "Sor", 3) == 0)
			m_pClientList[iClientH]->m_sType = 82;

		else if (memcmp(token, "ATK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 83;

		else if (memcmp(token, "Elf", 3) == 0)
			m_pClientList[iClientH]->m_sType = 84;

		else if (memcmp(token, "DSK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 85;

		else if (memcmp(token, "HBT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 86;

		else if (memcmp(token, "CT", 2) == 0)
			m_pClientList[iClientH]->m_sType = 87;

		else if (memcmp(token, "Bar", 3) == 0)
			m_pClientList[iClientH]->m_sType = 88;

		else if (memcmp(token, "AGC", 3) == 0)
			m_pClientList[iClientH]->m_sType = 89;

		else if (memcmp(token, "Gail", 4) == 0)
			m_pClientList[iClientH]->m_sType = 90;

		else if (memcmp(token, "gate", 4) == 0)
			m_pClientList[iClientH]->m_sType = 91;
	}
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	delete pStrTok;
}

void CGame::AdminOrder_SetInvi(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetInvis) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		//    '1'  . '0'  
		if (token[0] == '1') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		else
		if (token[0] == '0') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	}

	delete pStrTok;
}

BOOL CGame::bOnClose()
{
	if (m_bIsServerShutdowned == FALSE) 
		if (MessageBox(NULL, "Player data not saved! Shutdown server now?", m_cServerName, MB_ICONEXCLAMATION | MB_YESNO) == IDYES) return TRUE;
		else return FALSE;
	else return TRUE;
		
	return FALSE;
}

// 05/24/2004 - Hypnotoad - Hammer and Wand train to 100% fixed
void CGame::_CheckAttackType(int iClientH, short *spType)
{
	WORD wType;

	if (m_pClientList[iClientH] == NULL) return;
	wType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	switch (*spType) {
	case 2:	
		//    Effect  . 
		if (m_pClientList[iClientH]->m_cArrowIndex == -1) *spType = 0;
		//      .   .
		if (wType < 40) *spType = 1;
		break;

	case 20:
		//   
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[5] < 100) *spType = 1;
		break;

	case 21: 
		//   
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[7] < 100) *spType = 1;
		break;

	case 22: 
		//   
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[9] < 100) *spType = 1;
		break;

	case 23: 
		//   
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)   *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[8] < 100) *spType = 1;
		break;

	case 24: 
		//   
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[10] < 100) *spType = 1;
		break;

	case 25: 
		//   
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[6] < 100) *spType = 2;
		if (m_pClientList[iClientH]->m_cArrowIndex == -1)      *spType = 0;
		//      .   .
		if (wType < 40) *spType = 1;
		break;

	case 26: 
		// v2.16 2002-5-27   
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[14] < 100) *spType = 1;
		break;

	case 27: 
		// v2.16 2002-5-27   
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[21] < 100) *spType = 1;
		break;
	}
}

void CGame::ReqCreatePotionHandler(int iClientH, char *pData)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cI[6], cPotionName[21], cData[120];
 int    iRet, i, j, iEraseReq, iSkillLimit, iSkillLevel, iResult, iDifficulty;
 short * sp, sItemIndex[6], sTemp;
 short  sItemNumber[6], sItemArray[12];
 BOOL   bDup, bFlag;
 class  CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++) {
		cI[i] = -1;
		sItemIndex[i]  = -1;
		sItemNumber[i] = 0;
	}

	cp = (char *)(pData + 11);
	cI[0] = *cp;
	cp++;
	cI[1] = *cp;
	cp++;
	cI[2] = *cp;
	cp++;
	cI[3] = *cp;
	cp++;
	cI[4] = *cp;
	cp++;
	cI[5] = *cp;
	cp++;
	//    .        . 

	//     .
	for (i = 0; i < 6; i++) {
		if (cI[i] >= DEF_MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == NULL)) return;
	}

	for (i = 0; i < 6; i++)
	if (cI[i] >= 0) {
		//      
		bDup = FALSE;
		for (j = 0; j < 6; j++) 
		if (sItemIndex[j] == cI[i]) {
			// .   
			sItemNumber[j]++;
			bDup = TRUE;
		}
		if (bDup == FALSE) {
			// .  .
			for (j = 0; j < 6; j++) 
			if (sItemIndex[j] == -1) {
				sItemIndex[j] = cI[i];
				sItemNumber[j]++;
				goto RCPH_LOOPBREAK;
			}
RCPH_LOOPBREAK:;
		}
	}
	
	//    .    . 
	for (i = 0; i < 6; i++) 
	if (sItemIndex[i] != -1) {
		if (sItemIndex[i] < 0) return;
		if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == NULL) return;
		//    .
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < sItemNumber[i]) return;
	}

	//       . Bubble Sort
	bFlag = TRUE;
	while (bFlag == TRUE) {
		bFlag = FALSE;
		for (i = 0; i < 5; i++) 
		if ((sItemIndex[i] != -1) && (sItemIndex[i+1] != -1)) {
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) <
				(m_pClientList[iClientH]->m_pItemList[sItemIndex[i+1]]->m_sIDnum)) {
				// .
				sTemp = sItemIndex[i+1];
				sItemIndex[i+1] = sItemIndex[i];
				sItemIndex[i] = sTemp;
				sTemp = sItemNumber[i+1];
				sItemNumber[i+1] = sItemNumber[i];
				sItemNumber[i] = sTemp;
				bFlag = TRUE;
			}
		}
	}

	//testcode


	//    .    . 
	j = 0;
	for (i = 0; i < 6; i++) {
		if (sItemIndex[i] != -1)
			 sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j+1] = sItemNumber[i];
		j += 2;
	}



	// sItemArray 12     . 
	ZeroMemory(cPotionName, sizeof(cPotionName));

	for (i = 0; i < DEF_MAXPOTIONTYPES; i++) 
	if (m_pPotionConfigList[i] != NULL) {
		bFlag = FALSE;
		for (j = 0; j < 12; j++) 
		if (m_pPotionConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = TRUE;
		
		if (bFlag == FALSE) {
			//     . 
			ZeroMemory(cPotionName, sizeof(cPotionName));
			memcpy(cPotionName, m_pPotionConfigList[i]->m_cName, 20);
			iSkillLimit = m_pPotionConfigList[i]->m_iSkillLimit;
			iDifficulty = m_pPotionConfigList[i]->m_iDifficulty;
		}
	}

	//     
	if (strlen(cPotionName) == 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMATCHINGPOTION, NULL, NULL, NULL, NULL);
		return;
	}

	//    
	iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[12];
	if (iSkillLimit > iSkillLevel) {
		//       .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOWPOTIONSKILL, NULL, NULL, NULL, cPotionName);
		return;
	}

	//      .
	iSkillLevel -= iDifficulty;
	if (iSkillLevel <= 0) iSkillLevel = 1;

	iResult = iDice(1,100);
	if (iResult > iSkillLevel) {
		//   
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_POTIONFAIL, NULL, NULL, NULL, cPotionName);
		return;
	}

	//       .   
	CalculateSSN_SkillIndex(iClientH, 12, 1);
	
	//     strlen(cPotionName) 0 .   
	if (strlen(cPotionName) != 0) {
		pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;

		//    .
		for (i = 0; i < 6; i++)
		if (sItemIndex[i] != -1) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
				// v1.41 !!!
				SetItemCount(iClientH, sItemIndex[i], 
				             m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
			else ItemDepleteHandler(iClientH, sItemIndex[i], FALSE, TRUE);
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_POTIONSUCCESS, NULL, NULL, NULL, cPotionName);
		// v1.41    
		GetExp(iClientH, iDice(1, (iDifficulty/3)));

		if ((_bInitItemAttr(pItem, cPotionName) == TRUE)) {
			//   .    .    
			//      .
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				ZeroMemory(cData, sizeof(cData));
				//  .
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				
				// 1 . Amount !
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;	//   
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; //    .
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				
				
				if (iEraseReq == 1) delete pItem;
				
				//    
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					//     .
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
				
			}
			else {
				//      .
				//    . 
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					                                                         m_pClientList[iClientH]->m_sY, pItem);
				
				//      . 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4
				
				//     .
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					//     .
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
			}
		}
		else {
			delete pItem;
			pItem = NULL;
		}
	}
}

BOOL CGame::_bDecodePotionConfigFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iPotionConfigListIndex = 0;
 int  iCraftingConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					//   
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format(1).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pPotionConfigList[atoi(token)] != NULL) {
						//    . .
						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Duplicate potion number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPotionConfigList[atoi(token)] = new class CPotion;
					iPotionConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					//   
					ZeroMemory(m_pPotionConfigList[iPotionConfigListIndex]->m_cName, sizeof(m_pPotionConfigList[iPotionConfigListIndex]->m_cName));
					memcpy(m_pPotionConfigList[iPotionConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				default:
					//   m_sArray[0~10]
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPotionConfigList[iPotionConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
					cReadModeB++;
					break;

				case 14:
					//  m_sArray[11]
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPotionConfigList[iPotionConfigListIndex]->m_sArray[11] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					//   
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPotionConfigList[iPotionConfigListIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 16;
					break;
	
				case 16:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPotionConfigList[iPotionConfigListIndex]->m_iDifficulty = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 2: // Crafting
				switch (cReadModeB) {
				case 1:	// 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format(1).");
						delete pContents; delete pStrTok; return FALSE;
					}					
					if (m_pCraftingConfigList[atoi(token)] != NULL) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Duplicate crafting number.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pCraftingConfigList[atoi(token)] = new class CPotion;
					iCraftingConfigListIndex = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					ZeroMemory(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName, sizeof(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName));
					memcpy(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				default: // m_sArray[0~10]
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
					cReadModeB++;
					break;

				case 14: // m_sArray[11]
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_sArray[11] = atoi(token);
					cReadModeB = 15;
					break;

				case 15: // 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 16;
					break;
	
				case 16:// 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_iDifficulty = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "potion", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "crafting", 8) == 0) 
			{	cReadModeA = 2;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! POTION configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) POTION(Total:%d) configuration - success!", iPotionConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
///		Crafting functions copyed on Alchemy functions...
//////////////////////////////////////////////////////////////////////////////////////////////////////
void CGame::ReqCreateCraftingHandler(int iClientH, char *pData)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cI[6], cCraftingName[21], cData[120];
 int    iRet, i, j, iEraseReq, iRiskLevel, iDifficulty, iNeededContrib = 0;
 short * sp, sTemp;
 short  sItemIndex[6], sItemPurity[6], sItemNumber[6], sItemArray[12];
 BOOL   bDup, bFlag, bNeedLog;
 class  CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;

	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++) 
	{	cI[i] = -1;
		sItemIndex[i]  = -1;
		sItemNumber[i] = 0;
		sItemPurity[i] = -1;
	}
	cp = (char *)(pData + 11);
	cp += 20;
	cI[0] = *cp;
	cp++;
	cI[1] = *cp;
	cp++;
	cI[2] = *cp;
	cp++;
	cI[3] = *cp;
	cp++;
	cI[4] = *cp;
	cp++;
	cI[5] = *cp;
	cp++;

	for (i = 0; i < 6; i++) 
	{	if (cI[i] >= DEF_MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == NULL)) return;
	}

	for (i = 0; i < 6; i++)
	if (cI[i] >= 0) 
	{	bDup = FALSE;
		for (j = 0; j < 6; j++) 
		if (sItemIndex[j] == cI[i]) 
		{	sItemNumber[j]++;
			bDup = TRUE;
		}
		if (bDup == FALSE) 
		{	for (j = 0; j < 6; j++) 
			if (sItemIndex[j] == -1) 
			{	sItemIndex[j] = cI[i];
				sItemNumber[j]++;
				goto RCPH_LOOPBREAK;
			}
RCPH_LOOPBREAK:;	
	}	}

	
	for (i = 0; i < 6; i++) 
	if (sItemIndex[i] != -1) 
	{	if (sItemIndex[i] < 0) return;
		if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == NULL) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < sItemNumber[i]) return;
		sItemPurity[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sItemSpecEffectValue2;
		if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_NONE)
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSprite == 6)
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSpriteFrame == 129))
		{	sItemPurity[i] = 100; // Merien stones considered 100% purity.
		}		
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
		{	sItemPurity[i] = -1; // Diamonds / Emeralds.etc.. never have purity
		}
		if (sItemNumber[i] > 1) // No purity for stacked items
		{	sItemPurity[i] = -1;
		}
		

		if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_EQUIP)
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cEquipPos == DEF_EQUIPPOS_NECK))
		{	iNeededContrib = 10; // Necks Crafting requires 10 contrib
	}	}

	// Bubble Sort
	bFlag = TRUE;
	while (bFlag == TRUE) 
	{	bFlag = FALSE;
		for (i = 0; i < 5; i++) 
		if ((sItemIndex[i] != -1) && (sItemIndex[i+1] != -1)) 
		{	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) < (m_pClientList[iClientH]->m_pItemList[sItemIndex[i+1]]->m_sIDnum)) 
			{	sTemp = sItemIndex[i+1];
				sItemIndex[i+1] = sItemIndex[i];
				sItemIndex[i] = sTemp;
				sTemp = sItemPurity[i+1];
				sItemPurity[i+1] = sItemPurity[i];
				sItemPurity[i] = sTemp;
				sTemp = sItemNumber[i+1];
				sItemNumber[i+1] = sItemNumber[i];
				sItemNumber[i] = sTemp;
				bFlag = TRUE;
	}	}	}
	j = 0;
	for (i = 0; i < 6; i++)
	{	if (sItemIndex[i] != -1)
			 sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j+1] = sItemNumber[i];
		j += 2;
	}

	// Search Crafting you wanna build
	ZeroMemory(cCraftingName, sizeof(cCraftingName));
	for (i = 0; i < DEF_MAXPOTIONTYPES; i++) 
	if (m_pCraftingConfigList[i] != NULL) 
	{	bFlag = FALSE;
		for (j = 0; j < 12; j++) 
		{	if (m_pCraftingConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = TRUE; // one item mismatch	
		}
		if (bFlag == FALSE) // good Crafting receipe
		{	ZeroMemory(cCraftingName, sizeof(cCraftingName));
			memcpy(cCraftingName, m_pCraftingConfigList[i]->m_cName, 20);
			iRiskLevel  = m_pCraftingConfigList[i]->m_iSkillLimit;			// % to loose item if crafting fails
			iDifficulty = m_pCraftingConfigList[i]->m_iDifficulty;
	}	}


	// Check if recipe is OK
	if (strlen(cCraftingName) == 0) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 1, NULL, NULL, NULL); // "There is not enough material"
		return;
	}
	// Check for Contribution
	if (m_pClientList[iClientH]->m_iContribution < iNeededContrib)
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 2, NULL, NULL, NULL); // "There is not enough Contribution Point"	
		return;
	}
	// Check possible Failure
	if (iDice(1,100) > iDifficulty) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 3, NULL, NULL, NULL); // "Crafting failed"
		// Remove parts...
		pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;
		for (i = 0; i < 6; i++)
		if (sItemIndex[i] != -1) 
		{	// Deplete any Merien Stone
			if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_NONE)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSprite == 6)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSpriteFrame == 129))
			{	ItemDepleteHandler(iClientH, sItemIndex[i], FALSE, TRUE);
			}else 
			// Risk to deplete any other items (not stackable ones) // DEF_ITEMTYPE_CONSUME
			if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				|| (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_MATERIAL))
			{	if (iDice(1,100) < iRiskLevel)	
				{	ItemDepleteHandler(iClientH, sItemIndex[i], FALSE, TRUE);
		}	}	}
		return;
	}

	// Purity
	int iPurity, iTot = 0, iCount = 0;
	for (i = 0; i < 6; i++) 
	{	if (sItemIndex[i] != -1) 
		{	if (sItemPurity[i] != -1) 
			{	iTot += sItemPurity[i];
				iCount ++;
	}	}	}
	if (iCount == 0 ) 
	{	iPurity = 20 + iDice(1,80);			// Wares have random purity (20%..100%)
		bNeedLog = FALSE;
	}else 
	{	iPurity = iTot/iCount;
		iTot    = (iPurity*4)/5;
		iCount  = iPurity - iTot;
		iPurity = iTot + iDice(1,iCount);	// Jewel completion depends off Wares purity
		bNeedLog = TRUE;
	}
	if (iNeededContrib != 0) 
	{	iPurity = 0;						// Necks require contribution but no purity/completion
		bNeedLog = TRUE;
	}
	
	CalculateSSN_SkillIndex(iClientH, 18, 1);

	if (strlen(cCraftingName) != 0) 
	{	pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;
		for (i = 0; i < 6; i++)
		{	if (sItemIndex[i] != -1) 
			{	if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
				{	SetItemCount(iClientH, sItemIndex[i], 
						m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);					
				}else // So if item is not Type 5 (stackable items), you deplete item
				{	ItemDepleteHandler(iClientH, sItemIndex[i], FALSE, TRUE);
		}	}	}
		if (iNeededContrib !=0)
		{	m_pClientList[iClientH]->m_iContribution -= iNeededContrib;   
			// No known msg to send info to client, so client will compute shown Contrib himself.		
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRAFTING_SUCCESS, NULL, NULL, NULL, NULL);

		GetExp(iClientH, iDice(1, iDice(2, 100)));

		if ((_bInitItemAttr(pItem, cCraftingName) == TRUE)) 
		{	// // Snoopy: Added Purity to Oils/Elixirs
			if (iPurity != 0) 
			{	pItem->m_sItemSpecEffectValue2 = iPurity;
				pItem->m_dwAttribute = 1;
			}
			pItem->m_sTouchEffectType   = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = iDice(1,100000);
			pItem->m_sTouchEffectValue2 = iDice(1,100000);
			SYSTEMTIME SysTime;
			char cTemp[256];
			GetLocalTime(&SysTime);
			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);

			// SNOOPY log anything above WAREs
			if (bNeedLog) 		
			{	wsprintf(G_cTxt, "PC(%s) Crafting (%s) Purity(%d)"
					, m_pClientList[iClientH]->m_cCharName
					, pItem->m_cName
					, pItem->m_sItemSpecEffectValue2);			
				PutLogList(G_cTxt);
			}
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
			{	ZeroMemory(cData, sizeof(cData));
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);	
				*cp = 1;
				cp++;				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;				
				*cp = pItem->m_cItemType;
				cp++;				
				*cp = pItem->m_cEquipPos;
				cp++;				
				*cp = (char)0; 
				cp++;				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;				
				*cp = pItem->m_cGenderLimit;
				cp++;				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;
				*cp = pItem->m_cItemColor;
				cp++;
				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
								
				if (iEraseReq == 1) delete pItem;
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
			}else 
			{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					                                                         m_pClientList[iClientH]->m_sY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
				
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					break;
			}	}
		}else 
		{	delete pItem;
			pItem = NULL;	
	}	}
}

void CGame::LocalSavePlayerData(int iClientH)
{
 char * pData, * cp, cFn[256], cDir[256], cTxt[256], cCharDir[256];
 int    iSize;
 FILE * pFile;
 SYSTEMTIME SysTime;

	//         . 
	if (m_pClientList[iClientH] == NULL) return;
 
	pData = new char[30000];
	if (pData == NULL) return;
	ZeroMemory(pData, 30000);

	cp = (char *)(pData);
	iSize = _iComposePlayerDataFileContents(iClientH, cp);

	GetLocalTime(&SysTime);
	ZeroMemory(cCharDir, sizeof(cDir));
	wsprintf(cCharDir, "Character_%d_%d_%d_%d", SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);

	ZeroMemory(cDir, sizeof(cDir));
	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn,cCharDir);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	wsprintf(cTxt, "AscII%d", (unsigned char)m_pClientList[iClientH]->m_cCharName[0]);
	strcat(cFn, cTxt);
	strcpy(cDir, cFn);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn, m_pClientList[iClientH]->m_cCharName);
	strcat(cFn, ".txt");

	//  .
	_mkdir(cCharDir);
	_mkdir(cDir);

	if (iSize == 0) {
		PutLogList("(!) Character data body empty: Cannot create & save temporal player data file.");
		delete pData;
		return;
	}

	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		wsprintf(cTxt, "(!) Cannot create temporal player data file : Name(%s)", cFn);
		PutLogList(cTxt);
	}
	else {
		wsprintf(cTxt, "(!) temporal player data file saved : Name(%s)", cFn);
		PutLogList(cTxt);
		fwrite(cp, iSize, 1, pFile);
	}
	
	if (pFile != NULL) fclose(pFile);
	delete pData;
}

void CGame::MineralGenerator()
{
 int i, iP, tX, tY, iRet;
 
	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((iDice(1,4) == 1) && (m_pMapList[i] != NULL) && 
			(m_pMapList[i]->m_bMineralGenerator == TRUE) && 
			(m_pMapList[i]->m_iCurMineral < m_pMapList[i]->m_iMaxMineral)) {
	
			iP = iDice(1, m_pMapList[i]->m_iTotalMineralPoint) - 1;
			if ((m_pMapList[i]->m_MineralPointList[iP].x == -1) || (m_pMapList[i]->m_MineralPointList[iP].y == -1)) break;

			tX = m_pMapList[i]->m_MineralPointList[iP].x;
			tY = m_pMapList[i]->m_MineralPointList[iP].y;

		   	iRet = iCreateMineral(i, tX, tY, m_pMapList[i]->m_cMineralGeneratorLevel);
		}
	}		
}

int CGame::iCreateMineral(char cMapIndex, int tX, int tY, char cLevel)
{
 int i, iDynamicHandle, iMineralType;

	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return NULL;
	if (m_pMapList[cMapIndex] == NULL) return NULL;
	
	for (i = 1; i < DEF_MAXMINERALS; i++) 
	if (m_pMineral[i] == NULL) {
		//    .
		iMineralType = iDice(1, cLevel);
		m_pMineral[i] = new class CMineral(iMineralType, cMapIndex, tX, tY, 1);
		if (m_pMineral[i] == NULL) return NULL;
 		
		iDynamicHandle = NULL;
		switch (iMineralType) {
		case 1: // 
		case 2:
		case 3:
		case 4:
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
			break;
				
		case 5: //  
		case 6:
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL2, cMapIndex, tX, tY, NULL, i);
			break;
		
		default:
			//    
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
			break;
		}
		
		if (iDynamicHandle == NULL) {
			delete m_pMineral[i];
			m_pMineral[i] = NULL;
			return NULL;
		}
		m_pMineral[i]->m_sDynamicObjectHandle = iDynamicHandle;
		m_pMineral[i]->m_cMapIndex = cMapIndex;
		
		//   .
		switch (iMineralType) {
		case 1: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
		case 2: m_pMineral[i]->m_iDifficulty = 15; m_pMineral[i]->m_iRemain = 15; break;
		case 3: m_pMineral[i]->m_iDifficulty = 20; m_pMineral[i]->m_iRemain = 10; break;
		case 4: m_pMineral[i]->m_iDifficulty = 50; m_pMineral[i]->m_iRemain = 8; break;
		case 5: m_pMineral[i]->m_iDifficulty = 70; m_pMineral[i]->m_iRemain = 6; break;
		case 6: m_pMineral[i]->m_iDifficulty = 90; m_pMineral[i]->m_iRemain = 4; break;
		default: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
		}

		//    
		m_pMapList[cMapIndex]->m_iCurMineral++;
	
		return i;
	}

	return NULL;
}


void CGame::_CheckMiningAction(int iClientH, int dX, int dY)
{
	short sType;
	DWORD dwRegisterTime;
	int   iDynamicIndex, iSkillLevel, iResult, iItemID;
	class CItem * pItem;
	WORD  wWeaponType;

	if (m_pClientList[iClientH] == NULL)  return;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetDynamicObject(dX, dY, &sType, &dwRegisterTime, &iDynamicIndex);

	switch (sType) {
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		//     .   ?   ? 
		//     
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 25) {
			//   .    
		}
		else return;

		//     
		if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0) return;

		iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[0];
		if (iSkillLevel == 0) break;

		if (m_pDynamicObjectList[iDynamicIndex] == NULL) break;
		//     .
		iSkillLevel -= m_pMineral[ m_pDynamicObjectList[iDynamicIndex]->m_iV1 ]->m_iDifficulty;
		if (iSkillLevel <= 0) iSkillLevel = 1;

		iResult = iDice(1, 100);
		if (iResult <= iSkillLevel) {
			//  .    
			CalculateSSN_SkillIndex(iClientH, 0, 1);

			//     . 
			switch (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_cType) { 
				case 1: 
					switch (iDice(1,5)) { 
						case 1: 
						case 2: 
						case 3:    
							iItemID = 355; // Coal
							GetExp(iClientH, iDice(1, iDice(1,3)));
							break; 
						case 4:    
							iItemID = 357; // IronOre
							GetExp(iClientH, iDice(1, iDice(1,3)));
							break; 
						case 5:
							iItemID = 507; // BlondeStone
							GetExp(iClientH, iDice(1, iDice(1,3)));
							break;
					} 
					break; 

				case 2: 
					switch (iDice(1,5)) { 
						case 1: 
						case 2: 
							iItemID = 355; // Coal
							GetExp(iClientH, iDice(1, iDice(1,3)));
							break; 
						case 3:    
						case 4:    
							iItemID = 357; // IronOre
							GetExp(iClientH, iDice(1, iDice(1,3)));
							break; 
						case 5:
							if (iDice(1,3) == 2) { 
								iItemID = 356; // SilverNugget
								GetExp(iClientH, iDice(1, iDice(1,4)));
							} 
							else { 
								iItemID = 507; // BlondeStone
								GetExp(iClientH, iDice(1, iDice(1,3)));
							} 
							break; 
					} 
					break; 

				case 3: 
					switch (iDice(1,6)) { 
						case 1: 
							iItemID = 355; // Coal
							GetExp(iClientH, iDice(1, iDice(1,3)));
							break; 
						case 2: 
						case 3:    
						case 4:    
						case 5: 
							iItemID = 357; // IronOre
							GetExp(iClientH, iDice(1, iDice(1,3)));
							break; 
						case 6: 
							if (iDice(1,8) == 3) { 
								if (iDice(1,2) == 1) { 
									iItemID = 356; // SilverNugget
									GetExp(iClientH, iDice(1, iDice(1,4)));
								} 
								else { 
									iItemID = 357; // IronOre
									GetExp(iClientH, iDice(1, iDice(1,3)));
								}
								break;
							} 
							else { 
								iItemID = 357; // IronOre
								GetExp(iClientH, iDice(1, iDice(1,3)));
							} 
							break; 
					} 
					break; 

				case 4: 
					switch (iDice(1,6)) { 
						case 1: 
							iItemID = 355; // Coal
							GetExp(iClientH, iDice(1, iDice(1,3)));
							break; 
						case 2: 
							if (iDice(1,3) == 2) {
								iItemID =  356; // SilverNugget
								GetExp(iClientH, iDice(1, iDice(1,4)));
							}
							break;
						case 3:    
						case 4:    
						case 5: 
							iItemID = 357; // IronOre
							GetExp(iClientH, iDice(1, iDice(1,3)));
							break; 
						case 6: 
							if (iDice(1,8) == 3) { 
								if (iDice(1,4) == 3) { 
									if (iDice(1,4) < 3) { 
										iItemID = 508; // Mithral
										GetExp(iClientH, iDice(1, iDice(1,15)));
									} 
									else { 
										iItemID =  354; // GoldNugget
										GetExp(iClientH, iDice(1, iDice(1,5)));
									}
									break;
								} 
								else { 
									iItemID =  356; // SilverNugget
									GetExp(iClientH, iDice(1, iDice(1,4)));
								}
								break;
							} 
							else { 
								if (iDice(1,2) == 1) { 
									iItemID = 354; // GoldNugget
									GetExp(iClientH, iDice(1, iDice(1,5)));
								}
								else {
									iItemID = 357;  // IronOre
									GetExp(iClientH, iDice(1, iDice(1,3)));
								}
								break;
							} 
							break; 
					}
					break;

				case 5: 
					switch (iDice(1,19)) { 
						case 3: 
							iItemID = 352; // Sapphire
							GetExp(iClientH, iDice(1, iDice(2,3)));
							break; 
						default: 
							iItemID = 358; // Crystal
							GetExp(iClientH, iDice(1, iDice(2,3)));
							break; 
					} 
					break; 

				case 6: 
					switch (iDice(1,5)) { 
						case 1: 
							if (iDice(1,6) == 3) { 
								iItemID =  353; // Emerald 
								GetExp(iClientH, iDice(1, iDice(2,4)));
							} 
							else { 
								iItemID =  358; // Crystal
								GetExp(iClientH, iDice(1, iDice(2,3)));
							} 
							break; 
						case 2: 
							if (iDice(1,6) == 3) { 
								iItemID =  352; // Saphire
								GetExp(iClientH, iDice(1, iDice(2,4)));
							} 
							else { 
								iItemID =  358; // Crystal
								GetExp(iClientH, iDice(1, iDice(2,3)));
							} 
							break; 
						case 3: 
							if (iDice(1,6) == 3) { 
								iItemID =  351; // Ruby
								GetExp(iClientH, iDice(1, iDice(2,4)));
							} 
							else { 
								iItemID =  358; // Crystal 
								GetExp(iClientH, iDice(1, iDice(2,3)));
							} 
							break; 
						case 4: 
							iItemID =  358; // Crystal 
							GetExp(iClientH, iDice(1, iDice(2,3)));
							break; 
						case 5: 
							if (iDice(1,12) == 3) { 
								iItemID =  350; // Diamond
								GetExp(iClientH, iDice(1, iDice(2,5)));
							} 
							else { 
								iItemID =  358; // Crystal
								GetExp(iClientH, iDice(1, iDice(2,3)));
							} 
							break;
					} 
					break;

			} 

			pItem = new class CItem;
			if (_bInitItemAttr(pItem, iItemID) == FALSE) {
				delete pItem;
			}
			else {
				//    . 
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					m_pClientList[iClientH]->m_sY, pItem);
				//      . 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4
				    
			}

			//     0 .
			m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain--;
			if (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain <= 0) {
				//   . Delete Mineral 
				bDeleteMineral(m_pDynamicObjectList[iDynamicIndex]->m_iV1);

				//   
				delete m_pDynamicObjectList[iDynamicIndex];
				m_pDynamicObjectList[iDynamicIndex] = NULL;
			}
		}
		break;

	default: 
		break;
	}
}

BOOL CGame::bDeleteMineral(int iIndex)
{
 int iDynamicIndex;
 DWORD dwTime;

	dwTime = timeGetTime();
	
	if (m_pMineral[iIndex] == NULL) return FALSE;
	iDynamicIndex = m_pMineral[iIndex]->m_sDynamicObjectHandle;
	if (m_pDynamicObjectList[iDynamicIndex] == NULL) return FALSE;

	SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex, 
		                        m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, 
								m_pDynamicObjectList[iDynamicIndex]->m_sType, iDynamicIndex, NULL);
	//     .
	m_pMapList[m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, dwTime);
	//     . 
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->SetTempMoveAllowedFlag(m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, TRUE);
			
	//     
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->m_iCurMineral--;

	//    
	delete m_pMineral[iIndex];
	m_pMineral[iIndex] = NULL;

	return TRUE;
}

void CGame::NpcTalkHandler(int iClientH, int iWho)
{
 char cRewardName[21], cTargetName[21];
 int iResMode, iQuestNum, iQuestType, iRewardType, iRewardAmount, iContribution, iX, iY, iRange, iTargetType, iTargetCount;

	iQuestNum = 0;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	if (m_pClientList[iClientH] == NULL) return;
	switch (iWho) {
	case 1: break;
	case 2:	break;
	case 3:	break;
	case 4:
		iQuestNum = _iTalkToNpcResult_Cityhall(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		break;
	case 5: break;
	case 6:	break;
	case 32: break;
	case 21: 
		iQuestNum = _iTalkToNpcResult_Guard(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		if (iQuestNum >= 1000) return;
		break;
	}

	ZeroMemory(cRewardName, sizeof(cRewardName));
	if (iQuestNum > 0) {
		if (iRewardType > 1) {
			strcpy(cRewardName, m_pItemConfigList[iRewardType]->m_cName);
		}
		else {
			switch (iRewardType) {
			case -10: strcpy(cRewardName, "F-"); break;
			}
		}

		m_pClientList[iClientH]->m_iAskedQuest        = iQuestNum;
		m_pClientList[iClientH]->m_iQuestRewardType   = iRewardType;
		m_pClientList[iClientH]->m_iQuestRewardAmount = iRewardAmount;
	
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, iQuestType, iResMode, iRewardAmount, cRewardName, iContribution,
			          iTargetType, iTargetCount, iX, iY, iRange, cTargetName);
	}
	else {
		switch (iQuestNum) {
		case  0: SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (iWho+130), NULL, NULL, NULL, NULL); break;
		case -1:
		case -2:
		case -3:
		case -4: SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, abs(iQuestNum)+100, NULL, NULL, NULL, NULL); break;
		case -5: break;
		}
	}
}

void CGame::CheckFireBluring(char cMapIndex, int sX, int sY)
{
 int ix, iy, iItemNum;
  short sSpr, sSprFrame;
 char  cItemColor;
 class CItem * pItem;

	for (ix = sX -1; ix <= sX +1; ix++)
	for (iy = sY -1; iy <= sY +1; iy++) {
		//          .	
		iItemNum = m_pMapList[cMapIndex]->iCheckItem(ix, iy);
				
		switch (iItemNum) {
		case 355: 
			// .    .
			pItem = m_pMapList[cMapIndex]->pGetItem(ix, iy, &sSpr, &sSprFrame, &cItemColor);
			if (pItem != NULL) delete pItem;
			iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_FIRE, cMapIndex, ix, iy, 6000);	

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, cMapIndex,
				                        ix, iy, sSpr, sSprFrame, cItemColor);
			break;
		}
	}
}



void CGame::AdminOrder_GetNpcStatus(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cNpcName[256];
 class  CStrTok * pStrTok;
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGetNpcStatus) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, token);
	}

	for (i = 0; i < DEF_MAXNPCS; i++) 
	if (m_pNpcList[i] != NULL) {
		if (memcmp(m_pNpcList[i]->m_cName, cNpcName, 5) == 0) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINIFO, 1, i, NULL, NULL);	
		}
	}

	delete pStrTok;
	return;
}


int CGame::_iGetWeaponSkillType(int iClientH)
{
 WORD wWeaponType;

	if (m_pClientList[iClientH] == NULL) return 0;

	wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	if (wWeaponType == 0) {
		return 5;
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2)) {
		return 7;
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20)) {
		if (wWeaponType == 7) 
			 return 9;
		else return 8;
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 30)) {
		return 10;
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 35)) {
		return 14;
	}
	else if ((wWeaponType >= 35) && (wWeaponType < 40)) {
		return 21	;
	}
	else if (wWeaponType >= 40) {
		return 6;
	}
	
	return 1;
}

static int ___iCAB5[]  = {0,0, 0,1,2};
static int ___iCAB6[]  = {0,0, 0,0,0};
static int ___iCAB7[]  = {0,0, 1,2,3};
static int ___iCAB8[]  = {0,0, 1,3,5};
static int ___iCAB9[]  = {0,0, 2,4,8};
static int ___iCAB10[] = {0,0, 1,2,3};

int CGame::iGetComboAttackBonus(int iSkill, int iComboCount)
{
	if (iComboCount <= 1) return 0;
	if (iComboCount > 6) return 0;
	switch (iSkill) {
	case 5:
		return ___iCAB5[iComboCount];
		break;
	case 6:
		return ___iCAB6[iComboCount];
		break;
	case 7:
		return ___iCAB7[iComboCount];
		break;
	case 8:
		return ___iCAB8[iComboCount];
		break;
	case 9:
		return ___iCAB9[iComboCount];
		break;
	case 10:
		return ___iCAB10[iComboCount];
		break;
	case 14:
		return ___iCAB6[iComboCount];
		break;
	case 21:
		return ___iCAB10[iComboCount];
		break;
	}

	return 0;
}

void CGame::SetDownSkillIndexHandler(int iClientH, int iSkillIndex)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((iSkillIndex < 0) || (iSkillIndex >= DEF_MAXSKILLTYPE)) return;

	if (m_pClientList[iClientH]->m_cSkillMastery[iSkillIndex] > 0)
		m_pClientList[iClientH]->m_iDownSkillIndex = iSkillIndex;

	//     . 
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
}


BOOL CGame::_bDepleteDestTypeItemUseEffect(int iClientH, int dX, int dY, short sItemIndex, short sDestItemID)
{
 BOOL bRet;

	//          
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;

	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
	case DEF_ITEMEFFECTTYPE_OCCUPYFLAG:
		bRet =  __bSetOccupyFlag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			                     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
				 				 NULL, iClientH, NULL);
		if (bRet == TRUE) {
			GetExp(iClientH, (iDice(m_pClientList[iClientH]->m_iLevel, 10)));
		}
		else {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTFLAGSPOT, NULL, NULL, NULL, NULL);
		}
		return bRet;

	// crusade
	case DEF_ITEMEFFECTTYPE_CONSTRUCTIONKIT:
		//  .   . m_sItemEffectValue1:  , m_sItemEffectValue2:   
		bRet = __bSetConstructionKit(m_pClientList[iClientH]->m_cMapIndex, dX, dY,                                 // 
			                         m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,        //
				 				     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,        //
								     iClientH); //  
		if (bRet == TRUE) {
			//   
		}
		else {
			//  			
		}
		return bRet;
	
	case DEF_ITEMEFFECTTYPE_DYE:
		//  :    .
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL) {
				if ( (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 11) ||
					 (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 12) ) {
					//   .
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					//    . 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, NULL, NULL);
					return TRUE;
				}
				else {
					//   . 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, NULL, NULL);
					return FALSE;
				}
			}
		}	
		break;

	case DEF_ITEMEFFECTTYPE_ARMORDYE:
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL) {
				if (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 6) {
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, NULL, NULL);
					return TRUE;
				}
				else {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, NULL, NULL);
					return FALSE;
				}
			}
		}	
		break;

	case DEF_ITEMEFFECTTYPE_WEAPONDYE:
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
			if (m_pClientList[ iClientH ]->m_pItemList[sDestItemID] != NULL) {
				if (m_pClientList[ iClientH ]->m_pItemList[sDestItemID]->m_cCategory == 1) {
					m_pClientList[ iClientH ]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[ iClientH ]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[ iClientH ]->m_pItemList[sDestItemID]->m_cItemColor, NULL, NULL);
					return TRUE;
				}
				else {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, NULL, NULL);
					return FALSE;
				}
			}
		} 
		break;

	case DEF_ITEMEFFECTTYPE_FARMING:
		bRet = bPlantSeedBag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			                         m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
				 				     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,
								     iClientH);
		return bRet;

	default:
		break;
	}

	return TRUE;
}

/*********************************************************************************************************************
**  BOOL CGame::__bSetOccupyFlag(char cMapIndex,int dX,int dY,int iSide,int iEKNum,int iClientH,BOOL bAutoFlag)		**
**  description		:: A player has used a Flag during Heldenian event...        									**
**	Called when player sets a flag, or at Heldenian Type 2 beginning												**
*********************************************************************************************************************/
BOOL CGame::__bSetOccupyFlag(char cMapIndex, int dX, int dY, int iSide, int iEKNum, int iClientH, BOOL bAutoFlag)
{ int ix,iy;
 int   iDynamicObjectIndex, iIndex;
 class CTile * pTile;
 DWORD dwTime = timeGetTime();	
	if (m_pMapList[cMapIndex] == NULL)									return FALSE;
	if ((m_bHeldenianWarInitiated == FALSE)&&(bAutoFlag == FALSE))		return FALSE; // War must be started is player flag
	if (m_cHeldenianWinner != -1)										return FALSE; // War must not be finished
	if ((m_cHeldenianType == 1) && (m_iBTFieldMapIndex != cMapIndex))	return FALSE; // Type 1: only on BattleField
	if (   (m_cHeldenianType == 2) && (m_iRampartMapIndex != cMapIndex)				  // Type 2: 
		&& (m_iGodHMapIndex  != cMapIndex))                             return FALSE; // allowed only in HRampart / GodH
	if (   (m_cHeldenianType == 2) 										   			  // Type 2: 
		&& (m_iGodHMapIndex  == cMapIndex)											  // on GodH, allowed only
		&& (bAutoFlag == FALSE)														  // as autoflag
		&& (m_pClientList[iClientH] != NULL))									
	{	if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) return FALSE; // for attackers only
		if (m_pClientList[iClientH]->m_iGuildRank != 0)					return FALSE; // for a gm only
		if (   (abs(m_pMapList[cMapIndex]->m_sHeldenianWinningZoneX - dX) > 2)
			|| (abs(m_pMapList[cMapIndex]->m_sHeldenianWinningZoneY - dY) > 2)) return FALSE; // and in wining zone only
	}	
	if (   (dX < 25) || (dX >= m_pMapList[cMapIndex]->m_sSizeX - 25)
		|| (dY < 25) || (dY >= m_pMapList[cMapIndex]->m_sSizeY - 25))	return FALSE;

	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	if (pTile->m_iAttribute != NULL)									return FALSE;
	if (pTile->m_iOccupyFlagIndex != NULL)								return FALSE;
	if (pTile->m_bIsMoveAllowed == FALSE)								return FALSE;
	if (m_pMapList[cMapIndex]->m_iTotalOccupyFlags >= DEF_MAXOCCUPYFLAG) 
	{	return FALSE;
	}
	if (bAutoFlag == FALSE) // Flag set by a character
	{	if (m_pClientList[iClientH] == NULL) return FALSE;	
		switch (m_pClientList[iClientH]->m_cSide) {
		case 1:	// Aresden
			iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ARESDENFLAG1, cMapIndex, dX, dY, NULL, NULL);	
			break;
		case 2: // Elvine	
			iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ELVINEFLAG1, cMapIndex, dX, dY, NULL, NULL);	
			break;
		default: // Others
			return FALSE;
			break;
		}	
		if (iDynamicObjectIndex == NULL) return FALSE;
		iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
		if (iIndex == -1) PutLogList("Error registering OccupyFlag.");	
		for (ix = dX-iEKNum; ix <= dX+iEKNum; ix++) 
		for (iy = dY-iEKNum; iy <= dY+iEKNum; iy++) 
		{	if ((ix == dX) && (iy == dY)) 
			{}else 
			{	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);			
				if (pTile->m_iOccupyFlagIndex == NULL) 
				{	switch (m_pClientList[iClientH]->m_cSide) {
					case 1:	// Aresden 
						pTile->m_iOccupyStatus -= iEKNum; 
						break;
					case 2: // Elvine	
						pTile->m_iOccupyStatus += iEKNum; 
						break;
					default:
						pTile->m_iOccupyStatus = 0;
						break;
		}	}	}	}
		switch (m_pClientList[iClientH]->m_cSide) {
		case 1:	// Aresden 
			m_iHeldenianAresdenFlags++;
			break;
		case 2: // Elvine	
			m_iHeldenianElvineFlags++;				
			break;
		}
		wsprintf(G_cTxt, "PC(%s) \tused Flag...\t%s(%d %d)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cMapName
			, dX
			, dY);
		PutItemLogFileList(G_cTxt);
		PutLogEventFileList(G_cTxt);
		PutLogList(G_cTxt);	
		// Heldenian type 2 is won !
		if (   (m_pClientList[iClientH]->m_iGuildRank == 0)					// only by GuildMaster
			&& (m_pClientList[iClientH]->m_cSide != m_sLastHeldenianWinner) // only by attacker side
			&& (m_iGodHMapIndex == cMapIndex))								// only on GodHMap
		{	m_pClientList[iClientH]->m_iWarContribution   += (1000 * iEKNum); // double bonus for gm putting the flag...
			HeldenianVictoryNow(m_pClientList[iClientH]->m_cSide);
		}
		// give some Summon points in case the character was killed, he will be able to catch more scrolls..
		m_pClientList[iClientH]->m_iConstructionPoint += (1000 * iEKNum);
		m_pClientList[iClientH]->m_iWarContribution   += (100 * iEKNum);
		UpdateHeldenianStatus(-1);
		if (m_pClientList[iClientH]->m_iConstructionPoint > DEF_MAXHELDENIANSUMMONPOINT) m_pClientList[iClientH]->m_iConstructionPoint = DEF_MAXHELDENIANSUMMONPOINT;
	}else // bAutoFlag Flag set by server at Heldenian type 2 beginning
	{	if (m_cHeldenianType != 2) return FALSE;	
		switch (m_sLastHeldenianWinner) {
		case 1:	// Aresden:
			iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ARESDENFLAG1, cMapIndex, dX, dY, NULL, NULL);	
			break;
		case 2: // Elvine	
			iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ELVINEFLAG1, cMapIndex, dX, dY, NULL, NULL);	
			break;
		default: // Others
			return FALSE;
			break;
		}
		if (iDynamicObjectIndex == NULL) return FALSE;
		iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, 615, iDynamicObjectIndex);
		if (iIndex == -1) PutLogList("Error registering MasterOccupyFlag.");	
		for (ix = dX-20; ix <= dX+35; ix++) 
		for (iy = dY-20; iy <= dY+25; iy++) 
		{	if ((ix == dX) && (iy == dY)) 
			{}else 
			{	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);			
				if (pTile->m_iOccupyFlagIndex == NULL) 
				{	switch (m_sLastHeldenianWinner) {
					case 1:	// Aresden 
						pTile->m_iOccupyStatus -= 15; 
						break;
					case 2: // Elvine	
						pTile->m_iOccupyStatus += 15; 
						break;
					default:
						pTile->m_iOccupyStatus = 0;
						break;
		}	}	}	}	
		wsprintf(G_cTxt, "Server set Master Flag\t %s(%d %d)"
			, m_pMapList[cMapIndex]->m_cName
			, dX
			, dY);
		PutItemLogFileList(G_cTxt);
		PutLogEventFileList(G_cTxt);
		PutLogList(G_cTxt);	
	}
	return TRUE;
}

void CGame::SetSummonMobAction(int iClientH, int iMode, DWORD dwMsgSize, char *pData)
{ int i, iTargetIndex;
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;
	switch (iMode) {
	case 8: // Mobilize
		if (   (m_bIsHeldenianMode == TRUE)
			&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL)
			&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == 1))
		{	iRecoverFollowers(iClientH, TRUE);
		}
		break;	
	case 0: // Free 
	case 1: // Hold 
		for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) 
		{	if (   (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) 
				&& ((m_pNpcList[i]->m_bIsSummoned == TRUE) || (m_pNpcList[i]->m_dwTamingTime != 0) )
				&& (m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER) ) 
			{	m_pNpcList[i]->m_iSummonControlMode = iMode;
				m_pNpcList[i]->m_bIsPermAttackMode  = FALSE;
				m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
				m_pNpcList[i]->m_sBehaviorTurnCount = 0;
				m_pNpcList[i]->m_iTargetIndex       = NULL;
			}
		}
		break;	
	case 2:	// target
		if ((dwMsgSize)	<= 0) return;
		memcpy(cBuff, pData, dwMsgSize);
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
   	
		iTargetIndex = 0;
		if (token != NULL) 
		{	if (strlen(token) > 10) 
				 memcpy(cTargetName, token, 10);
			else memcpy(cTargetName, token, strlen(token));
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			{	if (   (m_pClientList[i] != NULL) 
					&& (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) 
					&& (strcmp(m_pClientList[iClientH]->m_cMapName, m_pClientList[i]->m_cMapName) == 0 ) ) 
				{	iTargetIndex = i;
					goto SSMA_SKIPSEARCH;
				}
			}
		}
SSMA_SKIPSEARCH:;
		if (   (iTargetIndex != 0) && (m_pClientList[iTargetIndex]->m_cSide != 0) 
			&& (m_pClientList[iTargetIndex]->m_cSide != m_pClientList[iClientH]->m_cSide) ) 
		{	for (i = 0; i < DEF_MAXNPCS; i++)
			if (m_pNpcList[i] != NULL) 
			{	if (   (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER)
					&& ((m_pNpcList[i]->m_bIsSummoned == TRUE) || (m_pNpcList[i]->m_dwTamingTime != 0) )
					&& (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH)) 
				{	m_pNpcList[i]->m_iSummonControlMode = iMode;
					m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
					m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[i]->m_iTargetIndex       = iTargetIndex;
					m_pNpcList[i]->m_cTargetType        = DEF_OWNERTYPE_PLAYER;
					m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;
				}
			}
		}
		delete pStrTok;
		break;
	}	
}

/*********************************************************************************************************************
**  BOOL CGame::GetOccupyFlagHandler(int iClientH)																	**
**  description		:: Buy the occupy Flag from commander										       				**
*********************************************************************************************************************/
void CGame::GetOccupyFlagHandler(int iClientH)
{int   i, iNum, iRet, iEraseReq, iEKNum;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 3) return;
	if (m_pClientList[iClientH]->m_cSide < 0) return;
	if (m_pClientList[iClientH]->m_cSide > 2) return;

	ZeroMemory(cItemName, sizeof(cItemName));
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: strcpy(cItemName, "AresdenFlag"); break;
	case 2: strcpy(cItemName, "ElvineFlag");  break;
	}
	// ReqPurchaseItemHandler
	iNum = 1;
	for (i = 1; i <= iNum; i++) 
	{	pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) 
		{	delete pItem;
		}else 
		{	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
			{	if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				if (m_pClientList[iClientH]->m_iEnemyKillCount > 10) 
				{	iEKNum = 10;
					m_pClientList[iClientH]->m_iEnemyKillCount -= 10;
				}else
				{	iEKNum = m_pClientList[iClientH]->m_iEnemyKillCount;
					m_pClientList[iClientH]->m_iEnemyKillCount = 0;
				}								
				// EKNum
				pItem->m_sItemSpecEffectValue2 = iEKNum;
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER; 
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1; 
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2; 
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3; 
				//testcode 
				wsprintf(G_cTxt, "(*) Get Flag : Char(%s) Flag-EK(%d) Player-EK(%d)"
					, m_pClientList[iClientH]->m_cCharName
					, iEKNum
					, m_pClientList[iClientH]->m_iEnemyKillCount);
				PutLogList(G_cTxt);
				PutItemLogFileList(G_cTxt);	
				PutLogEventFileList(G_cTxt); 
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp = 1;
				cp++;				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;				
				*cp = pItem->m_cItemType;
				cp++;				
				*cp = pItem->m_cEquipPos;
				cp++;				
				*cp = (char)0;  
				cp++;				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;				
				*cp = pItem->m_cGenderLimit;
				cp++;				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;
				*cp = pItem->m_cItemColor;
				cp++;
				*cp = (char)pItem->m_sItemSpecEffectValue2;
				cp++;					
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
														
				if (iEraseReq == 1) delete pItem;				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				iCalcTotalWeight(iClientH);				
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
			}else 
			{	delete pItem;
				iCalcTotalWeight(iClientH);
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
 	}	}	}	}
}



// v1.4311-3         GetFightzoneTicketHandler 
void CGame::GetFightzoneTicketHandler(int iClientH)
{
 int   iRet, iEraseReq, iMonth, iDay, iHour;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;
 
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iFightZoneTicketNumber <= 0) { 
		//    .
		//         ..
		m_pClientList[iClientH]->m_iFightzoneNumber  *= -1;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -1, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cItemName, sizeof(cItemName));

	if (m_pClientList[iClientH]->m_iFightzoneNumber == 1) 
		strcpy(cItemName,"ArenaTicket") ;
	else  wsprintf(cItemName,"ArenaTicket(%d)",m_pClientList[iClientH]->m_iFightzoneNumber ) ;

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, cItemName) == FALSE) {
		delete pItem;
		return;	
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		//   
		if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
			
		//          . 
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = m_pClientList[iClientH]->m_iFightZoneTicketNumber -1 ;
				
		pItem->m_sTouchEffectType   = DEF_ITET_DATE;
		
		iMonth = m_pClientList[iClientH]->m_iReserveTime / 10000 ;
		iDay = (m_pClientList[iClientH]->m_iReserveTime - iMonth*10000) /100 ;
	    iHour = m_pClientList[iClientH]->m_iReserveTime - iMonth*10000 - iDay*100 ;

		pItem->m_sTouchEffectValue1 = iMonth ;
		pItem->m_sTouchEffectValue2 = iDay ;
		pItem->m_sTouchEffectValue3 = iHour ;
		
		
		wsprintf(G_cTxt, "(*) Get FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)(%d)(%d)", m_pClientList[iClientH]->m_cCharName, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3	);		
		PutLogFileList(G_cTxt);
		PutLogList(G_cTxt);

		ZeroMemory(cData, sizeof(cData));

		//    .
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		// 1 .
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
				
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
				
		*cp = pItem->m_cItemType;
		cp++;
				
		*cp = pItem->m_cEquipPos;
		cp++;
				
		*cp = (char)0; //    .
		cp++;
				
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
				
		*cp = pItem->m_cGenderLimit;
		cp++;
				
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
				
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
				
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
				
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
				
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
													
		if (iEraseReq == 1) delete pItem;
				
		//    
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				
		//      
		iCalcTotalWeight(iClientH);
				
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
				//     .
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}	
	else {
		//      .
		delete pItem;

		//      
		iCalcTotalWeight(iClientH);

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
			//     .
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}		
}

int CGame::_iComposeFlagStatusContents(char * pData)
{
 SYSTEMTIME SysTime;
 char cTxt[120];
 int i;

	if (m_iMiddlelandMapIndex < 0) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");
	
	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");
	
	// 
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++) 
	if (m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i] != NULL) { 
		
		wsprintf(cTxt,"flag = %d %d %d %d", m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_cSide,
										    m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sX,
										    m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sY,
			                                m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_iEKCount);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}

	strcat(pData, "\n\n");

	return strlen(pData);
}


BOOL CGame::_bDecodeOccupyFlagSaveFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token;
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iFlagIndex = 0;
 int  iSide;
 class CStrTok * pStrTok;
 int dX, dY, iEKNum, iTotalFlags;

	if (m_iMiddlelandMapIndex < 0) {
		PutLogList("(!) This game server does not managing Middleland Map. OcuupyFlag data ignored.");
		return FALSE;
	}

	iTotalFlags = 0;

	pContents = new char[dwMsgSize+10];
	ZeroMemory(pContents, dwMsgSize+10);
	memcpy(pContents, pData, dwMsgSize - 9);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Side
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					iSide = atoi(token);
					cReadModeB = 2;
					break;
				
				case 2:
					// X  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					dX = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Y   
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					dY = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// EKNum
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					iEKNum = atoi(token);
					
					//     . (!!! Master Flag    )
					if (__bSetOccupyFlag(m_iMiddlelandMapIndex, dX, dY, iSide, iEKNum, -1, TRUE) == TRUE)
						iTotalFlags++;
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				
			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "flag", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file contents error!");
		return FALSE;
	}

	wsprintf(G_cTxt, "(!) OccupyFlag save file decoding success! Total(%d)", iTotalFlags); 
	PutLogList(G_cTxt);

	return TRUE;
}
//Hero Code by Zabuza - fixed by Centu
void CGame::GetHeroMantleHandler(int iClientH,int iItemID,char * pString) 
{ 
 int   i, iNum, iRet, iEraseReq; 
 char  * cp, cData[256], cItemName[21]; 
 class CItem * pItem; 
 DWORD * dwp; 
 short * sp; 
 WORD  * wp; 

	if (m_pClientList[iClientH] == NULL) return; 
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 100) return; 
	if (m_pClientList[iClientH]->m_iContribution < 10) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;
	
	if (_iGetItemSpaceLeft(iClientH) == 0) {
		SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
		return;
	}

	//Prevents a crash if item dosent exist
	if (m_pItemConfigList[iItemID] == NULL)  return;

	switch(iItemID) { 
	// Hero Cape
	case 400: //Aresden HeroCape
	case 401: //Elvine HeroCape
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 300) return; 
		m_pClientList[iClientH]->m_iEnemyKillCount -= 300; 
		break;
	}

	// Da el item correspondiente dependiendo el sexo del personaje, centu.
	switch (m_pClientList[iClientH]->m_cSex) {
	case 1:
		switch(iItemID) { 
		// Hero Helm
		case 403: //Aresden HeroHelm(M)
		case 405: //Elvine HeroHelm(M)
			if (m_pClientList[iClientH]->m_iEnemyKillCount < 150 || m_pClientList[iClientH]->m_iContribution < 20) return; 
			m_pClientList[iClientH]->m_iEnemyKillCount -= 150; 
			m_pClientList[iClientH]->m_iContribution -= 20; 
			break;
		// Hero Cap
		case 407: //Aresden HeroCap(M)
		case 409: //Elvine HeroCap(M)
			if (m_pClientList[iClientH]->m_iEnemyKillCount < 100 || m_pClientList[iClientH]->m_iContribution < 20) return;  
			m_pClientList[iClientH]->m_iEnemyKillCount -= 100;
			m_pClientList[iClientH]->m_iContribution -= 20; 
			break;
		// Hero Armour
		case 411: //Aresden HeroArmour(M)
		case 413: //Elvine HeroArmour(M)
			if (m_pClientList[iClientH]->m_iEnemyKillCount < 300 || m_pClientList[iClientH]->m_iContribution < 30) return;  
			m_pClientList[iClientH]->m_iEnemyKillCount -= 300;
			m_pClientList[iClientH]->m_iContribution -= 30; 
			break; 
		// Hero Robe
		case 415: //Aresden HeroRobe(M)
		case 417: //Elvine HeroRobe(M)
			if (m_pClientList[iClientH]->m_iEnemyKillCount < 200 || m_pClientList[iClientH]->m_iContribution < 20) return;  
			m_pClientList[iClientH]->m_iEnemyKillCount -= 200;
			m_pClientList[iClientH]->m_iContribution -= 20; 
			break;
		// Hero Hauberk
		case 419: //Aresden HeroHauberk(M)
		case 421: //Elvine HeroHauberk(M)
			if (m_pClientList[iClientH]->m_iEnemyKillCount < 100 || m_pClientList[iClientH]->m_iContribution < 10) return;  
			m_pClientList[iClientH]->m_iEnemyKillCount -= 100;
			m_pClientList[iClientH]->m_iContribution -= 10; 
			break;
		// Hero Leggings
		case 423: //Aresden HeroLeggings(M)
		case 425: //Elvine HeroLeggings(M)
			if (m_pClientList[iClientH]->m_iEnemyKillCount < 150 || m_pClientList[iClientH]->m_iContribution < 15) return;
			m_pClientList[iClientH]->m_iEnemyKillCount -= 150;  
			m_pClientList[iClientH]->m_iContribution -= 15; 
			break; 
		default: 
			break;
		}
		break;

	case 2:
		switch(iItemID) {
		case 404: //Aresden HeroHelm(W)
		case 406: //Elvine HeroHelm(W)
			if (m_pClientList[iClientH]->m_iEnemyKillCount < 150 || m_pClientList[iClientH]->m_iContribution < 20) return; 
			m_pClientList[iClientH]->m_iEnemyKillCount -= 150; 
			m_pClientList[iClientH]->m_iContribution -= 20; 
			break; 
		case 408: //Aresden HeroCap(W)
		case 410: //Elvine HeroCap(W)
			if (m_pClientList[iClientH]->m_iEnemyKillCount < 100 || m_pClientList[iClientH]->m_iContribution < 20) return; 
			m_pClientList[iClientH]->m_iEnemyKillCount -= 100; 
			m_pClientList[iClientH]->m_iContribution -= 20; 
			break;
		case 412: //Aresden HeroArmour(W)
		case 414: //Elvine HeroArmour(W)
			if (m_pClientList[iClientH]->m_iEnemyKillCount < 300 || m_pClientList[iClientH]->m_iContribution < 30) return;  
			m_pClientList[iClientH]->m_iEnemyKillCount -= 300;
			m_pClientList[iClientH]->m_iContribution -= 30; 
			break; 
		case 416: //Aresden HeroRobe(W)
		case 418: //Elvine HeroRobe(W)
			if (m_pClientList[iClientH]->m_iEnemyKillCount < 200 || m_pClientList[iClientH]->m_iContribution < 20) return; 
			m_pClientList[iClientH]->m_iEnemyKillCount -= 200; 
			m_pClientList[iClientH]->m_iContribution -= 20; 
			break;
		case 420: //Aresden HeroHauberk(W)
		case 422: //Elvine HeroHauberk(W)
			if (m_pClientList[iClientH]->m_iEnemyKillCount < 100 || m_pClientList[iClientH]->m_iContribution < 10) return;  
			m_pClientList[iClientH]->m_iEnemyKillCount -= 100;
			m_pClientList[iClientH]->m_iContribution -= 10;
			break; 
		case 424: //Aresden HeroLeggings(W)
		case 426: //Elvine HeroLeggings(W)
			if (m_pClientList[iClientH]->m_iEnemyKillCount < 150 || m_pClientList[iClientH]->m_iContribution < 15) return; 
			m_pClientList[iClientH]->m_iEnemyKillCount -= 150; 
			m_pClientList[iClientH]->m_iContribution -= 15; 
			break; 

		default: 
			break; 
		}
		break;
	}

	ZeroMemory(cItemName, sizeof(cItemName)); 
	memcpy(cItemName,m_pItemConfigList[iItemID]->m_cName,20); 
	// ReqPurchaseItemHandler
	iNum = 1; 
	for (i = 1; i <= iNum; i++) { 
		pItem = new class CItem; 
		if (_bInitItemAttr(pItem, cItemName) == FALSE) { 
			delete pItem; 
		} 
		else {                                
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) { 
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;            
				
				wsprintf(G_cTxt, "(*) Get HeroItem : Char(%s) Player-EK(%d) Player-Contr(%d) Hero Obtained(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iEnemyKillCount, m_pClientList[iClientH]->m_iContribution,cItemName); 
				PutLogFileList(G_cTxt); 

				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER; 
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1; 
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2; 
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3; 

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID); 
				*dwp = MSGID_NOTIFY; 
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE); 
				*wp  = DEF_NOTIFY_ITEMOBTAINED; 
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2); 

				*cp = 1; 
				cp++; 
            
				memcpy(cp, pItem->m_cName, 20); 
				cp += 20; 
            
				dwp  = (DWORD *)cp; 
				*dwp = pItem->m_dwCount; 
				cp += 4; 
            
				*cp = pItem->m_cItemType; 
				cp++; 
            
				*cp = pItem->m_cEquipPos; 
				cp++; 
            
				*cp = (char)0;
				cp++; 
            
				sp  = (short *)cp; 
				*sp = pItem->m_sLevelLimit; 
				cp += 2; 
            
				*cp = pItem->m_cGenderLimit; 
				cp++; 
            
				wp = (WORD *)cp; 
				*wp = pItem->m_wCurLifeSpan; 
				cp += 2; 
            
				wp = (WORD *)cp; 
				*wp = pItem->m_wWeight; 
				cp += 2; 
            
				sp  = (short *)cp; 
				*sp = pItem->m_sSprite; 
				cp += 2; 
            
				sp  = (short *)cp; 
				*sp = pItem->m_sSpriteFrame; 
				cp += 2; 

				*cp = pItem->m_cItemColor; 
				cp++; 

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++; 
            
				dwp = (DWORD *)cp; 
				*dwp = pItem->m_dwAttribute; 
				cp += 4;      
                                 
				if (iEraseReq == 1) delete pItem; 
            
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53); 
            
				iCalcTotalWeight(iClientH); 
            
				switch (iRet) { 
				case DEF_XSOCKEVENT_QUENEFULL: 
				case DEF_XSOCKEVENT_SOCKETERROR: 
				case DEF_XSOCKEVENT_CRITICALERROR: 
				case DEF_XSOCKEVENT_SOCKETCLOSED: 
					DeleteClient(iClientH, TRUE, TRUE); 
					return; 
				} 

				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL); 
			} 
			else { 
				delete pItem; 

				iCalcTotalWeight(iClientH); 

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID); 
				*dwp = MSGID_NOTIFY; 
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE); 
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM; 
            
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6); 
				switch (iRet) { 
				case DEF_XSOCKEVENT_QUENEFULL: 
				case DEF_XSOCKEVENT_SOCKETERROR: 
				case DEF_XSOCKEVENT_CRITICALERROR: 
				case DEF_XSOCKEVENT_SOCKETCLOSED: 
					DeleteClient(iClientH, TRUE, TRUE); 
					return; 
				} 
			} 
		} 
	} 
}

void CGame::_SetItemPos(int iClientH, char *pData)
{
 char * cp, cItemIndex;
 short * sp, sX, sY;

	if (m_pClientList[iClientH] == NULL) return;
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cItemIndex = *cp;
	cp++;

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	//    
	if (sY < -10) sY = -10; 

	if ((cItemIndex < 0) || (cItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemIndex] != NULL) {
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].x = sX;
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].y = sY;
	}
}

void CGame::CheckUniqueItemEquipment(int iClientH)
{
 int i, iDamage;

	if (m_pClientList[iClientH] == NULL) return;
	// v1.3     .       .

	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) &&
			 (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) ) {
			// Touch Effect Type DEF_ITET_OWNER Touch Effect Value 1, 2, 3    . 
						
			if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
				 (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
				 (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3) ) {
				// ID  .
			}
			else {
				//     .
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
				ReleaseItemHandler(iClientH, i, TRUE);
				// v1.4  . 
				iDamage = iDice(10, 10);
				m_pClientList[iClientH]->m_iHP -= iDamage;
				if (m_pClientList[iClientH]->m_iHP <= 0) {
					ClientKilledHandler(iClientH, NULL, NULL, iDamage);
				}
			}
		}
	}
}

void CGame::_BWM_Init(int iClientH, char *pData)
{
	if (m_pClientList[iClientH] == NULL) return;

	m_pClientList[iClientH]->m_bIsBWMonitor = TRUE;
	wsprintf(G_cTxt, "(*) BWMonitor(%d) registered.", iClientH);
	PutLogList(G_cTxt);
}

void CGame::_BWM_Command_Shutup(char *pData)
{
 char * cp, cName[11];
 int i;

	cp = (char *)(pData + 16);

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);

	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0) {
			m_pClientList[i]->m_iTimeLeft_ShutUp = 20*3*10; // 1 3. 20 1     10  
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, 20*3*10, NULL, NULL, cName);
			
			// Admin Log
			wsprintf(G_cTxt, "BWordMonitor shutup(%s %d)", cName, 20*3*10);
			PutAdminLogFileList(G_cTxt);

			return;
		}
	}
}

int CGame::_iGetItemSpaceLeft(int iClientH)
{
 int i, iTotalItem;

	iTotalItem = 0;
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) iTotalItem++;

	return (DEF_MAXITEMS - iTotalItem);
}

BOOL CGame::bAddItem(int iClientH, CItem * pItem, char cMode)
{
 char * cp, cData[256];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int iRet, iEraseReq;


	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		//  .
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1 . Amount !
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;	//   
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; //    .
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		
		
		if (iEraseReq == 1) {
			delete pItem;
			pItem = NULL;
		}
		
		//    
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		
		return TRUE;
	}
	else {
		//         .
		//    . 
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                         m_pClientList[iClientH]->m_sY, 
			                                                         pItem);
		
		//      . 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color
		
		//     .
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		
		return TRUE;
	}

	return FALSE;
}


int CGame::_iTalkToNpcResult_Cityhall(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
 int iQuest, iEraseReq;
 class CItem * pItem;
 unsigned long iExp;

	// Return Code
	// -1  :   
	// -2  :       .    
	// -3  :     .
	// -4  :     .     

	//    .      . 
	if (m_pClientList[iClientH] == NULL) return 0;

	if (m_pClientList[iClientH]->m_iQuest != NULL) {
		if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest] == NULL) return -4;
		else if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iFrom == 4) {
			//    .     -5 .
			if (m_pClientList[iClientH]->m_bIsQuestCompleted == TRUE) {
				//    (    )     .
				//     -5 .
				if ( (m_pClientList[iClientH]->m_iQuestRewardType > 0) &&
					 (m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType] != NULL) ) {
					//   .      .
					pItem = new class CItem;
					_bInitItemAttr(pItem, m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName);
					pItem->m_dwCount = m_pClientList[iClientH]->m_iQuestRewardAmount;
					if (_bCheckItemReceiveCondition(iClientH, pItem) == TRUE) {
						//      . .
						_bAddClientItemList(iClientH, pItem, &iEraseReq);
						SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, NULL);
						if (iEraseReq == 1) delete pItem;
						
						//   
						m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

						//      .   .
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							          m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);
						
						_ClearQuestStatus(iClientH);
						return -5;
					} 
					else {
						delete pItem;
						//        
						SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);

						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 0, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							          m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);

						return -5;
					}
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -1) {
					//   . 
					GetExp(iClientH, iDice(1, m_pClientList[iClientH]->m_iQuestRewardAmount));
					//   
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							      "              ", m_pClientList[iClientH]->m_iContribution);
					
					//   .
					_ClearQuestStatus(iClientH);
					return -5;
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -2) {
					//        * m_pClientList[iClientH]->m_iQuestRewardAmount   .
					//***
					iExp = (iDice(1, (10*m_pClientList[iClientH]->m_iLevel)) * m_pClientList[iClientH]->m_iQuestRewardAmount);
					
					GetExp(iClientH, iDice(1, iExp));
					//   
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, iExp, 
							      "              ", m_pClientList[iClientH]->m_iContribution);
					
					//   .
					_ClearQuestStatus(iClientH);
					return -5;
				}
				else {
					//   .  .
					//   
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, 0, 
							      "                     ", m_pClientList[iClientH]->m_iContribution);
					
					//   .
					_ClearQuestStatus(iClientH);
					return -5;
				}
			}
			else return -1;
		}
		
		return -4;	//  NPC   .     .   .
	}
	
	//     .      . 
	if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) == 0) {
		//   . 
		//     . 
		if (m_pClientList[iClientH]->m_iPKCount > 0) return -3;
		
		iQuest = __iSearchForQuest(iClientH, 4, pQuestType, pMode, pRewardType, pRewardAmount, pContribution, pTargetName, pTargetType, pTargetCount, pX, pY, pRange);
		if (iQuest <= 0) return -4;

		//  . 
		return iQuest;
	}
	else return -2; //     .

	return -4;
}


int CGame::_iTalkToNpcResult_Guard(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
	//  .      .
	if (m_pClientList[iClientH] == NULL) return 0;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
		//      
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			//     .
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (200), NULL, NULL, NULL, NULL);
			return 1000;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elv", 3) == 0) {
			//     .	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (201), NULL, NULL, NULL, NULL);
			return 1001;
		}
	}
	else
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			//     .	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (202), NULL, NULL, NULL, NULL);
			return 1002;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elv", 3) == 0) {
			//     .
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (203), NULL, NULL, NULL, NULL);
			return 1003;
		}
	}
	else
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			//     
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (204), NULL, NULL, NULL, NULL);
			return 1004;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
			//     .
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (205), NULL, NULL, NULL, NULL);
			return 1005;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "default", 7) == 0) {
			//  
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (206), NULL, NULL, NULL, NULL);
			return 1006;
		}
	}

	return 0;
}


BOOL CGame::_bDecodeQuestConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iQuestConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					//   
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pQuestConfigList[atoi(token)] != NULL) {
						//    . .
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Duplicate quest number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[atoi(token)] = new class CQuest;
					iQuestConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					//    
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_cSide = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					//    
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// TargetType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iTargetType = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// MaxCount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxCount= atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iFrom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMinLevel = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxLevel = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillNum = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillLevel = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iTimeLimit = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iAssignType = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[1] = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[1] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[2] = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[2] = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[3] = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[3] = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iContribution = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iContributionLimit = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iResponseMode = atoi(token);
					cReadModeB = 22;
					break;

				case 22:
					ZeroMemory(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, sizeof(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName));
					strcpy(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, token);
					cReadModeB = 23;
					break;

				case 23:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_sX = atoi(token);
					cReadModeB = 24;
					break;

				case 24:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_sY = atoi(token);
					cReadModeB = 25;
					break;

				case 25:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRange = atoi(token);
					cReadModeB = 26;
					break;

				case 26:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iQuestID = atoi(token);
					cReadModeB = 27;
					break;

				case 27:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iReqContribution = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "quest", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) QUEST(Total:%d) configuration - success!", iQuestConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}


int CGame::__iSearchForQuest(int iClientH, int iWho, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
 int i, iQuestList[DEF_MAXQUESTTYPE], iIndex, iQuest, iReward, iQuestIndex;

	if (m_pClientList[iClientH] == NULL) return -1;
 
	//    .
	iIndex = 0;
	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		iQuestList[i] = -1;

	for (i = 1; i < DEF_MAXQUESTTYPE; i++) 
	if (m_pQuestConfigList[i] != NULL) {
		
		if (m_pQuestConfigList[i]->m_iFrom != iWho) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iMinLevel > m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iMaxLevel < m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iReqContribution > m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

		if (m_pQuestConfigList[i]->m_iRequiredSkillNum != -1) {
			//    . 
			if (m_pClientList[iClientH]->m_cSkillMastery[m_pQuestConfigList[i]->m_iRequiredSkillNum] < 
				m_pQuestConfigList[i]->m_iRequiredSkillLevel) goto SFQ_SKIP;
		}
		
		//     1  .
		if ((m_bIsCrusadeMode == TRUE) && (m_pQuestConfigList[i]->m_iAssignType != 1)) goto SFQ_SKIP; 
		//      1  .
		if ((m_bIsCrusadeMode == FALSE) && (m_pQuestConfigList[i]->m_iAssignType == 1)) goto SFQ_SKIP; 

		if (m_pQuestConfigList[i]->m_iContributionLimit < m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

		//     . . 
		iQuestList[iIndex] = i;
		iIndex++;

SFQ_SKIP:;
	}

	// iIndex     .    1 .
	if (iIndex == 0) return -1;
	iQuest		 = (iDice(1, iIndex)) - 1;
	iQuestIndex  = iQuestList[iQuest];
	//   
	iReward = iDice(1,3);
	*pMode = m_pQuestConfigList[iQuestIndex]->m_iResponseMode;					//    
	*pRewardType   = m_pQuestConfigList[iQuestIndex]->m_iRewardType[iReward];	//    
	*pRewardAmount = m_pQuestConfigList[iQuestIndex]->m_iRewardAmount[iReward];	//    
	*pContribution = m_pQuestConfigList[iQuestIndex]->m_iContribution;			//     
	
	strcpy(pTargetName, m_pQuestConfigList[iQuestIndex]->m_cTargetName);			//     
	*pX     = m_pQuestConfigList[iQuestIndex]->m_sX;
	*pY     = m_pQuestConfigList[iQuestIndex]->m_sY;
	*pRange = m_pQuestConfigList[iQuestIndex]->m_iRange;

	*pTargetType  = m_pQuestConfigList[iQuestIndex]->m_iTargetType;
	*pTargetCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
	*pQuestType   = m_pQuestConfigList[iQuestIndex]->m_iType;

	return iQuestIndex;
}

// New 14/05/2004
void CGame::QuestAcceptedHandler(int iClientH)
{
 int iIndex;

	if (m_pClientList[iClientH] == NULL) return;
	
	// Does the quest exist ??
	if(m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest] == NULL) return;

	if (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iAssignType == 1) {
		//  . 
		switch (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iType) {
		case 10: //  1 .   .    .
			_ClearQuestStatus(iClientH);
			RequestTeleportHandler(iClientH, "2   ", m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_cTargetName,
				                   m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sX, m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sY);
			return;
		}
	}

	//   .  , ID .
	m_pClientList[iClientH]->m_iQuest = m_pClientList[iClientH]->m_iAskedQuest;
	iIndex = m_pClientList[iClientH]->m_iQuest;
	m_pClientList[iClientH]->m_iQuestID = m_pQuestConfigList[iIndex]->m_iQuestID;
	m_pClientList[iClientH]->m_iCurQuestCount    = 0;
	m_pClientList[iClientH]->m_bIsQuestCompleted = FALSE;
	
	_CheckQuestEnvironment(iClientH);
	_SendQuestContents(iClientH);
}


void CGame::_SendQuestContents(int iClientH)
{
 int iWho, iIndex, iQuestType, iContribution, iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted;
 char cTargetName[21];

	if (m_pClientList[iClientH] == NULL) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) {
		//  Quest . 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCONTENTS, NULL, NULL, NULL, NULL,  
		              NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	}
	else {
		//  Quest  .
		iWho          = m_pQuestConfigList[iIndex]->m_iFrom;
		iQuestType    = m_pQuestConfigList[iIndex]->m_iType;
		iContribution = m_pQuestConfigList[iIndex]->m_iContribution;
		iTargetType   = m_pQuestConfigList[iIndex]->m_iTargetType;
		iTargetCount  = m_pQuestConfigList[iIndex]->m_iMaxCount;
		iX            = m_pQuestConfigList[iIndex]->m_sX;
		iY            = m_pQuestConfigList[iIndex]->m_sY;
		iRange        = m_pQuestConfigList[iIndex]->m_iRange;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		iQuestCompleted = (int)m_pClientList[iClientH]->m_bIsQuestCompleted;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCONTENTS, iWho, iQuestType, iContribution, NULL,  
			          iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cTargetName);
	}
}

void CGame::_CheckQuestEnvironment(int iClientH)
{
 int iIndex;
 char cTargetName[21];

	if (m_pClientList[iClientH] == NULL) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) return;
	if (m_pQuestConfigList[iIndex] == NULL) return;

	if (iIndex >= 35 && iIndex <= 40) {
		m_pClientList[iClientH]->m_iQuest = 0;
		m_pClientList[iClientH]->m_iQuestID = NULL;
		m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
		m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
		return;
	}

	if (m_pQuestConfigList[iIndex]->m_iQuestID != m_pClientList[iClientH]->m_iQuestID) {
		//  ID  .    .  .
		m_pClientList[iClientH]->m_iQuest   = NULL;
		m_pClientList[iClientH]->m_iQuestID = NULL;
		m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
		m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
		return;
	}

	switch (m_pQuestConfigList[iIndex]->m_iType) {
	case DEF_QUESTTYPE_MONSTERHUNT:
	case DEF_QUESTTYPE_GOPLACE:
		//               ,   . 
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cTargetName, 10) == 0)
			 m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = TRUE;
		else m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = FALSE;
		break;
	}

}

BOOL CGame::_bCheckIsQuestCompleted(int iClientH)
{
 int iQuestIndex;

	//      .
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsQuestCompleted == TRUE) return FALSE;
	iQuestIndex = m_pClientList[iClientH]->m_iQuest;
	if (iQuestIndex == NULL) return FALSE;
		
	if (m_pQuestConfigList[iQuestIndex] != NULL) {
		switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
		case DEF_QUESTTYPE_MONSTERHUNT:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == TRUE) && 
				 (m_pClientList[iClientH]->m_iCurQuestCount >= m_pQuestConfigList[iQuestIndex]->m_iMaxCount) ) {
				//    .      . 
				m_pClientList[iClientH]->m_bIsQuestCompleted = TRUE;					
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
				return TRUE;
			}
			break;

		case DEF_QUESTTYPE_GOPLACE:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == TRUE) && //  
				 (m_pClientList[iClientH]->m_sX >= m_pQuestConfigList[iQuestIndex]->m_sX - m_pQuestConfigList[iQuestIndex]->m_iRange) && //   
				 (m_pClientList[iClientH]->m_sX <= m_pQuestConfigList[iQuestIndex]->m_sX + m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				 (m_pClientList[iClientH]->m_sY >= m_pQuestConfigList[iQuestIndex]->m_sY - m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				 (m_pClientList[iClientH]->m_sY <= m_pQuestConfigList[iQuestIndex]->m_sY + m_pQuestConfigList[iQuestIndex]->m_iRange) ) {
				//     .
				m_pClientList[iClientH]->m_bIsQuestCompleted = TRUE;					
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
				return TRUE;
			}
			break;
		}
	}

	return FALSE;
}

int CGame::_iTalkToNpcResult_GuildHall(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_GShop(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_BSmith(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_WHouse(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_WTower(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

void CGame::SendItemNotifyMsg(int iClientH, WORD wMsgType, CItem *pItem, int iV1)
{
 char  * cp, cData[512];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int     iRet;

	if (m_pClientList[iClientH] == NULL) return;

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	switch (wMsgType) {
	case DEF_NOTIFY_ITEMOBTAINED:
		*cp = 1; // 1 . <-  1     
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; //    .
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor; // v1.4
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		break;
	
	case DEF_NOTIFY_ITEMPURCHASED:
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; //    .
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;
		
		wp  = (WORD *)cp;
		*wp = iV1; 
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case DEF_NOTIFY_CANNOTCARRYMOREITEM:
		iRet =m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		break;
	}
}

BOOL CGame::_bCheckItemReceiveCondition(int iClientH, CItem *pItem)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	
	if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount) > (DWORD)_iCalcMaxLoad(iClientH)) 
		return FALSE;
		
	//     .
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) return TRUE;

	return FALSE;
}

void CGame::_ClearQuestStatus(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	m_pClientList[iClientH]->m_iQuest   = NULL;
	m_pClientList[iClientH]->m_iQuestID = NULL;
	m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
	m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
	m_pClientList[iClientH]->m_bIsQuestCompleted  = FALSE;
}


int CGame::iGetMaxHP(int iClientH, BOOL bBloodEffect)
{int iRet;
	if (m_pClientList[iClientH] == NULL) return 0;
	// Changed to this due to patch in client that in case of odd level and Str gives 1 more HP.
	iRet = (3*m_pClientList[iClientH]->m_iVit) + (2*m_pClientList[iClientH]->m_iLevel) + ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr)/2);

	if ((bBloodEffect == TRUE) && (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0))
		iRet = iRet - (iRet/m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

	return iRet;
}

int CGame::iGetMaxMP(int iClientH)
{
 int iRet;

	if (m_pClientList[iClientH] == NULL) return 0;

	iRet = (2*(m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag)) + (2*m_pClientList[iClientH]->m_iLevel) + ((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt)/2);
	
	return iRet;
}

int CGame::iGetMaxSP(int iClientH)
{
 int iRet;

	if (m_pClientList[iClientH] == NULL) return 0;

	iRet = (2*(m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr)) + (2*m_pClientList[iClientH]->m_iLevel);
	
	return iRet;
}

void CGame::GetMapInitialPoint(int iMapIndex, short *pX, short *pY, char * pPlayerLocation)
{
 int i, iTotalPoint;
 POINT  pList[DEF_MAXINITIALPOINT];

	if (m_pMapList[iMapIndex] == NULL) return;

	//  .
	iTotalPoint = 0;
	for (i = 0; i < DEF_MAXINITIALPOINT; i++)
	if (m_pMapList[iMapIndex]->m_pInitialPoint[i].x != -1) {
		pList[iTotalPoint].x = m_pMapList[iMapIndex]->m_pInitialPoint[i].x;
		pList[iTotalPoint].y = m_pMapList[iMapIndex]->m_pInitialPoint[i].y;
		iTotalPoint++;
	}

	if (iTotalPoint == 0) return;

	// v1.42    Initial Point  .
	if ((pPlayerLocation != NULL) && (memcmp(pPlayerLocation, "NONE", 4) == 0)) 
		 i = 0;
	else i = iDice(1, iTotalPoint) - 1;

	*pX = pList[i].x;
	*pY = pList[i].y;
}



void CGame::_CheckStrategicPointOccupyStatus(char cMapIndex)
{
 class CTile * pTile;
 int i, iX, iY, iSide, iValue;

	m_iStrategicStatus = 0;

	for (i = 0; i < DEF_MAXSTRATEGICPOINTS; i++)
	if (m_pMapList[cMapIndex]->m_pStrategicPointList[i] != NULL) {
	
		iSide  = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iSide;
		iValue = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iValue;
		iX = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iX;
		iY = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iY;

		pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + iX + iY*m_pMapList[cMapIndex]->m_sSizeY);

		//     . 
		m_iStrategicStatus += pTile->m_iOccupyStatus * iValue;
	}
}

#ifdef DEF_DBGAMESERVER
void CGame::OnSubLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 UINT iTmp;
 register int iLogSockH, iRet;

	iTmp = (WM_ONLOGSOCKETEVENT + 1);
	iLogSockH = message - iTmp;
	
	if (m_pSubLogSock[iLogSockH] == NULL) return;

	iRet = m_pSubLogSock[iLogSockH]->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:


		wsprintf(G_cTxt, "(!!!) Log Socket Connection Established Log#(%d) Address:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iGateServerPort);
		PutLogList(G_cTxt);

		m_bIsSubLogSockAvailable[iLogSockH] = TRUE;
		if((m_iSubLogSockFailCount + m_iSubLogSockActiveCount) > DEF_MAXSUBLOGSOCK && m_iSubLogSockFailCount > 0) m_iSubLogSockFailCount--;
    break;
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) connected.", iLogSockH);
		PutLogList(G_cTxt);
		m_iCurSubLogSockIndex = iLogSockH;
		if(!m_bIsGameServerRegistered) bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
        else bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVERSOCKET, NULL);
		m_bIsSocketConnected[iLogSockH] = TRUE;
		m_iSubLogSockActiveCount++;
		m_iSubLogSockInitIndex++;
	break;

	case DEF_XSOCKEVENT_READCOMPLETE:
		OnSubLogRead(iLogSockH);
	break;
	
	case DEF_XSOCKEVENT_BLOCK:
		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) BLOCKED!", iLogSockH);
		PutLogList(G_cTxt);
	break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		delete m_pSubLogSock[iLogSockH];
		m_pSubLogSock[iLogSockH] = NULL;
		m_bIsSubLogSockAvailable[iLogSockH] = FALSE;
		
		m_iSubLogSockFailCount++;
		m_iSubLogSockActiveCount--;

        if(m_iSubLogSockActiveCount == 0) m_bIsGameServerRegistered = FALSE;
			wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) connection lost!", iLogSockH);
			PutLogList(G_cTxt);
			m_bIsSocketConnected[iLogSockH] = FALSE;
		break;
	}
}

void CGame::OnSubLogRead(int iIndex)
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pSubLogSock[iIndex]->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}

BOOL CGame::_bCheckSubLogSocketIndex()
{
	for(BYTE b = 0; b < DEF_MAXSUBLOGSOCK; b++){
		if ((m_pSubLogSock[b] != NULL) && (m_bIsSubLogSockAvailable[b] == TRUE)) break; 
		if(b >= (DEF_MAXSUBLOGSOCK-1)){
			if(m_bOnExitProcess == FALSE){
				m_cShutDownCode      = 3;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost)!!!");
			}
			return FALSE;
		}
	}
	m_iCurSubLogSockIndex++;
	while(1){
		if(m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK || m_iCurSubLogSockIndex == 0) m_iCurSubLogSockIndex = 1;
		if ((m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) && (m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] == TRUE) && (!m_pSubLogSock[m_iCurSubLogSockIndex]->IsSocketInUse)) break;
	    else m_iCurSubLogSockIndex++;
	}
    return TRUE;
}
#else
void CGame::OnSubLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 UINT iTmp;
 int iLogSockH, iRet;

	iTmp = (WM_ONLOGSOCKETEVENT + 1);
	iLogSockH = message - iTmp;
	
	if (m_pSubLogSock[iLogSockH] == NULL) return;

	iRet = m_pSubLogSock[iLogSockH]->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:
		wsprintf(G_cTxt, "(!!!) Log Socket Connection Established Log#(%d) Address:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);

		m_bIsSubLogSockAvailable[iLogSockH] = TRUE;
		m_iSubLogSockActiveCount++;
		break;

	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		//    .
		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) connected.", iLogSockH);
		PutLogList(G_cTxt);
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		//  . 
		OnSubLogRead(iLogSockH);
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) BLOCKED!", iLogSockH);
		PutLogList(G_cTxt);
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		//  .
		delete m_pSubLogSock[iLogSockH];
		m_pSubLogSock[iLogSockH] = NULL;
		m_bIsSubLogSockAvailable[iLogSockH] = FALSE;
		
		m_iSubLogSockFailCount++;
		m_iSubLogSockActiveCount--;

		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) connection lost!", iLogSockH);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
		
		m_pSubLogSock[iLogSockH] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pSubLogSock[iLogSockH]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + iLogSockH + 1));
		m_pSubLogSock[iLogSockH]->bInitBufferSize(DEF_MSGBUFFERSIZE);

		wsprintf(G_cTxt, "(!!!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);
		
		break;
	}
}

void CGame::OnSubLogRead(int iIndex)
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pSubLogSock[iIndex]->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		//    .  .
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}

BOOL CGame::_bCheckSubLogSocketIndex()
{
 int  iCnt;
 BOOL bLoopFlag;

	//   Sub-log-socket   
	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;

	iCnt = 0;
	bLoopFlag = FALSE;
	while (bLoopFlag == FALSE) {
		if ((m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) && (m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] == TRUE)) 
			 bLoopFlag = TRUE;
		else m_iCurSubLogSockIndex++;

		iCnt++;
		if (iCnt >= DEF_MAXSUBLOGSOCK) {
			//    Sub-log-socket  .     
			if (m_bOnExitProcess == FALSE) {
				m_cShutDownCode      = 3;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				//        . 
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Log-server connection Lost)!!!");
			}
			return FALSE;
		}
	}

	return TRUE;
}
#endif

void CGame::_CheckGateSockConnection()
{
	//        .
	if (m_bIsServerShutdowned == TRUE) return;

	if (m_iGateSockConnRetryTimes != 0) {
		wsprintf(G_cTxt, "(!!!) Gate-socket connection counting...%d", m_iGateSockConnRetryTimes); 
		PutLogList(G_cTxt);
		m_iGateSockConnRetryTimes++;
	}

	// 60 Gate-socket      .
	if (m_iGateSockConnRetryTimes > 20) {
		//       .   .
		if (m_bOnExitProcess == FALSE) {
			m_iFinalShutdownCount = 1;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			//        . 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by gate-server connection Lost)!!!");
		}
	}
}

BOOL CGame::_bDecodeBuildItemConfigFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  i, iIndex = 0;
 class CStrTok * pStrTok;
 class CItem * pItem;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					//   
					ZeroMemory(m_pBuildItemList[iIndex]->m_cName, sizeof(m_pBuildItemList[iIndex]->m_cName));
					memcpy(m_pBuildItemList[iIndex]->m_cName, token, strlen(token));
										
					cReadModeB = 2;
					break;

				case 2:
					//   
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format(1).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[0] = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[0] = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[0] = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[1] = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[1] = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[1] = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[2] = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[2] = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[2] = atoi(token);
					cReadModeB = 12;
					break;


				case 12:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[3] = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[3] = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[3] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[4] = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[4] = atoi(token);
					
					cReadModeB = 17;
					break;

				case 17:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[4] = atoi(token);
					
					cReadModeB = 18;
					break;

				
				case 18:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[5] = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[5] = atoi(token);
					
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[5] = atoi(token);
					
					cReadModeB = 21;
					break;



				case 21:
					// m_iAverageValue
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iAverageValue = atoi(token);
					
					cReadModeB = 22;
					break;

				case 22:
					// m_iMaxSkill
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaxSkill = atoi(token);
					
					cReadModeB = 23;
					break;

				case 23:
					// m_wAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_wAttribute = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					
					pItem = new class CItem;
					if (_bInitItemAttr(pItem, m_pBuildItemList[iIndex]->m_cName) == TRUE) {
						//   .
						m_pBuildItemList[iIndex]->m_sItemID = pItem->m_sIDnum;

						//   
						for (i = 0; i < 6; i++)
							m_pBuildItemList[iIndex]->m_iMaxValue += (m_pBuildItemList[iIndex]->m_iMaterialItemValue[i]*100);

						iIndex++;	
					}
					else {
						//      .  
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! BuildItem configuration file error - Not Existing Item(%s)", m_pBuildItemList[iIndex]->m_cName);
						PutLogList(G_cTxt);
						
						delete m_pBuildItemList[iIndex];
						m_pBuildItemList[iIndex] = NULL;
						
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					delete pItem;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "BuildItem", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pBuildItemList[iIndex] = new class CBuildItem;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) BuildItem(Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);

	return TRUE;
}



// Centu : agregados items con atributos
void CGame::BuildItemHandler(int iClientH, char *pData)
{
 char * cp, cName[21], cElementItemID[6], cColor;
 int    i, x, z, iMatch, iCount, iPlayerSkillLevel, iResult, iTotalValue, iResultValue, iTemp, iItemCount[DEF_MAXITEMS];
 class  CItem * pItem;
 BOOL   bFlag, bItemFlag[6];
 double dV1, dV2, dV3;
 DWORD  dwTemp, dwTemp2, dwType, dwValue;
 WORD   wTemp;
 short sMagicLevel = 0;

   //    .
   if (m_pClientList[iClientH] == NULL) return;
   m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

   cp = (char *)(pData + 11);
   ZeroMemory(cName, sizeof(cName));
   memcpy(cName, cp, 20);
   cp += 20;

   ZeroMemory(cElementItemID, sizeof(cElementItemID));
   cElementItemID[0] = *cp;
   cp++;
   cElementItemID[1] = *cp;
   cp++;
   cElementItemID[2] = *cp;
   cp++;
   cElementItemID[3] = *cp;
   cp++;
   cElementItemID[4] = *cp;
   cp++;
   cElementItemID[5] = *cp;
   cp++;
   
   //   .
   bFlag = TRUE;
   while (bFlag == TRUE) {
      bFlag = FALSE;
      for (i = 0; i <= 4; i++)
      if ((cElementItemID[i] == -1) && (cElementItemID[i+1] != -1)) {
         cElementItemID[i] = cElementItemID[i+1];
         cElementItemID[i+1] = -1;
         bFlag = TRUE;
      }
   }

   for (i = 0; i < 6; i++) bItemFlag[i] = FALSE;

   iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[13];
   iResult = iDice(1, 100);

   if (iResult > iPlayerSkillLevel) {
      // .
      //   .
      SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
      return;
   }

   //     .
   for (i = 0; i < 6; i++)
   if (cElementItemID[i] != -1) {
      //  Item ID. 
      if ((cElementItemID[i] < 0) || (cElementItemID[i] > DEF_MAXITEMS)) return;
      if (m_pClientList[iClientH]->m_pItemList[cElementItemID[i]] == NULL) return;      
   }

   //       * .
   for (i = 0; i < DEF_MAXBUILDITEMS; i++)
   if (m_pBuildItemList[i] != NULL) {
      if (memcmp(m_pBuildItemList[i]->m_cName, cName, 20) == 0) {
         //  .     .
         
         //  *  .  *  .
         if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[13]) return;
                  
         for (x = 0; x < DEF_MAXITEMS; x++)
         if (m_pClientList[iClientH]->m_pItemList[x] != NULL)
             iItemCount[x] = m_pClientList[iClientH]->m_pItemList[x]->m_dwCount;
         else iItemCount[x] = 0;
         
         //      .      .
         iMatch = 0;
         iTotalValue = 0;
         
         for (x = 0; x < 6; x++) {
            if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) {
               iMatch++;
            }
            else {
               for (z = 0; z < 6; z++)
               if ((cElementItemID[z] != -1) && (bItemFlag[z] == FALSE)) {
                                    
                  if ((m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sIDnum  == m_pBuildItemList[i]->m_iMaterialItemID[x]) &&
                     (m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_dwCount >= m_pBuildItemList[i]->m_iMaterialItemCount[x]) &&
                     (iItemCount[cElementItemID[z]] > 0)) {
                     //   .
                     iTemp = m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sItemSpecEffectValue2;
                     if (iTemp > m_pClientList[iClientH]->m_cSkillMastery[13]) {
                        //        .
                        iTemp = iTemp - (iTemp - m_pClientList[iClientH]->m_cSkillMastery[13])/2;
                     }

                     iTotalValue += (iTemp * m_pBuildItemList[i]->m_iMaterialItemValue[x]);
                     iItemCount[cElementItemID[z]] -= m_pBuildItemList[i]->m_iMaterialItemCount[x];
                     iMatch++;
                     bItemFlag[z] = TRUE;
                  
                     goto BIH_LOOPBREAK;
                  }
               }
BIH_LOOPBREAK:;
            }
         }

         // * iMatch 6     .
         if (iMatch != 6) {
            //  .   
            SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
            return;
         }

         //  
         dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
         if (iTotalValue <= 0)
             dV3 = 1.0f;
         else dV3 = (double)iTotalValue;
         dV1 = (double)(dV3/dV2)*100.0f;

         //   .
         iTotalValue = (int)dV1;

         //  
         pItem = new class CItem;
         if (_bInitItemAttr(pItem, m_pBuildItemList[i]->m_cName) == FALSE) {
            delete pItem;
            return;
         }

         //  Custom-Made   
         dwTemp = pItem->m_dwAttribute;
         dwTemp = dwTemp & 0xFFFFFFFE;
         dwTemp = dwTemp | 0x00000001;
         pItem->m_dwAttribute = dwTemp;

         if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) {
            //     ()     .
            iTemp = iDice(1, (iPlayerSkillLevel/2)+1) -1;
            pItem->m_sItemSpecEffectValue2 = (iPlayerSkillLevel/2) + iTemp;
            // v2.15     
            pItem->m_sTouchEffectType   = DEF_ITET_ID;
            pItem->m_sTouchEffectValue1 = iDice(1,100000);
            pItem->m_sTouchEffectValue2 = iDice(1,100000);
            pItem->m_sTouchEffectValue3 = timeGetTime();

         }
         else {
            //      
            //   
            dwTemp = pItem->m_dwAttribute;
            dwTemp = dwTemp & 0x0000FFFF;

            dwTemp2 = (WORD)m_pBuildItemList[i]->m_wAttribute;
            dwTemp2 = dwTemp2 << 16;

            dwTemp  = dwTemp | dwTemp2;
            pItem->m_dwAttribute = dwTemp;

            iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);
            //    : SpecEffectValue1 , SpecEffectValue2  
            
            // 1.   ()
            if (iResultValue > 0) {
               dV2 = (double)iResultValue;
               dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
               dV1 = (dV2/dV3)*100.0f;
               pItem->m_sItemSpecEffectValue2 = (int)dV1;
            }
            else if (iResultValue < 0) {
               dV2 = (double)(iResultValue);
               dV3 = (double)(m_pBuildItemList[i]->m_iAverageValue);
               dV1 = (dV2/dV3)*100.0f;
               pItem->m_sItemSpecEffectValue2 = (int)dV1;
            }
            else pItem->m_sItemSpecEffectValue2 = 0;

            // 2.    
            dV2 = (double)pItem->m_sItemSpecEffectValue2;
            dV3 = (double)pItem->m_wMaxLifeSpan;
            dV1 = (dV2/100.0f)*dV3;

            iTemp  = (int)pItem->m_wMaxLifeSpan;
            iTemp += (int)dV1;

            // v2.15     
            pItem->m_sTouchEffectType   = DEF_ITET_ID;
            pItem->m_sTouchEffectValue1 = iDice(1,100000);
            pItem->m_sTouchEffectValue2 = iDice(1,100000);
            pItem->m_sTouchEffectValue3 = timeGetTime();

            if (iTemp <= 0)
                wTemp = 1;
            else wTemp = (WORD)iTemp;

            if (wTemp <= pItem->m_wMaxLifeSpan*2) {
               //       
               pItem->m_wMaxLifeSpan = wTemp;
               pItem->m_sItemSpecEffectValue1 = (short)wTemp;
               pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
            }
            else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;

            //Custom-Item  2 OGEID.
         
            
			if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
               // ?     ? 
               // *(3%) **(7%) (15%) (20%) ?(20%) ?(16%) (16%) **(3%)
               iResult = iDice(1,11500);
               if ((iResult >= 1) && (iResult <= 299)) {
                  dwType = 10;
                  cColor = 5;
               }
               else if ((iResult >= 300) && (iResult <= 999)) {
                  dwType = 12;
                  cColor = 5;
               }
               else if ((iResult >= 1000) && (iResult <= 2499)) {
                  dwType = 7;
                  cColor = 6;
               }
               else if ((iResult >= 2500) && (iResult <= 4499)) {
                  dwType = 7;
                  cColor = 6;
               }
               else if ((iResult >= 4500) && (iResult <= 6499)) {
                  dwType = 7;
                  cColor = 6;
               }
               else if ((iResult >= 6500) && (iResult <= 8099)) {
                  dwType = 7;
                  cColor = 6;
               }
               else if ((iResult >= 8100) && (iResult <= 9699)) {
                  dwType = 9;
                  cColor = 8;
               }
               else if ((iResult >= 9700) && (iResult <= 9999)) {
                  dwType = 9;
                  cColor = 8;
               }
			   else if ((iResult >= 10000) && (iResult <= 11499)) {
					dwType = 15; // Magic
					cColor = 10; // Black Color
			   }

               //   
               pItem->m_cItemColor = cColor;

               // *, **, , , ?, ?, , **
               //  Main  ? 

               //  Sub  ? 
               if (dwType == 15){
					iResult = iDice(1, 30060);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // Fire-Strike
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // Lightning
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // Chill-Wind
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // Ice-Strike
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // Energy-Strike
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // Mass-Fire-Strike
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // Mass-Chill-Wind
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // Earthworm-Strike
					else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // Bloody-Shock-Wave
					else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // Mass-Ice-Strike
					else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // Lightning-Strike
					else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // Ice-Whirlwind
					else if ((iResult >= 29970) && (iResult < 30000))  dwValue = 13; // Meteor-Strike
					else if ((iResult >= 30000) && (iResult < 30025))  dwValue = 14; // Mass-Magic-Missile
					else if ((iResult >= 30025) && (iResult < 30045))  dwValue = 15; // Blizzard
					else if ((iResult >= 30045) && (iResult <= 30060))  dwValue = 16; // Earth-Shock-Wave
					sMagicLevel = 1;
				}
				else{
					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906
					sMagicLevel = 0;
				}

               //  Main    ?
               switch (dwType) {
               case 1: //  ?  +5
                  if (dwValue <= 5) dwValue = 5;
                  break;
               case 2: // ? ?  +20
                  if (dwValue <= 4) dwValue = 4;
                  break;
               case 6: // *   +16%
                  if (dwValue <= 4) dwValue = 4;
                  break;
               case 8: // *  +14%               
                  if (dwValue <= 2) dwValue = 2;
                  break;

               }
               // v2.03 912  ? 2??   7
               if (dwValue > 7) dwValue = 7;

               //  Main ,  
               pItem->m_dwAttribute = NULL;
               dwType  = dwType << 20;
               dwValue = dwValue << 16;
               pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
         }

		if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE) {
               //   ??  , .

               // **(60%) * (30%)  (5%)  (5%)
               iResult = iDice(1,10000);//AQUI OGEID
               if ((iResult >= 1) && (iResult <= 5999))          dwType = 8;
               else if ((iResult >= 6000) && (iResult <= 8999))  dwType = 6;
               else if ((iResult >= 9000) && (iResult <= 9554))  dwType = 11; //dwType = 11;
               else if ((iResult >= 9555) && (iResult <= 10000)) dwType = 12; //dwType = 12;

               //  Sub  ? 
               iResult = iDice(1, 30000);
               if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
               else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 1;  // 6600/29348 = 22.4%
               else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 1;  // 4356/29348 = 14.8%
               else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 2;  // 2874/29348 = 9.7%
               else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 2;  // 1897/29348 = 6.4%
               else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 2;  // 1252/29348 = 4.2%
               else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 4;  // 826/29348 = 2.8%
               else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 4;  // 545/29348 = 1.85%
               else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 4;  // 360/29348 = 1.2%
               else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 6; // 237/29348 = 0.8%
               else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 6; // 156/29348 = 0.5%
               else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 10; // 103/29348 = 0.3%
               else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 10; // 68/29348 = 0.1%
               else dwValue = 1; // v2.03 906

               //  Main    ?
               switch (dwType) {
               case 6: // *  +16%
                  if (dwValue <= 4) dwValue = 4;
                  break;
               case 8: // *  +14%
                  if (dwValue <= 2) dwValue = 2;
                  break;

               case 11:
               case 12:
                  // v2.04
                  dwValue = (dwValue+1) / 2;
                  if (dwValue < 1) dwValue = 1;
                  if (dwValue > 2) dwValue = 2;
                  break;
               }
               // v2.03 912  ? 2??   7
               if (dwValue > 7) dwValue = 7;

               //  Main ,  
               pItem->m_dwAttribute = NULL;
               dwType  = dwType << 20;
               dwValue = dwValue << 16;
               pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

               //  Sub    40%
               if (iDice(1,10000) >= 3000) {

                  // ?  Sub   ?:
                  // (1),  *?(2),  (3), HP  (4), SP  (5)
                  //MP  (6),  (7),  ? *(8),  ? *(9)
                  // ? (10),   (11),  Gold(12)

                 //   
                  // (10%) (30%)    SP(15%)  HP(10%)
                  // MP (10%) (15%) ?*(3%) ?*(3%)
                  iResult = iDice(1,10000);
                  if ((iResult >= 1) && (iResult <= 999)) {         
                     dwType = 8;
                     cColor = 15;
                     }
                  else if ((iResult >= 1000) && (iResult <= 3999)) {
                     dwType = 8;
                     cColor = 15;
                     }
                  else if ((iResult >= 4000) && (iResult <= 5499))  {
                     dwType = 8;
                     cColor = 15;
                     }
                  else if ((iResult >= 5500) && (iResult <= 6499))  {
                     dwType = 9;
                     cColor = 10;
                     }
                  else if ((iResult >= 6500) && (iResult <= 7499))  {
                     dwType = 9;
                     cColor = 10;
                     }
                  else if ((iResult >= 7500) && (iResult <= 9399))  {
                     dwType = 9;
                     cColor = 10;
                     }
                  else if ((iResult >= 9400) && (iResult <= 9799))  {
                     dwType = 8;
                     cColor = 15;
                     }
                  else if ((iResult >= 9800) && (iResult <= 10000)) {
                     dwType = 9;
                     cColor = 10;
                     }

                  pItem->m_cItemColor = cColor;

                  //  Sub  ? 
                  iResult = iDice(1, 30000);
                  if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
                  else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 1;  // 6600/29348 = 22.4%
                  else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 1;  // 4356/29348 = 14.8%
                  else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 2;  // 2874/29348 = 9.7%
                  else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 2;  // 1897/29348 = 6.4%
                  else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 2;  // 1252/29348 = 4.2%
                  else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 2;  // 826/29348 = 2.8%
                  else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 4;  // 545/29348 = 1.85%
                  else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 6;  // 360/29348 = 1.2%
                  else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 6; // 237/29348 = 0.8%
                  else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 8; // 156/29348 = 0.5%
                  else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 8; // 103/29348 = 0.3%
                  else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 8; // 68/29348 = 0.1%
                  else dwValue = 1; // v2.03 906

                  //  Sub    ?
                  switch (dwType) {
                  case 1: //   +21%
                  case 3: //   +21%
                  case 7: //    +21%
                  case 8: // *  +9%
                  case 9: // *  +9%
                     if (dwValue <= 3) dwValue = 3;
                     break;
                  }
                  // v2.03 912  ? 2??   7
                  if (dwValue > 7) dwValue = 7;

                  //  Sub  
                  dwType  = dwType << 12;
                  dwValue = dwValue << 8;
                  pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
               }
   }
   }
         //testcode
         wsprintf(G_cTxt, "Custom-Item(%s) Value(%d) Life(%d/%d)", pItem->m_cName, pItem->m_sItemSpecEffectValue2, pItem->m_wCurLifeSpan, pItem->m_wMaxLifeSpan);
         PutLogList(G_cTxt);
      
         //  
         bAddItem(iClientH, pItem, NULL);
         SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMSUCCESS, pItem->m_sItemSpecEffectValue2, pItem->m_cItemType, NULL, NULL); // Integer  

#ifdef DEF_TAIWANLOG
         // v1.41    .
         _bItemLog(DEF_ITEMLOG_MAKE, iClientH, (int) -1, pItem);
#endif   

         //     .
         for (x = 0; x < 6; x++)
         if (cElementItemID[x] != -1) {
            if (m_pClientList[iClientH]->m_pItemList[cElementItemID[x]] == NULL) {
               // ### BUG POINT!!!
               //   .
               wsprintf(G_cTxt, "(?) Char(%s) ElementItemID(%d)", m_pClientList[iClientH]->m_cCharName, cElementItemID[x]);
               PutLogFileList(G_cTxt);
            }
            else {
               iCount = m_pClientList[iClientH]->m_pItemList[cElementItemID[x]]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
               if (iCount < 0) iCount = 0;
               SetItemCount(iClientH, cElementItemID[x], iCount);
            }
         }

         //    .       * . 
         if (m_pBuildItemList[i]->m_iMaxSkill > m_pClientList[iClientH]->m_cSkillMastery[13])
            CalculateSSN_SkillIndex(iClientH, 13, 1);

         // v1.41   
         GetExp(iClientH, iDice(1, (m_pBuildItemList[i]->m_iSkillLimit/4))); //m_pClientList[iClientH]->m_iExpStock += iDice(1, (m_pBuildItemList[i]->m_iSkillLimit/4));

         return;
      }
   }

   
}


void CGame::AdminOrder_SetAttackMode(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;
 int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetAttackMode) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if (token != NULL) {
		//    '1'   . 0     
		if (token[0] == '1') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = TRUE;
			//     .
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
				SendNotifyMsg(NULL, i, DEF_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);	
		}
		else if (token[0] == '0') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = FALSE;
			
			//     .
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
				SendNotifyMsg(NULL, i, DEF_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);	
		}
	}

	delete pStrTok;
}


void CGame::AdminOrder_UnsummonAll(int iClientH)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelUnsummonAll) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	//    . 
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		if ((m_pNpcList[i]->m_bIsSummoned == TRUE) && (m_pNpcList[i]->m_bIsKilled == FALSE)) 
			NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
	}
}

// 3.51 - 05/17/2004 - Hypnotoad/[KLKS] - Monster Special Abilities
char CGame::_cGetSpecialAbility(int iKindSA)
{
	char cSA;

	switch (iKindSA) {
	case 1: 
		// Slime, Orc, Orge, WereWolf, YB-, Rabbit, Mountain-Giant, Stalker, Hellclaw, 
		// Wyvern, Fire-Wyvern, Barlog, Tentocle, Centaurus, Giant-Lizard, Minotaurus,
		// Abaddon, Claw-Turtle, Giant-Cray-Fish, Giant-Plant, MasterMage-Orc, Nizie,
		// Tigerworm
		switch (iDice(1,2)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
		}
		break;

	case 2: 
		// Giant-Ant, Cat, Giant-Frog, 
		switch (iDice(1,3)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
			case 3: cSA = 5; break; // Poisonous
		}
		break;

	case 3: 
		// Zombie, Scorpion, Amphis, Troll, Dark-Elf
		switch (iDice(1,4)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
			case 3: cSA = 5; break; // Poisonous
			case 4: cSA = 6; break; // Critical Poisonous
		}
		break;

	case 4: 
		// no linked Npc
		switch (iDice(1,3)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
			case 3: cSA = 7; break; // Explosive
		}
		break;

	case 5: 
		// Stone-Golem, Clay-Golem, Beholder, Cannibal-Plant, Rudolph, DireBoar
		switch (iDice(1,4)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
			case 3: cSA = 7; break; // Explosive
			case 4: cSA = 8; break; // Critical-Explosive
		}
		break;

	case 6: 
		// no linked Npc
		switch (iDice(1,3)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
			case 3: cSA = 5; break; // Poisonous
		}
		break;

	case 7: 
		// Orc-Mage, Unicorn
		switch (iDice(1,3)) {
			case 1: cSA = 1; break; // Clairvoyant
			case 2: cSA = 2; break; // Distruction of Magic Protection
			case 3: cSA = 4; break; // Anti-Magic Damage
		}
		break;

	case 8: 
		// Frost, Ice-Golem, Ettin, Gagoyle, Demon, Liche, Hellbound, Cyclops, 
		// Skeleton
		switch (iDice(1,5)) {
			case 1: cSA = 1; break; // Clairvoyant
			case 2: cSA = 2; break; // Distruction of Magic Protection
			case 3: cSA = 4; break; // Anti-Magic Damage
			case 4: cSA = 3; break; // Anti-Physical Damage
			case 5: cSA = 8; break; // Critical-Explosive
		}
		break;

	case 9:
		// no linked Npc
		cSA = iDice(1,8); // All abilities available
		break;

	case 10: // guards
		switch (iDice(1,2)) {
			case 1: cSA = 1; break; // Clairvoyant
			case 2: cSA = 2; break; // Distruction of Magic Protection
		}
		break;
	}

	return cSA;
}

void CGame::AdminOrder_Summon(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cName_Master[10], cName_Slave[10], cNpcName[256], cWaypoint[11], cSA; 
 int    pX, pY, j, iNum, iNamingValue;
 class  CStrTok * pStrTok;
 BOOL   bMaster;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummon) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	ZeroMemory(cNpcName, sizeof(cNpcName));
	strcpy(cNpcName, token);

	token = pStrTok->pGet();
	
	if (token != NULL) 
		 iNum = atoi(token);
	else iNum = 1;

	if (iNum <= 0)  iNum = 1;
	if (iNum >= 50)  iNum = 50;
		
	cSA = 0;
	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;

	//   
	wsprintf(G_cTxt, "(!) Admin Order: Summon(%s)-(%d)", cNpcName, iNum);
	PutLogList(G_cTxt);

	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
	if (iNamingValue != -1) {
		// Master Mob .
		ZeroMemory(cName_Master, sizeof(cName_Master));
		wsprintf(cName_Master, "XX%d", iNamingValue);
		cName_Master[0] = '_';
		cName_Master[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
		if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE, TRUE)) == FALSE) {
			//   NameValue .
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
		}
	}		

	for (j = 0; j < (iNum - 1); j++) {
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// Slave Mob .
			ZeroMemory(cName_Slave, sizeof(cName_Slave));
			wsprintf(cName_Slave, "XX%d", iNamingValue);
			cName_Slave[0] = '_';
			cName_Slave[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
			// v1.411    . 
				
			if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE) == FALSE) {
				//   NameValue .
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				// Slave .
				bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
			}
		}
	}

	delete pStrTok;
}

void CGame::AdminOrder_SummonAll(int iClientH, char *pData, DWORD dwMsgSize)
{

 char   seps[] = "= \t\n";
 char   * token, * cp, cBuff[256], cLocation[11], cMapName[11];
 WORD   *wp;
 int    pX, pY, i;
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize) <= 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonAll) {
		 // Admin user level      .
		 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		 return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		 delete pStrTok;
		 return;
	}

	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;


	memcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);

	if (strlen(token) > 10)
	memcpy(cLocation, token, 10);
	else memcpy(cLocation, token, strlen(token));

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		 if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cLocation, token) == 0)) {
			  RequestTeleportHandler(i, "2   ", cMapName, pX, pY);
		 }

	wsprintf(G_cTxt,"GM Order(%s): PC(%s) Summoned to (%s)", m_pClientList[iClientH]->m_cLocation,
	   cLocation, cMapName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_SUMMONALL;
	cp++;

	memcpy(cp, cLocation, 10);
	cp += 10;

	memcpy(cp, cMapName, 10);
	cp += 10;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sX;
	cp += 2;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sY;
	cp += 2;

	bStockMsgToGateServer(cBuff, 25);

	delete pStrTok;
}

void CGame::AdminOrder_SummonPlayer(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, * cp, cBuff[256], cMapName[11], cName[11]; 
	WORD   *wp;
	int    pX, pY, i;
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonPlayer) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	ZeroMemory(cName, sizeof(cName));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;
	memcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);

	if (strlen(token) > 10)
		memcpy(cName, token, 10);
	else memcpy(cName, token, strlen(token));

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			if (i == iClientH) {
				delete pStrTok;
				return;
			}
			RequestTeleportHandler(i, "2   ", cMapName, pX, pY);
			delete pStrTok;
			return;
		}

	// find char on other hg's
	wsprintf(G_cTxt,"GM Order(%s): PC(%s) Summoned to (%s)", m_pClientList[iClientH]->m_cCharName,
				cName, cMapName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_SUMMONPLAYER;
	cp++;

	memcpy(cp, cName, 10);
	cp += 10;

	memcpy(cp, cMapName, 10);
	cp += 10;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sX;
	cp += 2;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sY;
	cp += 2;

	bStockMsgToGateServer(cBuff, 25);

	delete pStrTok;
}

void CGame::CheckSpecialEvent(int iClientH)
{
 SYSTEMTIME SysTime;
 char cItemName[21], cData[100], *cp;
 short * sp;
 class CItem * pItem;
 DWORD * dwp;
 WORD  * wp;
 int iEraseReq, iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;
	if (m_pClientList[iClientH]->m_iLevel < 15) return;
	GetLocalTime(&SysTime);
	if ((SysTime.wYear == 2003) && (SysTime.wMonth = 11)) {
		if (m_pClientList[iClientH]->m_iSpecialEventID < 20031101) return;
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName,"MemorialRing(4)");
		pItem = new class CItem;
		if (pItem == NULL) return;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			delete pItem;
		}
		else {
			bAddItem(iClientH, pItem, NULL);
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				wsprintf(G_cTxt, "(*) Get MemorialRing(4) (%s) Char(%s)", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(G_cTxt);
				pItem->m_sTouchEffectType	= DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				pItem->m_cItemColor         = 9;
				m_pClientList[iClientH]->m_iSpecialEventID = 20031101;
				_bItemLog(DEF_ITEMLOG_GET, iClientH, -1, pItem, NULL);
				ZeroMemory(cData, sizeof(cData));
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);;
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;

				cp = (char *)(cData + DEF_INDEX2_MSGTYPE+2);
				*cp = 1;
				cp++;

				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0;
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;
				
				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2;
				cp++;
				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE, TRUE, FALSE);
					return;
				}
			}
		}
	}
}

void CGame::AdminOrder_DisconnectAll(int iClientH, char *pData, DWORD dwMsgSize)
{

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelDisconnectAll) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	_iForcePlayerDisconect(DEF_MAXCLIENTS);
}

BOOL CGame::_bDecodeDupItemIDFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					//   
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pDupItemIDList[atoi(token)] != NULL) {
						//    . .
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[atoi(token)] = new class CItem;
					iIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// m_sTouchEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectType = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// m_sTouchEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue1 = atoi(token);
					cReadModeB = 4;
					break;
				
				case 4:
					// m_sTouchEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// m_sTouchEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue3 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_wPrice = (WORD)atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;

					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "DupItemID", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) ERROR! DupItemID configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) DupItemID(Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);
	
	return TRUE;
}

BOOL CGame::_bCheckDupItemID(CItem *pItem)
{
 int i;

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
	if (m_pDupItemIDList[i] != NULL) {
		if ((pItem->m_sTouchEffectType   == m_pDupItemIDList[i]->m_sTouchEffectType) &&
			(pItem->m_sTouchEffectValue1 == m_pDupItemIDList[i]->m_sTouchEffectValue1) &&
			(pItem->m_sTouchEffectValue2 == m_pDupItemIDList[i]->m_sTouchEffectValue2) &&
			(pItem->m_sTouchEffectValue3 == m_pDupItemIDList[i]->m_sTouchEffectValue3) ) {
			//    .
			pItem->m_wPrice = m_pDupItemIDList[i]->m_wPrice;
			return TRUE;
		}
	}
	
	return FALSE;
}

void CGame::_AdjustRareItemValue(CItem *pItem)
{
 DWORD dwSWEType, dwSWEValue;
 double dV1, dV2, dV3;

	if ((pItem->m_dwAttribute & 0x00F00000) != NULL) {
		dwSWEType  = (pItem->m_dwAttribute & 0x00F00000) >> 20;  
		dwSWEValue = (pItem->m_dwAttribute & 0x000F0000) >> 16;
		//    : 
		// 0-None 1- 2- 3- 
		// 5- 6- 7- 8- 9-
		switch (dwSWEType) {
		case 0: break;
		
		case 5: //  
			pItem->m_cSpeed--;
			if (pItem->m_cSpeed < 0) pItem->m_cSpeed = 0;
			break;

		case 6: //  
			dV2 = (double)pItem->m_wWeight;
			dV3 = (double)(dwSWEValue*4);
			dV1 = (dV3/100.0f)*dV2;
			pItem->m_wWeight -= (int)dV1;

			if (pItem->m_wWeight < 1) pItem->m_wWeight = 1;
			break;

		case 8: //  
		case 9: //  
			dV2 = (double)pItem->m_wMaxLifeSpan;
			dV3 = (double)(dwSWEValue*7);
			dV1 = (dV3/100.0f)*dV2;
			pItem->m_wMaxLifeSpan += (int)dV1;
			break;
		}
	}
}

void CGame::RequestNoticementHandler(int iClientH, char * pData)
{
 char * cp, cData[120];
 int  * ip, iRet, iClientSize;
 DWORD * dwp;
 WORD  * wp;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_dwNoticementDataSize < 10) return;

	ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
	iClientSize = *ip;

	if (iClientSize != m_dwNoticementDataSize) {
		//         .
		cp = new char[m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2];
		ZeroMemory(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);
		memcpy((cp + DEF_INDEX2_MSGTYPE + 2), m_pNoticementData, m_dwNoticementDataSize);
		
		dwp  = (DWORD *)(cp + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cp + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_REJECT;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);
	
		delete cp;
	}
	else {
		ZeroMemory(cData, sizeof(cData));
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	}
	//    .	
}

void CGame::_bDecodeNoticementFileContents(char *pData, DWORD dwMsgSize)
{
 char * cp;	
	
	cp = (pData);
	
	if (m_pNoticementData != NULL) {
		delete m_pNoticementData;
		m_pNoticementData = NULL;
	}

	m_pNoticementData = new char[strlen(cp) + 2];
	ZeroMemory(m_pNoticementData, strlen(cp) + 2);

	memcpy(m_pNoticementData, cp, strlen(cp));
	m_dwNoticementDataSize = strlen(cp);

	wsprintf(G_cTxt, "(!) Noticement Data Size: %d", m_dwNoticementDataSize);
	PutLogList(G_cTxt);
}

void CGame::RequestCheckAccountPasswordHandler(char *pData, DWORD dwMsgSize)
{
 int * ip, i, iLevel;
 char * cp, cAccountName[11], cAccountPassword[11];

	cp = (char *)(pData + 6);

	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	memcpy(cAccountName, cp, 10);
	cp += 10;

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ip = (int *)cp;
	iLevel = *ip;
	cp += 4;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cAccountName, cAccountName) == 0)) {
		//   .          . 
		if ((strcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword) != 0) || (m_pClientList[i]->m_iLevel != iLevel)) {
			wsprintf(G_cTxt, "(TestLog) Error! Account(%s)-Level(%d) password(or level) mismatch! Disconnect.", cAccountName, iLevel);
			PutLogList(G_cTxt);
			//     .
			DeleteClient(i, FALSE, TRUE);
			return;
		}
	}
}

void CGame::_TamingHandler(int iClientH, int iSkillNum, char cMapIndex, int dX, int dY)
{int iSkillLevel, iRange, iTamingLevel, iResult, iX, iY, iTamingType = 0, iNbeTamed = 0;
 short sOwnerH;
 char cOwnerType, cTamedString[500];
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pMapList[cMapIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
	{	if (   (m_pClientList[iClientH]->m_iStr > 100)
			&& (m_pClientList[iClientH]->m_iCharisma > 49))
		{	iTamingType = 2; // War-GuildMaster
		}else if (	(m_pClientList[iClientH]->m_iInt > 100)
			&&		(m_pClientList[iClientH]->m_iCharisma > 49))
		{	iTamingType = 1; // Mage-GuildMaster
		}	
	}else iTamingType = 3; // GameMaster
	iSkillLevel = (int)m_pClientList[iClientH]->m_cSkillMastery[iSkillNum];
	iRange = 2 + iSkillLevel / 20; 
	for (iX = dX - iRange; iX <= dX + iRange; iX++)
	for (iY = dY - iRange; iY <= dY + iRange; iY++) 
	{	sOwnerH = NULL;
		if ((iX > 0) && (iY > 0) && (iX < m_pMapList[cMapIndex]->m_sSizeX) && (iY < m_pMapList[cMapIndex]->m_sSizeY))
		{	m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, iX, iY);
		}
		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				continue;
				break;
			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) break;
				// 1st list for everybody			
				iTamingLevel = 201; // 201 means impossible
				switch (m_pNpcList[sOwnerH]->m_sType) {
					case 14: iTamingLevel = 35; break;	// Orc
					case 28: iTamingLevel = 65; break;	// Troll
					case 29: iTamingLevel = 100; break;	// Ogre
					case 58: iTamingLevel = 100; break;	// MG
					case 59: iTamingLevel = 120; break;	// Ettin
					case 77: iTamingLevel = 160; break;	// MasterMage-Orc 
					case 78: iTamingLevel = 170; break;	// Minos 
				}
				switch (iTamingType) {
				case 1: // Mage-GuildMaster				
					if (iTamingLevel > 199) iTamingLevel = 199;
					switch (m_pNpcList[sOwnerH]->m_sType) {
						case 12:							// Stone
						case 23: iTamingLevel =  40; break;	// Clay
						case 65: iTamingLevel =  70; break;	// IceGolem
						case 80: iTamingLevel =  80; break;	// Tentocle
						case 53: iTamingLevel = 100; break;	// BB
						case 31: iTamingLevel = 170; break;	// DD
					}
					break;
				case 2: // War-GuildMaster	
					if (iTamingLevel > 197) iTamingLevel = 197;
					switch (m_pNpcList[sOwnerH]->m_sType) { 
					case 18:							// Zombie 
					case 11: iTamingLevel =  35; break;	// Skel
					case 27: iTamingLevel =  65; break;	// hh
					case 30: iTamingLevel = 120; break;	// Liche
					case 31: iTamingLevel = 170; break;	// DD
					case 32: // Uni possible for some purest Wars
						if (   (m_pClientList[iClientH]->m_iPKCount == 0) // Uni
							&& (m_pClientList[iClientH]->m_iEnemyKillCount == 0)
							&& (m_pClientList[iClientH]->m_iRating > 0) )
						{	iTamingLevel = 100;
						}					
						break;
					}
					break;
				case 3: // GameMaster
					iTamingLevel = 30;
					if (m_pNpcList[sOwnerH]->m_cSide == 0) iTamingLevel = 201;
					break;
				}
				iResult = iDice(2, iSkillLevel);
				if (   (iResult >= iTamingLevel)
					&& (m_pNpcList[sOwnerH]->m_dwTamingTime == 0)
					&& (m_pNpcList[sOwnerH]->m_cSide != m_pClientList[iClientH]->m_cSide))
				{	iNbeTamed++;
					// Now change npc side...
					m_pNpcList[sOwnerH]->m_cOriginalSide = m_pNpcList[sOwnerH]->m_cSide;
					switch (iTamingType) {
					default:
					case 0: // Default -> npc becomes neutral 	
					case 3: // GameMaster
						m_pNpcList[sOwnerH]->m_cSide = 0;
						break;
					case 1: // Mage-GuildMaster -> npc becomes friendly 					
						switch (m_pNpcList[sOwnerH]->m_sType) {	
						case 12: // Stone
						case 23: // Clay
						case 65: // IceGolem
						case 80: // Tentocle
						case 53: // BB
						case 31: // DD						
							m_pNpcList[sOwnerH]->m_cSide = m_pClientList[iClientH]->m_cSide;
							break;
						default:
							m_pNpcList[sOwnerH]->m_cSide = 0;
							break;	
						}
						break;
					case 2: // War-GuildMaster	-> npc becomes friendly
						switch (m_pNpcList[sOwnerH]->m_sType) { 
						case 18: // Zombie 
						case 11: // Skel
						case 27: // hh
						case 30: // Liche
						case 31: // DD
							if (iDice(1,95) <= iSkillLevel) 
								 m_pNpcList[sOwnerH]->m_cSide = m_pClientList[iClientH]->m_cSide;
							else m_pNpcList[sOwnerH]->m_cSide = 0;
							break;
						case 32: // Uni
							m_pNpcList[sOwnerH]->m_cSide = m_pClientList[iClientH]->m_cSide;				
							break;
						default:  
							m_pNpcList[sOwnerH]->m_cSide = 0;
							break;	
						}
						break;
					}
					if (iGetFollowerNumber(sOwnerH, cOwnerType) > 5) return;
					m_pNpcList[sOwnerH]->m_dwTamingTime = timeGetTime() + 3000*iSkillLevel + 120000;
					m_pNpcList[sOwnerH]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
					m_pNpcList[sOwnerH]->m_sBehaviorTurnCount = 0;
					m_pNpcList[sOwnerH]->m_iTargetIndex       = NULL;
					if (m_pNpcList[sOwnerH]->m_cSide == m_pClientList[iClientH]->m_cSide)
					{	m_pNpcList[sOwnerH]->m_cMoveType		 = DEF_MOVETYPE_FOLLOW;
						m_pNpcList[sOwnerH]->m_cFollowOwnerType  = DEF_OWNERTYPE_PLAYER;
						m_pNpcList[sOwnerH]->m_iFollowOwnerIndex = iClientH;								
					}
					SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					// Increase skill if not easy Taming
					if (iTamingLevel >= iSkillLevel)
					{	CalculateSSN_SkillIndex(iClientH, 22, 1);
				}	} // End of succes in taming 1 creature
				break;
	}	}	}
	if (iNbeTamed == 0)  // No creature tamed
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, 0, NULL, NULL, NULL);
	}else 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, 1, NULL, NULL, NULL);
		ZeroMemory(cTamedString, sizeof(cTamedString));
		switch (iTamingType) {	
		case 2:	// War-GuildMaster
			wsprintf(cTamedString, " Undead turned: %d", iNbeTamed);
			break;
		case 1:	// Mage-GuildMaster
			wsprintf(cTamedString, " Magic things controled: %d", iNbeTamed);
			break;
		default:
		case 0:
		case 3:	 // GameMaster
			wsprintf(cTamedString, " Creatures neutralised: %d", iNbeTamed);
			break;
		}
		ShowClientMsg(iClientH, cTamedString);
		// Debug	
		wsprintf(cTamedString, "(!) Taming skill: %s is using Taming skill (%d%%) (Type %d), he tamed %d creatures."
				 , m_pClientList[iClientH]->m_cCharName
				 , iSkillLevel
				 , iTamingType
				 , iNbeTamed);
		PutLogList(cTamedString);
	}
}

void CGame::GetMagicAbilityHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] != 0) return;

	//    20  
	m_pClientList[iClientH]->m_cSkillMastery[4] = 20;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, 4, m_pClientList[iClientH]->m_cSkillMastery[4], NULL, NULL);
	// v1.4311    
	bCheckTotalSkillMasteryPoints(iClientH, 4);
}

int CGame::iRequestPanningMapDataRequest(int iClientH, char * pData)
{
 char  * cp, cDir, cData[3000];
 DWORD * dwp;
 WORD  * wp;
 short * sp, dX, dY;
 int   iRet, iSize;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	cDir = *(pData + DEF_INDEX2_MSGTYPE +2);
	if ((cDir <= 0) || (cDir > 8)) return 0;
		
	switch (cDir) {
	case 1:	dY--; break; // responding when mouse is placed north
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break; // responding when mouse placed at west side of screen
	case 8:	dX--; dY--;	break; // responding when mouse is placed north west
/*
player is in the center, and is trying to pan,
directions not responding or causing a break will be kept as X, 
others are the cDir case... 
		8	1	X

		7	_	X

		X	X	X
*/
	}

	m_pClientList[iClientH]->m_sX   = dX;
	m_pClientList[iClientH]->m_sY   = dY;
	m_pClientList[iClientH]->m_cDir = cDir;
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_PANNING;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOVE_CONFIRM;
		
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE+2);
		
	sp  = (short *)cp;
	*sp = (short)(dX - 10); 
	cp += 2;
		
	sp  = (short *)cp;
	*sp = (short)(dY - 7); 
	cp += 2;

	*cp = cDir;
	cp++;

	RefreshPartyCoords(iClientH);
		
	iSize = iComposeMoveMapData((short)(dX - 10), (short)(dY - 7), iClientH, cDir, cp);
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		//     .
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

void CGame::AdminOrder_EnableAdminCommand(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   * token, cBuff[256], len;
 char   seps[] = "= \t\n";
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		len = strlen(token);
		if(len > 10) len = 10;
		if (memcmp(token, m_cSecurityNumber, len) == 0) {
			m_pClientList[iClientH]->m_bIsAdminCommandEnabled = TRUE;
		}
		else {
			wsprintf(G_cTxt, "(%s) Player(%s) attempts to access /enableadmincommand with %s", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, token);
			PutHackLogFileList(G_cTxt);
			return;
		}
	}
}

void CGame::AdminOrder_CreateItem(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * cp, * token, cBuff[256], cItemName[256], cData[256], cTemp[256], cAttribute[256], cValue[256];
 SYSTEMTIME SysTime;
 class  CStrTok * pStrTok;
 class  CItem * pItem;
 short  * sp;
 int    iRet, iTemp, iEraseReq, iValue;
 DWORD * dwp;
 WORD  * wp, wTemp;
 double dV1, dV2, dV3;
 
	// if the client doesnt exist than no effect.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	// if the command is just "/createitem " than no effect.
	if ((dwMsgSize)	<= 0) return;

	// if client's admin level is less than 4 no effect.
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCreateItem) {
		// if the admin user level is not 0 and less than 4 send message 
		if (m_pClientList[iClientH]->m_iAdminUserLevel !=  0)	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	} // close if 

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	// if the token is something it is an item name
	if (token != NULL) {
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, token);
	} // close if 

	// if the 2nd token is true it is the item attribute
	ZeroMemory(cAttribute, sizeof(cAttribute));
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cAttribute, sizeof(cAttribute));
		strcpy(cAttribute, token);
	} // close if 

	// if the 3rd token is true it is the item value
	ZeroMemory(cValue, sizeof(cValue));
	iValue = 0;
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cValue, sizeof(cValue));
		strcpy(cValue, token);
		iValue = atoi(cValue);
	} // close if 

	pItem = new class CItem;
	// if the given itemname doesnt exist delete item
	if (_bInitItemAttr(pItem, cItemName) == FALSE) {
		delete pItem;
		return;	
	} //close if 

	if (strlen(cAttribute) != 0) {
		pItem->m_dwAttribute = atoi(cAttribute);
		if (pItem->m_dwAttribute == 1) {
			if ((iValue >= 1) && (iValue <= 200)) {
				pItem->m_cItemColor = 2;
				pItem->m_sItemSpecEffectValue2 = iValue - 100;
								
				dV2 = (double)pItem->m_sItemSpecEffectValue2;
				dV3 = (double)pItem->m_wMaxLifeSpan;
				dV1 = (dV2/100.0f)*dV3;

				iTemp  = (int)pItem->m_wMaxLifeSpan;
				iTemp += (int)dV1;

				if (iTemp <= 0) 
					 wTemp = 1;
				else wTemp = (WORD)iTemp;

				if (wTemp <= pItem->m_wMaxLifeSpan*2) {
					pItem->m_wMaxLifeSpan = wTemp;
					pItem->m_sItemSpecEffectValue1 = (short)wTemp;
					pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
				} // close if 
				else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;
			} // close if
			else pItem->m_dwAttribute = NULL;
		} // close if
		else {
			if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
				switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
				case 6:	pItem->m_cItemColor = 2; break;
				case 8: pItem->m_cItemColor = 3; break;
				case 1:	pItem->m_cItemColor = 5; break;
				case 5:	pItem->m_cItemColor = 1; break;
				case 3:	pItem->m_cItemColor = 7; break;
				case 2:	pItem->m_cItemColor = 4; break;
				case 7:	pItem->m_cItemColor = 6; break;
				case 9:	pItem->m_cItemColor = 8; break;
				} // close switch
			} // close if 
			else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
				switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
				case 10: pItem->m_cItemColor = 5; break;
				} // close switch 
			} // close else if
		} // close else 
	} // close if 

	// if the item id is
	switch (pItem->m_sIDnum) {
	case 511: // ArenaTicket
	case 513: // ArenaTicket(2)
	case 515: // ArenaTicket(3)
	case 517: // ArenaTicket(4)
	case 530: // ArenaTicket(5)
	case 531: // ArenaTicket(6)
	case 532: // ArenaTicket(7)
	case 533: // ArenaTicket(8)
	case 534: // ArenaTicket(9)
		GetLocalTime(&SysTime);
		pItem->m_sTouchEffectType   = DEF_ITET_DATE;
		// v1.4311-3         ..
		pItem->m_sTouchEffectValue1 = (short)SysTime.wMonth;
		pItem->m_sTouchEffectValue2 = (short)SysTime.wDay;
		pItem->m_sTouchEffectValue3 = 24 ;
		break;

	default:
		GetLocalTime(&SysTime);
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		//     , 	
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
		pItem->m_sTouchEffectValue3 = atoi(cTemp);
		break;
	}
	
	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		//  .
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1 . Amount !
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;	//   
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; //    .
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		// v2.15   
		if (iEraseReq == 1) {
			delete pItem;
			pItem = NULL ;
		}
		
		//    
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		

		// v2.14 Admin Log
		wsprintf(G_cTxt, "(%s) GM Order(%s): Create ItemName(%s)",m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cItemName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);

		return;
	}
	else {
		//     .		
		delete pItem;
		return;
	}
}

void CGame::RequestSellItemListHandler(int iClientH, char * pData)
{
 int i, * ip, iAmount;
 char * cp, cIndex;
 struct {
	char cIndex;
	int  iAmount;
 } stTemp[12];

	if (m_pClientList[iClientH] == NULL) return;

	cp = (char *)(pData + 6);
	for (i = 0; i < 12; i++) {
		stTemp[i].cIndex = *cp;
		cp++;

		ip = (int *)cp;
		stTemp[i].iAmount = *ip;
		cp += 4;
	}

	//   .  .
	for (i = 0; i < 12; i++) {
		cIndex = stTemp[i].cIndex;
		iAmount = stTemp[i].iAmount;

		if ((cIndex == -1) || (cIndex < 0) || (cIndex >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cIndex] == NULL) return;

		//    .
		ReqSellItemConfirmHandler(iClientH, cIndex, iAmount, NULL);
		//         !
		if (m_pClientList[iClientH] == NULL) return;
	}
}

void CGame::_DeleteRandomOccupyFlag(int iMapIndex)
{
 int i, iCount, iTotalFlags, iTargetFlag, iDynamicObjectIndex;
 int tx, ty, fx, fy, iLocalSide, iLocalEKNum, iPrevStatus;
 class CTile * pTile;
 DWORD dwTime;

	if (m_pMapList[iMapIndex] == NULL) return;

	dwTime = timeGetTime();

	//    .
	iTotalFlags = 0;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++)
	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != NULL) {
		iTotalFlags++;
	}

	//   .
	iTargetFlag = iDice(1, iTotalFlags);

	iCount = 0;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++)
	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != NULL) {
		iCount++;
		if ((iCount == iTotalFlags) && (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != NULL)) {
			//   .	

			//testcode
			wsprintf(G_cTxt, "(*)Delete OccupyFlag: Side(%d) XY(%d, %d)", m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_cSide, m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX, m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY);
			PutLogList(G_cTxt);

			fx = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX;
			fy = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY;
			iLocalSide  = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_cSide;
			iLocalEKNum = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iEKCount;
			
			pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX + 
				                    m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY*m_pMapList[iMapIndex]->m_sSizeY);
			//    
			m_pMapList[iMapIndex]->m_iTotalOccupyFlags--;
						
			iDynamicObjectIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iDynamicObjectIndex;
			//     
			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex, 
										m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, 
										m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, NULL);
			//     .
			m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);
						
			//    
			delete m_pMapList[iMapIndex]->m_pOccupyFlag[i];
			m_pMapList[iMapIndex]->m_pOccupyFlag[i] = NULL;

			//     
			pTile->m_iOccupyFlagIndex = NULL;

			//    
			delete m_pDynamicObjectList[iDynamicObjectIndex];
			m_pDynamicObjectList[iDynamicObjectIndex] = NULL;

			//        . ***    .
			for (tx = fx - 10; tx <= fx + 10; tx++)
			for (ty = fy - 8; ty <= fy + 8; ty++) {	
				if ((tx < 0) || (tx >= m_pMapList[iMapIndex]->m_sSizeX) || 
					(ty < 0) || (ty >= m_pMapList[iMapIndex]->m_sSizeY)) {
					//    
				}
				else {
					pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + tx + ty*m_pMapList[iMapIndex]->m_sSizeY);
					iPrevStatus = pTile->m_iOccupyStatus;
					// Side: (1)  (2)
					switch (iLocalSide) {
					case 1: 
						pTile->m_iOccupyStatus += iLocalEKNum;
						if (pTile->m_iOccupyStatus > 0) pTile->m_iOccupyStatus = 0;
						break;
					case 2:
						pTile->m_iOccupyStatus -= iLocalEKNum;
						if (pTile->m_iOccupyStatus < 0) pTile->m_iOccupyStatus = 0;
						break;
					}
				}
			}
			//
			return;
		}
	}
}


void CGame::CreateNewPartyHandler(int iClientH)
{
 BOOL bFlag;

	if (m_pClientList[iClientH] == NULL) return;

	bFlag = m_pClientList[iClientH]->bCreateNewParty();
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RESPONSE_CREATENEWPARTY, (int)bFlag, NULL, NULL, NULL);
}

void CGame::JoinPartyHandler(int iClientH, int iV1, char *pMemberName)
{
	char * cp, cData[120];
	short sAppr2;
	DWORD * dwp;
	WORD * wp;
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;

	switch (iV1) {
	case 0: //   
		RequestDeletePartyHandler(iClientH);
		break;

	case 1: //   
		//testcode
		wsprintf(G_cTxt, "Join Party Req: %s(%d) ID(%d) Stat(%d) ReqJoinH(%d) ReqJoinName(%s)", m_pClientList[iClientH]->m_cCharName, iClientH, 
			m_pClientList[iClientH]->m_iPartyID, m_pClientList[iClientH]->m_iPartyStatus, m_pClientList[iClientH]->m_iReqJoinPartyClientH,
			m_pClientList[iClientH]->m_cReqJoinPartyName);
		PutLogList(G_cTxt);

		if ((m_pClientList[iClientH]->m_iPartyID != NULL) || (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL)) {
			//          .
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			
			return;
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pMemberName) == 0)) {
				//     .
				sAppr2 = (short)((m_pClientList[i]->m_sAppr2 & 0xF000) >> 12);
				if (sAppr2 != 0) {
					//          .
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
					
				}
				else if (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) {
					//      .
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
					
				}
				else if (m_pClientList[i]->m_iPartyStatus == DEF_PARTYSTATUS_PROCESSING) {
					//            .  .
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
					//testcode
					wsprintf(G_cTxt, "Party join reject(2) ClientH:%d ID:%d JoinName:%d", i, m_pClientList[i]->m_iPartyID, m_pClientList[i]->m_cReqJoinPartyName);
					PutLogList(G_cTxt);

					m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
					ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
					m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				}
				else {
					//    .
					m_pClientList[i]->m_iReqJoinPartyClientH = iClientH;
					ZeroMemory(m_pClientList[i]->m_cReqJoinPartyName, sizeof(m_pClientList[i]->m_cReqJoinPartyName));
					strcpy(m_pClientList[i]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName);
					SendNotifyMsg(NULL, i, DEF_NOTIFY_QUERY_JOINPARTY, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);

					//        .   .
					m_pClientList[iClientH]->m_iReqJoinPartyClientH = i;
					ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
					strcpy(m_pClientList[iClientH]->m_cReqJoinPartyName, m_pClientList[i]->m_cCharName);
					//   
					m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
				}
				return;
			}
			break;

	case 2: //     
		if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) {
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 6; //    
			cp += 2;
			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			PutLogList("JoinPartyHandler case (2) send 6 to GateServer");
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		}
		break;
	}
}



BOOL CGame::bCheckEnergySphereDestination(int iNpcH, short sAttackerH, char cAttackerType)
{
 int i, sX,sY, dX, dY, iGoalMapIndex;
 char cResult;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex == -1) return FALSE;

	if (m_pNpcList[iNpcH]->m_cMapIndex != m_iMiddlelandMapIndex) {
		//   
		iGoalMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;
		
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
	
		cResult = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-2) && (sX <= dX+2) && (sY >= dY-2) && (sY <= dY+2)) {
			//   .
			//       
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;
		
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					//        +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					//  
					wsprintf(G_cTxt, "(!) EnergySphere Hit By Aresden Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					//       10 .
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				//       .
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					//    
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return TRUE;
		}

		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-2) && (sX <= dX+2) && (sY >= dY-2) && (sY <= dY+2)) {
			//   .
			//       
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					//        +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					//  
					wsprintf(G_cTxt, "(!) EnergySphere Hit By Elvine Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					//       10 .
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				//       .
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					//
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
		}
		return FALSE;
	}
	else {
		//   .

		//        
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
	
		cResult = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-4) && (sX <= dX+4) && (sY >= dY-4) && (sY <= dY+4)) {
			//   .
			//       
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;
		
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					//        +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					//  
					wsprintf(G_cTxt, "(!) EnergySphere Hit By Aresden Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					//       10 .
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				//       .
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					//    
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return TRUE;
		}

		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-4) && (sX <= dX+4) && (sY >= dY-4) && (sY <= dY+4)) {
			//   .
			//       
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					//        +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					//  
					wsprintf(G_cTxt, "(!) EnergySphere Hit By Aresden Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					//       10 .
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				//       .
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					//
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return TRUE;
		}
		return FALSE;
	}
}

void CGame::EnergySphereProcessor(BOOL bIsAdminCreate, int iClientH)
{
 int i, iNamingValue, iCIndex, iTemp, pX, pY;
 char cSA, cName_Internal[31], cWaypoint[31];

	if (bIsAdminCreate != TRUE) {
		
		if (m_iMiddlelandMapIndex < 0) return;
		if (m_pMapList[m_iMiddlelandMapIndex] == NULL) return;
		//     3 2000 1
		if (iDice(1,2000) != 123) return; 
		//     500   .
		if (m_iTotalGameServerClients < 500) return;
	
		//         .
		if (m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		//      
		iCIndex = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereCreationPoint);

		//        
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;
		
		//     
		cSA = 0;
 		pX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));
	
		iNamingValue = m_pMapList[m_iMiddlelandMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = m_iMiddlelandMapIndex + 65;
			
			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_iMiddlelandMapIndex]->m_cName, (rand() % 5), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) {
				m_pMapList[m_iMiddlelandMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}		

		//     
		iTemp  = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == NULL) return;
	
		//       
		m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		//       .
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, NULL, NULL);
		}

		//testcode
		wsprintf(G_cTxt, "(!) Energy Sphere Created! (%d, %d)", pX, pY);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
	else {
		//         .
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		//      
		iCIndex = iDice(1, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalEnergySphereCreationPoint);

		//        
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;
		
		//     
		cSA = 0;
 		pX = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));
	
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 5), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) {
				//   NameValue .
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}		

		//     
		iTemp  = iDice(1, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == NULL) return;
	
		//       
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		//       .
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, NULL, NULL);
		}

		//testcode
		wsprintf(G_cTxt, "(!) Admin Energy Sphere Created! (%d, %d)", pX, pY);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
}


void CGame::ActivateSpecialAbilityHandler(int iClientH)
{
 DWORD dwTime = timeGetTime();
 short sTemp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) return;
	if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) return;

	m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled  = TRUE;
	m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;

	m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;

	sTemp = m_pClientList[iClientH]->m_sAppr4;
	sTemp = sTemp & 0xFF0F;
	switch (m_pClientList[iClientH]->m_iSpecialAbilityType) {
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
		sTemp = sTemp | 0x0010;
		break;
	case 50:
	case 51:
	case 52:
	case 53:
	case 54:
		sTemp = sTemp | 0x0020;
		break;
	}
	m_pClientList[iClientH]->m_sAppr4 = sTemp;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, NULL);
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::CancelQuestHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	//   .
	_ClearQuestStatus(iClientH);
	//   .
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
}

int CGame::iGetItemWeight(CItem *pItem, int iCount)
{
 int iWeight;

	//     . Gold   20 1  
	iWeight = (pItem->m_wWeight);
	if (iCount < 0) iCount = 1;
	iWeight = iWeight * iCount;
	if (pItem->m_sIDnum == 90) iWeight = iWeight / 20;
	if (iWeight <= 0) iWeight = 1;

	return iWeight;
}

void CGame::UpdateMapSectorInfo()
{
 int i, ix, iy;
 int iMaxNeutralActivity, iMaxAresdenActivity, iMaxElvineActivity, iMaxMonsterActivity, iMaxPlayerActivity;
	
	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != NULL) {
	
		iMaxNeutralActivity = iMaxAresdenActivity = iMaxElvineActivity = iMaxMonsterActivity = iMaxPlayerActivity = 0;	
		m_pMapList[i]->m_iMaxNx = m_pMapList[i]->m_iMaxNy = m_pMapList[i]->m_iMaxAx = m_pMapList[i]->m_iMaxAy = 0;
		m_pMapList[i]->m_iMaxEx = m_pMapList[i]->m_iMaxEy = m_pMapList[i]->m_iMaxMx = m_pMapList[i]->m_iMaxMy = 0;
		m_pMapList[i]->m_iMaxPx = m_pMapList[i]->m_iMaxPy = 0;

		//   TempSectorInfo   SectorInfo   TempSectorInfo .
		for (ix = 0; ix < DEF_MAXSECTORS; ix++)
		for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity > iMaxNeutralActivity) {
				iMaxNeutralActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity;
				m_pMapList[i]->m_iMaxNx = ix;
				m_pMapList[i]->m_iMaxNy = iy;
			}
			
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity > iMaxAresdenActivity) {
				iMaxAresdenActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity;
				m_pMapList[i]->m_iMaxAx = ix;
				m_pMapList[i]->m_iMaxAy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity > iMaxElvineActivity) {
				iMaxElvineActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity;
				m_pMapList[i]->m_iMaxEx = ix;
				m_pMapList[i]->m_iMaxEy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity > iMaxMonsterActivity) {
				iMaxMonsterActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity;
				m_pMapList[i]->m_iMaxMx = ix;
				m_pMapList[i]->m_iMaxMy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity > iMaxPlayerActivity) {
				iMaxPlayerActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity;
				m_pMapList[i]->m_iMaxPx = ix;
				m_pMapList[i]->m_iMaxPy = iy;
			}
		}
	
		// TempSectorInfo .
		m_pMapList[i]->ClearTempSectorInfo();

		// Sector Info 
		if (m_pMapList[i]->m_iMaxNx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxNx][m_pMapList[i]->m_iMaxNy].iNeutralActivity++;
		if (m_pMapList[i]->m_iMaxAx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxAx][m_pMapList[i]->m_iMaxAy].iAresdenActivity++;
		if (m_pMapList[i]->m_iMaxEx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxEx][m_pMapList[i]->m_iMaxEy].iElvineActivity++;
		if (m_pMapList[i]->m_iMaxMx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxMx][m_pMapList[i]->m_iMaxMy].iMonsterActivity++;
		if (m_pMapList[i]->m_iMaxPx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxPx][m_pMapList[i]->m_iMaxPy].iPlayerActivity++;
	}
}


void CGame::AgingMapSectorInfo()
{
 int i, ix, iy;

	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != NULL) {
		for (ix = 0; ix < DEF_MAXSECTORS; ix++)
		for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
			m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity--;
			
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity   = 0;
		}
	}
}


BOOL CGame::__bSetConstructionKit(int iMapIndex, int dX, int dY, int iType, int iTimeCost, int iClientH)
{
 int iNamingValue, ix, iy, tX, tY;
 char cNpcName[21], cName[21], cNpcWaypoint[11], cOwnerType;
 short sOwnerH;

	//        .
	if ((m_bIsCrusadeMode == FALSE) || (m_pClientList[iClientH]->m_iCrusadeDuty != 2)) return FALSE;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures >= DEF_MAXCRUSADESTRUCTURES) {
		//        
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMORECRUSADESTRUCTURE, NULL, NULL, NULL, NULL);
		return FALSE;
	}

	//    NPC .
	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		//    NPC  .     .
	}
	else {

		//       .
		for (ix = dX -3; ix <= dX +5; ix++)
		for (iy = dY -3; iy <= dX +5; iy++) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH]->m_cActionLimit == 5)) return FALSE;
		}

		// NPC .
		ZeroMemory(cNpcName, sizeof(cNpcName));
		if (m_pClientList[iClientH]->m_cSide == 1) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Aresden"); break;
			case 2: strcpy(cNpcName, "CGT-Aresen"); break;
			case 3: strcpy(cNpcName, "MS-Aresden"); break;
			case 4: strcpy(cNpcName, "DT-Aresden"); break;
			}
		}
		else if (m_pClientList[iClientH]->m_cSide == 2) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Elvine"); break;
			case 2: strcpy(cNpcName, "CGT-Elvine"); break;
			case 3: strcpy(cNpcName, "MS-Elvine"); break;
			case 4: strcpy(cNpcName, "DT-Elvine"); break;
			}
		}
		else return FALSE;
	
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)dX;
		tY = (int)dY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
			//   NameValue .
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		} 
		else {
			// 
			wsprintf(G_cTxt, "Structure(%s) construction begin(%d,%d)!", cNpcName, tX, tY);
			PutLogList(G_cTxt);
			return TRUE;
		}
	}

	return FALSE;
}

void CGame::RequestSetGuildConstructLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
 char * cp, cData[120];
 int i;
 int *ip, iIndex;
 DWORD dwTemp, dwTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;

	//     
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDCONSTRUCTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;
	
	memcpy(cp, pMapName, 10);
	cp += 10;
	//

	dwTime = timeGetTime();

	//testcode
	wsprintf(G_cTxt, "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	//   GUID       . 
	//   2  .
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		//   .
		if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
			//  .   .
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			//   
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				
			//      
			bStockMsgToGateServer(cData, 23);
			return;
		}
	}
	
	//   .  .
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;

			//        
			bStockMsgToGateServer(cData, 23);
			return;
		}
		else {
			//       .
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}

	//    .         (iIndex)   .
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildConstructLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;

	//      
	bStockMsgToGateServer(cData, 23);
}

// New 14/05/2004 Changed
void CGame::RequestSummonWarUnitHandler(int iClientH, int dX, int dY, char cType, char cNum, char cMode)
{
 char cName[6], cNpcName[21], cMapName[11], cNpcWayPoint[11], cOwnerType;
 int i, x;
 int iNamingValue, tX, tY, ix, iy;
 BOOL bRet;
 short sOwnerH;
 DWORD dwTime = timeGetTime();
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cMapName, sizeof(cMapName));
		
	//   
	if (cType < 0) return;
	if (cType >= DEF_MAXNPCTYPES) return;
	if (cNum  >  10) return;

	//   .
	if (m_pClientList[iClientH]->m_iConstructionPoint < m_iNpcConstructionPoint[cType]) return;
	//      .
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE)) return; 

	//  
	cNum = 1;

	// ConstructionPoint     .
	for (x = 1; x <= cNum; x++) {
		//      
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) {
			//    NPC  .     .
			//  ?
		}
		else {
			// NPC .
			ZeroMemory(cName, sizeof(cName));
			wsprintf(cName, "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
			
			//        

			switch (cType) {
			case 43: // Light War Beetle
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "LWB-Aresden"); break;
				case 2: strcpy(cNpcName, "LWB-Elvine"); break;
				}
				break;

			case 36: // Arrow Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "AGT-Aresden"); break;
				case 2: strcpy(cNpcName, "AGT-Elvine"); break;
				}
				break;

			case 37: // Cannon Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CGT-Aresden"); break;
				case 2: strcpy(cNpcName, "CGT-Elvine"); break;
				}
				break;

			case 38: // Mana Collector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "MS-Aresden"); break;
				case 2: strcpy(cNpcName, "MS-Elvine"); break;
				}
				break;

			case 39: // Detector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "DT-Aresden"); break;
				case 2: strcpy(cNpcName, "DT-Elvine"); break;
				}
				break;

			case 51: // Catapult
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CP-Aresden"); break;
				case 2: strcpy(cNpcName, "CP-Elvine"); break;
				}
				break;

			case 44:
				strcpy(cNpcName, "GHK");
				break;

			case 45:
				strcpy(cNpcName, "GHKABS");
				break;

			case 46:
				strcpy(cNpcName, "TK");
				break;

			case 47:
				strcpy(cNpcName, "BG");
				break;

			case 82:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "Sor-Aresden"); break;
					case 2: strcpy(cNpcName, "Sor-Elvine"); break;
				}
				break;

			case 83:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "ATK-Aresden"); break;
					case 2: strcpy(cNpcName, "ATK-Elvine"); break;
				}
				break;

			case 84:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "Elf-Aresden"); break;
					case 2: strcpy(cNpcName, "Elf-Elvine"); break;
				}
				break;

			case 85:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "DSK-Aresden"); break;
					case 2: strcpy(cNpcName, "DSK-Elvine"); break;
				}
				break;

			case 86:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "HBT-Aresden"); break;
					case 2: strcpy(cNpcName, "HBT-Elvine"); break;
				}
				break;

			case 87:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "CT-Aresden"); break;
					case 2: strcpy(cNpcName, "CT-Elvine"); break;
				}
				break;

			case 88:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "Bar-Aresden"); break;
					case 2: strcpy(cNpcName, "Bar-Elvine"); break;
				}
				break;

			case 89:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "AGC-Aresden"); break;
					case 2: strcpy(cNpcName, "AGC-Elvine"); break;
				}
				break;
			}

			//testcode
			wsprintf(G_cTxt, "(!) Request Summon War Unit (%d) (%s)", cType, cNpcName);
			PutLogList(G_cTxt);
			
			tX = (int)dX;
			tY = (int)dY;
						
			//       .
			bRet = FALSE;
			switch (cType) {
			case 36:
			case 37:
			case 38:
			case 39:
				//   
				if (strcmp(m_pClientList[iClientH]->m_cConstructMapName, m_pClientList[iClientH]->m_cMapName) != 0) bRet = TRUE;
				if (abs(m_pClientList[iClientH]->m_sX - m_pClientList[iClientH]->m_iConstructLocX) > 10) bRet = TRUE;
				if (abs(m_pClientList[iClientH]->m_sY - m_pClientList[iClientH]->m_iConstructLocY) > 10) bRet = TRUE;

				if (bRet == TRUE) {
					//        .
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 2, NULL, NULL, NULL);
					return;
				}

				//     .      .
				/////
				for (i = 0; i < DEF_MAXGUILDS; i++) 
				if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
					m_pGuildTeleportLoc[i].m_dwTime = dwTime;
					if (m_pGuildTeleportLoc[i].m_iV2 >= DEF_MAXCONSTRUCTNUM) {
						//    .  .
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);		
						return;
					}
					else {
						//    .
						m_pGuildTeleportLoc[i].m_iV2++;
						goto RSWU_LOOPBREAK;
					}
				}

				//    .  .
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
				return;
				

			case 43:
			case 44:
			case 45:
			case 46:
			case 47:
			case 51:
			case 40:
			case 41:
			case 42:
			case 48:
			case 49:
			case 50:
				break;
			}
			
RSWU_LOOPBREAK:;

			//          .
			bRet = FALSE;
			switch (cType) {
			case 36:
			case 37:
				for (ix = tX-2; ix <= tX+2; ix++)
				for (iy = tY-2; iy <= tY+2; iy++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC)) {
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 36:
						case 37:
							bRet = TRUE;
							break;
						}
					}
				}

				//    
				if ((dY <= 32) || (dY >= 783)) bRet = TRUE;
				break;
			}

			if (bRet == TRUE) {
				//    .
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 1, NULL, NULL, NULL);
				return;
			}

			//      
			if (cMode == NULL) {
				bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_FOLLOW, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
				bSetNpcFollowMode(cName, m_pClientList[iClientH]->m_cCharName, DEF_OWNERTYPE_PLAYER);
			}
			else bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_GUARD, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
				
			if (bRet == FALSE) {
				//   NameValue .
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
			} 
			else {
				//      .
				m_pClientList[iClientH]->m_iConstructionPoint -= m_iNpcConstructionPoint[cType];
				if (m_pClientList[iClientH]->m_iConstructionPoint < 0) m_pClientList[iClientH]->m_iConstructionPoint = 0;
				//   .
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, NULL, NULL);
			}
		}
	}
}

void CGame::CheckConnectionHandler(int iClientH, char *pData)
{
 char * cp;
 DWORD * dwp, dwTimeRcv, dwTime, dwTimeGapClient, dwTimeGapServer;
	
	dwTime = timeGetTime();
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	dwp = (DWORD *)cp;
	dwTimeRcv = *dwp;

	if (!CheckDenialServiceAttack(iClientH, dwTimeRcv)) return;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_dwInitCCTimeRcv == NULL) {
		m_pClientList[iClientH]->m_dwInitCCTimeRcv = dwTimeRcv;
		m_pClientList[iClientH]->m_dwInitCCTime = dwTime;
	}
	else {
		dwTimeGapClient = (dwTimeRcv - m_pClientList[iClientH]->m_dwInitCCTimeRcv);
		dwTimeGapServer = (dwTime - m_pClientList[iClientH]->m_dwInitCCTime);
		
		if (dwTimeGapClient < dwTimeGapServer) return;
		if ((abs(int(dwTimeGapClient - dwTimeGapServer))) >= (DEF_CLIENTTIMEOUT)) {
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}
}

void CGame::SelectCrusadeDutyHandler(int iClientH, int iDuty)
{

	if (m_pClientList[iClientH] == NULL) return;
	if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (iDuty == 3)) return;

	if (m_iLastCrusadeWinner == m_pClientList[iClientH]->m_cSide &&
		m_pClientList[iClientH]->m_dwCrusadeGUID == 0 && iDuty == 3) {
			m_pClientList[iClientH]->m_iConstructionPoint = 3000;
	}
	m_pClientList[iClientH]->m_iCrusadeDuty = iDuty;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
	if (iDuty == 1) 
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,NULL,"Fighter");
	else if (iDuty == 2) 
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,NULL,"Constructor");
	else
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,NULL,"Commander");
}

void CGame::MapStatusHandler(int iClientH, int iMode, char * pMapName)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return;

	switch (iMode) {
	case 1:
		if (m_pClientList[iClientH]->m_iCrusadeDuty == NULL) return;

		for (i = 0; i < DEF_MAXGUILDS; i++) 
		if ((m_pGuildTeleportLoc[i].m_iV1 != NULL) && (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID)) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TCLOC, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY,
				          NULL, m_pGuildTeleportLoc[i].m_cDestMapName, m_pGuildTeleportLoc[i].m_sDestX2, m_pGuildTeleportLoc[i].m_sDestY2,
						  NULL, NULL, NULL, NULL, m_pGuildTeleportLoc[i].m_cDestMapName2);	
			//    .
			ZeroMemory(m_pClientList[iClientH]->m_cConstructMapName, sizeof(m_pClientList[iClientH]->m_cConstructMapName));
			memcpy(m_pClientList[iClientH]->m_cConstructMapName, m_pGuildTeleportLoc[i].m_cDestMapName2, 10);
			m_pClientList[iClientH]->m_iConstructLocX = m_pGuildTeleportLoc[i].m_sDestX2;
			m_pClientList[iClientH]->m_iConstructLocY = m_pGuildTeleportLoc[i].m_sDestY2;
			return;
		}

		//     .
		break;

	case 3:
		//if (m_pClientList[iClientH]->m_iCrusadeDuty != 3) return;
		//     
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = NULL;
		}
		m_pClientList[iClientH]->m_iCSIsendPoint = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cSendingMapName, sizeof(m_pClientList[iClientH]->m_cSendingMapName));

		if (strcmp(pMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName) == 0) {
			//      .
			//       .
			for (i = 0; i < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures; i++) {
				// v2.15  Commander     .
				if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) 
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
				else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType == 42) 
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
			}
			memcpy(m_pClientList[iClientH]->m_cSendingMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 10);
		}
		else {
			//    .    
			if (strcmp(pMapName, "middleland") == 0) {
				for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
				// v2.15  Commander     .
					if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) 
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}								
					else if (m_stMiddleCrusadeStructureInfo[i].cType == 42)
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}
				}
				strcpy(m_pClientList[iClientH]->m_cSendingMapName, "middleland");
			}
			else {
				//    .
			}
		}
	
		_SendMapStatus(iClientH);
		break;
	}
}

void CGame::_SendMapStatus(int iClientH)
{
 int i, iDataSize;
 char *cp, cData[DEF_MAXCRUSADESTRUCTURES*6];
 short * sp;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);

	memcpy(cp, m_pClientList[iClientH]->m_cSendingMapName, 10);
	cp += 10;
	
	sp = (short *)cp;
	*sp = (short)m_pClientList[iClientH]->m_iCSIsendPoint;
	cp += 2;

	//       .
	cp++;

	if (m_pClientList[iClientH]->m_iCSIsendPoint == NULL)
		m_pClientList[iClientH]->m_bIsSendingMapStatus = TRUE;

	// 100  .
	iDataSize = 0;
	for (i = 0 ; i < 100; i++) {
		if (m_pClientList[iClientH]->m_iCSIsendPoint >= DEF_MAXCRUSADESTRUCTURES) goto SMS_ENDOFDATA;
		if (m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType == NULL) goto SMS_ENDOFDATA;
		
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType;
		cp++;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sX;
		cp += 2;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sY;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cSide;
		cp++;

		iDataSize += 6;
		m_pClientList[iClientH]->m_iCSIsendPoint++;
	}

	//       .
	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAPSTATUSNEXT, iDataSize +13, NULL, NULL, cData);
	return;

SMS_ENDOFDATA:;

	//     .
	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAPSTATUSLAST, iDataSize +13, NULL, NULL, cData);
	m_pClientList[iClientH]->m_bIsSendingMapStatus = FALSE;

	return;
}

void CGame::RequestHelpHandler(int iClientH)
{
 //  .     .
 int i;	

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iGuildRank == -1) return;
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 1) return;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildRank == 0) && 
		(m_pClientList[i]->m_iCrusadeDuty == 3) && (m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
		//       .
		SendNotifyMsg(NULL, i, DEF_NOTIFY_HELP, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_iHP, m_pClientList[iClientH]->m_cCharName);
		return;
	}

	//      .
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELPFAILED, NULL, NULL, NULL, NULL);
}


BOOL CGame::bStockMsgToGateServer(char *pData, DWORD dwSize)
{
 char * cp;

	//testcode
	wsprintf(G_cTxt, "StockMsg(%d) Size(%d)", *pData, dwSize);
	PutLogList(G_cTxt);

	if ((m_iIndexGSS + dwSize) >= DEF_MAXGATESERVERSTOCKMSGSIZE-10) return FALSE;

	cp = (char *)(m_cGateServerStockMsg + m_iIndexGSS);	
	memcpy(cp, pData, dwSize);

	m_iIndexGSS += dwSize;

	return TRUE;
}


void CGame::SendStockMsgToGateServer()
{
 DWORD * dwp;
 WORD * wp;
 char * cp;

	//      .
	if (m_iIndexGSS > 6) {
		//testcode
		wsprintf(G_cTxt, "(!) Sending Gate Server Stock Msg(%d)", m_iIndexGSS);
		PutLogList(G_cTxt);

		SendMsgToGateServer(MSGID_SERVERSTOCKMSG, NULL, m_cGateServerStockMsg);
	
		//  
		ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
		//    
		cp = (char *)m_cGateServerStockMsg;
		dwp = (DWORD *)cp;
		*dwp = MSGID_SERVERSTOCKMSG;
		cp += 4;
		wp = (WORD *)cp;
		*wp = DEF_MSGTYPE_CONFIRM;
		cp += 2;

		m_iIndexGSS = 6;
	}
}

void CGame::ServerStockMsgHandler(char *pData)
{
 char * cp, * cp2, cTemp[120], cLocation[10], cGuildName[20], cName[11], cTemp2[120], cTemp3[120], cMapName[11], cBuffer[256]; short * sp;
 WORD * wp, wServerID, wClientH, wV1, wV2, wV3, wV4, wV5;
 DWORD * dwp;
 BOOL bFlag = FALSE;
 int * ip, i, iTotal, iV1, iV2, iV3, iRet;
 short sX, sY;

	iTotal = 0;
	cp = (char *)(pData + 6);
	while (bFlag == FALSE) {
		iTotal++;
		switch (*cp) {
		
		case GSM_REQUEST_SUMMONGUILD:
			cp++;

			ZeroMemory(cGuildName, sizeof(cGuildName));
			memcpy(cGuildName, cp, 20);
			cp += 20;

			ZeroMemory(cTemp, sizeof(cMapName));
			memcpy(cMapName, cp, 10);
			cp += 10;

			cp2 = (char *) cTemp + 10;
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp = (WORD *)cp;
			wV2 = *wp;
			cp += 2;

			for (i = 0; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cGuildName, cGuildName) == 0))
			{	wsprintf(G_cTxt,"PC(%s) summoned by Guild(%s) to %s.", m_pClientList[i]->m_cCharName, cGuildName, cMapName);
				PutLogList(G_cTxt);
				RequestTeleportHandler(i, "2   ", cMapName, wV1, wV2);
			}

			break;

		// v2.14     
		case GSM_REQUEST_SUMMONPLAYER:
			cp++;
			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			cp2 = (char *) cTemp + 10 ;
			
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
					RequestTeleportHandler(i, "2   ", cTemp ,wV1, wV2);
					break;
				}
			break;
		
		case GSM_REQUEST_SUMMONALL:
			cp++;
			ZeroMemory(cLocation, sizeof(cLocation));
			memcpy(cLocation, cp, 10);
			cp += 10;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			cp2 = (char *) cTemp + 10;
			
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			
			for (i = 0; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cLocation, cLocation) == 0)) {
			RequestTeleportHandler(i, "2   ", cTemp, wV1, wV2);
		}
		break;

		case GSM_CHATMSG:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			ZeroMemory(cName, sizeof(cName));
			iV1 = *cp;
			cp++;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			memcpy(cName, cp, 10);
			cp += 10;;
			sp = (short *)cp;
			wV1 = (WORD)*sp;
			cp += 2;
			ChatMsgHandlerGSM(iV1, iV2, cName, cp, wV1);
			cp += wV1;
			break;
		
		case GSM_CONSTRUCTIONPOINT:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			GSM_ConstructionPoint(iV1, iV2);
			break;

		case GSM_SETGUILDTELEPORTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildTeleportLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_SETGUILDCONSTRUCTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildConstructLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_REQUEST_SETFORCERECALLTIME:
			cp++;
			wp = (WORD *)cp;
			m_sForceRecallTime = *wp;
			cp += 2;

			wsprintf(G_cTxt,"(!) Game Server Force Recall Time (%d)min",m_sForceRecallTime) ;
			PutLogList(G_cTxt) ;
			break;

		case GSM_MIDDLEMAPSTATUS:
			cp++;
			//  
			for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
				m_stMiddleCrusadeStructureInfo[i].cType = NULL;
				m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
				m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
				m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
			}
			sp = (short *)cp;
			m_iTotalMiddleCrusadeStructures = *sp;
			cp += 2;
			//  .
			for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
				m_stMiddleCrusadeStructureInfo[i].cType = *cp;
				cp++;
				m_stMiddleCrusadeStructureInfo[i].cSide = *cp;
				cp++;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sX = *sp;
				cp += 2;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sY = *sp;
				cp += 2;	
			}
			break;
		
		case GSM_BEGINCRUSADE:
			cp++;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartCrusadeMode(*dwp);
			break;

		case GSM_BEGINAPOCALYPSE:
			cp++;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartApocalypse(*dwp);
			break;

		case GSM_ENDAPOCALYPSE:
			cp++;
			LocalEndApocalypse();
			break;

		case GSM_STARTHELDENIAN:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartHeldenianMode(wV1, wV2, *dwp);
			break;

		case GSM_ENDHELDENIAN:
			cp++;
			dwp = (DWORD *)cp;
			cp += 4;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			LocalEndHeldenianMode(*dwp ,iV1);
			break;
			
		case GSM_UPDATECONFIGS:
			cp++;
			LocalUpdateConfigs(*cp);
			cp += 16;
			break;

		case GSM_ENDCRUSADE:
			cp++;
			LocalEndCrusadeMode(*cp);
			cp += 16;
			break;

		case GSM_COLLECTEDMANA:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			CollectedManaHandler(wV1, wV2);
			break;

		case GSM_GRANDMAGICLAUNCH:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;

			switch (wV1) {
			case 1: //   
				MeteorStrikeMsgHandler((char)wV2);
				break;
			}
			break;
		
		case  GSM_GRANDMAGICRESULT:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV3 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV4 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV5 = *wp;

			GrandMagicResultHandler(cTemp, wV1, wV2, wV3, wV4, wV5, cp);
			break;
		
			// v2.15 2002-5-21
		case GSM_REQUEST_SHUTUPPLAYER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			GSM_RequestShutupPlayer(cTemp,wServerID,wClientH, wV1, cName);
			break ;

		case GSM_RESPONSE_SHUTUPPLAYER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;


			if (wServerID == m_wServerID_GSS) {
				if ((m_pClientList[wClientH] != NULL)&& (strcmp(m_pClientList[wClientH]->m_cCharName, cName) == 0)&&(m_pClientList[wClientH]->m_iAdminUserLevel > 0)) {
					SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_PLAYERSHUTUP, wV1, NULL, NULL, cTemp);

				}
			}
			break;

		// New 16/05/2004
		case GSM_WHISFERMSG:
			ZeroMemory(cName, sizeof(cName));
			ZeroMemory(cBuffer, sizeof(cBuffer));
			cp++;
			memcpy(cName, cp, 10);
			cp += 10;
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			memcpy(cBuffer, cp, wV1);
			cp += wV1;

			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cBuffer, wV1);
					if(	m_pClientList[i]->m_iAdminUserLevel > 0) {
						char cTxt[200],cTmpName[12] ;
						ZeroMemory(cTxt,sizeof(cTxt)) ;
						ZeroMemory(cTmpName,sizeof(cTmpName)) ;

						memcpy(cTmpName,cBuffer+10,10) ;
						wsprintf(cTxt,"PC Chat(%s):\"%s\"\tto GM(%s)",cTmpName,cBuffer+21,m_pClientList[i]->m_cCharName) ;
						bSendMsgToLS(MSGID_GAMEMASTERLOG, i, NULL, cTxt);
					}
					break;
				}
		break;

		// New 16/05/2004 Changed
		case GSM_REQUEST_FINDCHARACTER:
			cp++;

			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;

			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			ZeroMemory(cTemp2, sizeof(cTemp2));
			memcpy(cTemp2, cp, 10);
			cp += 10;

			GSM_RequestFindCharacter(wServerID, wClientH, cTemp, cTemp2);
			break;

		case GSM_RESPONSE_FINDCHARACTER:
			sX = -1;
			sY = -1;
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			ZeroMemory(cTemp2, sizeof(cTemp2));
			memcpy(cTemp2, cp, 10);
			cp += 10;

			ZeroMemory(cTemp3, sizeof(cTemp3));
			memcpy(cTemp3, cp, 14);

			if ((wServerID == m_wServerID_GSS) && m_pClientList[wClientH] != NULL) {
				if (m_pClientList[wClientH]->m_bIsAdminOrderGoto == TRUE) {
					m_pClientList[wClientH]->m_bIsAdminOrderGoto = FALSE;
					ZeroMemory(cMapName, sizeof(cMapName));
					memcpy(cMapName, cp, 10);
					cp += 10;

					wp = (WORD *)cp;
					sX = *wp;
					cp += 2;

					wp = (WORD *)cp;
					sY = *wp;
					cp += 2;

					if (m_pClientList[wClientH]->m_iAdminUserLevel > 0) {
						if(sX == -1 && sY == -1){
							wsprintf(G_cTxt,"GM Order(%s): GoTo MapName(%s)",m_pClientList[wClientH]->m_cCharName, cMapName);
						}
						else{
							wsprintf(G_cTxt,"GM Order(%s): GoTo MapName(%s)(%d %d)",m_pClientList[wClientH]->m_cCharName,
								cMapName, sX, sY);
						}
						bSendMsgToLS(MSGID_GAMEMASTERLOG, wClientH, FALSE, G_cTxt);
						RequestTeleportHandler(wClientH,"2   ", cMapName, sX, sY);
					}
				}
				else{
					if ((m_pClientList[wClientH]->m_bIsCheckingWhisperPlayer == TRUE) && (strcmp(m_pClientList[wClientH]->m_cWhisperPlayerName, cTemp) == 0)) {
						m_pClientList[wClientH]->m_iWhisperPlayerIndex = 10000;
						SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[wClientH]->m_cWhisperPlayerName);
					}
					else{
						if (m_pClientList[wClientH]->m_iAdminUserLevel == 0) {
							ZeroMemory(cTemp3, sizeof(cTemp3));
						}
						if (strcmp(m_pClientList[wClientH]->m_cCharName, cTemp2) == 0) {
							SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_PLAYERONGAME, NULL, NULL, NULL, cTemp,
								NULL, NULL, NULL, NULL, NULL, NULL, cTemp3);
						}
					}
				}
			}
			break;

		default:
			bFlag = TRUE;
			break;
		}
	}
}

void CGame::GSM_RequestFindCharacter(WORD wReqServerID, WORD wReqClientH, char *pName, char * pFinder)
{
 char * cp, cTemp[120];
 WORD * wp;
 int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL)  && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
		// .
		ZeroMemory(cTemp, sizeof(cTemp));
		cp = (char *)(cTemp);
		*cp = GSM_RESPONSE_FINDCHARACTER;
		cp++;

		wp = (WORD *)cp;
		*wp = wReqServerID;
		cp += 2;

		wp = (WORD *)cp;
		*wp = wReqClientH;
		cp += 2;
		
		memcpy(cp, pName, 10);
		cp += 10;

		memcpy(cp, pFinder, 10);
		cp += 10;

		memcpy(cp, m_pClientList[i]->m_cMapName, 10);
		cp += 10;

		wp = (WORD *)cp;
		*wp = m_pClientList[i]->m_sX;
		cp += 2;

		wp = (WORD *)cp;
		*wp = m_pClientList[i]->m_sY;
		cp += 2;

		bStockMsgToGateServer(cTemp, 39);
		return;	
	}
}

// New 11/05/2004 Changed
void CGame::DoMeteorStrikeDamageHandler(int iMapIndex)
{
 int i, iDamage;

	//    HP  
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_cSide != 0) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
		if (m_pClientList[i]->m_iLevel < 80) 
			 iDamage = m_pClientList[i]->m_iLevel   +iDice(1,10);
		else iDamage = m_pClientList[i]->m_iLevel*2 +iDice(1,10);
		iDamage = iDice(1, m_pClientList[i]->m_iLevel) + m_pClientList[i]->m_iLevel;
		//  255   .
		if (iDamage > 255) iDamage = 255;
	
		if (m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) { //magic cut in half
			iDamage = (iDamage/2) - 2;
		}

		if (m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 5) { 
			iDamage = 0;
		}
		
		if (m_pClientList[i]->m_iAdminUserLevel > 0) { // Admins get no damage
			iDamage = 0;
		}

		m_pClientList[i]->m_iHP -= iDamage;
		if (m_pClientList[i]->m_iHP <= 0) {
			//  .
			ClientKilledHandler(i, NULL, NULL, iDamage);	
			m_stMeteorStrikeResult.iCasualties++;
		}
		else {
			if (iDamage > 0) {
				//   . <- HP  .
				SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				//     
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

				if (m_pClientList[i]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(0, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				}
			
				if (m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
					m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}		
	}
}

void CGame::SyncMiddlelandMapInfo()
{
 int i;
 char * cp;
 short * sp;

	//     .           .
	if (m_iMiddlelandMapIndex != -1) {
		//  
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = NULL;
			m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
			m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
			m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
		}
		//       
		m_iTotalMiddleCrusadeStructures = m_pMapList[m_iMiddlelandMapIndex]->m_iTotalCrusadeStructures;
		ZeroMemory(G_cData50000, sizeof(G_cData50000));
		cp = (char *)G_cData50000;
		*cp = GSM_MIDDLEMAPSTATUS;
		cp++;

		sp = (short *)cp;
		*sp = (short)m_iTotalMiddleCrusadeStructures;
		cp += 2;
				
		for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cType;
			m_stMiddleCrusadeStructureInfo[i].cSide = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cSide;
			m_stMiddleCrusadeStructureInfo[i].sX    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sX;
			m_stMiddleCrusadeStructureInfo[i].sY    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sY;
			
			*cp = m_stMiddleCrusadeStructureInfo[i].cType;
			cp++;
			*cp = m_stMiddleCrusadeStructureInfo[i].cSide;
			cp++;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sX;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sY;
			cp += 2;
		}
		
		//  .
		if (m_iTotalMiddleCrusadeStructures != 0) {
			//testcode
			wsprintf(G_cTxt, "m_iTotalMiddleCrusadeStructures: %d", m_iTotalMiddleCrusadeStructures);
			PutLogList(G_cTxt);
			bStockMsgToGateServer(G_cData50000, 3 + m_iTotalMiddleCrusadeStructures*6);
		}
	}
}

void CGame::GSM_SetGuildConstructLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
 int i, iIndex;
 DWORD dwTemp, dwTime;

	//         .   .
	
	//testcode
	wsprintf(G_cTxt, "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	dwTime = timeGetTime();

	//   GUID       .
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		//   .
		if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
			//  .   .
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			//  
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
	}
	
	//   .  .
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			//       .
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}

	//    .         (iIndex)   .
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildConstLocuct Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
}

void CGame::CheckCommanderConstructionPoint(int iClientH)
{
 char * cp, cData[120];
 int  * ip, i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_bIsCrusadeMode == FALSE) return;
	if (m_pClientList[iClientH]->m_iConstructionPoint <= 0) return;

	switch (m_pClientList[iClientH]->m_iCrusadeDuty) {
	case 1: // 
	case 2: // :      .
		for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
			(m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
			//      .     
			m_pClientList[i]->m_iConstructionPoint += m_pClientList[iClientH]->m_iConstructionPoint;
			m_pClientList[i]->m_iWarContribution   += (m_pClientList[iClientH]->m_iConstructionPoint / 10);

			if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
				m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
		
			if (m_pClientList[i]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
				m_pClientList[i]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

			SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
			m_pClientList[iClientH]->m_iConstructionPoint = 0; //   
			return;
		}

		//     .
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_CONSTRUCTIONPOINT;
		cp++;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iGuildGUID;
		cp += 4;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iConstructionPoint;
		cp += 4;
		bStockMsgToGateServer(cData, 9);

		m_pClientList[iClientH]->m_iConstructionPoint = 0; //   
		break;

	case 3: // :    
		
		break;
	}
}

void CGame::GSM_ConstructionPoint(int iGuildGUID, int iPoint)
{
 int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
		(m_pClientList[i]->m_iGuildGUID == iGuildGUID)) {
		//    .
		m_pClientList[i]->m_iConstructionPoint += iPoint;
		m_pClientList[i]->m_iWarContribution   += iPoint/10;
		
		if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
			m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
		
		if (m_pClientList[i]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
			m_pClientList[i]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

		SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
		//testcode
		wsprintf(G_cTxt, "GSM_ConstructionPoint: %d %d", iGuildGUID, iPoint);
		PutLogList(G_cTxt);
		return;
	}
}

BOOL CGame::bAddClientShortCut(int iClientH)
{
 int i; 

	//     

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_iClientShortCut[i] == iClientH) return FALSE;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_iClientShortCut[i] == 0) {
		m_iClientShortCut[i] = iClientH;
		return TRUE;
	}

	return FALSE;
}

void CGame::RemoveClientShortCut(int iClientH)
{
 int i;

	for (i = 0; i < DEF_MAXCLIENTS+1; i++)
	if (m_iClientShortCut[i] == iClientH) {
		m_iClientShortCut[i] = 0;
		goto RCSC_LOOPBREAK;
	}

RCSC_LOOPBREAK:;

	//   .
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_iClientShortCut[i] == 0) && (m_iClientShortCut[i+1] != 0)) {
		m_iClientShortCut[i] = m_iClientShortCut[i+1];
		m_iClientShortCut[i+1] = 0;
	}
}

void CGame::_CreateCrusadeGUID(DWORD dwCrusadeGUID, int iWinnerSide)
{
 char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;
		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));
	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"CrusadeGUID.Txt");
		
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		//         . 
		wsprintf(cTxt, "(!) Cannot create CrusadeGUID(%d) file", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	else {
		ZeroMemory(cTemp, sizeof(cTemp));
		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "CrusadeGUID = %d\n", dwCrusadeGUID);
		strcat(cTemp, cTxt);

		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);
		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		
		wsprintf(cTxt, "(O) CrusadeGUID(%d) file created", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}


BOOL CGame::bReadCrusadeGUIDFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		//      .
		PutLogList("(!) Cannot open CrusadeGUID file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading CrusadeGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwCrusadeGUID = atoi(token);
					wsprintf(G_cTxt, "CrusadeGUID = %d", m_dwCrusadeGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;

				case 2:
					// New 13/05/2004 Changed
					m_iLastCrusadeWinner = atoi(token);
					wsprintf(G_cTxt, "CrusadeWinnerSide = %d", m_iLastCrusadeWinner);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "CrusadeGUID", 11) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}
			
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

void CGame::ManualEndCrusadeMode(int iWinnerSide)
{
 char * cp, cData[256];
 WORD * wp;

	//    .   .
	if (m_bIsCrusadeMode == FALSE) return;

	LocalEndCrusadeMode(iWinnerSide);

	//     .
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp =  GSM_ENDCRUSADE;
	cp++;

	*cp = (char)iWinnerSide;
	cp++;			

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;
		
	cp += 10;

	bStockMsgToGateServer(cData, 18);
}

int CGame::iGetMapLocationSide(char *pMapName)
{

	if (strcmp(pMapName, "aresden") == 0) return 3;
	if (strcmp(pMapName, "elvine") == 0) return 4;
	if (strcmp(pMapName, "arebrk11") == 0) return 3;
	if (strcmp(pMapName, "elvbrk11") == 0) return 4;

	if (strcmp(pMapName, "cityhall_1") == 0) return 1;
	if (strcmp(pMapName, "cityhall_2") == 0) return 2;
	if (strcmp(pMapName, "cath_1") == 0) return 1;
	if (strcmp(pMapName, "cath_2") == 0) return 2;
	if (strcmp(pMapName, "gshop_1") == 0) return 1;
	if (strcmp(pMapName, "gshop_2") == 0) return 2;
	if (strcmp(pMapName, "bsmith_1") == 0) return 1;
	if (strcmp(pMapName, "bsmith_2") == 0) return 2;
	if (strcmp(pMapName, "wrhus_1") == 0) return 1;
	if (strcmp(pMapName, "wrhus_2") == 0) return 2;
	if (strcmp(pMapName, "gldhall_1") == 0) return 1;
	if (strcmp(pMapName, "gldhall_2") == 0) return 2;
	if (strcmp(pMapName, "wzdtwr_1") == 0) return 1;
	if (strcmp(pMapName, "wzdtwr_2") == 0) return 2;
	if (strcmp(pMapName, "arefarm") == 0) return 1;
	if (strcmp(pMapName, "elvfarm") == 0) return 2;
	if (strcmp(pMapName, "arewrhus") == 0) return 1;
	if (strcmp(pMapName, "elvwrhus") == 0) return 2;
	if (strcmp(pMapName, "cmdhall_1") == 0) return 1;
	if (strcmp(pMapName, "Cmdhall_2") == 0) return 2;

	return 0;
}

BOOL CGame::bCopyItemContents(CItem * pCopy, CItem *pOriginal)
{
	if (pOriginal == NULL) return FALSE;
	if (pCopy == NULL) return FALSE;
	
	pCopy->m_sIDnum = pOriginal->m_sIDnum;					//    
	pCopy->m_cItemType = pOriginal->m_cItemType;
	pCopy->m_cEquipPos = pOriginal->m_cEquipPos;
	pCopy->m_sItemEffectType = pOriginal->m_sItemEffectType;     
	pCopy->m_sItemEffectValue1 = pOriginal->m_sItemEffectValue1;
	pCopy->m_sItemEffectValue2 = pOriginal->m_sItemEffectValue2;
	pCopy->m_sItemEffectValue3 = pOriginal->m_sItemEffectValue3; 
	pCopy->m_sItemEffectValue4 = pOriginal->m_sItemEffectValue4;
	pCopy->m_sItemEffectValue5 = pOriginal->m_sItemEffectValue5;
	pCopy->m_sItemEffectValue6 = pOriginal->m_sItemEffectValue6; 
	pCopy->m_wMaxLifeSpan = pOriginal->m_wMaxLifeSpan;
	pCopy->m_sSpecialEffect = pOriginal->m_sSpecialEffect;
	
	//v1.432    .     .
	pCopy->m_sSpecialEffectValue1 = pOriginal->m_sSpecialEffectValue1;
	pCopy->m_sSpecialEffectValue2 = pOriginal->m_sSpecialEffectValue2; 

	pCopy->m_sSprite = pOriginal->m_sSprite;
	pCopy->m_sSpriteFrame = pOriginal->m_sSpriteFrame;

	pCopy->m_cApprValue = pOriginal->m_cApprValue;
	pCopy->m_cSpeed = pOriginal->m_cSpeed;

	pCopy->m_wPrice = pOriginal->m_wPrice; 
	pCopy->m_wWeight = pOriginal->m_wWeight;
	pCopy->m_sLevelLimit = pOriginal->m_sLevelLimit;	
	pCopy->m_cGenderLimit = pOriginal->m_cGenderLimit;

	pCopy->m_sRelatedSkill = pOriginal->m_sRelatedSkill;
	
	pCopy->m_cCategory = pOriginal->m_cCategory;
	pCopy->m_bIsForSale = pOriginal->m_bIsForSale;
	// 

	pCopy->m_dwCount = pOriginal->m_dwCount;
	pCopy->m_sTouchEffectType = pOriginal->m_sTouchEffectType;
	pCopy->m_sTouchEffectValue1 =pOriginal->m_sTouchEffectValue1;
	pCopy->m_sTouchEffectValue2 = pOriginal->m_sTouchEffectValue2;
	pCopy->m_sTouchEffectValue3 = pOriginal->m_sTouchEffectValue3;
	pCopy->m_cItemColor = pOriginal->m_cItemColor;
	pCopy->m_sItemSpecEffectValue1 = pOriginal->m_sItemSpecEffectValue1;
	pCopy->m_sItemSpecEffectValue2 = pOriginal->m_sItemSpecEffectValue2;
	pCopy->m_sItemSpecEffectValue3 = pOriginal->m_sItemSpecEffectValue3;
	pCopy->m_wCurLifeSpan = pOriginal->m_wCurLifeSpan;
	pCopy->m_dwAttribute = pOriginal->m_dwAttribute;			

	return TRUE;
}

void CGame::SendMsg(short sOwnerH, char cOwnerType, BOOL bStatus, long lPass) { 
	if (m_pClientList[sOwnerH] == NULL) return; 

	SendNotifyMsg(NULL, sOwnerH, lPass, NULL, NULL, NULL, NULL);

}

void CGame::RequestChangePlayMode(int iClientH)
{

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPKCount > 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if (memcmp(m_pClientList[iClientH]->m_cMapName,"cityhall",8) != 0) return;

	if (m_pClientList[iClientH]->m_iLevel < 100||
		m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE) {
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden",7) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"arehunter");
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine",6) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"elvhunter");
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter",9) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"aresden");
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter",9) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"elvine");

			if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
				m_pClientList[iClientH]->m_bIsPlayerCivil = FALSE;
			else m_pClientList[iClientH]->m_bIsPlayerCivil = TRUE;

			SendNotifyMsg(NULL,iClientH,DEF_NOTIFY_CHANGEPLAYMODE,NULL,NULL,NULL,m_pClientList[iClientH]->m_cLocation);
			SendEventToNearClient_TypeA(iClientH,DEF_OWNERTYPE_PLAYER,MSGID_EVENT_MOTION,100,NULL,NULL,NULL);
		}
}

/*********************************************************************************************************************
**  void CGame::SetInvisibilityFlag(short sOwnerH, char cOwnerType, BOOL bStatus)									**
**  description			:: changes the status of the player to show invisibility aura								**
**  last updated		:: November 20, 2004; 9:30 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetInvisibilityFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000010;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFEF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000010;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFEF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}

/*********************************************************************************************************************
**  void CGame::SetInhibitionCastingFlag(short sOwnerH, char cOwnerType, BOOL bStatus)								**
**  description			:: changes the status of the player to show inhibit casting aura							**
**  last updated		:: November 20, 2004; 9:33 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetInhibitionCastingFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00100000;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFEFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00100000;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFEFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetBerserkFlag(short sOwnerH, char cOwnerType, BOOL bStatus)									**
**  description			:: changes the status of the player to show berserk aura									**
**  last updated		:: November 20, 2004; 9:35 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetBerserkFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000020;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFDF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000020;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFDF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetIceFlag(short sOwnerH, char cOwnerType, BOOL bStatus)										**
**  description			:: changes the status of the player to show frozen aura										**
**  last updated		:: November 20, 2004; 9:35 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIceFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000040;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFBF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000040;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFBF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetPoisonFlag(short sOwnerH, char cOwnerType, BOOL bStatus)									**
**  description			:: changes the status of the player to show poison aura										**
**  last updated		:: November 20, 2004; 9:36 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetPoisonFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000080;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFF7F;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000080;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFF7F;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetIllusionFlag(short sOwnerH, char cOwnerType, BOOL bStatus)									**
**  description			:: changes the status of the player to show illusion aura									**
**  last updated		:: November 20, 2004; 9:36 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIllusionFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x01000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFEFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x01000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFEFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetHeroFlag(short sOwnerH, char cOwnerType, BOOL bStatus)										**
**  description			:: changes the status of the player to show hero item aura									**
**  last updated		:: November 20, 2004; 9:37 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetHeroFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00020000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFDFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00020000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFDFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetDefenseShieldFlag(short sOwnerH, char cOwnerType, BOOL bStatus)								**
**  description			:: changes the status of the player to show defense aura									**
**  last updated		:: November 20, 2004; 9:37 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetDefenseShieldFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x02000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFDFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x02000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFDFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetMagicProtectionFlag(short sOwnerH, char cOwnerType, BOOL bStatus)							**
**  description			:: changes the status of the player to show magic protect aura								**
**  last updated		:: November 20, 2004; 9:38 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetMagicProtectionFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x04000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFBFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x04000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFBFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetProtectionFromArrowFlag(short sOwnerH, char cOwnerType, BOOL bStatus)						**
**  description			:: changes the status of the player to show arrow protect aura								**
**  last updated		:: November 20, 2004; 9:39 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetProtectionFromArrowFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
 	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x08000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xF7FFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x08000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xF7FFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetIllusionMovementFlag(short sOwnerH, char cOwnerType, BOOL bStatus)							**
**  description			:: changes the status of the player to show illusion movement aura							**
**  last updated		:: November 20, 2004; 9:39 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIllusionMovementFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00200000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFDFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

// New 07/05/2004
void CGame::RequestGuildNameHandler(int iClientH, int iObjectID, int iIndex)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((iObjectID <= 0) || (iObjectID >= DEF_MAXCLIENTS)) return;

	if (m_pClientList[iObjectID] == NULL) {
		//   Object .

	}
	else {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REQGUILDNAMEANSWER, m_pClientList[iObjectID]->m_iGuildRank, iIndex, NULL, m_pClientList[iObjectID]->m_cGuildName);	
	}
}

// MORLA2.2 - Para determinar el Rango devuelve los EKs y PKs del user
void CGame::RequestRango(int iClientH, int iObjectID)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((iObjectID <= 0) || (iObjectID >= DEF_MAXCLIENTS)) return;

	if (m_pClientList[iObjectID] == NULL) {
		//   Object .

	}
	else {
		// centu - que cuente m_iMaxEK
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REQRANGO, m_pClientList[iObjectID]->m_iMaxEK, m_pClientList[iObjectID]->m_iRating, NULL, NULL);
	}
}


// thx to kazin
void CGame::RequestOnlines(CClient * p)
{
	char * cData = G_cData50000; //esta es el "buffer", onda, la memoria que neceisto para enviar

	DWORD * dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_REQUEST_ONLINE;//a la memoria esa le escribo este mensaje
	WORD * wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);			   
	*wp  = 0;//este no se usa, le mando 0

	char * cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2); //eso se usa para decirle "desde aca empiezo a escribir"

	short * pTotal = (short *)cp;
	cp += 2;

	int count = 0;
	for (int i = 0; i <= DEF_MAXCLIENTS; i++) //recorro todosl os clientes
	{
		if (!m_pClientList[i])//si son nulls
			continue;//no darles bola y seguir

		memcpy(cp, m_pClientList[i]->m_cCharName, 10); //copiar el nombre del char (de tamao 10) a la data
		cp += 10;//decirle a la data que le sume 10 bites

		memcpy(cp, m_pClientList[i]->m_cGuildName, 21); //copiar el nombre del char (de tamao 10) a la data
		cp += 21;//decirle a la data que le sume 10 bites
		count++;
	}

	*pTotal = count; //esto es medio enroscado, es para decirle cuantos onlines escribio
	p->m_pXSock->iSendMsg(G_cData50000, cp - G_cData50000);//mandarle la data a p que es el cliente
}

// Item Logging
BOOL CGame::_bItemLog(int iAction,int iGiveH, int iRecvH, class CItem * pItem,BOOL bForceItemLog)
{
	char  cTxt[1024], cTemp1[120], cTemp2[120];
	int iItemCount ;
	if (pItem == NULL) return FALSE;

	// !!    New Item    iGive  .
	if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;

	if (iAction == DEF_ITEMLOG_DUPITEMID) {
		//    . 
		if (m_pClientList[iGiveH] == NULL) return FALSE;
		if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
		wsprintf(G_cTxt, "(!) Delete-DupItem(%s %d %d %d %d) Owner(%s)", pItem->m_cName, pItem->m_dwCount, pItem->m_sTouchEffectValue1,
			pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3,
			m_pClientList[iGiveH]->m_cCharName);
		bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,G_cTxt);
		return TRUE;
	}

	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));

	switch (iAction) {
		
		case DEF_ITEMLOG_EXCHANGE:
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "(%s) PC(%s)\tExchange\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)",m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
			break;

		case DEF_ITEMLOG_GIVE:	
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "(%s) PC(%s)\tGive\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)",m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
			break;

		case DEF_ITEMLOG_DROP:
			wsprintf(cTxt, "(%s) PC(%s)\tDrop\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_GET:
			wsprintf(cTxt, "(%s) PC(%s)\tGet\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_MAKE:
			wsprintf(cTxt, "(%s) PC(%s)\tMake\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_DEPLETE:	
			wsprintf(cTxt, "(%s) PC(%s)\tDeplete\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_BUY:
			iItemCount = iRecvH ;
			wsprintf(cTxt, "(%s) PC(%s)\tBuy\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, iItemCount , 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_SELL:
			wsprintf(cTxt, "(%s) PC(%s)\tSell\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_RETRIEVE:
			wsprintf(cTxt, "(%s) PC(%s)\tRetrieve\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_DEPOSIT:
			wsprintf(cTxt, "(%s) PC(%s)\tDeposit\t%s(%d %d %d %d %x)\t%s(%d %d)",m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_UPGRADEFAIL:
			wsprintf(cTxt, "(%s) PC(%s)\tUpgrade Fail\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_UPGRADESUCCESS:
			wsprintf(cTxt, "(%s) PC(%s)\tUpgrade Success\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;
		default:
			return FALSE ;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,cTxt);
	return TRUE;
}

BOOL CGame::_bItemLog(int iAction,int iClientH , char * cName, class CItem * pItem)
{
	if(pItem == NULL) return FALSE;
	if(_bCheckGoodItem( pItem ) == FALSE) return FALSE;
	if(iAction != DEF_ITEMLOG_NEWGENDROP)
	{
		if( m_pClientList[iClientH] == NULL ) return FALSE;
	}
	char  cTxt[200], cTemp1[120];
	//   . 
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	if( m_pClientList[iClientH] != NULL ) m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp1);

	switch (iAction) {
		
		case DEF_ITEMLOG_NEWGENDROP:
		if (pItem == NULL) return FALSE;
		wsprintf(cTxt, "NPC(%s)\tDrop\t%s(%d %d %d %d)",cName, pItem->m_cName, pItem->m_dwCount,  
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3);
		break;
	case DEF_ITEMLOG_SKILLLEARN:
	case DEF_ITEMLOG_MAGICLEARN:
		if (cName == NULL) return FALSE; 
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt, "PC(%s)\tLearn\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 
	case DEF_ITEMLOG_SUMMONMONSTER:
		if (cName == NULL) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt,"PC(%s)\tSummon\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break ;
	case DEF_ITEMLOG_POISONED:
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt,"PC(%s)\tBe Poisoned\t \t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, 
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 

	case DEF_ITEMLOG_REPAIR:
		if (cName == NULL) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt,"PC(%s)\tRepair\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 

	default:
		return FALSE;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,cTxt);
	return TRUE ;
}

BOOL CGame::_bCheckGoodItem( class CItem * pItem )
{
	if( pItem == NULL ) return FALSE;

	if( pItem->m_sIDnum == 90 )
	{
		if( pItem->m_dwCount > 10000 ) return TRUE;  //Gold  10000   .
		else return FALSE;
	}
	switch (pItem->m_sIDnum) {
	// Gold  
	case 259:
	case 290:
	case 291:
	case 292:
	case 300:
	case 305:
	case 308:
	case 311:
	case 334:
	case 335:
	case 336:
	case 338:
	case 380:
	case 381:
	case 382:
	case 391:
	case 400:
	case 401:
	case 490:
	case 491:
	case 492:
	case 508:
	case 581:
	case 610:
	case 611:
	case 612:
	case 613:
	case 614:
	case 616:  // -
	case 618:  // -

	case 620:
	case 621:
	case 622:
	case 623:

	case 630:
	case 631:

	case 632:
	case 633:
	case 634:
	case 635:
	case 636:
	case 637:
	case 638:
	case 639:
	case 640:
	case 641:

	case 642:
	case 643:

	case 644:
	case 645:
	case 646:
	case 647:

	case 650:
	case 654:
	case 655:
	case 656:
	case 657:

	case 700: 	// v2.03   
	case 701:
	case 702:
	case 703:
	case 704:
	case 705:
	case 706:
	case 707:
	case 708:
	case 709:
	case 710:
	case 711:
	case 712:
	case 713:
	case 714:
	case 715:

	case 720:
	case 721:
	case 722:
	case 723:

	case 724:
	case 725:
	case 726:
	case 727:
	case 728:
	case 729:
	case 730:
	case 731:
	case 732:
	case 733:

	case 734:
	case 735:

	case 736:  //    
	case 737:  //    
	case 738:  //  

		return TRUE;  //   ...
		break;
	default:
		// v2.17 2002-7-31     .
		if ((pItem->m_dwAttribute & 0xF0F0F001) == NULL) return FALSE;  //     ..
		else if( pItem->m_sIDnum > 30 ) return TRUE;  //        ..
		else return FALSE;  //      ...
	}
}


void CGame::GetExp(int iClientH, unsigned long iExp, BOOL bIsAttackerOwn)
{
	
	double dV1, dV2, dV3;
	int i, iH, iUnitValue;
	DWORD dwTime = timeGetTime();
	int iTotalPartyMembers;

	if (m_pClientList[iClientH] == NULL) return;
	if (iExp <= 0) return;

	if (m_pClientList[iClientH]->m_iLevel <= 80) {
		dV1 = (double)(80 - m_pClientList[iClientH]->m_iLevel);
		dV2 = dV1 * 0.025f;
		dV3 = (double)iExp;
		dV1 = (dV2 + 1.025f)*dV3;
		iExp = (int)dV1;
	}
	else { //Lower exp
		if ((m_pClientList[iClientH]->m_iLevel >= 100) &&((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) 
			|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0))) {
				iExp = (iExp/10) ;
			}
		else if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) 
			|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {
				iExp = (iExp*1/4) ;
			}
	}

	//nose pasa de lvl 
	int iStruckLevel = m_pClientList[iClientH]->m_iLevel - m_iPlayerMaxLevel; // By Mkintosh
        if ((m_pClientList[iClientH]->m_iLevel > m_iPlayerMaxLevel) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
            m_pClientList[iClientH]->m_iLevel = m_iPlayerMaxLevel;
            m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLU_Pool - (iStruckLevel*3);
        }
	
	//Check for party status, else give exp to player
	if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) {
			//Only divide exp if > 1 person and exp > 10
			if(iExp >= 10 && m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers > 0){
				
				iTotalPartyMembers = 0;
				for(i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++){
					iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
					if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iHP > 0)) {
						if ((strlen(m_pMapList[m_pClientList[iH]->m_cMapIndex]->m_cName)) == (strlen(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName))) {
							if(memcmp(m_pMapList[m_pClientList[iH]->m_cMapIndex]->m_cName, 
									  m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 
									  strlen(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName)) == 0){
								iTotalPartyMembers++;
							}
						}
					}
				}

				//Check for party bug
				if(iTotalPartyMembers > 8){
					wsprintf(G_cTxt, "(X) Party Bug !! partyMember %d XXXXXXXXXX", iTotalPartyMembers);
					PutLogFileList(G_cTxt);
					iTotalPartyMembers = 8;
				}

				//Figure out how much exp a player gets
				dV1 = (double)iExp;

				switch(iTotalPartyMembers){
				case 1:
					dV2 = dV1;
					break;
				case 2:
					dV2 = (dV1 + (dV1 * 2.0e-2)) / 2.0;
					break;
				case 3:
					dV2 = (dV1 + (dV1 * 5.0e-2)) / 3.0;
					break;
				case 4:
					dV2 = (dV1 + (dV1 * 7.000000000000001e-2)) / 4.0;
					break;
				case 5:
					dV2 = (dV1 + (dV1 * 1.0e-1)) / 5.0;
					break;
				case 6:
					dV2 = (dV1 + (dV1 * 1.4e-1)) / 6.0;
					break;
				case 7:
					dV2 = (dV1 + (dV1 * 1.7e-1)) / 7.0;
					break;
				case 8:
					dV2 = (dV1 + (dV1 * 2.0e-1)) / 8.0;
					break;
				}

				dV3 = dV2 + 5.0e-1;
				iUnitValue = (int)dV3;

				//Divide exp among party members
				for(i = 0; i < iTotalPartyMembers; i++){
					iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
					//Player who kills monster gets more exp
					if(iH == iClientH){
						if((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iHP > 0)) { // Is player alive ??
							//Exp gain based on lvl
							if((m_pClientList[iH]->m_iStatus & 0x10000) != 0) iUnitValue *= 3;
							MultiplicadorExp(iH, iUnitValue);
						}
					}
					else{
						//Other players get normal exp :P
						if((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iHP > 0))
							if(m_pClientList[iH]->m_bSkillUsingStatus[19] != 1)
								//Only players on same map get exp
								if(m_pClientList[iH]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)
									MultiplicadorExp(iH, iUnitValue);
					}
				}

				if (bIsAttackerOwn == TRUE)
					if(iTotalPartyMembers > 1)
						MultiplicadorExp(iClientH, (iUnitValue/10));
			}
			else{
				if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0) iExp *= 3;
					
				MultiplicadorExp(iClientH, iExp);
			}
		}
		else{
			if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0) iExp *= 3;
			MultiplicadorExp(iClientH, iExp);
		}
}

void CGame::MultiplicadorExp(int Client, unsigned long Exp)
{

	if (m_pClientList[Client] == NULL) return;

	if		(m_pClientList[Client]->m_iLevel <= 20)		Exp *= 2;
	else if	(m_pClientList[Client]->m_iLevel <= 60)		Exp *= 1.4;
	else if	(m_pClientList[Client]->m_iLevel <= 100)	Exp *= 1;
	else if	(m_pClientList[Client]->m_iLevel <= 140)	Exp *= 0.75;
	else if	(m_pClientList[Client]->m_iLevel <= 160)	Exp *= 0.4;
	else if	(m_pClientList[Client]->m_iLevel <= 180)	Exp *= 0.2;
	
	m_pClientList[Client]->m_iExpStock += Exp;

}

BOOL CGame::bCheckAndConvertPlusWeaponItem(int iClientH, int iItemIndex)
{
	//   +1, +2    Attribute      .
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return FALSE;

	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
	case 4:  // Dagger +1
	case 9:  // Short Sword +1
	case 13: // Main Gauge +1
	case 16: // Gradius +1
	case 18: // Long Sword +1
	case 19: // Long Sword +2
	case 21: // Excaliber +1
	case 24: // Sabre +1
	case 26: // Scimitar +1
	case 27: // Scimitar +2
	case 29: // Falchoin +1
	case 30: // Falchion +2
	case 32: // Esterk +1
	case 33: // Esterk +2
	case 35: // Rapier +1
	case 36: // Rapier +2
	case 39: // Broad Sword +1
	case 40: // Broad Sword +2
	case 43: // Bastad Sword +1
	case 44: // Bastad Sword +2
	case 47: // Claymore +1
	case 48: // Claymore +2
	case 51: // Great Sword +1
	case 52: // Great Sword +2
	case 55: // Flameberge +1
	case 56: // Flameberge +2
	case 60: // Light Axe +1
	case 61: // Light Axe +2
	case 63: // Tomahoc +1
	case 64: // Tomohoc +2
	case 66: // Sexon Axe +1
	case 67: // Sexon Axe +2
	case 69: // Double Axe +1
	case 70: // Double Axe +2
	case 72: // War Axe +1
	case 73: // War Axe +2

	case 580: // Battle Axe +1
	case 581: // Battle Axe +2
	case 582: // Sabre +2
		return TRUE;
		
	}
	return FALSE;
}

void CGame::ArmorLifeDecrement(int iAttackerH, int iTargetH, char cOwnerType, int iValue)
{
 int iTemp;

	if (m_pClientList[iAttackerH] == NULL) return;
	
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == NULL) return;
		break;

	case DEF_OWNERTYPE_NPC:
	default: 
		return;
	}

	if (m_pClientList[iAttackerH]->m_cSide == m_pClientList[iTargetH]->m_cSide) return;
	if (m_pClientList[iTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) return;

	switch (iDice(1,13)) {
	case 1: 
		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 50) m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
					ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}	
		break;

	case 2:
		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {


			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)){
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}
		break;
		
	case 3:
		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50;
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}
		break;
	   
	case 4:
		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50;
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}
		break;
	   
	case 5: 
		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50;
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}
		break;
		
	case 6: 
		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50;
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}

		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50;
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}
		break;
		
	case 7:
		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}

		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {


			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}
		break;
		
	case 8: 
		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {


			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}

		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}
		break;
		
	case 9: 
		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}
		break;
		
	case 10: 
		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}

		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}
		break;
		
	case 11: 
		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}

		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}
		break;
		
	case 12: 
		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}
		break;
		
	case 13: 
		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}
		iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
		if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {


			if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
				if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 250){
					ReleaseItemHandler(iTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
			if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
				m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(iTargetH, iTemp, TRUE);  
			}
		}
		break;
	} 
}

void CGame::AdminOrder_GoTo(int iClientH, char* pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cPlayerName[11],cMapName[32];
	class  CStrTok * pStrTok;
	char *cp;
	WORD *wp;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGoto) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token == NULL) {
		delete pStrTok;
		return;
	}

	if (strlen(token) > 10) {
		memcpy(cPlayerName,token,10);
	}
	else{
		memcpy(cPlayerName,token,strlen(token));
	}

	for(int i = 1; i < DEF_MAXCLIENTS; i++){
		if (m_pClientList[i] != NULL) {
			if (memcmp(cPlayerName,m_pClientList[i]->m_cCharName, 10) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
					if(m_pClientList[i]->m_sX == -1 && m_pClientList[i]->m_sX == -1){
						wsprintf(cBuff,"GM Order(%s): GoTo MapName(%s)",m_pClientList[iClientH]->m_cCharName,m_pClientList[i]->m_cMapName);
					}
					else{
						wsprintf(cBuff,"GM Order(%s): GoTo MapName(%s)(%d %d)",m_pClientList[iClientH]->m_cCharName,
							     m_pClientList[i]->m_cMapName,m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);
					}
					bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH,FALSE,cBuff);
					ZeroMemory(cMapName,sizeof(cMapName));
					strcpy(cMapName, m_pClientList[i]->m_cMapName);
					RequestTeleportHandler(iClientH,"2   ", cMapName, m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);
				}
				delete pStrTok;
				return;
			}
		}
	}
	m_pClientList[iClientH]->m_bIsAdminOrderGoto = TRUE;

	ZeroMemory(cBuff,sizeof(cBuff));
	
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;

	wp = (WORD *)cp;
	*wp = m_wServerID_GSS;
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp,cPlayerName,10);
	cp += 10;

	memcpy(cp,m_pClientList[iClientH]->m_cCharName,10);
	cp += 10;

	bStockMsgToGateServer(cBuff,25);

	delete pStrTok;
}

void CGame::AdminOrder_MonsterCount(int iClientH, char* pData, DWORD dwMsgSize)
{
	int iMonsterCount;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelMonsterCount) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	iMonsterCount = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAliveObject;
	SendNotifyMsg(0,iClientH, DEF_NOTIFY_MONSTERCOUNT, iMonsterCount,NULL,NULL,NULL);
}

// v2.17 2002-7-15    .
void CGame::AdminOrder_SetForceRecallTime(int iClientH, char *pData, DWORD dwMsgSize)
{
 class  CStrTok * pStrTok;
 char   seps[] = "= \t\n";
 char   * token, cBuff[256],* cp; 
 WORD * wp ;
 int    iTime;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;


	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetRecallTime) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {

		if (token == NULL) 
			 iTime = 0;
		else iTime = atoi(token);
	
		if (iTime < 0) iTime = 0;
	 	
		m_sForceRecallTime = iTime ;

		ZeroMemory(cBuff, sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_SETFORCERECALLTIME;
		cp++;
	
		wp = (WORD *)cp;
		*wp = iTime ;
		cp += 2;

		bStockMsgToGateServer(cBuff, 3);

		wsprintf(G_cTxt,"(!) Game Server Force Recall Time (%d)min",m_sForceRecallTime) ;
		PutLogList(G_cTxt) ;
	}

	delete pStrTok;
	return ;
}

void CGame::AdminOrder_UnsummonBoss(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelUnsummonBoss) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	for(int i = 1; i < DEF_MAXNPCS; i++){
		if (m_pNpcList[i] != NULL && m_pNpcList[i]->m_bIsSummoned == FALSE) {
			switch(m_pNpcList[i]->m_sType) {
			case 31: //Demon
			case 49: //Hellclaw
			case 45: //GHKABS
			case 47: //BG
			case 50: //Tigerworm
			case 52: //Gagoyle
			case 81: //Abaddon
			case 66: //Wyvern
			case 73: //Fire-Wyvern
				m_pNpcList[i]->m_bIsUnsummoned = TRUE;
				NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
				break;
			}
		}
	}
}

void CGame::AdminOrder_ClearNpc(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelClearNpc) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	for(int i = 1; i < DEF_MAXNPCS; i++){
		if (m_pNpcList[i] != NULL && m_pNpcList[i]->m_bIsSummoned == FALSE) {
			switch(m_pNpcList[i]->m_sType) {
			case 15:
			case 19:
			case 20:
			case 24:
			case 25:
			case 26:
			case 67:
			case 68:
			case 69:
			case 90:
			case 91:
				break;

			default:
				m_pNpcList[i]->m_bIsUnsummoned = TRUE;
				NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
				break;
			}
		}
	}
}

// New 13/05/2004
BOOL CGame::_bCrusadeLog(int iAction,int iClientH,int iData, char * cName)
{
	char  cTxt[200];

	//   . 
	ZeroMemory(cTxt, sizeof(cTxt));

	switch (iAction) {

		case DEF_CRUSADELOG_ENDCRUSADE:
			if (cName == NULL) return FALSE;
			wsprintf(cTxt,"\tEnd Crusade\t%s",cName);
			break;

		case DEF_CRUSADELOG_SELECTDUTY :
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tSelect Duty\t(%s)\t \t(%s)", m_pClientList[iClientH]->m_cCharName,cName,m_pClientList[iClientH]->m_cGuildName);
			break ;

		case DEF_CRUSADELOG_GETEXP :
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tGet Exp\t(%d)\t \t(%s)", m_pClientList[iClientH]->m_cCharName, iData, m_pClientList[iClientH]->m_cGuildName);
			break ;

		case DEF_CRUSADELOG_STARTCRUSADE:
			wsprintf(cTxt,"\tStart Crusade");
			break ;

		default:
			return FALSE;
	}

	bSendMsgToLS(MSGID_GAMECRUSADELOG, iClientH, NULL,cTxt);
	return TRUE ;
}

// Testcode, found reference to it in 3.51, InitPlayerData and RequestTeleportHandler
int CGame::iGetPlayerABSStatus(int iClientH)
{
	int iRet;

	if (m_pClientList[iClientH] == NULL) return 0;

	iRet = 0;

		if (m_pClientList[iClientH]->m_iPKCount != 0) {
			iRet = 8;
		}

		if (m_pClientList[iClientH]->m_cSide != 0) {
			iRet = iRet | 4;
		}

		if (m_pClientList[iClientH]->m_cSide == 1) {
			iRet = iRet | 2;
		}

		if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
			iRet = iRet | 1;

		return iRet;
}

// New 16/05/2004
void CGame::ReqCreateSlateHandler(int iClientH, char* pData)
{
	int i, iRet;
	short *sp;
	char cItemID[4], ctr[4];
	char *cp, cSlateColour, cData[120];
	BOOL bIsSlatePresent = FALSE;
	CItem * pItem;
	int iSlateType, iEraseReq;
	DWORD *dwp;
	WORD *wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;

	for(i = 0; i < 4; i++){
		cItemID[i] = 0;
		ctr[i] = 0;
	}

	cp = (char *)pData;
	cp += 11;

	// 14% chance of creating slates
	if (iDice(1,100) < m_sSlateSuccessRate) bIsSlatePresent = TRUE;

    try{
	// make sure slates really exist
	for(i = 0; i < 4; i++){
		cItemID[i] = *cp;
		cp++;

		if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] == NULL || cItemID[i] >DEF_MAXITEMS){ 
			bIsSlatePresent = FALSE;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL);  			
			return; 
		}

		//No duping
		if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 868) // LU
			ctr[0] = 1;
		else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 869) // LD
			ctr[1] = 1;
		else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 870) // RU
			ctr[2] = 1;
		else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 871) // RD
			ctr[3] = 1;
	}
     }
     catch(...){
	//Crash Hacker Caught
	bIsSlatePresent = FALSE;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL);  
	wsprintf(G_cTxt, "TSearch Slate Hack: (%s) Player: (%s) - creating slates without correct item!", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
	PutHackLogFileList(G_cTxt);
	DeleteClient(iClientH, TRUE, TRUE);
	return;
     }

	// Are all 4 slates present ??
	if (ctr[0] != 1 || ctr[1] != 1 || ctr[2] != 1 || ctr[3] != 1) {
		bIsSlatePresent = FALSE;
		return; 
	}

	if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) bIsSlatePresent = TRUE;

	// if we failed, kill everything
	if (!bIsSlatePresent) { 
		for(i = 0; i < 4; i++){ 
			if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] != NULL) {
				ItemDepleteHandler(iClientH, cItemID[i], FALSE, FALSE);
			}
		} 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL); 
		return; 
	}

	// make the slates
	for(i = 0; i < 4; i++){
		if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] != NULL) {
			ItemDepleteHandler(iClientH,cItemID[i], FALSE, FALSE);
		}
	}

	pItem = new class CItem;

	i = iDice(1,1000);

	if (i < 50) { // Hp slate
		iSlateType = 1;
		cSlateColour = 32;
	}
	else if (i < 250) { // Bezerk slate
		iSlateType = 2;
		cSlateColour = 3;
	}
	else if (i < 750) { // Exp slate
		iSlateType = 4;
		cSlateColour = 7;
	}
	else if (i < 950) { // Mana slate
		iSlateType = 3;
		cSlateColour = 37;
	}
	else if (i <  1001) { // Hp slate
		iSlateType = 1;
		cSlateColour = 32;
	}

	// Notify client
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATESUCCESS, iSlateType, NULL, NULL, NULL);

	ZeroMemory(cData,sizeof(cData));

	// Create slates
	if (_bInitItemAttr(pItem, 867) == FALSE) {
		delete pItem;
		return;
	}
	else{
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		pItem->m_sTouchEffectValue3 = (short)timeGetTime();

		_bItemLog(DEF_ITEMLOG_GET, iClientH, -1, pItem);

		pItem->m_sItemSpecEffectValue2 = iSlateType;
		pItem->m_cItemColor = cSlateColour;
		if(_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE){
			ZeroMemory(cData,sizeof(cData));
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp = 1;
			cp++;

			memcpy(cp, pItem->m_cName, 20);
			cp += 20;

			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char)0; //    .
			cp++;

			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;

			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor;
			cp++;

			*cp = (char)pItem->m_sItemSpecEffectValue2;
			cp ++;

			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			if (iEraseReq == 1) delete pItem;

			//    
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					//     .
					DeleteClient(iClientH, TRUE, TRUE);
					return;
			}
		}
		else{
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			SendEventToNearClient_TypeB(MSGID_MAGICCONFIGURATIONCONTENTS, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
										m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame,
										pItem->m_cItemColor);
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						//     .
						DeleteClient(iClientH, TRUE, TRUE);
						break;
			}
		}
	}
	return;
}

void CGame::SetSlateFlag(int iClientH, short sType, bool bFlag)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (sType == DEF_NOTIFY_SLATECLEAR) {
		m_pClientList[iClientH]->m_iStatus &= 0xFFBFFFFF;
		m_pClientList[iClientH]->m_iStatus &= 0xFF7FFFFF;
		m_pClientList[iClientH]->m_iStatus &= 0xFFFEFFFF;
		return;
	}

	if (bFlag == TRUE) {
		if (sType == 1) { // Invincible slate
			m_pClientList[iClientH]->m_iStatus |= 0x400000;
		}
		else if (sType == 3) { // Mana slate
			m_pClientList[iClientH]->m_iStatus |= 0x800000;
		}
		else if (sType == 4) { // Exp slate
			m_pClientList[iClientH]->m_iStatus |= 0x10000;
		}
	}
	else{
		if ((m_pClientList[iClientH]->m_iStatus & 0x400000) != 0) {
			m_pClientList[iClientH]->m_iStatus &= 0xFFBFFFFF;
		}
		else if ((m_pClientList[iClientH]->m_iStatus & 0x800000) != 0) {
			m_pClientList[iClientH]->m_iStatus &= 0xFF7FFFFF;
		}
		else if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0) {
			m_pClientList[iClientH]->m_iStatus &= 0xFFFEFFFF;
		}
	}

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}

// New 18/05/2004
void CGame::SetPlayingStatus(int iClientH)
{
	char cMapName[11], cLocation[11];

	if (m_pClientList[iClientH] == NULL) return;

	ZeroMemory(cMapName, sizeof(cMapName));
	ZeroMemory(cLocation, sizeof(cLocation));

	strcpy(cLocation, m_pClientList[iClientH]->m_cLocation);
	strcpy(cMapName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex]->m_cName);

	m_pClientList[iClientH]->m_cSide = 0;
	m_pClientList[iClientH]->m_bIsOwnLocation = FALSE;
	m_pClientList[iClientH]->m_bIsPlayerCivil = FALSE;

	if (memcmp(cLocation, cMapName, 3) == 0) {
		m_pClientList[iClientH]->m_bIsOwnLocation = TRUE;
	}

	if (memcmp(cLocation, "are", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 1;
	else if (memcmp(cLocation, "elv", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 2;
	else{ 
		if (strcmp(cMapName, "elvine") == 0 || strcmp(cMapName, "aresden") == 0) {
			m_pClientList[iClientH]->m_bIsOwnLocation = TRUE;
		}
		m_pClientList[iClientH]->m_bIsNeutral = TRUE;
	}

	if (memcmp(cLocation, "arehunter", 9) == 0 || memcmp(cLocation, "elvhunter", 9) == 0) {
		m_pClientList[iClientH]->m_bIsPlayerCivil = TRUE;
	}

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) == 0) {
		m_pClientList[iClientH]->m_bIsPlayerCivil = FALSE;
	}

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "bsmith", 6) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "gldhall", 7) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "gshop", 5) == 0)
		m_pClientList[iClientH]->m_pIsProcessingAllowed = TRUE;
	else
		m_pClientList[iClientH]->m_pIsProcessingAllowed = FALSE;

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "wrhus", 5) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "arewrhus", 8) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "elvwrhus", 8) == 0)
		m_pClientList[iClientH]->m_bIsInsideWarehouse = TRUE;
	else
		m_pClientList[iClientH]->m_bIsInsideWarehouse = FALSE;

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "wzdtwr", 6) == 0)
		m_pClientList[iClientH]->m_bIsInsideWizardTower = TRUE;
	else
		m_pClientList[iClientH]->m_bIsInsideWizardTower = FALSE;
}

void CGame::ForceChangePlayMode(int iClientH, bool bNotify)
{
	if(m_pClientList[iClientH] == NULL) return;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0)
		strcpy(m_pClientList[iClientH]->m_cLocation, "aresden");
	else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0)
		strcpy(m_pClientList[iClientH]->m_cLocation, "elvine");

	if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
		m_pClientList[iClientH]->m_bIsPlayerCivil = FALSE;

	if (bNotify) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CHANGEPLAYMODE, NULL, NULL, NULL, m_pClientList[iClientH]->m_cLocation);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	}
}


// v2.15 2002-5-21
void CGame::GSM_RequestShutupPlayer(char * pGMName,WORD wReqServerID, WORD wReqClientH, WORD wTime,char * pPlayer )
{
	char * cp, cTemp[120];
	WORD * wp;
 int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pPlayer) == 0)) {
			// .
			ZeroMemory(cTemp, sizeof(cTemp));
			cp = (char *)(cTemp);
			*cp = GSM_RESPONSE_SHUTUPPLAYER;
			cp++;

			wp = (WORD *)cp;
			*wp = wReqServerID;
			cp += 2;

			wp = (WORD *)cp;
			*wp = wReqClientH;
			cp += 2;

			memcpy(cp, pGMName, 10);
			cp += 10;

			wp = (WORD *)cp;
			*wp = (WORD) wTime;
			cp += 2;

			memcpy(cp, pPlayer, 10);
			cp += 10;

			// v2.14   
			m_pClientList[i]->m_iTimeLeft_ShutUp = wTime*20; // 1 3. 20 1 

			SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, wTime, NULL, NULL, pPlayer);

			bStockMsgToGateServer(cTemp, 27);
			return;	
		}
}

// v2.14 05/22/2004 - Hypnotoad - adds pk log
BOOL CGame::_bPKLog(int iAction,int iAttackerH , int iVictumH, char * pNPC)
{
	char  cTxt[1024], cTemp1[120], cTemp2[120];

	//   . 
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));

	if ( m_pClientList[iVictumH] == NULL) return FALSE ;

	switch (iAction) {

		case DEF_PKLOG_REDUCECRIMINAL: 
			wsprintf(cTxt, "(%s) PC(%s)\tReduce\tCC(%d)\t%s(%d %d)\t", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_iPKCount,
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY);
			break; 

		case DEF_PKLOG_BYPLAYER:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "(%s) PC(%s)\tKilled by PC\t \t%s(%d %d)\t(%s) PC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cCharName);
			break;
		case DEF_PKLOG_BYPK:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "(%s) PC(%s)\tKilled by PK\tCC(%d)\t%s(%d %d)\t(%s) PC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, m_pClientList[iAttackerH]->m_iPKCount,
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cCharName);
			break; 
		case DEF_PKLOG_BYENERMY:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "(%s) PC(%s)\tKilled by Enemy\t \t%s(%d %d)\t(%s) PC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cCharName);
			break; 
		case DEF_PKLOG_BYNPC:
			if(pNPC==NULL) return FALSE ;
			wsprintf(cTxt, "(%s) PC(%s)\tKilled by NPC\t \t%s(%d %d)\tNPC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,pNPC);
			break; 
		case DEF_PKLOG_BYOTHER:
			wsprintf(cTxt, "(%s) PC(%s)\tKilled by Other\t \t%s(%d %d)\tUnknown", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY);
			break; 
		default:
			return FALSE;
	}
	PutPvPLogFileList(cTxt);
	return TRUE ;
}

void CGame::RequestResurrectPlayer(int iClientH, bool bResurrect)
{
short sX, sY;
char buff[100];

	if (m_pClientList[iClientH] == NULL) return;

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	if (bResurrect == FALSE) {
		m_pClientList[iClientH]->m_bIsBeingResurrected = FALSE;
		return;
	}

	if (m_pClientList[iClientH]->m_bIsBeingResurrected == FALSE) {
		wsprintf(buff, "(!!!) Player(%s) Tried To Use Resurrection Hack", m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE, TRUE, TRUE);
		return;
	}

	wsprintf(buff, "(*) Resurrect Player! %s", m_pClientList[iClientH]->m_cCharName);
	PutLogList(buff);


	m_pClientList[iClientH]->m_bIsKilled = FALSE;
	// Player's HP becomes half of the Max HP. 
	m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH, FALSE)/2; 
	// Player's MP
	m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
	// Player's SP
	m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);
	// Player's Hunger
	m_pClientList[iClientH]->m_iHungerStatus = 100;

	m_pClientList[iClientH]->m_bIsBeingResurrected = FALSE;

	// !!! RequestTeleportHandler m_cMapName      
	RequestTeleportHandler(iClientH, "2   ", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
}

BOOL CGame::bCheckClientAttackFrequency(int iClientH, DWORD dwClientTime)
{
 DWORD dwTimeGap;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return FALSE;

	if (m_pClientList[iClientH]->m_dwAttackFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;
	else {
		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwAttackFreqTime;
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;

		if (dwTimeGap < 450) {
			wsprintf(G_cTxt, "Swing Hack: (%s) Player: (%s) - attacking with weapon at irregular rates.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);

			return FALSE;
		}


	}

	return FALSE;
}

BOOL CGame::bCheckClientMagicFrequency(int iClientH, DWORD dwClientTime)
{
 DWORD dwTimeGap;
	
	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (m_pClientList[iClientH]->m_dwMagicFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;
	else {
		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMagicFreqTime;
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;

		if ((dwTimeGap < 1500) && (m_pClientList[iClientH]->m_bMagicConfirm == TRUE)) {
			wsprintf(G_cTxt, "Speed Cast: (%s) Player: (%s) - casting magic at irregular rates. ", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);
			return FALSE;
		}
		
		m_pClientList[iClientH]->m_iSpellCount--;
		m_pClientList[iClientH]->m_bMagicConfirm = FALSE;
		m_pClientList[iClientH]->m_bMagicPauseTime = FALSE;
		

	}

	return FALSE;
}

BOOL CGame::bCheckClientMoveFrequency(int iClientH, DWORD dwClientTime)
{
 DWORD dwTimeGap;
	
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return FALSE;

	if (m_pClientList[iClientH]->m_dwMoveFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;
	else {
		if (m_pClientList[iClientH]->m_bIsMoveBlocked == TRUE) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = NULL;
			m_pClientList[iClientH]->m_bIsMoveBlocked = FALSE;
			return FALSE;
		}

		if (m_pClientList[iClientH]->m_bIsAttackModeChange == TRUE) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = NULL;
			m_pClientList[iClientH]->m_bIsAttackModeChange = FALSE;
			return FALSE;
		}

		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMoveFreqTime;
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;
		
		if ((dwTimeGap < 200) && (dwTimeGap >= 0)) {
			wsprintf(G_cTxt, "Speed Hack: (%s) Player: (%s) - running too fast.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);
			return FALSE;
		}

	}

	return FALSE;
}



void CGame::CrusadeWarStarter()
{
 SYSTEMTIME SysTime;
 int i;

	if (m_bIsCrusadeMode == TRUE) return;
	if (m_bIsCrusadeWarStarter == FALSE) return;

	//   1 
	GetLocalTime(&SysTime);
	
	for (i = 0; i < DEF_MAXSCHEDULE; i++)
	if	((m_stCrusadeWarSchedule[i].iDay == SysTime.wDayOfWeek) && 
		(m_stCrusadeWarSchedule[i].iHour == SysTime.wHour) && 
		(m_stCrusadeWarSchedule[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated crusade is being initiated!");
			GlobalStartCrusadeMode();
			return;
	}
}


BOOL CGame::bReadScheduleConfigFile(char *pFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int   iIndex;

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(pFn, "rt");
	if (pFile == NULL) {
		//      .
		PutLogList("(!) Cannot open Schedule file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Schedule file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					if (strcmp(m_cServerName, token) == 0) {
						PutLogList("(!) Success: This server will schedule crusade total war.");
						m_bIsCrusadeWarStarter = TRUE;
					}
					cReadModeA = 0;
					break;

				case 2:
					if (strcmp(m_cServerName, token) == 0) {
						PutLogList("(!) Success: This server will schedule apocalypse.");
						m_bIsApocalypseStarter = TRUE;
					}
					cReadModeA = 0;
					break;

				case 3:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXSCHEDULE) {
							PutLogList("(!) WARNING! Too many crusade war schedule!"); 
							return TRUE;
						}
						m_stCrusadeWarSchedule[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stCrusadeWarSchedule[iIndex].iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stCrusadeWarSchedule[iIndex].iMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				case 4:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXAPOCALYPSE) {
							PutLogList("(!) WARNING! Too many Apocalypse schedule!"); 
							return TRUE;
						}
						m_stApocalypseScheduleStart[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stApocalypseScheduleStart[iIndex].iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stApocalypseScheduleStart[iIndex].iMinute = atoi(token);
						iIndex++;
						m_bIsApocalypseScheduleLoaded = TRUE;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				case 5:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXAPOCALYPSE) {
							PutLogList("(!) WARNING! Too many Apocalypse schedule!"); 
							return TRUE;
						}
						m_stApocalypseScheduleEnd[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stApocalypseScheduleEnd[iIndex].iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stApocalypseScheduleEnd[iIndex].iMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				case 6:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXHELDENIAN) {
							PutLogList("(!) WARNING! Too many Heldenians scheduled!"); 
							return TRUE;
						}
						m_stHeldenianSchedule[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stHeldenianSchedule[iIndex].StartiHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stHeldenianSchedule[iIndex].StartiMinute = atoi(token);
						cReadModeB = 4;
						break;
					case 4:
						m_stHeldenianSchedule[iIndex].EndiHour = atoi(token);
						cReadModeB = 5;
						break;
					case 5:
						m_stHeldenianSchedule[iIndex].EndiMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;

					}
					break;
				}
			}
			else {
				if (memcmp(token, "crusade-server-name", 19) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
				if (memcmp(token, "apocalypse-server-name", 22) == 0) {
					cReadModeA = 2;
					cReadModeB = 1;
				}
				if (memcmp(token, "crusade-schedule", 16) == 0) {
					cReadModeA = 3;
					cReadModeB = 1;
				}
				if (memcmp(token, "apocalypse-schedule-start", 25) == 0) {
					cReadModeA = 4;
					cReadModeB = 1;
				}
				if (memcmp(token, "apocalypse-schedule-end", 23) == 0) {
					cReadModeA = 5;
					cReadModeB = 1;
				}
				if (memcmp(token, "Heldenian-schedule", 18) == 0) {
					cReadModeA = 6;
					cReadModeB = 1;
				}
			}
			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}


void CGame::GlobalStartCrusadeMode()
{
 char * cp, cData[120];
 DWORD * dwp, dwCrusadeGUID;
 SYSTEMTIME SysTime;

	//          
	GetLocalTime(&SysTime);
	if (m_iLatestCrusadeDayOfWeek != -1) {
		if (m_iLatestCrusadeDayOfWeek == SysTime.wDayOfWeek) return;
	}
	else m_iLatestCrusadeDayOfWeek = SysTime.wDayOfWeek;

	dwCrusadeGUID = timeGetTime();

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_BEGINCRUSADE;
	cp++;
	dwp = (DWORD *)cp;
	*dwp = dwCrusadeGUID;
	cp += 4;

	bStockMsgToGateServer(cData, 5);

	LocalStartCrusadeMode(dwCrusadeGUID);
}

void CGame::OnStartGameSignal()
{
 int i;
	
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) 
		__bReadMapInfo(i);
	
	bReadCrusadeStructureConfigFile("..\\GameConfigs\\Crusade.cfg");
	_LinkStrikePointMapIndex();
	bReadScheduleConfigFile("..\\GameConfigs\\Schedule.cfg");

	bReadCrusadeGUIDFile("GameData\\CrusadeGUID.txt");
	bReadApocalypseGUIDFile("GameData\\ApocalypseGUID.txt");
	bReadHeldenianGUIDFile("GameData\\HeldenianGUID.txt");

	PutLogList("");
	PutLogList("(!) Game Server Activated.");

	
}

void CGame::RequestGuildTeleportHandler(int iClientH)
{
 int i;
 char cMapName[11];
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iLockedMapTime != NULL) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);
		return;
	}

	// if a guild teleport is set when its not a crusade, log the hacker
	if (!m_bIsCrusadeMode) {
		wsprintf(G_cTxt, "Accessing crusade teleport: (%s) Player: (%s) - setting teleport location when crusade is disabled.", 
			m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	// if a player is using guild teleport and he is not in a guild, log the hacker
	if (m_pClientList[iClientH]->m_iCrusadeDuty == 0) {
		wsprintf(G_cTxt, "Accessing crusade teleport: (%s) Player: (%s) - teleporting when not in a guild", 
			m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	if ((m_pClientList[iClientH]->m_cMapIndex == m_iMiddlelandMapIndex) &&
		m_iMiddlelandMapIndex != -1)
		return;

	for (i = 0; i < DEF_MAXGUILDS; i++) 
	if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
		//  .
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, m_pGuildTeleportLoc[i].m_cDestMapName);

		//testcode
		wsprintf(G_cTxt, "ReqGuildTeleport: %d %d %d %s", m_pClientList[iClientH]->m_iGuildGUID, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY, cMapName);
		PutLogList(G_cTxt);

		// !!! RequestTeleportHandler m_cMapName      
		RequestTeleportHandler(iClientH, "2   ", cMapName, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY);
		return;
	}
	
	//     .    
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: //   
	case 2: //  
		break;
	}
}


void CGame::GSM_SetGuildTeleportLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
 int i, iIndex;
 DWORD dwTemp, dwTime;

	//         .   .
	
	//testcode
	wsprintf(G_cTxt, "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	dwTime = timeGetTime();

	//   GUID       .
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		//   .
		if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
			//  .   .
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			//  
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
	}
	
	//   .  .
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			//       .
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}

	//    .         (iIndex)   .
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;
}


void CGame::RequestSetGuildTeleportLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
 char * cp, cData[120];
 int i;
 int *ip, iIndex;
 DWORD dwTemp, dwTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;

	// if a player is teleporting and its not a crusade, log the hacker
	if (!m_bIsCrusadeMode) {
		wsprintf(G_cTxt, "Accessing Crusade Set Teleport:(%s) Player: (%s) - setting point when not a crusade.", 
			m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	
	// if a player is teleporting and its not a crusade, log the hacker
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 3) {
		wsprintf(G_cTxt, "Accessing Crusade Set Teleport: (%s) Player: (%s) - setting point when not a guildmaster.", 
			m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	// v2.04   
	if (dY < 100) dY = 100;
	if (dY > 600) dY = 600;

	//     
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDTELEPORTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;
	
	memcpy(cp, pMapName, 10);
	cp += 10;
	//

	dwTime = timeGetTime();

	//testcode
	wsprintf(G_cTxt, "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	//   GUID       .
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		//   .
		if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
			//  .   .
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			//   
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				
			//      
			bStockMsgToGateServer(cData, 23);
			return;
		}
	}
	
	//   .  .
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;

			//        
			bStockMsgToGateServer(cData, 23);
			return;
		}
		else {
			//       .
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}

	//    .         (iIndex)   .
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;

	//      
	bStockMsgToGateServer(cData, 23);
}

// New 12/05/2004 Changed
void CGame::MeteorStrikeHandler(int iMapIndex)
{
 int i, ix, iy, dX, dY, iIndex, iTargetIndex, iTotalESG, iEffect;
 int iTargetArray[DEF_MAXSTRIKEPOINTS];
 short sOwnerH;
 char  cOwnerType;
 DWORD dwTime = timeGetTime();
	
	PutLogList("(!) Beginning Meteor Strike Procedure...");

	if (iMapIndex == -1) {
		PutLogList("(X) MeteorStrikeHandler Error! MapIndex -1!");
		return;
	}
	
	if (m_pMapList[iMapIndex] == NULL) {
		PutLogList("(X) MeteorStrikeHandler Error! NULL Map!");
		return;
	}
	
	if (m_pMapList[iMapIndex]->m_iTotalStrikePoints == 0) {
		PutLogList("(X) MeteorStrikeHandler Error! No Strike Points!");
		return;
	}
	
	for (i = 0; i < DEF_MAXSTRIKEPOINTS; i++) iTargetArray[i] = -1;

	iIndex = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iTargetArray[iIndex] = i; //    .
			iIndex++;
		}
	}

	//testcode
	wsprintf(G_cTxt, "(!) Map(%s) has %d available strike points", m_pMapList[iMapIndex]->m_cName, iIndex);
	PutLogList(G_cTxt);

	//    
	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;

	if (iIndex == 0) {
		//   .  .
		PutLogList("(!) No strike points!");
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}
	else {

		//         
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKEHIT, NULL, NULL, NULL, NULL);
		}
		
		for (i = 0; i < iIndex; i++) {
			//       .
			iTargetIndex = iTargetArray[i];

			if (iTargetIndex == -1) {
				PutLogList("(X) Strike Point MapIndex: -1!");
				goto MSH_SKIP_STRIKE;
			}

			dX = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dX;
			dY = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dY;

			// dX, dY    2  Energy Shield Generator    .  1   HP .
			// NPC       .
			iTotalESG = 0;
			for (ix = dX-10; ix <= dX+10; ix++) 
			for (iy = dY-10; iy <= dY+10; iy++) {
				m_pMapList[iMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH] != NULL) && (m_pNpcList[sOwnerH]->m_sType == 40)) {
					iTotalESG++;
				}
			}
			
			// testcode
			wsprintf(G_cTxt, "(!) Meteor Strike Target(%d, %d) ESG(%d)", dX, dY, iTotalESG);
			PutLogList(G_cTxt);

			if (iTotalESG < 2) {
			
				m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP -= (2 - iTotalESG);
				if (m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP <= 0) {
					//  .
					m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP = 0;
					//   
					m_pMapList[m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iMapIndex]->m_bIsDisabled = TRUE;
					m_stMeteorStrikeResult.iCrashedStructureNum++;
				}
				else {
					//   .
					m_stMeteorStrikeResult.iStructureDamageAmount += (2 - iTotalESG);
					//        
					iEffect = iDice(1,5)-1;
					iAddDynamicObjectList(NULL, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE2, iMapIndex, 
						                  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectX[iEffect] +(iDice(1,3) -2), 
										  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectY[iEffect] +(iDice(1,3) -2), 60*1000*50);
				}
			}
MSH_SKIP_STRIKE:;
		}

		// 1      
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 1000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		// 4      
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 4000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		// 6    .
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}
}

void CGame::CheckForceRecallTime(int iClientH)
{
	SYSTEMTIME SysTime;
	int iTL_;

	if(m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return;

	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
		// has admin set a recall time ??
		if (m_sForceRecallTime > 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = m_sForceRecallTime * 20;
		}
		// use standard recall time calculations
		else{
			GetLocalTime(&SysTime);
			switch(SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeMonday; break;  //  3 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeTuesday; break;  //  3 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeWednesday; break;  //  3 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeThursday; break;  //  3 
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeFriday; break; // 15
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSaturday; break; // 45 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSunday; break; // 60
			}
		}
	}
	else{
		// has admin set a recall time ??
		if (m_sForceRecallTime > 0) {
			iTL_ = m_sForceRecallTime * 20;
		}
		// use standard recall time calculations
		else{
			GetLocalTime(&SysTime);
			switch(SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeMonday; break;  //  3 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeTuesday; break;  //  3 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeWednesday; break;  //  3 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeThursday; break;  //  3 
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeFriday; break; // 15
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSaturday; break; // 45 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSunday; break; // 60
			}
		}
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
	}
}

int ITEMSPREAD_FIEXD_COORD [25][2] =
{
	{ 0,  0},	//1
	{ 1,  0},	//2
	{ 1,  1},	//3
	{ 0,  1},	//4
	{-1,  1},	//5
	{-1,  0},	//6
	{-1, -1},	//7
	{ 0, -1},	//8
	{ 1, -1},	//9
	{ 2, -1},	//10
	{ 2,  0},	//11
	{ 2,  1},	//12
	{ 2,  2},	//13
	{ 1,  2},	//14
	{ 0,  2},	//15
	{-1,  2},	//16
	{-2,  2},	//17
	{-2,  1},	//18
	{-2,  0},	//19
	{-2, -1},	//20
	{-2, -2},	//21
	{-1, -2},	//22
	{ 0, -2},	//23
	{ 1, -2},	//24
	{ 2, -2},	//25
};

BOOL CGame::bGetMultipleItemNamesWhenDeleteNpc(short sNpcType, int iProbability, int iMin, int iMax, short sBaseX, short sBaseY,
											   int iItemSpreadType, int iSpreadRange,
											   int *iItemIDs, POINT *BasePos, int *iNumItem)
{
	int		iProb = 100;
	float	fProb, fProbA, fProbB, fProbC;
	int		iItemID;
	int		iNum = 0;
	
	for(int i=0; i<iMax; i++ )
	{
		if( i>iMin ) iProb = iProbability;

		fProb = (float)(100 - iProb) / 10.0f;	//Wyvern  50
		if( fProb < 1.0f ) fProb = 1.0f;

		fProbA = fProbB = fProbC = fProb;

		fProbA = fProbA * 8.0f;
		fProbB = fProbB * 4.0f;
		fProbC = fProbC;

		iItemID = 0;

		switch(sNpcType)
		{
		case 69: // Wyvern...stupid koreans
			// 
			switch (iDice(1,4)) {
				case 1: if (iDice(1,(6000 * fProbA)) == 3) iItemID = 845; break; // StormBringer
				case 2: if (iDice(1,(5000 * fProbA)) == 3) iItemID = 848; break; // LightingBlade
				case 3: if (iDice(1,(3000 * fProbA)) == 2) iItemID = 614; break; // SwordofIceElemental
				case 4: if (iDice(1,(4500 * fProbA)) == 3) iItemID = 380; break; // IceStormManual
			}

			// 
			if( iItemID == 0 )
			{
				switch( iDice(1, 6) ) {	
					case  1: if (iDice(1,(500  * fProbB)) == 2) iItemID = 642; break; // KnecklaceOfIcePro       
					case  2: if (iDice(1,(2000 * fProbB)) == 2) iItemID = 643; break; // KnecklaceOfIceEle
					case  3: if (iDice(1,(1000 * fProbB)) == 3) iItemID = 636; break; // RingofGrandMage         	
					case  4: if (iDice(1,(1500  * fProbB)) == 3) iItemID = 734; break; // RingOfArcmage           
					case  5: if (iDice(1,(500  * fProbB)) == 3) iItemID = 634; break; // RingofWizard            
					case  6: if (iDice(1,(500  * fProbB)) == 2) iItemID = 290; break; // Flameberge+3(LLF)
				}
			}
			break; 

		case 73: // Fire-Wyvern
			// 
			switch (iDice(1, 7)) {
				case  1: if (iDice(1,(5000 * fProbA)) == 3) iItemID = 847; break; // DarkExecutor            
				case  2: if (iDice(1,(3000 * fProbA)) == 2) iItemID = 630; break; // RingoftheXelima
				case  3: if (iDice(1,(3000 * fProbA)) == 2) iItemID = 860; break; // NecklaceOfXelima        
				case  4: if (iDice(1,(3000 * fProbA)) == 2) iItemID = 735; break; // RingOfDragonpower       
				case  5: if (iDice(1,(3000 * fProbA)) == 2) iItemID =  20; break; // Excaliber
				case  6: if (iDice(1,(3000 * fProbA)) == 3) iItemID = 382; break; // BloodyShockW.Manual
				case  7: if (iDice(1,(3000 * fProbA)) == 3) iItemID = 381; break; // MassFireStrikeManual  			
			}

			// 
			if( iItemID == 0 )
			{
				switch( iDice(1, 9) ) {
					case  1: if (iDice(1,(1000 * fProbB)) == 2) iItemID = 645; break; // KnecklaceOfEfreet       	
					case  2: if (iDice(1,(500  * fProbB)) == 2) iItemID = 638; break; // KnecklaceOfFirePro			
					case  3: if (iDice(1,(1000 * fProbB)) == 3) iItemID = 636; break; // RingofGrandMage	
					case  4: if (iDice(1,(800  * fProbB)) == 3) iItemID = 734; break; // RingOfArcmage           
					case  5: if (iDice(1,(500  * fProbB)) == 3) iItemID = 634; break; // RingofWizard            
					case  6: if (iDice(1,(500  * fProbB)) == 2) iItemID = 290; break; // Flameberge+3(LLF)
					case  7: if (iDice(1,(500  * fProbB)) == 3) iItemID = 490; break; // BloodSword              
					case  8: if (iDice(1,(500  * fProbB)) == 3) iItemID = 491; break; // BloodAxe              
					case  9: if (iDice(1,(500  * fProbB)) == 3) iItemID = 492; break; // BloodRapier
				}
			}

			break;

		case 81: // Abaddon

			// 
			switch (iDice(1, 6)) {
				case 1: if (iDice(1,(100 * fProbA)) == 3) iItemID = 846; break; // The_Devastator
				case 2: if (iDice(1,(100 * fProbA)) == 3) iItemID = 847; break; // DarkExecutor            
				case 3: if (iDice(1,(100 * fProbA)) == 3) iItemID = 860; break; // NecklaceOfXelima
				case 4: if (iDice(1,(100 * fProbA)) == 3) iItemID = 865; break; // ResurWand(MS.20)
				case 5: if (iDice(1,(100 * fProbA)) == 2) iItemID = 631; break; // RingoftheAbaddon        	
				case 6: if (iDice(1,(100 * fProbA)) == 2) iItemID = 866; break; // BerserkWand(MS.10)
			}

			// 
			if( iItemID == 0 )
			{
				switch( iDice(1, 15) ) {
					case  1: if (iDice(1,(4 * fProbB)) == 3) iItemID = 762; break; // GBattleHammer           
					case  2: if (iDice(1,(4 * fProbB)) == 3) iItemID = 490; break; // BloodSword              
					case  3: if (iDice(1,(4 * fProbB)) == 3) iItemID = 491; break; // BloodAxe                
					case  4: if (iDice(1,(4 * fProbB)) == 3) iItemID = 492; break; // BloodRapier             
					case  5: if (iDice(1,(4 * fProbB)) == 3) iItemID = 611; break; // XelimaAxe
					case  6: if (iDice(1,(4 * fProbB)) == 3) iItemID = 610; break; // XelimaBlade
					case  7: if (iDice(1,(4 * fProbB)) == 3) iItemID = 612; break; // XelimaRapier
					case 10: if (iDice(1,(4 * fProbB)) == 3) iItemID = 645; break; // KnecklaceOfEfreet       	
					case 11: if (iDice(1,(4 * fProbB)) == 3) iItemID = 638; break; // KnecklaceOfFirePro      			
					case 12: if (iDice(1,(4 * fProbB)) == 3) iItemID = 382; break; // BloodyShockW.Manual
					case 13: if (iDice(1,(4 * fProbB)) == 3) iItemID = 381; break; // MassFireStrikeManual  
					case 14: if (iDice(1,(4 * fProbB)) == 3) iItemID = 259; break; // MagicWand(M.Shield)
					case 15: if (iDice(1,(4 * fProbB)) == 3) iItemID = 291; break; // MagicWand(MS30-LLF)
				}
			}
			break;
		} // switch

		//   ....dumb korean idiots
		if( iItemID == 0 )
		{
			switch( iDice(1, 24) ) {
				case  1: if (iDice(1,(2 * fProbC)) == 2) iItemID = 740; break; // BagOfGold-medium
				case  2: if (iDice(1,(2 * fProbC)) == 2) iItemID = 741; break; // BagOfGold-large
				case  3: if (iDice(1,(2 * fProbC)) == 2) iItemID = 742; break; // BagOfGold-largest
				case  4: if (iDice(1,(2 * fProbC)) == 2) iItemID = 868; break; // AcientTablet(LU)
				case  5:
				case  6:
				case  7: if (iDice(1,(2 * fProbC)) == 2) iItemID = 650; break; // ZemstoneOfSacrifice
				case  8:
				case  9: if (iDice(1,(2 * fProbC)) == 2) iItemID = 656; break; // StoneOfXelima
				case 10:
				case 11:
				case 12: if (iDice(1,(2 * fProbC)) == 2) iItemID = 657; break; // StoneOfMerien
				case 13: if (iDice(1,(2 * fProbC)) == 2) iItemID = 333; break; // PlatinumRing          
				case 14: if (iDice(1,(2 * fProbC)) == 2) iItemID = 334; break; // LuckyGoldRing         
				case 15: if (iDice(1,(2 * fProbC)) == 2) iItemID = 335; break; // EmeraldRing           
				case 16: if (iDice(1,(2 * fProbC)) == 2) iItemID = 336; break; // SapphireRing          
				case 17: if (iDice(1,(2 * fProbC)) == 2) iItemID = 337; break; // RubyRing              
				case 18: if (iDice(1,(2 * fProbC)) == 2) iItemID = 290; break; // Flameberge+3(LLF)
				case 19: if (iDice(1,(2 * fProbC)) == 2) iItemID = 292; break; // GoldenAxe(LLF)
				case 20: if (iDice(1,(2 * fProbC)) == 2) iItemID = 259; break; // MagicWand(M.Shield)
				case 21: if (iDice(1,(2 * fProbC)) == 2) iItemID = 300; break; // MagicNecklace(RM10)
				case 22: if (iDice(1,(2 * fProbC)) == 2) iItemID = 311; break; // MagicNecklace(DF+10)
				case 23: if (iDice(1,(2 * fProbC)) == 2) iItemID = 305; break; // MagicNecklace(DM+1)
				case 24: if (iDice(1,(2 * fProbC)) == 2) iItemID = 308; break; // MagicNecklace(MS10)
			}
		}

		//  100     .
		// Gold . retarded koreans -_-
		if( iItemID == 0 && iProb == 100 ) iItemID = 90; // Gold

		if( iItemID != 0 )
		{
			// item id
			iItemIDs[iNum] = iItemID;

			// item position
			switch(iItemSpreadType)
			{
			case DEF_ITEMSPREAD_RANDOM:
				BasePos[iNum].x = sBaseX + iSpreadRange - iDice(1, iSpreadRange * 2 );
				BasePos[iNum].y = sBaseY + iSpreadRange - iDice(1, iSpreadRange * 2 );
				break;

			case DEF_ITEMSPREAD_FIXED:
				BasePos[iNum].x = sBaseX + ITEMSPREAD_FIEXD_COORD[iNum][0];
				BasePos[iNum].y = sBaseY + ITEMSPREAD_FIEXD_COORD[iNum][1];
				break;
			}
			iNum++;
		}

	} // for

	*iNumItem = iNum;

	return TRUE;

} // bGetMultipleItemNamesWhenDeleteNpc... duh...korean morons

// 05/21/2004 - Hypnotoad - Balances to drop status
void CGame::NpcDeadItemGenerator(int iNpcH, short sAttackerH, char cAttackerType)
{
	class CItem * pItem;
	char  cColor, cItemName[21];
	BOOL  bIsGold;
	int   iGenLevel, iResult, iItemID;
	DWORD dwType, dwValue;
	double dTmp1, dTmp2, dTmp3;
	short sMagicLevel = 0;

	if (m_pNpcList[iNpcH] == NULL) return;
	if ((cAttackerType != DEF_OWNERTYPE_PLAYER) || (m_pNpcList[iNpcH]->m_bIsSummoned == TRUE)) return;
	if (m_pNpcList[iNpcH]->m_bIsUnsummoned == TRUE) return;

	ZeroMemory(cItemName, sizeof(cItemName));
	bIsGold = FALSE;

	switch (m_pNpcList[iNpcH]->m_sType) {
		// NPC not dropping Gold
	case 21: // Guard
	case 34: // Dummy
	case 64: // Crop
		return;
	}

	// 6500 default; the lower the greater the Weapon/Armor/Wand Drop
	if (iDice(1,10000) >= m_iPrimaryDropRate) {
		// 35% Drop 60% of that is gold
		// 35% Chance of drop (35/100)
		if (iDice(1,10000) <= 6000) {
			iItemID = 90; // Gold: (35/100) * (60/100) = 21%
			// If a non-existing itemID is given create no item
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, iItemID) == FALSE) {
				delete pItem;
				return;	
			}

			pItem->m_dwCount = (DWORD)(iDice(1, (m_pNpcList[iNpcH]->m_iGoldDiceMax - m_pNpcList[iNpcH]->m_iGoldDiceMin)) + m_pNpcList[iNpcH]->m_iGoldDiceMin);

			// v1.42 Gold 
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_iAddGold != NULL)) {
				dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddGold;
				dTmp2 = (double)pItem->m_dwCount;
				dTmp3 = (dTmp1/100.0f)*dTmp2;
				pItem->m_dwCount += (int)dTmp3;
			}
		}
		else {
			// 9000 default; the lower the greater the Weapon/Armor/Wand Drop
			// 35% Drop 40% of that is an Item 
			dTmp1 = m_pClientList[sAttackerH]->m_iRating*m_cRepDropModifier;
			if (dTmp1 > 3000) dTmp1 = 3000;
			if (dTmp1 < -3000) dTmp1 = -3000;
			dTmp2 = (m_iSecondaryDropRate - (dTmp1));
			if (iDice(1,10000) <= dTmp2) { 
				// 40% Drop 90% of that is a standard drop
				// Standard Drop Calculation: (35/100) * (40/100) * (90/100) = 12.6%
				iResult = iDice(1,12000);
				if ((iResult >= 1) && (iResult <= 3000))          dwValue = 1;
				else if ((iResult >= 3001) && (iResult <= 4000))  dwValue = 2;
				else if ((iResult >= 4001) && (iResult <= 5500))  dwValue = 3;
				else if ((iResult >= 5501) && (iResult <= 7000))  dwValue = 4;
				else if ((iResult >= 7001) && (iResult <= 8500))  dwValue = 5;
				else if ((iResult >= 8501) && (iResult <= 9200))  dwValue = 6;
				else if ((iResult >= 9201) && (iResult <= 9800))  dwValue = 7;
				else if ((iResult >= 9801) && (iResult <= 10000)) dwValue = 8;
				else if ((iResult >= 10001) && (iResult <= 12000)) dwValue = 9;

				switch (dwValue) {	
						case 1: iItemID = 95; break; // Green Potion
						case 2: iItemID = 91; break; // Red Potion
						case 3: iItemID = 93; break; // Blue Potion
						case 4: iItemID = 96; break; // Big Green Potion
						case 5: iItemID = 92; break; // Big Red Potion
						case 6: iItemID = 94; break; // Big Blue Potion
						case 7: switch(iDice(1,2)) {
								case 1: iItemID = 390; break; // Power Green Potion
								case 2: iItemID = 95;  break; // Green Potion
								}
								break;
						case 8: switch(iDice(1,6)) {
								case 1: iItemID = 391; break; // Super Power Green Potion
								case 2: iItemID = 650; break; // Zemstone of Sacrifice
								case 3: iItemID = 656; break; // Xelima Stone
								case 4: iItemID = 657; break; // Merien Stone
								case 5: iItemID = 95;  break; // Green Potion
								case 6: switch(iDice(1,5)) {
										case 1: iItemID = 651; break; // GreenBall
										case 2: iItemID = 652; break; // RedBall
										case 3: iItemID = 653; break; // YellowBall
										case 4: iItemID = 654; break; // BlueBall
										case 5: switch(iDice(1,11)) {
												case 1: iItemID = 881; break; // ArmorDye(Indigo)
												case 2: iItemID = 882; break; // ArmorDye(Crimson-Red)
												case 3: iItemID = 883; break; // ArmorDye(Gold)
												case 4: iItemID = 884; break; // ArmorDye(Aqua)
												case 5: iItemID = 885; break; // ArmorDye(Pink)
												case 6: iItemID = 886; break; // ArmorDye(Violet)
												case 7: iItemID = 887; break; // ArmorDye(Blue)
												case 8: iItemID = 888; break; // ArmorDye(Khaki)
												case 9: iItemID = 889; break; // ArmorDye(Yellow)
												case 10: iItemID = 890; break; // ArmorDye(Red)
												case 11: iItemID = 655; break; // PearlBall
												}
												break;
										}
										break;
								}
								break;

						case 9: 		
							SYSTEMTIME SysTime;
							GetLocalTime(&SysTime);
							if (((short)SysTime.wMonth == 12) && (m_pNpcList[iNpcH]->m_sType == 61 || 55)) {
								switch(iDice(1,4)) {
								case 1: iItemID = 780; break; // Red Candy
								case 2: iItemID = 781; break; // Blue Candy
								case 3: iItemID = 782; break; // Green Candy
								case 4: iItemID = 91;  break; // Red Potion
								}
							}
							break;
				}
				// If a non-existing item is created then delete the item
				pItem = new class CItem;
				if (_bInitItemAttr(pItem, iItemID) == FALSE) {
					delete pItem;
					return;	
				}
			}
			else {
				// Valuable Drop Calculation: (35/100) * (40/100) * (10/100) = 1.4%
				// Define iGenLevel using Npc.cfg#
				switch (m_pNpcList[iNpcH]->m_sType) {

				case 10: // Slime
				case 16: // Giant-Ant
				case 22: // Amphis
				case 55: // Rabbit
				case 56: //	Cat
					iGenLevel = 1;
					break;

				case 11: // Skeleton
				case 14: // Orc, Orc-Mage
				case 17: // Scorpion
				case 18: // Zombie
					iGenLevel = 2;
					break;

				case 12: // Stone-Golem
				case 23: // Clay-Golem
					iGenLevel = 3;
					break;

				case 27: // Hellbound
				case 61: // Rudolph
					iGenLevel = 4;
					break; 

				case 72: // Claw-Turtle
				case 76: // Giant-Plant
				case 74: // Giant-Crayfish
				case 13: // Cyclops
				case 28: // Troll
				case 53: // Beholder
				case 60: // Cannibal-Plant
				case 62: // DireBoar
					iGenLevel = 5;
					break;

				case 29: // Orge
				case 33: // WereWolf
				case 48: // Stalker
				case 54: // Dark-Elf
				case 65: // Ice-Golem
			    case 78: // Minotaurus
					iGenLevel = 6;
					break;

		 	    case 70: // Balrogs
				case 71: // Centaurus
				case 30: // Liche
				case 63: // Frost
			    case 79: // Nizie
					iGenLevel = 7;
					break;

				case 31: // Demon
				case 32: // Unicorn
				case 49: // Hellclaw
				case 50: // Tigerworm
				case 52: // Gagoyle
					iGenLevel = 8;
					break; 

				case 58: // MountainGiant
					iGenLevel = 9;
					break;

			    case 77: // MasterMage-Orc
				case 59: // Ettin
				case 75: // Lizards
					iGenLevel = 10;
					break;
				}	

				if (iGenLevel == 0) return;

				// Weapon Drop: 
				// 1.4% chance Valuable Drop 60% that it is a Weapon
				if (iDice(1,10000) <= 6000) {
					if (iDice(1,10000) <= 8000) {
						// 70% the Weapon is Melee
						switch (iGenLevel) { 

				case 1: // Slime, Giant-Ant, Amphis, Rabbit, Cat
					switch (iDice(1,3)) { 
				case 1: iItemID = 1;  break; // Dagger
				case 2: iItemID = 8;  break; // ShortSword
				case 3: iItemID = 59; break; // LightAxe
					}
					break; 

				case 2: // Skeleton, Orc, Orc-Mage, Scorpion, Zombie
					switch (iDice(1,6)) {
						case 1: iItemID = 12;  break; // MainGauche
						case 2: iItemID = 15;  break; // Gradius
						case 3: iItemID = 65;  break; // SexonAxe
						case 4: iItemID = 62;  break; // Tomahoc
						case 5: iItemID = 23;  break; // Sabre
						case 6: iItemID = 31;  break; // Esterk
					}
					break;

				case 3: // Stone-Golem, Clay-Golem
					switch (iDice(1,4)) {
				case 1: iItemID = 17;  break; // LongSword
				case 2: iItemID = 68;  break; // DoubleAxe
				case 3: iItemID = 23;  break; // Sabre
				case 4: iItemID = 31;  break; // Esterk
					}
					break;

				case 4: // Hellbound, Rudolph
					switch (iDice(1,5)) {
				case 1: iItemID = 23;  break; // Sabre
				case 2: iItemID = 25;  break; // Scimitar
				case 3: iItemID = 28;  break; // Falchion
				case 4: iItemID = 31;  break; // Esterk
				case 5: iItemID = 34;  break; // Rapier
					}
					break;

				case 5: // Cyclops, Troll, Beholder, Cannibal-Plant, DireBoar
					switch (iDice(1,3)) {
				case 1: iItemID = 31;  break; // Esterk
				case 2: iItemID = 34;  break; // Rapier
				case 3: iItemID = 71;  break; // WarAxe
					}
					break;

				case 6: // Orge, WereWolf, Stalker, Dark-Elf, Ice-Golem
					switch (iDice(1,6)) {
				case 1: iItemID = 50;  break; // GreatSword
				case 2: iItemID = 54;  break; // Flameberge
				case 3: iItemID = 46;  break; // Claymore
				case 4: iItemID = 31;  break; // Esterk
				case 5: iItemID = 34;  break; // Rapier
				case 6: iItemID = 617; break; // CompositeBow
					}
					break;

				case 7: // Liche, Frost
					switch (iDice(1,4)) {
				case 1: iItemID = 50;  break; // GreatSword
				case 2: iItemID = 54;  break; // Flameberge
				case 3: iItemID = 31;  break; // Esterk
				case 4: iItemID = 34;  break; // Rapier
					}
					break;

				case 8: // Demon, Unicorn, Hellclaw, Tigerworm, Gagoyle
					switch (iDice(1,7)) {
				case 1: iItemID = 50;  break; // GreatSword
				case 2: iItemID = 54;  break; // Flameberge
				case 3: iItemID = 560; break; // BattleAxe
				case 4: iItemID = 31;  break; // Esterk
				case 5: iItemID = 34;  break; // Rapier
				case 6: iItemID = 55;  break; // Flameberge+1
				case 7: iItemID = 615; break; // GiantSword
					}
					break;

				case 9: // MountainGiant
					switch (iDice(1,6)) {
				case 1: iItemID = 23;  break; // Sabre
				case 2: iItemID = 25;  break; // Scimitar
				case 3: iItemID = 28;  break; // Falchion
				case 4: iItemID = 31;  break; // Esterk
				case 5: iItemID = 34;  break; // Rapier
				case 6: iItemID = 760; break; // Hammer
					}
					break;

				case 10: // Ettin
					switch (iDice(1,5)) {
					case 1: iItemID = 46;  break; // Claymore
					case 2: iItemID = 31;  break; // Esterk
					case 3: iItemID = 34;  break; // Rapier
					case 4: iItemID = 760; break; // Hammer
					case 5: iItemID = 761; break; // GiantHammer
					}
					break;

						}
					}
					else {
						// 30% the weapon is a Wand
						switch (iGenLevel) {

						case 2: 
						case 3:
							iItemID = 258; break; // MagicWand(MS0)
						case 4: 
						case 5: 
						case 6: 
							iItemID = 257; break; // MagicWand(MS10)
						case 7:
						case 8:
							iItemID = 256; break; // MagicWand(MS20)
						case 9:
						case 10:
							break;
						}	
					}
				}
				else {
					// 1.4% chance Valuable Drop 40% that drop is an Armor/Shield
					switch (iGenLevel) {

					case 1: // Slime, Giant-Ant, Amphis, Rabbit, Cat
					case 2: // Skeleton, Orc, Orc-Mage, Scorpion, Zombie
						switch (iDice(1,2)) { 
							case 1: iItemID = 79;  break; // WoodShield
							case 2: iItemID = 81;  break; // TargeShield
						}
						break; 

					case 3: // Stone-Golem, Clay-Golem
						iItemID = 81; // TargeShield
						break;

					case 4: // Hellbound, Rudolph
						switch (iDice(1,5)) {
							case 1: iItemID = 454; break; // Hauberk(M)
							case 2: iItemID = 472; break; // Hauberk(W)
							case 3: iItemID = 461; break; // ChainHose(M)
							case 4: iItemID = 482; break; // ChainHose(W)
							case 5: iItemID = 83;  break; // BlondeShield
						}
						break;

					case 5: // Cyclops, Troll, Beholder, Cannibal-Plant, DireBoar
						switch (iDice(1,3)) {
							case 1: iItemID = 455; break; // LeatherArmor(M)
							case 2: iItemID = 475; break; // LeatherArmor(W)
							case 3: iItemID = 84;  break; // IronShield
						}
						break;

					case 6: // Orge, WereWolf, Stalker, Dark-Elf, Ice-Golem
						switch (iDice(1,6)) {
						case 1: switch(iDice(1,2)) {
							case 1: iItemID = 456; break; // ChainMail(M)
							case 2: iItemID = 476; break; // ChainMail(W)
						}
						break;
						case 2: switch(iDice(1,2)) {
							case 1: iItemID = 458; break; // PlateMail(M)
							case 2: iItemID = 478; break; // PlateMail(W)
						}
						break;
						case 3: iItemID = 85; break; // LagiShield
						case 4: switch(iDice(1,8)) {
							case 1: iItemID = 750; break; // Horned-Helm(M)
							case 2: iItemID = 751; break; // Wings-Helm(M)
							case 3: iItemID = 754; break; // Horned-Helm(W)
							case 4: iItemID = 755; break; // Wings-Helm(W)
							case 5: iItemID = 752; break; // Wizard-Cap(M) 
							case 6: iItemID = 753; break; // Wizard-Hat(M)
							case 7: iItemID = 756; break; // Wizard-Cap(W) 
							case 8: iItemID = 757; break; // Wizard-Hat(W) 
						}
						break;	
						case 5: switch(iDice(1,2)) {
							case 1: iItemID = 454; break; // Hauberk(M)
							case 2: iItemID = 472; break; // Hauberk(W)
						}
						break;
						case 6: switch(iDice(1,2)) {
							case 1: iItemID = 461; break; // ChainHose(M)
							case 2: iItemID = 482; break; // ChainHose(W)
						}
						break;
						}
						break;


					case 7: // Liche, Frost
						switch (iDice(1,6)) {
						case 1: switch(iDice(1,2)) {
							case 1: iItemID = 457; break; // ScaleMail(M)
							case 2: iItemID = 477; break; // ScaleMail(W)
							}
							break;
						case 2: switch(iDice(1,2)) {
							case 1: iItemID = 458; break; // PlateMail(M)
							case 2: iItemID = 478; break; // PlateMail(W)
							}
							break;
						case 3: iItemID = 86; break; // KnightShield
						case 4: iItemID = 87; break; // TowerShield
						case 5: switch(iDice(1,2)) {
							case 1: iItemID = 600; break; // Helm(M)
							case 2: iItemID = 602; break; // Helm(M)
							}
							break;
						case 6: switch(iDice(1,2)) {
							case 1: iItemID = 601; break; // Full-Helm(M)
							case 2: iItemID = 603; break; // Full-Helm(M)
							}
							break;
						}
						break;

					case 8: // Demon, Unicorn, Hellclaw, Tigerworm, Gagoyle
						iItemID = 402; // Cape
						break;

					case 9:
					case 10:
						break;
					}
				}
				// 0-None 1- 2- 3-  
				// 5- 6- 7- 8- 9- 10- 
				//   
				pItem = new class CItem;
				//     
				if (_bInitItemAttr(pItem, iItemID) == FALSE) {
					delete pItem;
					return;	
				}

				if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
					//        
					// (3%) (7%) (15%) (20%) (20%) (16%) (16%) (3%)
					iResult = iDice(1,11500);
					if ((iResult >= 1) && (iResult <= 299)) {
						dwType = 6; 
						cColor = 2; 
					}
					else if ((iResult >= 300) && (iResult <= 999)) {
						dwType = 8; 
						cColor = 3;
					}
					else if ((iResult >= 1000) && (iResult <= 2499)) {
						dwType = 1;
						cColor = 5;
					}
					else if ((iResult >= 2500) && (iResult <= 4499)) {
						dwType = 5;
						cColor = 1;
					}
					else if ((iResult >= 4500) && (iResult <= 6499)) {
						dwType = 3;
						cColor = 7;
					}
					else if ((iResult >= 6500) && (iResult <= 8099)) {
						dwType = 2;
						cColor = 4;
					}
					else if ((iResult >= 8100) && (iResult <= 9699)) {
						dwType = 7;
						cColor = 6;
					}
					else if ((iResult >= 9700) && (iResult <= 9999)) {
						dwType = 9;
						cColor = 8;
					}
					// Magic Weapons - Drops Improvement
					else if ((iResult >= 10000) && (iResult <= 11499)) {
						dwType = 15; // Magic
						cColor = 10; // Black Color
					}
					// End of Magic Weapons

					//    
					pItem->m_cItemColor = cColor;

					// , , , , , , , 
					//  Main    

					//  Sub    
					// Magic Weapons - Set the Spell Effect on Dropped Item
					if (dwType == 15){
						iResult = iDice(1, 30060);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // Fire-Strike
						else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // Lightning
						else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // Chill-Wind
						else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // Ice-Strike
						else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // Energy-Strike
						else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // Mass-Fire-Strike
						else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // Mass-Chill-Wind
						else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // Earthworm-Strike
						else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // Bloody-Shock-Wave
						else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // Mass-Ice-Strike
						else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // Lightning-Strike
						else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // Ice-Whirlwind
						else if ((iResult >= 29970) && (iResult < 30000))  dwValue = 13; // Meteor-Strike
						else if ((iResult >= 30000) && (iResult < 30025))  dwValue = 14; // Mass-Magic-Missile
						else if ((iResult >= 30025) && (iResult < 30045))  dwValue = 15; // Blizzard
						else if ((iResult >= 30045) && (iResult <= 30060))  dwValue = 16; // Earth-Shock-Wave
						else dwValue = 1;
						sMagicLevel = 1;
					}
					else{
						iResult = iDice(1, 30000);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
						else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
						else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
						else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
						else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
						else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
						else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
						else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
						else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
						else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
						else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
						else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
						else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
						else dwValue = 1; // v2.03 906
						sMagicLevel = 0;
					}
					// End of Magic Weapons 

					//  Main     
					switch (dwType) {
					case 1: //    +5
						if (dwValue <= 5) dwValue = 5;
						break; 
					case 2: //    +20
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 6: //    +16%
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 8: //   +14%					
						if (dwValue <= 2) dwValue = 2;
						break; 
					// Magic Weapons - Better Stats for Strong NPC killed
					case 15:
						switch(iGenLevel){
							case 1: // Slime, Giant-Ant, Amphis, Rabbit, Cat
								if(dwValue > 4) dwValue = 4;
								if(dwValue < 1) dwValue = 1;
								break;
							case 2: // Skeleton, Orc, Orc-Mage, Scorpion, Zombie
								if(dwValue > 6) dwValue = 6;
								if(dwValue < 3) dwValue = 3;
								break;
							case 3: // Stone-Golem, Clay-Golem
								if(dwValue > 7) dwValue = 7;
								if(dwValue < 4) dwValue = 4;
								break;
							case 4: // Hellbound, Rudolph
								if(dwValue > 8) dwValue = 8;
								if(dwValue < 5) dwValue = 5;
								break;
							case 5: // Cyclops, Troll, Beholder, Cannibal-Plant, DireBoar
								if(dwValue > 10) dwValue = 10;
								if(dwValue < 7) dwValue = 7;
								break;
							case 6: // Orge, WereWolf, Stalker, Dark-Elf, Ice-Golem
								if(dwValue > 12) dwValue = 12;
								if(dwValue < 9) dwValue = 9;
								break;
							case 7: // Liche, Frost
								if(dwValue > 13) dwValue = 13;
								if(dwValue < 10) dwValue = 10;
								break;
							case 8: // Demon, Unicorn, Hellclaw, Tigerworm, Gagoyle
								if(dwValue > 16) dwValue = 16;
								if(dwValue < 13) dwValue = 13;
								break;
						}
						break;
					// End of Magic Weapons
					}
					// v2.03 912   2   7
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

					//  Main ,  
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					//  Sub    40%
					if (iDice(1,10000) >= 6000) {

						//   Sub   : 
						// (1),  (2),  (3), HP  (4), SP  (5)
						//MP  (6),  (7),   (8),   (9)
						//  (10),   (11),  Gold(12)

						//     (50%),   (35%),   Gold(10%),   (5%)
						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 4999))          dwType = 2;
						else if ((iResult >= 5000) && (iResult <= 8499))  dwType = 10;
						else if ((iResult >= 8500) && (iResult <= 9499))  dwType = 12;
						else if ((iResult >= 9500) && (iResult <= 10000)) dwType = 11;

						//  Sub    
						// Magic Weapons - Set the Spell Effect on Dropped Item
						if (dwType == 15){
							iResult = iDice(1, 30060);
							if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // Fire-Strike
							else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // Lightning
							else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // Chill-Wind
							else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // Ice-Strike
							else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // Energy-Strike
							else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // Mass-Fire-Strike
							else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // Mass-Chill-Wind
							else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // Earthworm-Strike
							else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // Bloody-Shock-Wave
							else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // Mass-Ice-Strike
							else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // Lightning-Strike
							else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // Ice-Whirlwind
							else if ((iResult >= 29970) && (iResult < 30000))  dwValue = 13; // Meteor-Strike
							else if ((iResult >= 30000) && (iResult < 30025))  dwValue = 14; // Mass-Magic-Missile
							else if ((iResult >= 30025) && (iResult < 30045))  dwValue = 15; // Blizzard
							else if ((iResult >= 30045) && (iResult <= 30060))  dwValue = 16; // Earth-Shock-Wave
							else dwValue = 1;
							sMagicLevel = 1;
						}
						else{
							iResult = iDice(1, 30000);
							if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
							else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
							else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
							else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
							else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
							else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
							else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
							else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
							else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
							else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
							else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
							else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
							else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
							else dwValue = 1; // v2.03 906
							sMagicLevel = 0;
						}
						// End of Magic Weapons 

						//  Sub     
						switch (dwType) {
						case 2: //   +21%
							if (dwValue <= 3) dwValue = 3;
							break; 
						case 10: //    +1  7
							if (dwValue > 7) dwValue = 7; 
							break; 
						case 11: // Exp  +20%
							dwValue = 2;
							break; 
						case 12: // Gold  +50%
							dwValue = 5;
							break; 
						}

						// Magic Weapons - Better Stats for Strong NPC Killed
						if (sMagicLevel >0){
							switch(iGenLevel){
								case 1: // Slime, Giant-Ant, Amphis, Rabbit, Cat
									if(dwValue > 2) dwValue = 2;
									if(dwValue < 1) dwValue = 1;
									break;
								case 2: // Skeleton, Orc, Orc-Mage, Scorpion, Zombie
									if(dwValue > 3) dwValue = 3;
									if(dwValue < 1) dwValue = 1;
									break;
								case 3: // Stone-Golem, Clay-Golem
									if(dwValue > 4) dwValue = 4;
									if(dwValue < 2) dwValue = 2;
									break;
								case 4: // Hellbound, Rudolph
									if(dwValue > 5) dwValue = 5;
									if(dwValue < 2) dwValue = 2;
									break;
								case 5: // Cyclops, Troll, Beholder, Cannibal-Plant, DireBoar
									if(dwValue > 7) dwValue = 7;
									if(dwValue < 3) dwValue = 3;
									break;
								case 6: // Orge, WereWolf, Stalker, Dark-Elf, Ice-Golem
									if(dwValue > 9) dwValue = 9;
									if(dwValue < 5) dwValue = 5;
									break;
								case 7: // Liche, Frost
									if(dwValue > 10) dwValue = 10;
									if(dwValue < 6) dwValue = 6;
									break;
								case 8: // Demon, Unicorn, Hellclaw, Tigerworm, Gagoyle
									if(dwValue > 15) dwValue = 15;
									if(dwValue < 9) dwValue = 9;
									break;
							}
						}
						// End of Magic Weapons

						// v2.03 912   2   7
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

						//  Sub  
						dwType  = dwType << 12;
						dwValue = dwValue << 8;

						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}

				else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
					//         10, 11
					//  (100%) <-          .
					dwType = 10;
					cColor = 5;

					//    
					pItem->m_cItemColor = cColor;

						// Magic Weapons - Set the Spell Effect on Dropped Item
						
							iResult = iDice(1, 30000);
							if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
							else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
							else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
							else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
							else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
							else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
							else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
							else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
							else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
							else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
							else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
							else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
							else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
							else dwValue = 1; // v2.03 906
							
						// End of Magic Weapons 

					// v2.03 912   2   7
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

					//  Main ,  
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					//  Sub    40%
					if (iDice(1,10000) >= 6000) {

						//   Sub   : 
						// (1),  (2),  (3), HP  (4), SP  (5)
						//MP  (6),  (7),   (8),   (9)
						//  (10),   (11),  Gold(12)

						//     (50%),   (35%),   Gold(10%),   (5%)
						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 4999))          dwType = 2;
						else if ((iResult >= 5000) && (iResult <= 8499))  dwType = 10;
						else if ((iResult >= 8500) && (iResult <= 9499))  dwType = 12;
						else if ((iResult >= 9500) && (iResult <= 10000)) dwType = 11;

						//  Sub    
						// Magic Weapons - Set the Spell Effect on Dropped Item
						
							iResult = iDice(1, 30000);
							if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
							else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
							else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
							else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
							else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
							else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
							else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
							else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
							else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
							else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
							else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
							else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
							else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
							else dwValue = 1; // v2.03 906
							
						// End of Magic Weapons 

						// v2.03 912   2   7
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

						//  Sub     
						switch (dwType) {
						case 2: //   +21%
							if (dwValue <= 3) dwValue = 3;
							break; 
						case 10: //    +1  7
							if (dwValue > 7) dwValue = 7; 
							break; 
						case 11: // Exp  +20%
							dwValue = 2;
							break; 
						case 12: // Gold  +50%
							dwValue = 5;
							break; 
						}

						//  Sub  
						dwType  = dwType << 12;
						dwValue = dwValue << 8;
						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}
				else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE) {
					//     , .

					// (60%)  (30%)  (5%)  (5%)
					iResult = iDice(1,10000);
					if ((iResult >= 1) && (iResult <= 5999))          dwType = 8;
					else if ((iResult >= 6000) && (iResult <= 8999))  dwType = 6;
					else if ((iResult >= 9000) && (iResult <= 9554))  dwType = 11; //dwType = 11;
					else if ((iResult >= 9555) && (iResult <= 10000)) dwType = 12; //dwType = 12;

					//  Sub    
					// Magic Weapons - Set the Spell Effect on Dropped Item
						
							iResult = iDice(1, 30000);
							if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
							else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
							else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
							else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
							else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
							else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
							else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
							else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
							else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
							else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
							else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
							else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
							else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
							else dwValue = 1; // v2.03 906
							
						// End of Magic Weapons 

					//  Main     
					switch (dwType) {
					case 6: //   +16%
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 8: //   +14%
						if (dwValue <= 2) dwValue = 2;
						break; 

					case 11:
					case 12:
						// v2.04
						dwValue = (dwValue+1) / 2;
						if (dwValue < 1) dwValue = 1;
						if ((iGenLevel <= 3) && (dwValue > 2)) dwValue = 2;
						break;
					}
					// v2.03 912   2   7
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

					//  Main ,  
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					//  Sub    40%
					if (iDice(1,10000) >= 6000) {

						//   Sub   : 
						// (1),  (2),  (3), HP  (4), SP  (5)
						//MP  (6),  (7),   (8),   (9)
						//  (10),   (11),  Gold(12)

						//    
						// (10%) (30%)    SP(15%)  HP(10%) 
						// MP (10%) (15%) (3%) (3%)
						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 999))           dwType = 3;
						else if ((iResult >= 1000) && (iResult <= 3999))  dwType = 1;
						else if ((iResult >= 4000) && (iResult <= 5499))  dwType = 5;
						else if ((iResult >= 5500) && (iResult <= 6499))  dwType = 4;
						else if ((iResult >= 6500) && (iResult <= 7499))  dwType = 6;
						else if ((iResult >= 7500) && (iResult <= 9399))  dwType = 7;
						else if ((iResult >= 9400) && (iResult <= 9799))  dwType = 8;
						else if ((iResult >= 9800) && (iResult <= 10000)) dwType = 9;

						//  Sub    
						// Magic Weapons - Set the Spell Effect on Dropped Item
						
							iResult = iDice(1, 30000);
							if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
							else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
							else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
							else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
							else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
							else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
							else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
							else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
							else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
							else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
							else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
							else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
							else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
							else dwValue = 1; // v2.03 906
							
						// End of Magic Weapons 

						//  Sub     
						switch (dwType) {
						case 1: //   +21%
						case 3: //   +21%
						case 7: //    +21%
						case 8: //   +9%
						case 9: //   +9%
							if (dwValue <= 3) dwValue = 3;
							break; 
						}
						// v2.03 912   2   7
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

						//  Sub  
						dwType  = dwType << 12;
						dwValue = dwValue << 8;
						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}

				//       
				_AdjustRareItemValue(pItem);
			}
		}

		//     
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		//     , 	
		SYSTEMTIME SysTime;
		char cTemp[256];
		GetLocalTime(&SysTime);
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
		pItem->m_sTouchEffectValue3 = atoi(cTemp);

		//    . 
		m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, 
			m_pNpcList[iNpcH]->m_sY, 
			pItem);

		//      . 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
			m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY,
			pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color

		//  .
		_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, NULL, pItem);
	}
}

BOOL CGame::bReadAdminSetConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, * token, cReadMode, cGSMode[16] = "";
	char seps[] = "= \t\n";
	class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
	 return FALSE;
	}
	else {
		 PutLogList("(!) Reading settings file...");
		 cp = new char[dwFileSize+2];
		 ZeroMemory(cp, dwFileSize+2);
		 fread(cp, dwFileSize, 1, pFile);

		 pStrTok = new class CStrTok(cp, seps);
		 token = pStrTok->pGet();
		 while( token != NULL )   {

		 if (cReadMode != 0) {
		   switch (cReadMode) {

		   case 1:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGMKill = atoi(token);
			}
			else{
				m_iAdminLevelGMKill = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		   case 2:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGMRevive = atoi(token);
			}
			else{
				m_iAdminLevelGMRevive = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		   case 3:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGMCloseconn = atoi(token);
			}
			else{
				m_iAdminLevelGMCloseconn = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		   case 4:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGMCheckRep = atoi(token);
			}
			else{
				m_iAdminLevelGMCheckRep = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 5:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelWho = atoi(token);
			}
			else{
				m_iAdminLevelWho = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 6:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelEnergySphere = atoi(token);
			}
			else{
				m_iAdminLevelEnergySphere = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 7:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelShutdown = atoi(token);
			}
			else{
				m_iAdminLevelShutdown = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 8:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelObserver = atoi(token);
			}
			else{
				m_iAdminLevelObserver = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 9:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelShutup = atoi(token);
			}
			else{
				m_iAdminLevelShutup = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 10:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCallGaurd = atoi(token);
			}
			else{
				m_iAdminLevelCallGaurd = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 11:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummonDemon = atoi(token);
			}
			else{
				m_iAdminLevelSummonDemon = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------		   
		  case 12:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummonDeath = atoi(token);
			}
			else{
				m_iAdminLevelSummonDeath = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 13:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelReserveFightzone = atoi(token);
			}
			else{
				m_iAdminLevelReserveFightzone = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 14:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCreateFish = atoi(token);
			}
			else{
				m_iAdminLevelCreateFish = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 15:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelTeleport = atoi(token);
			}
			else{
				m_iAdminLevelTeleport = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 16:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCheckIP = atoi(token);
			}
			else{
				m_iAdminLevelCheckIP = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 17:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelPolymorph = atoi(token);
			}
			else{
				m_iAdminLevelPolymorph = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 18:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetInvis = atoi(token);
			}
			else{
				m_iAdminLevelSetInvis = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 19:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetZerk = atoi(token);
			}
			else{
				m_iAdminLevelSetZerk = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 20:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetIce = atoi(token);
			}
			else{
				m_iAdminLevelSetIce = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 21:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGetNpcStatus = atoi(token);
			}
			else{
				m_iAdminLevelGetNpcStatus = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------				
		  case 22:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetAttackMode = atoi(token);
			}
			else{
				m_iAdminLevelSetAttackMode = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 23:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelUnsummonAll = atoi(token);
			}
			else{
				m_iAdminLevelUnsummonAll = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 24:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelUnsummonDemon = atoi(token);
			}
			else{
				m_iAdminLevelUnsummonDemon = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 25:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummon = atoi(token);
			}
			else{
				m_iAdminLevelSummon = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------			
		  case 26:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummonAll = atoi(token);
			}
			else{
				m_iAdminLevelSummonAll = 4;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 27:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummonPlayer = atoi(token);
			}
			else{
				m_iAdminLevelSummonPlayer = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 28:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelDisconnectAll = atoi(token);
			}
			else{
				m_iAdminLevelDisconnectAll = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 29:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelEnableCreateItem = atoi(token);
			}
			else{
				m_iAdminLevelEnableCreateItem = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------			
		  case 30:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCreateItem = atoi(token);
			}
			else{
				m_iAdminLevelCreateItem = 4;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 31:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelStorm = atoi(token);
			}
			else{
				m_iAdminLevelStorm = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 32:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelWeather = atoi(token);
			}
			else{
				m_iAdminLevelWeather = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 33:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetStatus = atoi(token);
			}
			else{
				m_iAdminLevelSetStatus = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 34:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGoto = atoi(token);
			}
			else{
				m_iAdminLevelGoto = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 35:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelMonsterCount = atoi(token);
			}
			else{
				m_iAdminLevelMonsterCount = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------			
		  case 36:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetRecallTime = atoi(token);
			}
			else{
				m_iAdminLevelSetRecallTime = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 37:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelUnsummonBoss = atoi(token);
			}
			else{
				m_iAdminLevelUnsummonBoss = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 38:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelClearNpc = atoi(token);
			}
			else{
				m_iAdminLevelClearNpc = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------				
		  case 39:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelTime = atoi(token);
			}
			else{
				m_iAdminLevelTime = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 40:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelPushPlayer = atoi(token);
			}
			else{
				m_iAdminLevelPushPlayer = 2;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 41:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummonGuild = atoi(token);
			}
			else{
				m_iAdminLevelSummonGuild = 3;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 42:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCheckStatus = atoi(token);
			}
			else{
				m_iAdminLevelCheckStatus = 1;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 43:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCleanMap = atoi(token);
			}
			else{
				m_iAdminLevelCleanMap = 1;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
			}
		  }
		  else {
			if (memcmp(token, "Admin-Level-/kill", 17) == 0)						cReadMode = 1;
			if (memcmp(token, "Admin-Level-/revive", 19) == 0)						cReadMode = 2;
			if (memcmp(token, "Admin-Level-/closecon", 21) == 0)					cReadMode = 3;
			if (memcmp(token, "Admin-Level-/checkrep", 21) == 0)					cReadMode = 4;
			if (memcmp(token, "Admin-Level-/who", 16) == 0)							cReadMode = 5;
			if (memcmp(token, "Admin-Level-/energysphere", 25) == 0)				cReadMode = 6;
			if (memcmp(token, "Admin-Level-/shutdownthisserverrightnow", 39) == 0)	cReadMode = 7;
			if (memcmp(token, "Admin-Level-/setobservermode", 28) == 0)				cReadMode = 8;
			if (memcmp(token, "Admin-Level-/shutup", 19) == 0)						cReadMode = 9;
			if (memcmp(token, "Admin-Level-/attack", 19) == 0)						cReadMode = 10;
			if (memcmp(token, "Admin-Level-/summondemon", 24) == 0)					cReadMode = 11;
			if (memcmp(token, "Admin-Level-/summondeath", 24) == 0)					cReadMode = 12;
			if (memcmp(token, "Admin-Level-/reservefightzone", 28) == 0)			cReadMode = 13;
			if (memcmp(token, "Admin-Level-/createfish", 23) == 0)					cReadMode = 14;
			if (memcmp(token, "Admin-Level-/teleport", 21) == 0)					cReadMode = 15;
			if (memcmp(token, "Admin-Level-/checkip", 20) == 0)						cReadMode = 16;
			if (memcmp(token, "Admin-Level-/polymorph", 22) == 0)					cReadMode = 17;
			if (memcmp(token, "Admin-Level-/setinvi", 20) == 0)						cReadMode = 18;
			if (memcmp(token, "Admin-Level-/setzerk", 20) == 0)						cReadMode = 19;
			if (memcmp(token, "Admin-Level-/setfreeze", 22) == 0)					cReadMode = 20;
			if (memcmp(token, "Admin-Level-/gns", 16) == 0)							cReadMode = 21;
			if (memcmp(token, "Admin-Level-/setattackmode", 26) == 0)				cReadMode = 22;
			if (memcmp(token, "Admin-Level-/unsummonall", 24) == 0)					cReadMode = 23;
			if (memcmp(token, "Admin-Level-/unsummondemon", 26) == 0)				cReadMode = 24;
			if (memcmp(token, "Admin-Level-/summonnpc", 22) == 0)					cReadMode = 25;
			if (memcmp(token, "Admin-Level-/summonall", 22) == 0)					cReadMode = 26;
			if (memcmp(token, "Admin-Level-/summonplayer", 25) == 0)				cReadMode = 27;
			if (memcmp(token, "Admin-Level-/disconnectall", 26) == 0)				cReadMode = 28;
			if (memcmp(token, "Admin-Level-/enableadmincreateitem", 34) == 0)		cReadMode = 29;
			if (memcmp(token, "Admin-Level-/createitem", 23) == 0)					cReadMode = 30;
			if (memcmp(token, "Admin-Level-/storm", 18) == 0)						cReadMode = 31;
			if (memcmp(token, "Admin-Level-/weather", 20) == 0)						cReadMode = 32;
			if (memcmp(token, "Admin-Level-/setstatus", 22) == 0)					cReadMode = 33;
			if (memcmp(token, "Admin-Level-/goto", 17) == 0)						cReadMode = 34;
			if (memcmp(token, "Admin-Level-/monstercount", 17) == 0)				cReadMode = 35;
			if (memcmp(token, "Admin-Level-/setforcerecalltime", 23) == 0)			cReadMode = 36;
			if (memcmp(token, "Admin-Level-/unsummonboss", 25) == 0)				cReadMode = 37;
			if (memcmp(token, "Admin-Level-/clearnpc", 21) == 0)					cReadMode = 38;
			if (memcmp(token, "Admin-Level-/time", 17) == 0)						cReadMode = 39;
			if (memcmp(token, "Admin-Level-/send", 17) == 0)						cReadMode = 40;
			if (memcmp(token, "Admin-Level-/summonguild", 24) == 0)					cReadMode = 41;
			if (memcmp(token, "Admin-Level-/checkstatus", 24) == 0)					cReadMode = 42;	
			if (memcmp(token, "Admin-Level-/clearmap", 21) == 0)					cReadMode = 43;	
		  }

		  token = pStrTok->pGet();
		 }
		 delete pStrTok;
		 delete cp;
		}
		if (pFile != NULL) fclose(pFile);

		return TRUE;
}

void CGame::AdminOrder_CheckRep(int iClientH, char *pData,DWORD dwMsgSize)
{
 class  CStrTok * pStrTok;
 short m_iRating;
 char   * token, cName[11], cTargetName[11], cRepMessage[256], cTemp[256], seps[] = "= \t\n", cBuff[256];
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cRepMessage, sizeof(cRepMessage));
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		wsprintf(cRepMessage, " You have %d reputation points.", m_pClientList[iClientH]->m_iRating);
		ShowClientMsg(iClientH, cRepMessage);
	} 
	else {
		if ((dwMsgSize)	<= 0) return;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();

		token = pStrTok->pGet();
		
		if (token != NULL) {
			ZeroMemory(cName, sizeof(cName));
			strcpy(cName, token);
		} 
		else {
			ZeroMemory(cName, sizeof(cName));
			strcpy(cName, "null");
		}

		token = pStrTok->pGet();
		
		if (token != NULL) {
			m_iRating = atoi(token);
		} 
		
		if (token == NULL) { 
			token = "null"; 
		}
		
			if (cName != NULL) {
			token = cName;

				if (strlen(token) > 10) 
  					memcpy(cTargetName, token, 10);
				else memcpy(cTargetName, token, strlen(token));

				for (i = 1; i < DEF_MAXCLIENTS; i++) 
  					if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
						wsprintf(cRepMessage, " %s has %d reputation points.", m_pClientList[i]->m_cCharName, m_pClientList[i]->m_iRating);
						ShowClientMsg(iClientH, cRepMessage);
					}
			}
	}
}

void CGame::AdminOrder_Pushplayer(int iClientH, char * pData, DWORD dwMsgSize)
{
//Push Player- By:ACiDx  Monday , September 2004
	//Teleports a Defined Player to Defined Destination
	// /push playername mapname sX dX
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cMapName[256], cName[11], cTargetName[11];
 class  CStrTok * pStrTok;
 int dX, dY;
  int i;
 BOOL   bFlag;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));

	dX = dY = -1;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelPushPlayer) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dY = atoi(token);
	}

	if (token == NULL) { token = "null"; }
	if (cName != NULL) {
		token = cName;

	if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			bFlag = FALSE;
			//Asks For Flag on maps
			if (strcmp("2ndmiddle", cMapName) == 0) bFlag = TRUE;
			if (strcmp("abaddon", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("arebrk11", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arebrk12", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arebrk21", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arebrk22", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arefarm", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arejail", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aremidl", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aremidr", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aresden", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aresdend1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("areuni", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arewrhus", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bisle", cMapName) == 0)   bFlag = TRUE;
			if (strcmp("bsmith_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bsmith_1f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bsmith_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bsmith_2f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("BtField", cMapName) == 0) bFlag = TRUE;
			if (strcmp("cath_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("cath_2", cMapName) == 0)      bFlag = TRUE;
			if (strcmp("cityhall_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("cityhall_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("CmdHall_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("CmdHall_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("default", cMapName) == 0) bFlag = TRUE;
			if (strcmp("dglv2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("dglv3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("dglv4", cMapName) == 0) bFlag = TRUE;
			if (strcmp("druncncity", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("elvbrk11", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvbrk12", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvbrk21", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvbrk22", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvfarm", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvine", cMapName) == 0)  bFlag = TRUE;
			if (strcmp("elvined1", cMapName) == 0)    bFlag = TRUE;
			if (strcmp("elvjail", cMapName) == 0)    bFlag = TRUE;
			if (strcmp("elvmidl", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvmidr", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvuni", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvwrhus", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gldhall_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gldhall_2", cMapName) == 0)   bFlag = TRUE;
			if (strcmp("GodH", cMapName) == 0)   bFlag = TRUE;
			if (strcmp("gshop_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gshop_1f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gshop_2", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("gshop_2f", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("HRampart", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("huntzone1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("huntzone2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("huntzone3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("huntzone4", cMapName) == 0) bFlag = TRUE;
			if (strcmp("icebound", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("inferniaA", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("inferniaB", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("maze", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("middled1n", cMapName) == 0) bFlag = TRUE;
			if (strcmp("middled1x", cMapName) == 0) bFlag = TRUE;
			if (strcmp("middleland", cMapName) == 0) bFlag = TRUE;
			if (strcmp("penalty", cMapName) == 0) bFlag = TRUE;
			if (strcmp("procella", cMapName) == 0) bFlag = TRUE;
			if (strcmp("resurr1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("resurr2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("toh1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("toh2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("toh3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wrhus_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wrhus_1f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wrhus_2", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("wrhus_2f", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wzdtwr_2", cMapName) == 0) bFlag = TRUE;

			//Defines I as Max clients
				if (bFlag == TRUE)
					//Reqeust the Push/Teleport
					RequestTeleportHandler(i, "2   ", cMapName, dX, dY);
   					wsprintf(G_cTxt,"(%s) GM(%s) sends (%s) Player(%s) to [%s](%d,%d)",m_pClientList[iClientH]->m_cIPaddress, 
						m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName, cMapName, dX, dY);
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
				delete pStrTok;
				return;
			}
}
}

void CGame::SendCollectedMana()
{
 char * cp, cData[120];
 WORD * wp;

	//      .       .
	if ((m_iCollectedMana[1] == 0) && (m_iCollectedMana[2] == 0)) return;

	//testcode
	wsprintf(G_cTxt, "Sending Collected Mana: %d %d", m_iCollectedMana[1], m_iCollectedMana[2]);
	PutLogList(G_cTxt);

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp = GSM_COLLECTEDMANA;
	cp++;

	wp = (WORD *)cp;
	*wp = (WORD)m_iCollectedMana[1];
	cp += 2;

	wp = (WORD *)cp;
	*wp = (WORD)m_iCollectedMana[2];
	cp += 2;

	CollectedManaHandler(m_iCollectedMana[1], m_iCollectedMana[2]);

	bStockMsgToGateServer(cData, 5);
	
	//     .
	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;
}

void CGame::CollectedManaHandler(WORD wAresdenMana, WORD wElvineMana)
{
	if (m_iAresdenMapIndex != -1) {
		m_iAresdenMana += wAresdenMana;
		//testcode
		if (wAresdenMana > 0) {
			wsprintf(G_cTxt, "Aresden Mana: %d Total:%d", wAresdenMana, m_iAresdenMana);
			PutLogList(G_cTxt);
		}
	}

	if (m_iElvineMapIndex != -1) {
		m_iElvineMana += wElvineMana;
		//testcode
		if (wElvineMana > 0) {
			wsprintf(G_cTxt, "Elvine Mana: %d Total:%d", wElvineMana, m_iElvineMana);
			PutLogList(G_cTxt);
		}
	}
}

void CGame::_LinkStrikePointMapIndex()
{
 int i, z, x;

	//         !
	for (i = 0; i < DEF_MAXMAPS; i++)
	if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_iTotalStrikePoints != 0)) {
		//    .        .
		for (z = 0; z < DEF_MAXSTRIKEPOINTS; z++) 
		if (strlen(m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) != 0) {
			for (x = 0; x < DEF_MAXMAPS; x++) 
			if ((m_pMapList[x] != NULL) && (strcmp(m_pMapList[x]->m_cName,m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) == 0)) {
				//  . .
				m_pMapList[i]->m_stStrikePoint[z].iMapIndex = x;
				//testcode
				wsprintf(G_cTxt, "(!) Map(%s) Strike Point(%d) Related Map(%s) Index(%d)", m_pMapList[i]->m_cName, z, m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName, x);
				PutLogList(G_cTxt);

				goto LSPMI_LOOPBREAK;
			}
LSPMI_LOOPBREAK:;
		}
	}
}

//New Changed 11/05/2004
void CGame::GrandMagicResultHandler(char *cMapName, int iCrashedStructureNum, int iStructureDamageAmount, int iCasualities, int iActiveStructure, int iTotalStrikePoints, char * cData)
{
 int i;
	
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) {
		SendNotifyMsg(NULL, i, DEF_NOTIFY_GRANDMAGICRESULT, iCrashedStructureNum, iStructureDamageAmount, iCasualities, cMapName, iActiveStructure, NULL, NULL, NULL, NULL, iTotalStrikePoints, cData);
	}
}

// v2.16 2002-5-21  
BOOL CGame::bCheckIsItemUpgradeSuccess(int iClientH, int iItemIndex, int iSomH, BOOL bBonus)
{
 int iValue, iProb, iResult;

	if (m_pClientList[iClientH]->m_pItemList[iSomH] == NULL) return FALSE;
	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x0F0000000) >> 28;

	switch (iValue) {
	case 0: iProb = 30; break;  // +1 :90%     +1~+2
	case 1: iProb = 25; break;  // +2 :80%      +3
	case 2: iProb = 20; break;  // +3 :48%      +4 
	case 3: iProb = 15; break;  // +4 :24%      +5
	case 4: iProb = 10; break;  // +5 :9.6%     +6
	case 5: iProb = 10; break;  // +6 :2.8%     +7
	case 6: iProb =  8; break;  // +7 :0.57%    +8
	case 7: iProb =  8; break;  // +8 :0.05%    +9
	case 8: iProb =  5; break;  // +9 :0.004%   +10
	case 9: iProb =  3; break;  // +10:0.00016%
	default: iProb = 1; break;
	}

	if (((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 > 100)) {	
		if (iProb > 20) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 10);
		else if (iProb > 7) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 20);
		else
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 40);
	}
	if ( bBonus == TRUE) iProb *=2 ;

	iProb *= 100;
	iResult = iDice(1,10000);

	if (iProb >= iResult) { 
		_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
		return TRUE;
	}

	_bItemLog(DEF_ITEMLOG_UPGRADEFAIL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

	return FALSE;
}

BOOL CGame::bReadAdminListConfigFile(char *pFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int   iIndex;
 char len;

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(pFn, "rt");
	if (pFile == NULL) {
		//      .
		PutLogList("(!) Cannot open AdminList.cfg file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading AdminList.cfg...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
						if (iIndex >= DEF_MAXADMINS) {
							PutLogList("(!) WARNING! Too many GMs on the AdminList.cfg!"); 
							return TRUE;
						}
						len = strlen(token);
						if(len > 10) len = 10;
						ZeroMemory(m_stAdminList[iIndex].m_cGMName, sizeof(m_stAdminList[iIndex].m_cGMName));
						memcpy(m_stAdminList[iIndex].m_cGMName, token, strlen(token));
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
				}
			}
			else {
				if (memcmp(token, "verified-admin", 14) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

BOOL CGame::bReadBannedListConfigFile(char *pFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int   iIndex;
 char len;

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(pFn, "rt");
	if (pFile == NULL) {
		//      .
		PutLogList("(!) Cannot open BannedList.cfg file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading BannedList.cfg...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
						if (iIndex >= DEF_MAXBANNED) {
							PutLogList("(!) WARNING! Too many banned on the BannedList.cfg!"); 
							return TRUE;
						}
						len = strlen(token);
						if(len > 20) len = 20;
						ZeroMemory(m_stBannedList[iIndex].m_cBannedIPaddress, sizeof(m_stBannedList[iIndex].m_cBannedIPaddress));
						memcpy(m_stBannedList[iIndex].m_cBannedIPaddress, token, strlen(token));
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
				}
			}
			else {
				if (memcmp(token, "banned-ip", 9) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

void CGame::AdminOrder_CleanMap(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	class  CStrTok * pStrTok;
	char   * token, cMapName[11], cBuff[256];
	BOOL bFlag = FALSE;	//Used to check if we are on the map we wanna clear
	int i;
	CItem *pItem;
	short sRemainItemSprite, sRemainItemSpriteFrame, dX, dY;
	char cRemainItemColor, len;


	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCleanMap) {
		// Admin user level      .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);

		for (i = 0; i < DEF_MAXMAPS; i++)	//Enum all maps
			if (m_pMapList[i] != NULL) {	//Is allocated map
				if (memcmp(m_pMapList[i]->m_cName, cMapName, 10) == 0) {	//is map same name
					bFlag = TRUE; //Set flag
					//Get X and Y coords
					int m_x = m_pMapList[i]->m_sSizeX;
					int m_y = m_pMapList[i]->m_sSizeY;
					for(int j = 1; j < m_x; j++)
						for(int k = 1; k < m_y; k++){
							do {	//Delete all items on current tile
								pItem = m_pMapList[i]->pGetItem(j, k, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor); // v1.4
								if (pItem != NULL) {
									delete pItem;	//Delete item;
								}
							} while(pItem != NULL);
						}
					break;	//Break outo f loop
				}
			}

		if (!bFlag) {	//Notify GM he has to be on the map he clears
		}
		else{	//Notify GM that all items have been cleared
			for(int i = 1; i < DEF_MAXCLIENTS; i++){
				if (m_pClientList[i] != NULL) {
				len = strlen(cMapName);
				if(len > 10) len = 10;
				if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cMapName, len) != 0) return;
				dX = m_pClientList[i]->m_sX;
				dY = m_pClientList[i]->m_sY;
				ZeroMemory(cMapName,sizeof(cMapName));
				strcpy(cMapName, m_pClientList[i]->m_cMapName);
				RequestTeleportHandler(i,"2   ", cMapName, dX, dY);
				}
			}
		}
	}

	delete pStrTok;
	return;
}

void CGame::ShowClientMsg(int iClientH, char* pMsg)
{
	char * cp, cTemp[256];
	DWORD * dwp, dwMsgSize;
	WORD * wp;
	short * sp;

	ZeroMemory(cTemp, sizeof(cTemp));

	dwp = (DWORD *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;

	wp  = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	memcpy(cp, "Server", 8); // Player name :P
	cp += 10;

	*cp = 10; // chat type
	cp++;

	dwMsgSize = strlen(pMsg);
	if(dwMsgSize > 50) dwMsgSize = 50;
	memcpy(cp, pMsg, dwMsgSize);
	cp += dwMsgSize;

	m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
}

void CGame::GlobalUpdateConfigs(char cConfigType)
{
 char * cp, cData[120];

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_UPDATECONFIGS;
	cp++;

	*cp = (char)cConfigType;
	cp++;			

	LocalUpdateConfigs(cConfigType);

	bStockMsgToGateServer(cData, 5);
}

void CGame::LocalUpdateConfigs(char cConfigType)
{
	if (cConfigType == 1) {
		bReadSettingsConfigFile("..\\GameConfigs\\Settings.cfg");
		PutLogList("(!!!) Settings.cfg updated successfully!");
	}
	if (cConfigType == 2) {
		bReadAdminListConfigFile("..\\GameConfigs\\AdminList.cfg");
		PutLogList("(!!!) AdminList.cfg updated successfully!");
	}
	if (cConfigType == 3) {
		bReadBannedListConfigFile("..\\GameConfigs\\BannedList.cfg");
		PutLogList("(!!!) BannedList.cfg updated successfully!");
	}
	if (cConfigType == 4) {
		bReadAdminSetConfigFile("..\\GameConfigs\\AdminSettings.cfg");
		PutLogList("(!!!) AdminSettings.cfg updated successfully!");
	}
}



//**************************************************************************************
// HBx server introduced only the skeletton off Apocalypse functions, and sometime not so good!
// I rewrote them, maybe not following the "official" pattern but it works!
// I also needed to add many new functions.
//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         bReadApocalypseGUIDFile(DWORD dwApocalypseGUID) 
//         Reads the GUID file when server starts
// DynamicGateType = 1: Opens Gate when Apoc begins, for 15 min
// DynamicGateType = 2: Open the gate when map is empty
// DynamicGateType = 3: Gate stays closed will change to 4 value to open it, along with a boss spawn.
// DynamicGateType = 4: Gate is openned. (set by server when Abaddon is spawning)
// DynamicGateType = 5: Gate is used by GM command    
// m_iApocalypseMobGenType = 1: Gate will open as soon as the map is empty
// m_iApocalypseMobGenType = 2: A big mob will spawn when map is empty, gate will open depend if Type 2 or 3.
//**************************************************************************************
BOOL CGame::bReadApocalypseGUIDFile(char * cFn)
{FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
	cReadMode = 0;
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFn, "rt");
	if (pFile == NULL) 
	{	PutLogList("(!) Cannot open ApocalypseGUID file.");
		return FALSE;
	}else 
	{	PutLogList("(!) Reading ApocalypseGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL )   
		{	if (cReadMode != 0) 
			{	switch (cReadMode) {
				case 1:
					m_dwApocalypseGUID = _atoi64(token);
					cReadMode = 0;
					break;
				}
			}else 
			{	if (memcmp(token, "Apocalypse GUID", 14) == 0) cReadMode = 1;
			}			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);
	wsprintf(G_cTxt, "(!) Read ApocalypseGUID (%d) file.", m_dwApocalypseGUID);
	PutLogList(G_cTxt);
	return TRUE;
}

/*********************************************************************************************************************
**  BOOL CGame::bReadHeldenianGUIDFile(char * cFn)																	**
**  description		:: Read thee GUID file for each server						                        			**
**             		:: Used when server starts																		**
**																													**
*********************************************************************************************************************/
BOOL CGame::bReadHeldenianGUIDFile(char * cFn)
{FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
	cReadMode = 0;
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFn, "rt");
	if (pFile == NULL) 
	{	PutLogList("(!) Cannot open HeldenianGUID file.");
		return FALSE;
	}else 
	{	PutLogList("(!) Reading HeldenianGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL )   			
		{	if (cReadMode != 0) 
			{	switch (cReadMode) {
				case 1:
					m_dwHeldenianGUID = _atoi64(token);
					cReadMode = 0;
					break;
				case 2:
					m_sLastHeldenianWinner = atoi(token);
					cReadMode = 0;
					break;
				}
			}else 
			{	if (memcmp(token, "HeldenianGUID", 13) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);
	switch (m_sLastHeldenianWinner) {
	case 1:	wsprintf(G_cTxt, "(!) Read HeldenianGUID (%d) file: Aresden owns BtField (%d).", m_dwHeldenianGUID, m_sLastHeldenianWinner);
		break;
	case 2: wsprintf(G_cTxt, "(!) Read HeldenianGUID (%d) file: Elvine owns BtField (%d).", m_dwHeldenianGUID, m_sLastHeldenianWinner);
		break;		
	default:wsprintf(G_cTxt, "(!) Read HeldenianGUID (%d) file: Nobody owns BtField (%d).", m_dwHeldenianGUID, m_sLastHeldenianWinner);
		break;
	}
	PutLogList(G_cTxt);
	return TRUE;
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         _CreateApocalypseGUID(DWORD dwApocalypseGUID) 
//         Create the GUID file if it doesn't exist at Apoc beginning
//         or at the Apocalypse end.
//**************************************************************************************
void CGame::_CreateApocalypseGUID(DWORD dwApocalypseGUID)
{char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"ApocalypseGUID.Txt");		
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) 
	{ 	wsprintf(cTxt, "(!) Cannot create Apocalypse GUID (%d) file", dwApocalypseGUID);
		PutLogList(cTxt);
	}else 
	{	ZeroMemory(cTemp, sizeof(cTemp));		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "ApocalypseGUID = %d\n", dwApocalypseGUID);
		strcat(cTemp, cTxt);		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);		
		wsprintf(cTxt, "(!) Apocalypse GUID (%d) file created", dwApocalypseGUID);
		PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}

// New 06/05/2004
// Party Code
void CGame::RequestCreatePartyHandler(int iClientH)
{
	char *cp, cData[120];
	DWORD * dwp;
	WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) {
		//        .
		return;
	}

	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;

	// Gate Server   PartyID   . 
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;

	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 1; // 1, request
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;

	PutLogList("RequestCreatePartyHandler send 1 to GateServer");
	SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);

	//testcode
	wsprintf(G_cTxt, "Request Create Party: %d", iClientH);
	PutLogList(G_cTxt);
}

// Last Updated October 28, 2004 - 3.51 translation
void CGame::PartyOperationResultHandler(char *pData)
{
 char * cp, cResult, cName[12];
 WORD * wp;
 int i, iClientH, iPartyID, iTotal;

	cp = (char *)(pData + 4);
	wp = (WORD *)cp;
	cp += 2;

	switch (*wp) {
	case 1:
		cResult = *cp;
		cp++;

		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;

		PartyOperationResult_Create(iClientH, cName, cResult, iPartyID);

		wsprintf(G_cTxt, "party Operation Result: Create(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;

	case 2:
		wp = (WORD *)cp;
		iPartyID = *wp;
		cp += 2;

		PartyOperationResult_Delete(iPartyID);

		wsprintf(G_cTxt, "party Operation Result: Delete(PartyID:%d)", iPartyID);
		PutLogList(G_cTxt);
		break;

	case 3:
		wp = (WORD *)cp;
		iClientH = *wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		if ((iClientH < 0) && (iClientH > DEF_MAXCLIENTS)) return;
		if (m_pClientList[iClientH] == NULL) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, cName) != 0) return;

		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;

				wsprintf(G_cTxt, "PartyID:%d member:%d Out(Clear) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORH_LOOPBREAK1;
			}
PORH_LOOPBREAK1:;

				for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
				if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] != 0)) {
					m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i]   = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1];
					m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] = 0;
				}

				m_pClientList[iClientH]->m_iPartyID = NULL;
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;

				wsprintf(G_cTxt, "Party Status NULL: %s", m_pClientList[iClientH]->m_cCharName);
				PutLogList(G_cTxt);

				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 8, 0, NULL, NULL);
				break;

	case 4:
		cResult = *cp;
		cp++;

		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;

		PartyOperationResult_Join(iClientH, cName, cResult, iPartyID);

		wsprintf(G_cTxt, "party Operation Result: Join(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;

	case 5:
		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (WORD *)cp;
		iTotal = (int)*wp;
		cp += 2;

		PartyOperationResult_Info(iClientH, cName, iTotal, cp);

		wsprintf(G_cTxt, "party Operation Result: Info(ClientH:%d Total:%d)", iClientH, iTotal);
		PutLogList(G_cTxt);
		break;

	case 6:
		cResult = *cp;
		cp++;

		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;

		PartyOperationResult_Dismiss(iClientH, cName, cResult, iPartyID);

		wsprintf(G_cTxt, "party Operation Result: Dismiss(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;
	}
}


void CGame::PartyOperationResult_Create(int iClientH, char *pName, int iResult, int iPartyID)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD * wp;
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

	switch (iResult) {
	case 0: //    
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = NULL;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 1, 0, NULL, NULL);
		break;

	case 1: //    
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 1, 1, NULL, NULL);

		//     .
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
				//testcode
				wsprintf(G_cTxt, "PartyID:%d member:%d New Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORC_LOOPBREAK1;
			}
PORC_LOOPBREAK1:;

			if ((m_pClientList[iClientH]->m_iReqJoinPartyClientH != NULL) && (strlen(m_pClientList[iClientH]->m_cReqJoinPartyName) != NULL)) {
				ZeroMemory(cData, sizeof(cData));

				cp = (char *)cData;

				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;

				wp = (WORD*)cp;
				*wp = 3;
				cp += 2;

				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
				cp += 10;

				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;

				PutLogList("PartyOperationResult_Create send 3 to GateServer");
				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
				ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
			}
			break;
	}
}

// Last Updated October 28, 2004 - 3.51 translation
void CGame::PartyOperationResult_Join(int iClientH, char *pName, int iResult, int iPartyID)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;

	switch (iResult) {
	case 0:
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = NULL;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 4, 0, NULL, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1:
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 4, 1, NULL, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));

		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;

				wsprintf(G_cTxt, "PartyID:%d member:%d In(Join) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORC_LOOPBREAK1;
			}
PORC_LOOPBREAK1:;

			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((i != iClientH) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 4, 1, NULL, pName);
				}
				break;
	}
}

void CGame::PartyOperationResult_Dismiss(int iClientH, char *pName, int iResult, int iPartyID)
{
	int i;
	// iClientH     .

	switch (iResult) {
	case 0: //    ?  ?
		break;

	case 1: //    
		if (iClientH == NULL) {
			// iClientH  NULL        .
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
					iClientH = i;
					goto PORD_LOOPBREAK;
				}
PORD_LOOPBREAK:;

				//     .
				for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
					if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
						m_stPartyInfo[iPartyID].iIndex[i] = 0;
						m_stPartyInfo[iPartyID].iTotalMembers--;
						//testcode
						wsprintf(G_cTxt, "PartyID:%d member:%d Out Total:%d", iPartyID, iClientH, m_stPartyInfo[iPartyID].iTotalMembers);
						PutLogList(G_cTxt);
						goto PORC_LOOPBREAK1;
					}
PORC_LOOPBREAK1:;
					//    .
					for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
						if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i+1] != 0)) {
							m_stPartyInfo[iPartyID].iIndex[i]   = m_stPartyInfo[iPartyID].iIndex[i+1];
							m_stPartyInfo[iPartyID].iIndex[i+1] = 0;
						}

						if (m_pClientList[iClientH] != NULL) {
							m_pClientList[iClientH]->m_iPartyID = NULL;
							m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
							m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
						}

						//   .
						for (i = 1; i < DEF_MAXCLIENTS; i++)
							if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
								SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 6, 1, NULL, pName);
							}
							return;
		}

		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING)) return;
		if ((m_pClientList[iClientH] != NULL) && (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0)) return;

		//   .
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 6, 1, NULL, pName);
			}

			//     .
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
				if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
					m_stPartyInfo[iPartyID].iIndex[i] = 0;
					m_stPartyInfo[iPartyID].iTotalMembers--;
					//testcode
					wsprintf(G_cTxt, "PartyID:%d member:%d Out Total:%d", iPartyID, iClientH, m_stPartyInfo[iPartyID].iTotalMembers);
					PutLogList(G_cTxt);
					goto PORC_LOOPBREAK2;
				}
PORC_LOOPBREAK2:;
				//    .
				for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
					if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i+1] != 0)) {
						m_stPartyInfo[iPartyID].iIndex[i]   = m_stPartyInfo[iPartyID].iIndex[i+1];
						m_stPartyInfo[iPartyID].iIndex[i+1] = 0;
					}

					if (m_pClientList[iClientH] != NULL) {
						m_pClientList[iClientH]->m_iPartyID = NULL;
						m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
						m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
					}
					break;
	}
}

void CGame::PartyOperationResult_Delete(int iPartyID)
{
	int i;

	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
	{
		m_stPartyInfo[iPartyID].iIndex[i] = 0;
		m_stPartyInfo[iPartyID].iTotalMembers = 0;
	}

	//   
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 2, 0, NULL, NULL);
			m_pClientList[i]->m_iPartyID = NULL;
			m_pClientList[i]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[i]->m_iReqJoinPartyClientH = NULL;
			//testcode
			wsprintf(G_cTxt, "Notify delete party: %d", i);
			PutLogList(G_cTxt);
		}
}



void CGame::RequestJoinPartyHandler(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * cp, * token, cBuff[256], cData[120], cName[12];
	class  CStrTok * pStrTok;
	DWORD * dwp;
	WORD  * wp;
	int i;

	//     .
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	}
	else return;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
			//      .
			if ((m_pClientList[i]->m_iPartyID == NULL) || (m_pClientList[i]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM)) {
				//       .
				return;
			}

			ZeroMemory(cData, sizeof(cData));
			
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 3; //    
			cp += 2;
			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[i]->m_iPartyID;
			cp += 2;
			PutLogList("RequestJoinPartyHandler send 3 to GateServer");
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			return;
		}

		//        .
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
}



void CGame::RequestDismissPartyHandler(int iClientH)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 4; //   
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	PutLogList("RequestDismissPartyHandler send 4 to GateServer");
	SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);

	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
}


void CGame::GetPartyInfoHandler(int iClientH)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 5; //   
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	PutLogList("GetPartyInfoHandler send 5 to GateServer");
	SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
}


void CGame::PartyOperationResult_Info(int iClientH, char * pName, int iTotal, char *pNameList)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 5, 1, iTotal, pNameList);
}

void CGame::RequestDeletePartyHandler(int iClientH)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyID != NULL) {
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		dwp = (DWORD *)cp;
		*dwp = MSGID_PARTYOPERATION;
		cp += 4;
		wp = (WORD*)cp;
		*wp = 4; //   
		cp += 2;
		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_iPartyID;
		cp += 2;
		PutLogList("RequestDeletePartyHandler send 4 to GateServer");
		SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		//  
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
	}
}

void CGame::RequestAcceptJoinPartyHandler(int iClientH, int iResult)
{
	char *cp, cData[120];
	DWORD * dwp;
	WORD * wp;
	int iH;

	if (m_pClientList[iClientH] == NULL) return;

	switch (iResult) {
	case 0: //     .
		iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
		if (m_pClientList[iH] == NULL) {
			//     .
			return;
		}
		if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
			//     .
			return;
		}
		if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
			//     .
			return;
		}
		if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
			//      .
			return;
		}

		SendNotifyMsg(NULL, iH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
		//testcode
		wsprintf(G_cTxt, "Party join reject(3) ClientH:%d ID:%d", iH, m_pClientList[iH]->m_iPartyID);
		PutLogList(G_cTxt);

		m_pClientList[iH]->m_iPartyID = NULL;
		m_pClientList[iH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1: //    
		if ((m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) && (m_pClientList[iClientH]->m_iPartyID != NULL)) {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == NULL) {
				//     .
				return;
			}
			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				//     .
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				//     .
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				//      .
				return;
			}

			//   .
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 3; //    
			cp += 2;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			PutLogList("RequestAcceptJoinPartyHandler send 3 to GateServer");
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		}
		else {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == NULL) {
				//     .
				return;
			}
			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				//     .
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				//     .
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				//      .
				return;
			}

			if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_NULL) {
				//        .     .
				RequestCreatePartyHandler(iClientH);
			}
			else {
				//  
			}
		}
		break;

	case 2: //    
		//          .
		if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) {
			//   .
			RequestDismissPartyHandler(iClientH);
		}
		else {
			//      .
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;

			//      NULL  .
			if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iReqJoinPartyClientH == iClientH) && 
				(strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) == 0)) {
					//       .
					m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
					ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));
				}

				m_pClientList[iClientH]->m_iPartyID = NULL;
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
				ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		}
		break;
	}
}



void CGame::TimeHitPointsUp(int iClientH)
{
 int iMaxHP, iTemp, iTotal;
 double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;

	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;
	
	iMaxHP = iGetMaxHP(iClientH);

	if (m_pClientList[iClientH]->m_iHP < iMaxHP) {
		
		iTemp = iDice(1, (m_pClientList[iClientH]->m_iVit));

		if (iTemp < (m_pClientList[iClientH]->m_iVit/2)) iTemp = (m_pClientList[iClientH]->m_iVit/2);

		if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)

			iTemp -= (iTemp / m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

		iTotal = iTemp + m_pClientList[iClientH]->m_iHPstock;

		if (m_pClientList[iClientH]->m_iAddHP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddHP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iHP += iTotal;

		if (m_pClientList[iClientH]->m_iHP > iMaxHP) m_pClientList[iClientH]->m_iHP = iMaxHP;

		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
	}

	m_pClientList[iClientH]->m_iHPstock = 0;
}

char CGame::_cCheckHeroItemEquipped(int iClientH)
{
	short sHeroLeggings, sHeroHauberk, sHeroArmor, sHeroHelm;

	if (m_pClientList[iClientH] == NULL) return 0;

	sHeroHelm = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
	sHeroArmor = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	sHeroHauberk = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
	sHeroLeggings = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];

	if ((sHeroHelm < 0) || (sHeroLeggings < 0) || (sHeroArmor < 0) || (sHeroHauberk < 0)) return 0; 

	if(m_pClientList[iClientH]->m_pItemList[sHeroHelm] == NULL) return 0;
	if(m_pClientList[iClientH]->m_pItemList[sHeroLeggings] == NULL) return 0;
	if(m_pClientList[iClientH]->m_pItemList[sHeroArmor] == NULL) return 0;
	if(m_pClientList[iClientH]->m_pItemList[sHeroHauberk] == NULL) return 0;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 403) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 411) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 419) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 423)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 407) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 415) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 419) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 423)) return 2;
	
	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 404) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 412) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 420) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 424)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 408) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 416) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 420) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 424)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 405) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 413) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 421) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 425)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 409) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 417) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 421) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 425)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 406) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 414) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 422) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 426)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 410) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 418) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 422) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 426)) return 2;

	return 0;
}

BOOL CGame::bPlantSeedBag(int iMapIndex, int dX, int dY, int iItemEffectValue1, int iItemEffectValue2, int iClientH)
{
 int iNamingValue, tX, tY;
 short sOwnerH;
 char cOwnerType, cNpcName[21], cName[21], cNpcWaypointIndex[11];
 BOOL bRet;

	if(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture >= 200){
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMOREAGRICULTURE, NULL, NULL, NULL, NULL);
		return FALSE;
	}

	if (iItemEffectValue2 > m_pClientList[iClientH]->m_cSkillMastery[2]) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AGRICULTURESKILLLIMIT, NULL, NULL, NULL, NULL);
		return FALSE;
	}

	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();

	if (iNamingValue == -1) {
	}
	else{
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
	if (sOwnerH != NULL && sOwnerH == DEF_OWNERTYPE_NPC && m_pNpcList[sOwnerH]->m_cActionLimit == 5) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
		return FALSE;
	}
	else{
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsFarm(dX, dY) == FALSE) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
		return FALSE;
	}
	
	ZeroMemory(cNpcName, sizeof(cNpcName));
	strcpy(cNpcName, "Crops");
	ZeroMemory(cName, sizeof(cName));
	wsprintf(cName, "XX%d", iNamingValue);
	cName[0] = '_';
	cName[1] = iMapIndex+65;

	ZeroMemory(cNpcWaypointIndex,sizeof(cNpcWaypointIndex));
	tX = dX;
	tY = dY;

	bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypointIndex, NULL, NULL, 0, FALSE, TRUE);
	if (bRet == FALSE) {
			m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
		} 
		else{
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
			if (m_pNpcList[sOwnerH] == NULL) return 0;
				m_pNpcList[sOwnerH]->m_cCropType = iItemEffectValue1;
					switch (iItemEffectValue1) {
					case 1: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 2: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 3: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 4: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 5: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 6: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 7: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 8: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 9: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 10: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 11: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 12: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 13: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					default: m_pNpcList[sOwnerH]->m_cCropSkill = 100; break;				
				}
				m_pNpcList[sOwnerH]->m_sAppr2 = 1;
				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
				wsprintf(G_cTxt, "(skill:%d type:%d)plant(%s) Agriculture begin(%d,%d) sum(%d)!", m_pNpcList[sOwnerH]->m_cCropSkill, m_pNpcList[sOwnerH]->m_cCropType, cNpcName, tX, tY, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture);
				PutLogList(G_cTxt);
				return TRUE;
			}
		}
	}
	return FALSE;
}



void CGame::_CheckFarmingAction(short sAttackerH, short sTargetH, BOOL bType)
{
 char cCropType;
 int iItemID;
 class CItem * pItem;

 iItemID = 0;
 cCropType = 0;

	cCropType = m_pNpcList[sTargetH]->m_cCropType;
	switch (cCropType) {
	case 1: GetExp(sAttackerH, iDice(3,10)); iItemID = 820; break; // WaterMelon
	case 2: GetExp(sAttackerH, iDice(3,10)); iItemID = 821; break; // Pumpkin
	case 3: GetExp(sAttackerH, iDice(4,10)); iItemID = 822; break; // Garlic
	case 4: GetExp(sAttackerH, iDice(4,10)); iItemID = 823; break; // Barley
	case 5: GetExp(sAttackerH, iDice(5,10)); iItemID = 824; break; // Carrot
	case 6: GetExp(sAttackerH, iDice(5,10)); iItemID = 825; break; // Radish
	case 7: GetExp(sAttackerH, iDice(6,10)); iItemID = 826; break; // Corn
	case 8: GetExp(sAttackerH, iDice(6,10)); iItemID = 827; break; // ChineseBellflower
	case 9: GetExp(sAttackerH, iDice(7,10)); iItemID = 828; break; // Melone
	case 10: GetExp(sAttackerH, iDice(7,10)); iItemID = 829; break; // Tommato
	case 11: GetExp(sAttackerH, iDice(8,10)); iItemID = 830; break; // Grapes
	case 12: GetExp(sAttackerH, iDice(8,10)); iItemID = 831; break; // BlueGrapes
	case 13: GetExp(sAttackerH, iDice(9,10)); iItemID = 832; break; // Mushroom
	default: GetExp(sAttackerH, iDice(10,10)); iItemID = 721; break; // Ginseng
	
	}
	
	pItem = new class CItem;
	if (_bInitItemAttr(pItem, iItemID) == FALSE) {
		delete pItem;
	}
	if (bType == 0) {
		m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->bSetItem(m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[sAttackerH]->m_cMapIndex,
			m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY,  pItem->m_sSprite, 
			pItem->m_sSpriteFrame, pItem->m_cItemColor, FALSE);
	}
	else if (bType == 1) {
		m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bSetItem(m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[sTargetH]->m_cMapIndex,
			m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY,  pItem->m_sSprite, 
			pItem->m_sSpriteFrame, pItem->m_cItemColor, FALSE);
	} 

}

void CGame::bCalculateEnduranceDecrement(short sTargetH, short sAttackerH, char cTargetType, int iArmorType)
{
 int iDownValue, iHammerChance, iItemIndex;

	iHammerChance = 100;
	iDownValue = 1;
	if (m_pClientList[sTargetH] == NULL) return;
	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] == NULL)) return;
	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide)) {
		switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
		case 14: 
			if ((((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4) == 31) || 
				(((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4) == 32)) {
				iItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if ((iItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[iItemIndex] != NULL)) {
					if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 761) { // BattleHammer 
						iDownValue = 30;
						break;
					}
					else if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
						iDownValue = 35;
						break;
					}
					else if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 843) { // BarbarianHammer
						iDownValue = 30;
						break;
					}
				}
			}
			iDownValue = 20;
			break;
		case 10: 
			iDownValue = 3;
			break;
		default: 
			iDownValue = 1; 
			break;
		}
	}
	if (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE) {
		switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
		case 52: 
			iDownValue = 0; 
			iHammerChance = 0; 
			break;
		}
	}
	if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan > 0)) {
		m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan -= iDownValue;
	}
	if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan <= 0) {
		m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan = 0;
		SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, NULL, NULL);
		ReleaseItemHandler(sTargetH, iArmorType, TRUE);
		return;
	}
	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14) && (iHammerChance == 100)) {
		if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan < 2000) {
			iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
		}
		else {
			iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
		}
		if ((((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4) == 31) || 
			(((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4) == 32)) {
			iItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
			if ((iItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[iItemIndex] != NULL)) {
				if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 761) { // BattleHammer 
					iHammerChance = iHammerChance / 2; 
				}
				if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
					iHammerChance -= (5 * iHammerChance) / 8;
				}
				if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 843) { // BarbarianHammer
					iHammerChance = iHammerChance / 2;
				}
			}
			else {
				iHammerChance = iHammerChance / 4;
			}
			switch (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_sIDnum) {
			case 621:
			case 622:
				iHammerChance = 0;
				break;
			}
			if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan > iHammerChance) {
				ReleaseItemHandler(sTargetH, iArmorType, TRUE);
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, NULL, NULL);
			}
		}
	}
}

int CGame::iCalculateAttackEffect(short sTargetH, char cTargetType, short sAttackerH, char cAttackerType, int tdX, int tdY, int iAttackMode, BOOL bNearAttack, BOOL bIsDash, BOOL bArrowUse, BOOL bMainGaucheAttack)
{
 int    iAP_SM, iAP_L, iAttackerHitRatio, iTargetDefenseRatio, iDestHitRatio, iResult, iAP_Abs_Armor, iAP_Abs_Shield, iAP_Abs_Cape;
 char   cAttackerName[21], cAttackerDir, cAttackerSide, cTargetDir, cProtect, cCropSkill, cFarmingSkill;
 short  sWeaponIndex, sAttackerWeapon, dX, dY, sX, sY, sAtkX, sAtkY, sTgtX, sTgtY;
 DWORD  dwTime;
 WORD   wWeaponType;
 double dTmp1, dTmp2, dTmp3;
 BOOL   bKilled;
 BOOL   bNormalMissileAttack;
 BOOL   bIsAttackerBerserk;
 int    iKilledDice, iDamage, iWepLifeOff, iSideCondition, iMaxSuperAttack, iWeaponSkill, iComboBonus, iTemp;
 int    iAttackerHP, iMoveDamage, iRepDamage;
 char   cAttackerSA;
 int    iAttackerSAvalue, iHitPoint, iFarmingSSN;
 char   cDamageMoveDir;
 int    iPartyID, iConstructionPoint, iWarContribution, tX, tY, iDst1, iDst2;
 short	sItemIndex;
 short	sSkillUsed;
 unsigned long iExp;

	dwTime = timeGetTime();
	bKilled = FALSE;
	iExp = 0;
	iPartyID = 0;
	bNormalMissileAttack = FALSE;
	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	cAttackerSA      = NULL;
	iAttackerSAvalue = NULL;
	wWeaponType      = NULL;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sAttackerH] == NULL) return 0;
		if ((m_bAdminSecurity == TRUE) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return 0; 
		if ((m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) && (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) return 0;
		
		if (   (m_bIsHeldenianMode == TRUE)				
			&& (m_bHeldenianWarInitiated == FALSE)			// No attack work before war has begun
			&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) 
			&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1)) return 0; 

		if (cAttackerType == DEF_OWNERTYPE_NPC) 
		{	if (   ( m_pClientList[sTargetH]->m_bSkillUsingStatus[22] == TRUE )
				&& (iDice(1,100) <= m_pClientList[sTargetH]->m_cSkillMastery[22]) )
				return 0;// SNOOPY, do not attack while Taming in progress
		}

		if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return 0;

		if ((m_pClientList[sAttackerH]->m_iStatus & 0x10) != 0) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_PLAYER, FALSE);
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
			m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
		}
		
		if ((m_pClientList[sAttackerH]->m_sAppr2 & 0xF000) == 0) return 0;

		iAP_SM = 0;
		iAP_L  = 0;

		wWeaponType = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);

		sSkillUsed = m_pClientList[sAttackerH]->m_sUsingWeaponSkill;
		if ((bIsDash == TRUE) && (m_pClientList[sAttackerH]->m_cSkillMastery[sSkillUsed] != 100) && (wWeaponType != 25) && (wWeaponType != 27)) {
			wsprintf(G_cTxt, "TSearch Fullswing Hack: (%s) Player: (%s) - dashing with only (%d) weapon skill.", m_pClientList[sAttackerH]->m_cIPaddress, m_pClientList[sAttackerH]->m_cCharName, m_pClientList[sAttackerH]->m_cSkillMastery[sSkillUsed]);
			PutHackLogFileList(G_cTxt);
			DeleteClient(sAttackerH, TRUE, TRUE);
			return 0;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;

		// SNOOPY Added a 2nd attack if character has a MainGauche.
		if (bMainGaucheAttack)
		{	sSkillUsed = 20;
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio + m_pClientList[sAttackerH]->m_cSkillMastery[20];			
			if ( iAttackerHitRatio < 1 ) iAttackerHitRatio = 1;
			// Compute damage
			iAP_SM = iDice(1, 6);
			iAP_L  = iDice(1, 8);
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) 
			{	int dwSWEType  = (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				int dwSWEValue = (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				// CriticalDamage && Poison Damage will have no effect on armors & MainGauche
				switch (dwSWEType) {
				case 7: // Sharp
					iAP_SM = iDice(1, 7);
					iAP_L  = iDice(1, 9);				
					break;
				case 9: // Ancient
					iAP_SM = iDice(1, 8);
					iAP_L  = iDice(1, 10);
					break;				
			}	}

			dTmp1 = (double)iAP_SM;
			if (m_pClientList[sAttackerH]->m_iStr <= 0)
				 dTmp2 = 1.0f;
			else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr);

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_SM = (int)(dTmp3 +0.5f);

			dTmp1 = (double)iAP_L;
			if (m_pClientList[sAttackerH]->m_iStr <= 0)
				 dTmp2 = 1.0f;
			else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr);

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_L = (int)(dTmp3 +0.5f);
		}else
				
		if (wWeaponType == 0) {
			iAP_SM = iAP_L    = iDice(1, ((m_pClientList[sAttackerH]->m_iStr+m_pClientList[sAttackerH]->m_iAngelicStr) / 12));
			if (iAP_SM <= 0) iAP_SM = 1;
			if (iAP_L  <= 0) iAP_L  = 1;
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio + m_pClientList[sAttackerH]->m_cSkillMastery[5];
			m_pClientList[sAttackerH]->m_sUsingWeaponSkill = 5 ;

		}
		else if ((wWeaponType >= 1) && (wWeaponType < 40)) {
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;

			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;

			dTmp1 = (double)iAP_SM;
			if ((m_pClientList[sAttackerH]->m_iStr+m_pClientList[sAttackerH]->m_iAngelicStr) <= 0)
				dTmp2 = 1.0f;
			else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iStr+m_pClientList[sAttackerH]->m_iAngelicStr);

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_SM = (int)(dTmp3 +0.5f);

			dTmp1 = (double)iAP_L;
			if ((m_pClientList[sAttackerH]->m_iStr+m_pClientList[sAttackerH]->m_iAngelicStr) <= 0)
				dTmp2 = 1.0f;
			else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iStr+m_pClientList[sAttackerH]->m_iAngelicStr);

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_L = (int)(dTmp3 +0.5f);
		}
		else if (wWeaponType >= 40) {
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;

			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;
			bNormalMissileAttack = TRUE;

			iAP_SM += iDice(1, ((m_pClientList[sAttackerH]->m_iStr+m_pClientList[sAttackerH]->m_iAngelicStr) / 20));
			iAP_L  += iDice(1, ((m_pClientList[sAttackerH]->m_iStr+m_pClientList[sAttackerH]->m_iAngelicStr) / 20));
		}
	
		iAttackerHitRatio += 50;
		if (iAP_SM <= 0) iAP_SM = 1;
		if (iAP_L  <= 0) iAP_L  = 1;

		if (m_pClientList[sAttackerH]->m_iCustomItemValue_Attack != 0) {
			if ((m_pClientList[sAttackerH]->m_iMinAP_SM != 0) && (iAP_SM < m_pClientList[sAttackerH]->m_iMinAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMinAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMinAP_L != 0) && (iAP_L < m_pClientList[sAttackerH]->m_iMinAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMinAP_L;
			}
			if ((m_pClientList[sAttackerH]->m_iMaxAP_SM != 0) && (iAP_SM > m_pClientList[sAttackerH]->m_iMaxAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMaxAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMaxAP_L != 0) && (iAP_L > m_pClientList[sAttackerH]->m_iMaxAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMaxAP_L;
			}
		}

		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 1) {
			iAttackerHitRatio += 100;
			iAP_SM += 5;
			iAP_L += 5;
		}

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 851) || // KlonessEsterk 
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863) || // KlonessWand(MS.20)
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864)) { // KlonessWand(MS.10) 
				if (m_pClientList[sAttackerH]->m_iRating > 0) {
					iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
					iAP_SM += iRepDamage;
					iAP_L += iRepDamage;
				}
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == NULL) return 0;
					if (m_pClientList[sTargetH]->m_iRating <= 0) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
					}
				}
			}
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 861) || // BerserkWand(MS.20)
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 862)) { // BerserkWand(MS.10)
				iAP_SM ++;
				iAP_L ++;
			}
		}

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
			
			if (   (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 616) // DemonSlayer	
				&& (cTargetType == DEF_OWNERTYPE_NPC)) 
			{	if ( m_pNpcList[sTargetH]->m_sType == 31) 
				{	iAttackerHitRatio += 100;
					iAP_L += iDice(1,((2*iAP_L)/3));							
			}	}

			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 847) && 
				(m_cDayOrNight == 2)) {
					iAP_SM += 4;
					iAP_L += 4;
			}
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 848) && 
				(m_cDayOrNight == 1)) {
					iAP_SM += 4;
					iAP_L += 4;
			}
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 849) || // KlonessBlade 
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 850)) { // KlonessAxe
				if (m_pClientList[sAttackerH]->m_iRating > 0) {
					iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
					iAP_SM += iRepDamage;
					iAP_L += iRepDamage;
				}
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == NULL) return 0;
					if (m_pClientList[sTargetH]->m_iRating <= 0) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
					}
				}
			}
		}

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
			if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == NULL) return 0;
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/20);
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
				}
			}
		}

		cAttackerDir = m_pClientList[sAttackerH]->m_cDir;
		strcpy(cAttackerName, m_pClientList[sAttackerH]->m_cCharName);

		if (m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0)
			bIsAttackerBerserk = TRUE;
		else bIsAttackerBerserk = FALSE;
		
		if ((bArrowUse != TRUE) && (m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {

			dTmp1 = (double)iAP_SM;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 +0.5f);
			iAP_SM += iTemp;

			dTmp1 = (double)iAP_L;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 +0.5f);
			iAP_L += iTemp;

			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
				case 6:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); iAttackerHitRatio  += 30 ; break;
				case 7:  iAP_SM *= 1; iAP_L *= 1; break;				
				case 8:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); iAttackerHitRatio += 30 ; break;
				case 10:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5) ;                           break;
				case 14:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5) ; iAttackerHitRatio += 20 ; break;
				case 21:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5); iAttackerHitRatio +=  50 ; break;
				default: break;
			}
			iAttackerHitRatio += 100;
			iAttackerHitRatio += m_pClientList[sAttackerH]->m_iCustomItemValue_Attack;
		}
		if (bIsDash == TRUE) {
			iAttackerHitRatio += 20;
			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
				case 8:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); break;
				case 10: iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5);break;
				case 14: iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5);break;
				default: break;
			}
		}
		iAttackerHP = m_pClientList[sAttackerH]->m_iHP;
		iAttackerHitRatio += m_pClientList[sAttackerH]->m_iAddAR;
		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:

		if (m_pNpcList[sAttackerH] == NULL) return 0;
		if (m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) return 0;

		if ((m_pNpcList[sAttackerH]->m_iStatus & 0x10) != 0) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_NPC, FALSE);
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);
			m_pNpcList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
		}

		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		iAP_SM = 0;
		iAP_L  = 0;

		if (m_pNpcList[sAttackerH]->m_cAttackDiceThrow != 0) 
			iAP_L = iAP_SM = iDice(m_pNpcList[sAttackerH]->m_cAttackDiceThrow, m_pNpcList[sAttackerH]->m_cAttackDiceRange);

		iAttackerHitRatio = m_pNpcList[sAttackerH]->m_iHitRatio;

		cAttackerDir = m_pNpcList[sAttackerH]->m_cDir;
		memcpy(cAttackerName, m_pNpcList[sAttackerH]->m_cNpcName, 20);

		if (m_pNpcList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0)
			bIsAttackerBerserk = TRUE;
		else bIsAttackerBerserk = FALSE;

		iAttackerHP = m_pNpcList[sAttackerH]->m_iHP;
		cAttackerSA = m_pNpcList[sAttackerH]->m_cSpecialAbility;

		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;

		// Check for arrow attack
		switch (m_pNpcList[sAttackerH]->m_sType) {
		case 54: // Dark-Elf				
			// No more "not arrow attack if close" (was buggy)
			bNormalMissileAttack = TRUE; 	
			break;
		default:		
			break;
		}
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == NULL) return 0;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return 0;
		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return 0;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == FALSE) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return 0;
				
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsOwnLocation == TRUE)) return 0;
		
		if ((m_pClientList[sTargetH]->m_sX != tdX) || (m_pClientList[sTargetH]->m_sY != tdY)) return 0;

		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return 0; 

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) 
			&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return 0;

		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return 0;

		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pClientList[sTargetH]->m_iDefenseRatio;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE)) { 
			iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
			if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
				iAP_SM = iAP_SM / 2;
				iAP_L  = iAP_L / 2;
			}
			else {
				if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
					if (m_pClientList[sAttackerH]->m_iGuildGUID == m_pClientList[sTargetH]->m_iGuildGUID) return 0;
					else {
						iAP_SM = iAP_SM / 2;
						iAP_L  = iAP_L / 2;
					}
				}
				else return 0;
			}
		}

		iTargetDefenseRatio += m_pClientList[sTargetH]->m_iAddDR;

		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:

		if (m_pNpcList[sTargetH] == NULL) return 0;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return 0;

		if ((m_pNpcList[sTargetH]->m_sX != tdX) || (m_pNpcList[sTargetH]->m_sY != tdY)) return 0;

		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pNpcList[sTargetH]->m_iDefenseRatio;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		{	switch (m_pNpcList[sTargetH]->m_sType) {
			case 40: // ESG
			case 41: // GMG
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return 0;
				break;
			case 36: // AGT
			case 37: // CGT
			case 38: // MS
			case 39: // DT		
				// Snoopy added Tile where you can't stay (behind crusade structures) 
				// If you try to stay behind and accept normal punition, damage is worse and at each attack...
				if (   (m_bIsCrusadeMode == TRUE)
					&& (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)
					&& (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->bGetIsStayAllowedTile(m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY) == FALSE))
				{	char iDir = (char)iDice(1,7);
					if (iDir >= 5) iDir ++;
					int iDamage = m_pClientList[sAttackerH]->m_iHP/8 + iDice(1,20) + iAP_SM;					
					if (iDamage < 40) iDamage = 30 + iDice(1,20);
					if (iDamage > m_pClientList[sAttackerH]->m_iHP) iDamage = m_pClientList[sAttackerH]->m_iHP -1;
					m_pClientList[sAttackerH]->m_iHP -= iDamage;					
					m_pClientList[sAttackerH]->m_iLastDamage = iDamage;
					m_pClientList[sAttackerH]->m_dwRecentAttackTime = dwTime;
					SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_DAMAGEMOVE, iDir, iDamage, 0, NULL);					
					iAP_SM = iAP_SM/2; 
					iAP_L = iAP_L/2;
				}
				break;
			} 

			if (   (wWeaponType == 25) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) 
				&& (m_pNpcList[sTargetH]->m_iBuildCount > 0)) 
			{	if ((m_pClientList[sAttackerH]->m_iCrusadeDuty != 2) && (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) break;
				switch (m_pNpcList[sTargetH]->m_sType) {
				case 36: // AGT
				case 37: // CGT
				case 38: // MS
				case 39: // DT
					// administrators instantly build crusade structures
					// SNOOPY: was buugy because those structure woundn't Attack due to a m_iBuildCount = 0 value....
					if (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0) 
					{	m_pNpcList[sTargetH]->m_sAppr2 = 0;
						m_pNpcList[sTargetH]->m_iBuildCount = 1;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}				
					switch (m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1:
						m_pNpcList[sTargetH]->m_sAppr2 = 0;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						// SNOOPY: Will not send those message outside crusades...
						if (m_bIsCrusadeMode == TRUE) 
						{	switch (m_pNpcList[sTargetH]->m_sType) {
							case 36: iConstructionPoint = 700; iWarContribution = 700; break;
							case 37: iConstructionPoint = 700; iWarContribution = 700; break;
							case 38: iConstructionPoint = 500; iWarContribution = 500; break;
							case 39: iConstructionPoint = 500; iWarContribution = 500; break;
							}
							// Snoopy: Forbid Tile behind finished crusade structure
							m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetStayAllowedFlag(m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY-1, FALSE);
							m_pClientList[sAttackerH]->m_iWarContribution   += iWarContribution;
							if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
								m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;
							if (m_pClientList[sAttackerH]->m_iWarContribution >= 256*128)
								SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, (m_pClientList[sAttackerH]->m_iWarContribution %(256*128)), 1, NULL);

							wsprintf(G_cTxt, "Construction Complete: PC(%s) - WarContribution +%d"
								, m_pClientList[sAttackerH]->m_cCharName
								, iWarContribution);
							PutLogList(G_cTxt);
							PutLogEventFileList(G_cTxt);
							SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
						}
						break;
					case 5:
						m_pNpcList[sTargetH]->m_sAppr2 = 1;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						break;
					case 10:
						m_pNpcList[sTargetH]->m_sAppr2 = 2;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						break;
					}
					break;
				}
				
				m_pNpcList[sTargetH]->m_iBuildCount--;
				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) {
					m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}
				return 0;
			}
			if (   (wWeaponType == 27) && (m_pNpcList[sTargetH]->m_cCropType != 0) 
				&& (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) 
			{	cFarmingSkill = m_pClientList[sAttackerH]->m_cSkillMastery[2];
				cCropSkill = m_pNpcList[sTargetH]->m_cCropSkill;
				if (cFarmingSkill < 20) return 0;
				if (m_pClientList[sAttackerH]->m_iLevel < 20) return 0;
				switch(m_pNpcList[sTargetH]->m_sType) {
				case 64:
					// There skill increase only if needed skill is less than 10% over the minimum skill for such crop
					// Only count once per seedbag if over mimi Skill +10%
					iFarmingSSN = 1;
					if (cFarmingSkill <= (cCropSkill + 10)) 
					{	iFarmingSSN = 1;
					}else 
					{	iFarmingSSN = 0;					
					}
					switch(m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1:	
						m_pNpcList[sTargetH]->m_sAppr2 = 3;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						//sub_4B67E0
						CalculateSSN_SkillIndex(sAttackerH, 2, 1); 
						_CheckFarmingAction(sAttackerH, sTargetH, 1);
						DeleteNpc(sTargetH);
						return 0;
					case 8:	
						m_pNpcList[sTargetH]->m_sAppr2 = 3;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						CalculateSSN_SkillIndex(sAttackerH, 2, iFarmingSSN);
						_CheckFarmingAction(sAttackerH, sTargetH, 0);
						m_pNpcList[sTargetH]->m_iBuildCount--;
						break;
					case 18:
						m_pNpcList[sTargetH]->m_sAppr2 = 2;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						CalculateSSN_SkillIndex(sAttackerH, 2, iFarmingSSN);
						_CheckFarmingAction(sAttackerH, sTargetH, 0);
						// 1/20 chance to have 4 crops
						if (iDice(1,20) != 2)  m_pNpcList[sTargetH]->m_iBuildCount--;
						break;
					default:
						// SNOOPY Added a Skill Check to slow down a bit the process.
						// With minima Skill will cost twice the time
						if (   ((iDice(1,100) <= ((50+cFarmingSkill)-(cCropSkill)))// Chance off succes depends on skill
							|| (iDice(1,100)) <6 )) { // 1/20 chace of succes  ever skill you have
							m_pNpcList[sTargetH]->m_iBuildCount--;
						}
						break;
					}
					break;
				}
				// Useless? safety check !			
				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) 
				{	m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}
				// They forgot to put Hoe deplession here..
				// Weapon's wep life off				
				sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				if ( sWeaponIndex != -1)
				{	m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan -=1;
					if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan < 1)
						m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
					// then notify the client...
					if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan == 0)
					{	SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_cEquipPos, sWeaponIndex, NULL, NULL);
						ReleaseItemHandler(sAttackerH, sWeaponIndex, TRUE);
				}	}
				return 0;
		}	}

		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;
		break;
	}

	if ( (cAttackerType == DEF_OWNERTYPE_PLAYER) && (cTargetType == DEF_OWNERTYPE_PLAYER) ) {

		sX = m_pClientList[sAttackerH]->m_sX;
		sY = m_pClientList[sAttackerH]->m_sY;

		dX = m_pClientList[sTargetH]->m_sX;
		dY = m_pClientList[sTargetH]->m_sY;

		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) return 0;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) return 0;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if ((m_pClientList[sAttackerH]->m_iDex+m_pClientList[sAttackerH]->m_iAngelicDex) > 50) {
			iAttackerHitRatio += ((m_pClientList[sAttackerH]->m_iDex+m_pClientList[sAttackerH]->m_iAngelicDex) - 50); 	
		}
	}

	if (wWeaponType >= 40) {
		switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
		case 0:	break;
		case 1:	iAttackerHitRatio -= (iAttackerHitRatio / 20); break;
		case 2:	iAttackerHitRatio -= (iAttackerHitRatio / 10); break;
		case 3:	iAttackerHitRatio -= (iAttackerHitRatio / 4);  break;
		}
	}

	if (iAttackerHitRatio < 0)   iAttackerHitRatio = 0;    
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT];
		break;

	case DEF_OWNERTYPE_NPC:
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]; 
		break;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] == NULL) {
				m_pClientList[sAttackerH]->m_bIsItemEquipped[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] = FALSE;
				DeleteClient(sAttackerH, TRUE, TRUE);
				return 0;
			}

			if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_ARROW) {
				if (m_pClientList[sAttackerH]->m_cArrowIndex == -1) {
					return 0;
				}
				else {
					if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex] == NULL) 
						return 0;

					if (bArrowUse != TRUE)
						m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex]->m_dwCount--;
					if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount <= 0) {

						ItemDepleteHandler(sAttackerH, m_pClientList[sAttackerH]->m_cArrowIndex, FALSE, TRUE);
						m_pClientList[sAttackerH]->m_cArrowIndex = _iGetArrowItemIndex(sAttackerH);
					}
					else {
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_SETITEMCOUNT, m_pClientList[sAttackerH]->m_cArrowIndex, m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount, FALSE, NULL);
						iCalcTotalWeight(sAttackerH);
					}
				}
				if (cProtect == 1) return 0;
			}
			else {
				switch (cProtect) {
				case 3: iTargetDefenseRatio += 40;  break;
				case 4: iTargetDefenseRatio += 100; break;
				}
				if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
			}
		}
	}
	else {
		switch (cProtect) {
		case 1: 
			switch (m_pNpcList[sAttackerH]->m_sType) {
				case 54:
					if ((abs(sTgtX - m_pNpcList[sAttackerH]->m_sX) >= 1) || (abs(sTgtY - m_pNpcList[sAttackerH]->m_sY) >= 1)) return 0; 
					}
					break;
		case 3: iTargetDefenseRatio += 40;  break;
		case 4: iTargetDefenseRatio += 100; break;
		}
		if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
	}

	if (cAttackerDir == cTargetDir) iTargetDefenseRatio = iTargetDefenseRatio / 2;
	if (iTargetDefenseRatio < 1)   iTargetDefenseRatio = 1;

	dTmp1 = (double)(iAttackerHitRatio);
	dTmp2 = (double)(iTargetDefenseRatio);
	dTmp3 = (dTmp1 / dTmp2) * 50.0f;
	iDestHitRatio = (int)(dTmp3); 

	if (iDestHitRatio < DEF_MINIMUMHITRATIO) iDestHitRatio = DEF_MINIMUMHITRATIO;
	if (iDestHitRatio > DEF_MAXIMUMHITRATIO) iDestHitRatio = DEF_MAXIMUMHITRATIO;

	if ((bIsAttackerBerserk == TRUE) && (iAttackMode < 20)) {
		iAP_SM = iAP_SM * 2;
		iAP_L  = iAP_L  * 2;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
		iAP_L  += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
	}

	if (bNearAttack == TRUE) {
		iAP_SM = iAP_SM / 2;
		iAP_L  = iAP_L / 2;
	}

	if (cTargetType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
		iAP_L  -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (iAP_SM <= 1) iAP_SM = 1;
		if (iAP_L  <= 1) iAP_L  = 1;
	}
	else {
		if (iAP_SM <= 0) iAP_SM = 0;
		if (iAP_L  <= 0) iAP_L  = 0;
	}

	iResult = iDice(1, 100);

	if (iResult <= iDestHitRatio) {
		if (   (m_bHeldenianWarInitiated == TRUE)
			&& (bCheckHeldenianMap(sAttackerH, cAttackerType) == TRUE))
		{	iAP_SM += iAP_SM/3;
			iAP_L  += iAP_L/3;
		}
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {

			if (((m_pClientList[sAttackerH]->m_iHungerStatus <= 10) || (m_pClientList[sAttackerH]->m_iSP <= 0)) && (iDice(1,10) == 5)) return FALSE;	
			m_pClientList[sAttackerH]->m_iComboAttackCount++;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount < 0) m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount > 4) m_pClientList[sAttackerH]->m_iComboAttackCount = 1;
			iWeaponSkill = _iGetWeaponSkillType(sAttackerH);
			iComboBonus = iGetComboAttackBonus(iWeaponSkill, m_pClientList[sAttackerH]->m_iComboAttackCount);

			if ((m_pClientList[sAttackerH]->m_iComboAttackCount > 1) && (m_pClientList[sAttackerH]->m_iAddCD != NULL))
				iComboBonus += m_pClientList[sAttackerH]->m_iAddCD;

			iAP_SM += iComboBonus;
			iAP_L  += iComboBonus;

			switch (m_pClientList[sAttackerH]->m_iSpecialWeaponEffectType) {
				case 0: break;
				case 1:
					if ((m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {
						iAP_SM += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
						iAP_L  += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
					}
					break;

				case 2:
					cAttackerSA = 61;
					iAttackerSAvalue = m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue*5; 
					break;

				case 3:
					cAttackerSA = 62;
					break;
			}

			if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
				iAP_SM += iAP_SM/3;
				iAP_L  += iAP_L/3;
			}

			if (bCheckHeldenianMap(sAttackerH, DEF_OWNERTYPE_PLAYER) == 1) {
				iAP_SM += iAP_SM/3;
				iAP_L  += iAP_L/3;
			}
			
			if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
				if (m_pClientList[sAttackerH]->m_iLevel <= 80) {
					iAP_SM += iAP_SM;
					iAP_L += iAP_L;
				}
				else if (m_pClientList[sAttackerH]->m_iLevel <= 100) {
					iAP_SM += (iAP_SM* 7)/10;
					iAP_L += (iAP_L* 7)/10;
				} else {
					iAP_SM += iAP_SM/3;
					iAP_L += iAP_L/3;
				}
			}
		}

		switch (cTargetType) {
		case DEF_OWNERTYPE_PLAYER:
			ClearSkillUsingStatus(sTargetH);
			if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) {
				return 0;
			}
			else {
				switch (cAttackerSA) {
					case 62:
						if (m_pClientList[sTargetH]->m_iRating < 0) {
							iTemp = abs(m_pClientList[sTargetH]->m_iRating)/10;
							if (iTemp > 10) iTemp = 10;
							iAP_SM += iTemp;
						}
						break;
				}

				iAP_Abs_Armor  = 0;
				iAP_Abs_Shield = 0;

				iAP_Abs_Cape   = 0;

				iTemp = iDice(1,10000);
				if ((iTemp >= 1) && (iTemp < 5000))           iHitPoint = 1;
				else if ((iTemp >= 5000) && (iTemp < 7500))   iHitPoint = 2;
				else if ((iTemp >= 7500) && (iTemp < 9000))   iHitPoint = 3;
				else if ((iTemp >= 9000) && (iTemp <= 10000)) iHitPoint = 4;

				// PA: Armures
				if (iHitPoint == 2)
				{	if (cAttackerType == DEF_OWNERTYPE_NPC)
					{	switch (m_pNpcList[sAttackerH]->m_sType) {
						case 10: // Slime 
						case 16: // Ant
						case 22: // Snake
						case 55: // Rabbit
						case 56: // Cat
								iHitPoint = 5; // Only boots depleted
								break;
						case 17: // Scorpions 
						case 80: // Tentocle
								iHitPoint = 4 + iDice(1,2); // 5-boots (50%) or 6-both (50%)
								break;
						default: if (iDice(1,3) == 2) iHitPoint = 6; // 6-both (50%)
								break;					
						}
					}else if (cAttackerType == DEF_OWNERTYPE_PLAYER)
					{	if (iDice(1,3) == 2) iHitPoint = 6;
				}	}

				switch (iHitPoint) {
				

				case 1: // torse
					iAP_Abs_Armor = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY];
					break;
				case 2: // jambes
					iAP_Abs_Armor = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS];
					break;
				case 3:  // bras
					iAP_Abs_Armor = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS];
					break;
				case 4: // tte
					iAP_Abs_Armor = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD];
					break;	
				case 5: // Bottes
					iAP_Abs_Armor = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS];
					break;	
				case 6: // Bottes et jambes
					if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
						m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) > 0) 
					{	if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
							m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) >= 60)
							 iAP_Abs_Armor = 60.0f;
						else iAP_Abs_Armor = (double)(m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] + m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]);
					}
					break;
				}

				// PA: Shields
				if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield > 0) 
				{	if (iDice(1,100) <= (m_pClientList[sTargetH]->m_cSkillMastery[11])) 
					{	CalculateSSN_SkillIndex(sTargetH, 11, 1);
						iAP_Abs_Shield = m_pClientList[sTargetH]->m_iDamageAbsorption_Shield;
						// Usure Shield
						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
						if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) 
						{	if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
								m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
							if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) 
							{	SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
								ReleaseItemHandler(sTargetH, iTemp, TRUE);
				}	}	}	}
				// PA: Back (capes)  Added Damage absorbtion for enchanted capes  iAP_Abs_Cape
				if (   (cAttackerDir == cTargetDir) // Of course only when attacked from behind !
					&& (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BACK] > 0)) 
				{	iAP_Abs_Cape = m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BACK];
					// Deplete Cape durability in this case	
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) 
					{	if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
						if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) 
						{	SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							ReleaseItemHandler(sTargetH, iTemp, TRUE);
				}	}	}

				// PA: Hammer reduces PA unless if robed...
				if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) 
					&& (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14)) 	// PA counts for 3/4 vs Hammers
				{	iAP_Abs_Armor  = iAP_Abs_Armor  - iAP_Abs_Armor/4;
					iAP_Abs_Shield = iAP_Abs_Shield + iAP_Abs_Shield/4;
					// Robes have an extra PA vs hammers
					iAP_Abs_Cape   = iAP_Abs_Cape + m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_RELEASEALL];
				}

				// PA total: Calculer les dgts restants.
				iAP_Abs_Armor = iAP_Abs_Armor + iAP_Abs_Shield + iAP_Abs_Cape;
				if (iAP_Abs_Armor >= 80) 
					dTmp1 = 80.0f;
				else dTmp1 = (double)iAP_Abs_Armor;
				dTmp2 = (double)iAP_SM;
				dTmp3 = (dTmp1 / 100.0f) * dTmp2;
				iAP_SM = iAP_SM - (int)dTmp3;
				if (iAP_SM <= 0) iAP_SM = 1;

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_bIsSpecialAbilityEnabled == TRUE)) {
					switch (m_pClientList[sAttackerH]->m_iSpecialAbilityType) {
						case 0: break;
						case 1: // Xelima weapon
							iTemp = (m_pClientList[sTargetH]->m_iHP / 2);
							if (   (m_bIsCrusadeMode == FALSE) && (m_bHeldenianWarInitiated == FALSE)
								&& (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)
								&& (m_pClientList[sTargetH]->m_iLevel >= 140))
							{}else	if (iTemp > iAP_SM) iAP_SM = iTemp;
							if (iAP_SM <= 0) iAP_SM = 1;
							break;
						case 2: // Ice weapon
							if (   (bCheckResistingIceSuccess(0, sTargetH, DEF_OWNERTYPE_PLAYER, 50) == FALSE) 
								&& (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)) 
							{	m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sTargetH, DEF_OWNERTYPE_PLAYER, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + 30000, 
									sTargetH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
							break;
						case 3: // Medusa sword
							if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] >= 5) break; 
							// Medusa neck or very high PR gives invulnerability, unless having a Medusa Blade...
							if (   ((m_pClientList[sTargetH]->m_cSkillMastery[23] + m_pClientList[sTargetH]->m_iAddPR + iDice(1,100)) >= 250) 
								&& (m_pClientList[sTargetH]->m_iSpecialAbilityType != 3)) break; 
							m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 5;
							// Nota: The client was fixed to show "paralysed" for any 2+ value
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + 10000, 
								sTargetH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 5, NULL, NULL);								
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, 5, NULL, NULL);		
							break;
						case 4: // Instant kill weapon
							iAP_SM = (m_pClientList[sTargetH]->m_iHP);
							break;
						case 5: // Vampiric weapon
							m_pClientList[sAttackerH]->m_iHP += iAP_SM;
							if (iGetMaxHP(sAttackerH) < m_pClientList[sAttackerH]->m_iHP)  // BloodEffect limite le regen
								m_pClientList[sAttackerH]->m_iHP = iGetMaxHP(sAttackerH);
							SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
							break;
					}
				}

				if (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)
				{	if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) 
					{	switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
						case 50: // Merien Plate
							if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
								sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
							else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
							if ((sWeaponIndex != -1) && (iWeaponSkill !=6)) // Don't break bows
								m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
							break;
						case 51: // Merien Shield effect on armor piece
							if (iHitPoint == m_pClientList[sTargetH]->m_iSpecialAbilityEquipPos)
								iAP_SM = 0;
							break;
						case 52: // Merien Shield
							iAP_SM = 0;
							break;
						}
					}else if (cAttackerType == DEF_OWNERTYPE_NPC) 
					{	switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
						case 50: // Merien Plate							
							if (m_pNpcList[sAttackerH]->m_cActionLimit < 2)
							{	m_pNpcList[sAttackerH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[sAttackerH]->m_cBehavior = DEF_BEHAVIOR_FLEE;
								m_pNpcList[sAttackerH]->m_bIsPermAttackMode = FALSE;
								m_pNpcList[sAttackerH]->m_iTargetIndex = NULL;
							}
							break;
						case 51: // Merien Shield effect on armor piece
							if (iHitPoint == m_pClientList[sTargetH]->m_iSpecialAbilityEquipPos)
								iAP_SM = 0;
							break;
						case 52: // Merien Shield
							iAP_SM = iAP_SM/2;
							break;				
				}	}	}

				if ((m_pClientList[sTargetH]->m_bIsLuckyEffect > 0) && (iDice(1,100) <= m_pClientList[sTargetH]->m_bIsLuckyEffect) 
					&& (m_pClientList[sTargetH]->m_iHP <= iAP_SM)) 
				{	iAP_SM = m_pClientList[sTargetH]->m_iHP - 1;
				}

				switch (iHitPoint) {
				case 1:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
					if (iTemp == -1) iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RELEASEALL];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					break;

				case 2:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					else {
						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
						if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
							bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
						}
					}
					break;

				case 3:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					break;

				case 4:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					break;
				}
	
				if ((cAttackerSA == 2) && (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != 0)) {
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT ], NULL, NULL);
					switch(m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]) {
					case 1:
						SetProtectionFromArrowFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
						break;
					case 2:
					case 5:
						SetMagicProtectionFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
						break;
					case 3:
					case 4:
						SetDefenseShieldFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
						break;
					}
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
				}

				if ( (m_pClientList[sTargetH]->m_bIsPoisoned == FALSE) && 
					((cAttackerSA == 5) || (cAttackerSA == 6) || (cAttackerSA == 61)) ) {
					if (bCheckResistingPoisonSuccess(sTargetH, DEF_OWNERTYPE_PLAYER) == FALSE) {
						m_pClientList[sTargetH]->m_bIsPoisoned = TRUE;
						if (cAttackerSA == 5)		m_pClientList[sTargetH]->m_iPoisonLevel = 15;
						else if (cAttackerSA == 6)  m_pClientList[sTargetH]->m_iPoisonLevel = 40;
						else if (cAttackerSA == 61) m_pClientList[sTargetH]->m_iPoisonLevel = iAttackerSAvalue;

						m_pClientList[sTargetH]->m_dwPoisonTime = dwTime;
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sTargetH]->m_iPoisonLevel, NULL, NULL);
						SetPoisonFlag(sTargetH, DEF_OWNERTYPE_PLAYER, TRUE);
					}
				}

				// Magic Weapons - Add Magical Damages
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
					double iInitial_AP_SM, iWeaponDamage, iTotalMagicDamage;
					int iMagDamage;
					short sManaCost;
					DWORD dwType1, dwType2, dwValue1, dwValue2;

					if(m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1){
						sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
					}
					else if(m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1){
						sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
					}
					else sItemIndex = -1;

					if(sItemIndex != -1){
						if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
							dwType1  = (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
							dwValue1 = (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
							dwType2  = (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
							dwValue2 = (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
						}
						if(dwType1 == 15){
							sManaCost = dwValue2*2;
							if(m_pClientList[sAttackerH]->m_iMP >= sManaCost){
								iWeaponDamage = (double)dwValue2*7;
								iInitial_AP_SM = (double)iAP_SM;
								iMagDamage = (double)(m_pClientList[sAttackerH]->m_iMag+m_pClientList[sAttackerH]->m_iAngelicMag)/20;
								iTotalMagicDamage = ((iInitial_AP_SM/100.0f)*(iWeaponDamage+100))+iMagDamage;
								iAP_SM = (int)iTotalMagicDamage;
								m_pClientList[sAttackerH]->m_iMP -= sManaCost;
								SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
							}
						}
					}
				}
				// End of Magic Weapons 
				
				// DS reduce Demon's Damage:  max 34-39 damage by DDs (Never fly by DDs)		
				sItemIndex = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if ((sItemIndex != -1) && (m_pClientList[sTargetH]->m_pItemList[sItemIndex] != NULL)) 
				{	if (   (m_pClientList[sTargetH]->m_pItemList[sItemIndex]->m_sIDnum == 616) // DemonSlayer	
						&& (cAttackerType == DEF_OWNERTYPE_NPC)) 
					{	if ( m_pNpcList[sAttackerH]->m_sType == 31) 
						{	if (iAP_SM >= 40) iAP_SM = 33 + iDice(1,6);
				}	}	}

				m_pClientList[sTargetH]->m_iHP -= iAP_SM;
				if (m_pClientList[sTargetH]->m_iHP <= 0) {
					if (cAttackerType == DEF_OWNERTYPE_PLAYER)
						bAnalyzeCriminalAction(sAttackerH, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iAP_SM);	
					bKilled     = TRUE;
					iKilledDice = m_pClientList[sTargetH]->m_iLevel;
				}
				else {
					if (iAP_SM > 0) {
						if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
							dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
							dTmp2 = (double)iAP_SM;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iTemp = iGetMaxMP(sTargetH);
							m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
							if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
						}
						if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
							// Crit increase items (bug < and not <= means CritIncrease 1% have no effect)
							if (iDice(1,100) <= (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
								iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
								if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
									SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
							}
						}

					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

					if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
						sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
					else sAttackerWeapon = 1;

					if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) 
						iMoveDamage = 60;
					else iMoveDamage = 40;

					if (iAP_SM >= iMoveDamage) {
						if (sTgtX == sAtkX) {
							if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE;
								else if (sTgtY > sAtkY) cDamageMoveDir = 5;
								else if (sTgtY < sAtkY) cDamageMoveDir = 1;
							}
							else if (sTgtX > sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 3;
									else if (sTgtY > sAtkY) cDamageMoveDir = 4;
									else if (sTgtY < sAtkY) cDamageMoveDir = 2;
								}
								else if (sTgtX < sAtkX) {
									if (sTgtY == sAtkY)     cDamageMoveDir = 7;
										else if (sTgtY > sAtkY) cDamageMoveDir = 6;
										else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
								}
							m_pClientList[sTargetH]->m_iLastDamage = iAP_SM;

							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iAP_SM, sAttackerWeapon, NULL);
						}
						else {
CAE_SKIPDAMAGEMOVE:;
							int iProb;
							if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
								switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
									case 6 : iProb = 3500; break;
									case 8 : iProb = 1000; break;
									case 9 : iProb = 2900; break;
									case 10: iProb = 2500; break;
									case 14: iProb = 2000; break;
									case 21: iProb = 2000; break;
									default: iProb = 1; break;
								}
							}
							else iProb = 1;

							if (iDice(1,10000) >= iProb) 
								SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iAP_SM, sAttackerWeapon, NULL);		
							}

							if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
								m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
								bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
							}

							m_pClientList[sTargetH]->m_iSuperAttackCount++;
							if (m_pClientList[sTargetH]->m_iSuperAttackCount > 14) { 
								m_pClientList[sTargetH]->m_iSuperAttackCount = 0;
								iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
								if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
									SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
							}
						}
					}
				}
				break;				   

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_DEAD) return 0;
			if (m_pNpcList[sTargetH]->m_bIsKilled == TRUE) return 0;
			if (m_bIsCrusadeMode == TRUE) {
				if (cAttackerSide == m_pNpcList[sTargetH]->m_cSide) {
					switch (m_pNpcList[sTargetH]->m_sType) {
						case 40:
						case 41:
						case 43:
						case 44:
						case 45:
						case 46:
						case 47: 
						case 51:
							return 0;

						default: break;
					}
				}
				else {
					switch (m_pNpcList[sTargetH]->m_sType) {
						case 41:
							if (cAttackerSide != 0) {
								m_pNpcList[sTargetH]->m_iV1 += iAP_L;
								if (m_pNpcList[sTargetH]->m_iV1 > 500) {
									m_pNpcList[sTargetH]->m_iV1 = 0;
									m_pNpcList[sTargetH]->m_iManaStock--;
									if (m_pNpcList[sTargetH]->m_iManaStock <= 0) m_pNpcList[sTargetH]->m_iManaStock = 0;
									wsprintf(G_cTxt, "ManaStock down: %d", m_pNpcList[sTargetH]->m_iManaStock);
									PutLogList(G_cTxt);
								}
							}
							break;
					}
				}
			}
			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
				case 1:
				case 2:
				return 0;
			}

			// Snoopy: Added possibilty of activated weapons effect on npcs
			if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) 
				&& (m_pClientList[sAttackerH] != NULL) 
				&& (m_pClientList[sAttackerH]->m_bIsSpecialAbilityEnabled == TRUE)) 
			{	switch (m_pClientList[sAttackerH]->m_iSpecialAbilityType) {
				case 0: break;
				case 1: // Xelima weapon, deals double damage 1 in 3 times
					if (iDice(1,3)==2) 
					{	iAP_SM *= 2;
						iAP_L *= 2;
					}
					break;
				case 2: // Ice weapon, will ice npcs						
					if (   (bCheckResistingIceSuccess(0, sTargetH, DEF_OWNERTYPE_NPC, 50) == FALSE) 
							&& (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0)) 
					{	m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 2;
						SetIceFlag(sTargetH, DEF_OWNERTYPE_NPC, TRUE);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + 20000, 
							sTargetH, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 1, NULL, NULL);
					}
					break;
				case 3: // Medusa sword - hold for 10 sec
					if (m_pNpcList[sTargetH]->m_cMagicLevel >= 6)
					{	// Not on magic npcs,
					}else  // para for 10 sec
					{	if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 0) 
						{	m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 3;
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + 10000, 
								sTargetH, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 3, NULL, NULL);
							// May be canceled due to damage later...					
					}	}
					break;
				case 4: // Instant kill weapon, deals Double damage
					iAP_SM *= 2;
					iAP_L *= 2;
					break;
				case 5: // Vampiric weapon 1/8 of given HP
					if (m_pNpcList[sTargetH]->m_cSize == 0)	
						 m_pClientList[sAttackerH]->m_iHP += iAP_SM/8;					
					else m_pClientList[sAttackerH]->m_iHP += iAP_L/8;
					if (iGetMaxHP(sAttackerH) < m_pClientList[sAttackerH]->m_iHP) // BloodEffect limite le regen
						m_pClientList[sAttackerH]->m_iHP = iGetMaxHP(sAttackerH);
					SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					break;
			}	}

			if (m_pNpcList[sTargetH]->m_cSize == 0)	
				iDamage = iAP_SM;					
			else iDamage = iAP_L;

			// PA monsters
			if (m_pNpcList[sTargetH]->m_iAbsDamage < 0) // negative value: PA mobs
			{	dTmp1 = (double)iDamage;
				dTmp2 = (double)(abs(m_pNpcList[sTargetH]->m_iAbsDamage))/100.0f;
				dTmp3 = dTmp1 * dTmp2;										
				if (   (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) 
					&& (m_pNpcList[sTargetH]->m_cSpecialAbility == 3)
					&& (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14)) 	// PA counts for 1/2 vs Hammers but not against natural PA
				{	dTmp2 = dTmp1 - (dTmp3/2);	
				}else dTmp2 = dTmp1 - dTmp3;	
				iDamage = (int)dTmp2;
				if (iDamage < 0) iDamage = 1;
			}

			if ((cAttackerSA == 2) && (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0)) {
					switch(m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]) {
					case 1:
						SetProtectionFromArrowFlag(sTargetH, DEF_OWNERTYPE_NPC, FALSE);
						break;
					case 2:
					case 5:
						SetMagicProtectionFlag(sTargetH, DEF_OWNERTYPE_NPC, FALSE);
						break;
					case 3:
					case 4:
						SetDefenseShieldFlag(sTargetH, DEF_OWNERTYPE_NPC, FALSE);
						break;
					}
				m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = NULL;
				bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_PROTECT);					  
			}

			// Magic Weapons - Add Magical Damages
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				double iInitial_AP_SM, iWeaponDamage, iTotalMagicDamage;
				int iMagDamage;
				short sManaCost;
				DWORD dwType1, dwType2, dwValue1, dwValue2;

				if(m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1){
					sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				}
				else if(m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1){
					sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				}
				else sItemIndex = -1;

				if(sItemIndex != -1){
					if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
						dwType1  = (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
						dwValue1 = (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
						dwType2  = (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
						dwValue2 = (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
					}
					if(dwType1 == 15){
						sManaCost = dwValue2*2;
						if(m_pClientList[sAttackerH]->m_iMP >= sManaCost){
							iWeaponDamage = (double)dwValue2*7;
							iInitial_AP_SM = (double)iDamage;
							iMagDamage = (double)(m_pClientList[sAttackerH]->m_iMag+m_pClientList[sAttackerH]->m_iAngelicMag)/20;
							iTotalMagicDamage = ((iInitial_AP_SM/100.0f)*(iWeaponDamage+100))+iMagDamage;
							iDamage = (int)iTotalMagicDamage;
							m_pClientList[sAttackerH]->m_iMP -= sManaCost;
							SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
						}
					}
				}
			}
			// End of Magic Weapons 

			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
			case 0:
			case 3:
			case 5:
				m_pNpcList[sTargetH]->m_iHP -= iDamage;
				break;
			}

			if (m_pNpcList[sTargetH]->m_iHP <= 0) {
				NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
				bKilled = TRUE;
				iKilledDice = m_pNpcList[sTargetH]->m_iHitDice;
			}
			else {
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) goto CAE_SKIPCOUNTERATTACK;

				// Tammed mobs
				if ((m_pNpcList[sTargetH]->m_dwTamingTime != 0) && (m_pNpcList[sTargetH]->m_iSummonControlMode == 1)) goto CAE_SKIPCOUNTERATTACK;

				if (m_pNpcList[sTargetH]->m_cActionLimit != 0) goto CAE_SKIPCOUNTERATTACK;
				if (m_pNpcList[sTargetH]->m_bIsPermAttackMode == TRUE) goto CAE_SKIPCOUNTERATTACK;
				if ((m_pNpcList[sTargetH]->m_bIsSummoned == TRUE) && (m_pNpcList[sTargetH]->m_iSummonControlMode == 1)) goto CAE_SKIPCOUNTERATTACK;
				if (m_pNpcList[sTargetH]->m_sType == 51) goto CAE_SKIPCOUNTERATTACK;

				if (iDice(1,3) == 2) {
					if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
						tX = tY = 0;
						switch (m_pNpcList[sTargetH]->m_cTargetType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex] != NULL) {
									tX = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
									tY = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex] != NULL) {
									tX = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
									tY = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
								}
								break;
							}

						iDst1 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);

						tX = tY = 0;
						switch (cAttackerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sAttackerH] != NULL) {
									tX = m_pClientList[sAttackerH]->m_sX;
									tY = m_pClientList[sAttackerH]->m_sY;
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sAttackerH] != NULL) {
									tX = m_pNpcList[sAttackerH]->m_sX;
									tY = m_pNpcList[sAttackerH]->m_sY;
								}
								break;
						}

						iDst2 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);

						if (iDst2 <= iDst1) {
							m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
							m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
							m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
							m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
						}
					}
					else {
						m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
						m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
					}
				}

CAE_SKIPCOUNTERATTACK:;

				if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0))
					m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
					sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
				else sAttackerWeapon = 1;

				if ((wWeaponType < 40) && (m_pNpcList[sTargetH]->m_cActionLimit == 4)) {
 					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE2;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}

					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
						cDamageMoveDir = iDice(1,8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
					}

					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX   = dX;
					m_pNpcList[sTargetH]->m_sY   = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
						cDamageMoveDir = iDice(1,8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
					}

					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX   = dX;
					m_pNpcList[sTargetH]->m_sY   = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

 					if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) {
						if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
							iExp = (m_pNpcList[sTargetH]->m_iExp/3);
							if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0)
								iExp += m_pNpcList[sTargetH]->m_iNoDieRemainExp;

							if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1/100.0f)*dTmp2;
								iExp += (int)dTmp3;
							}

							if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

							GetExp(sAttackerH, iExp);

							DeleteNpc(sTargetH);
							return FALSE;
						}
					}
				}
				else {
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, sAttackerWeapon, NULL);
				}

CAE_SKIPDAMAGEMOVE2:;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}
				else if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 2) {
					if ((m_pNpcList[sTargetH]->m_iHitDice > 50) && (iDice(1, 10) == 5)) {
						m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
						bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
					}
				}

				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					(cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
						if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
							iExp = iDamage;
							m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
						}
						else {
							iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
							m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
						}

						if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						if (m_bIsCrusadeMode == TRUE) iExp = iExp/3;

						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}
					}
			}
			break;
		}

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
		{	if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
				 sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
			else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
// SNOOPY: ADDED support for Dual-Wielding on 4th Combo Attack
			// And add MainGauche Attack on succesfull 4th combo Attacks
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
			if ((bMainGaucheAttack == FALSE) // No 2nd MainGauche Attack
				&& (sItemIndex != -1)
				&& (m_pClientList[sAttackerH]->m_iComboAttackCount == 4)
				&& (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {				
				iWeaponSkill = _iGetWeaponSkillType(sAttackerH);
				if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 10) // MainGauche
					&& ((iWeaponSkill==7)||(iWeaponSkill==9)) // Only SS or Fencers					
					&& (iDice(1,120) < m_pClientList[sAttackerH]->m_cSkillMastery[20]) )// Dual-Wielding skill					 
				{	iExp += iCalculateAttackEffect(sTargetH, cTargetType, sAttackerH, DEF_OWNERTYPE_PLAYER, tdX, tdY, 2, FALSE, FALSE, FALSE, TRUE);				
			}	}			
			//SNOOPY: Increase Dual-Wielding Skill if appropriate
			if (bMainGaucheAttack == TRUE) {
				CalculateSSN_SkillIndex(sAttackerH, 20, 1);
				if (bKilled == FALSE)
					CalculateSSN_SkillIndex(sAttackerH, 20, 1);
				else {
					if (m_pClientList[sAttackerH]->m_iHP <= 3)
						 CalculateSSN_SkillIndex(sAttackerH, 20, iDice(1, iKilledDice));
					else CalculateSSN_SkillIndex(sAttackerH, 20, iDice(1, ((int)(iKilledDice/2))));
				}
			}else // Else compute normal weapons skill increase
			// Compute skill increase
			if ((sWeaponIndex != -1) && (bArrowUse != TRUE)) {
				// No skill increase if bArrowUse
				if (   (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) 
					&& (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum != 231) )  //  Not for PickAxe
				{	if (bKilled == FALSE)
						CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, 1);
					else 
					{	if (m_pClientList[sAttackerH]->m_iHP <= 3)
							 CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice)*2);
						else CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice));
				}	}
				// Weapon's wep life off
				if (   (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) 
					&& (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wMaxLifeSpan != 0) ) 
				{	iWepLifeOff = 1;
					if ((wWeaponType >= 1) && (wWeaponType < 40)) 
					{	switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
						case 0:	break;
						case 1:	if (iDice(1,3) == 1) iWepLifeOff++; break;
						case 2:	if (iDice(1,2) == 1) iWepLifeOff += iDice(1,2); break;
						case 3:	if (iDice(1,2) == 1) iWepLifeOff += iDice(1,3); break;
						}
					}
					if (m_pClientList[sAttackerH]->m_cSide != 0) {
						if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan < iWepLifeOff) 
							 m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
						else m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan -= iWepLifeOff;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan == 0) {
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_cEquipPos, sWeaponIndex, NULL, NULL);
						ReleaseItemHandler(sAttackerH, sWeaponIndex, TRUE);
				}	}
			}else 
			{	if (wWeaponType == 0)  // Open-Hand Skill increase
				{	CalculateSSN_SkillIndex(sAttackerH, 5, 1);
		}	}	}
	}else  // Missing the target !
	{	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {	//bMainGaucheAttack
			m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
			//SNOOPY: Adding MainGauche Attack
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
			if ((bMainGaucheAttack == FALSE) // Not if alreaddy a MainGauche Attack
				&& (sItemIndex != -1)
				&& (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {				
				iWeaponSkill = _iGetWeaponSkillType(sAttackerH);
				if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 10) // MainGauche
					&& ((iWeaponSkill == 7)||(iWeaponSkill == 9)) // Only SS or Fencers					
					&& (iDice(1,150) < m_pClientList[sAttackerH]->m_cSkillMastery[20]) )// Dual-Wielding skill					 
				{	iExp = iCalculateAttackEffect(sTargetH, cTargetType, sAttackerH, DEF_OWNERTYPE_PLAYER, tdX, tdY, 2, FALSE, FALSE, FALSE, TRUE);
	}	}	}	}
	return iExp;
}

// October 19, 2004 - 3.51 translated
void CGame::_GrandMagicLaunchMsgSend(int iType, char cAttackerSide)
{
 char * cp, cBuff[120];
 WORD * wp;

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_GRANDMAGICLAUNCH;
	cp++;

	wp = (WORD *)cp;
	*wp = (WORD)iType;
	cp += 2;

	wp = (WORD *)cp;
	*wp = (WORD)cAttackerSide;
	cp += 2;
	
	bStockMsgToGateServer(cBuff, 5);
}

// October 19, 2004 - 3.51 translated
BOOL CGame::_bNpcBehavior_ManaCollector(int iNpcH)
{
 int dX, dY, iMaxMP, iTotal;
 short sOwnerH;
 char  cOwnerType;
 double dV1, dV2, dV3;
 BOOL bRet;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return FALSE;

	bRet = FALSE;
	for (dX = m_pNpcList[iNpcH]->m_sX-5; dX <= m_pNpcList[iNpcH]->m_sX+5; dX++)
	for (dY = m_pNpcList[iNpcH]->m_sY-5; dY <= m_pNpcList[iNpcH]->m_sY+5; dY++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pNpcList[iNpcH]->m_cSide == m_pClientList[sOwnerH]->m_cSide) {
					iMaxMP = (2*(m_pClientList[sOwnerH]->m_iMag+m_pClientList[sOwnerH]->m_iAngelicMag)) + (2*m_pClientList[sOwnerH]->m_iLevel) + ((m_pClientList[sOwnerH]->m_iInt+m_pClientList[sOwnerH]->m_iAngelicInt)/2);
					if (m_pClientList[sOwnerH]->m_iMP < iMaxMP) {
						iTotal = iDice(1, (m_pClientList[sOwnerH]->m_iMag+m_pClientList[sOwnerH]->m_iAngelicMag));
						if (m_pClientList[sOwnerH]->m_iAddMP != 0) {
							dV2 = (double)iTotal;
							dV3 = (double)m_pClientList[sOwnerH]->m_iAddMP;
							dV1 = (dV3 / 100.0f)*dV2;
							iTotal += (int)dV1;
						}

						m_pClientList[sOwnerH]->m_iMP += iTotal;
		
						if (m_pClientList[sOwnerH]->m_iMP > iMaxMP) 
							m_pClientList[sOwnerH]->m_iMP = iMaxMP;

						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
					}
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if ((m_pNpcList[sOwnerH]->m_sType == 42) && (m_pNpcList[sOwnerH]->m_iV1 > 0)) {
					if (m_pNpcList[sOwnerH]->m_iV1 >= 3) {
						m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] += 3;
						m_pNpcList[sOwnerH]->m_iV1 -= 3;
						bRet = TRUE;
					}
					else {
						m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] += m_pNpcList[sOwnerH]->m_iV1; 
						m_pNpcList[sOwnerH]->m_iV1 = 0;
						bRet = TRUE;
					}
				}
				break;
			}
		}
	}
	return bRet;
}

// October 19, 2004 - 3.51 translated
void CGame::MeteorStrikeMsgHandler(char cAttackerSide)
{
 int i;
 DWORD dwTime = timeGetTime();
	
	switch (cAttackerSide) {
	case 1:
		if (m_iElvineMapIndex != -1) {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvine") == 0) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 1, NULL, NULL, NULL);
				}
				else {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
				}
			}
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 5000, NULL, NULL, m_iElvineMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
			}
		}
		break;

	case 2:
		if (m_iAresdenMapIndex != -1) {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresden") == 0) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 3, NULL, NULL, NULL);
				}
				else {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
				}
			}
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 1000*5, NULL, NULL, m_iAresdenMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
			}
		}
		break;
	}
}

// October 19, 2004 - 3.51 translated
void CGame::_NpcBehavior_GrandMagicGenerator(int iNpcH)
{
	switch (m_pNpcList[iNpcH]->m_cSide) {
	case 1:
		if (m_iAresdenMana > DEF_GMGMANACONSUMEUNIT) {
			m_iAresdenMana = 0 ; 
			m_pNpcList[iNpcH]->m_iManaStock++;
			if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
				_GrandMagicLaunchMsgSend(1, 1);
				MeteorStrikeMsgHandler(1);
				m_pNpcList[iNpcH]->m_iManaStock = 0;
				m_iAresdenMana = 0;
			}
			wsprintf(G_cTxt, "(!) Aresden GMG %d/%d", m_pNpcList[iNpcH]->m_iManaStock, m_pNpcList[iNpcH]->m_iMaxMana);
			PutLogList(G_cTxt);
		}
		break;

	case 2:
		if (m_iElvineMana > DEF_GMGMANACONSUMEUNIT) {
			m_iElvineMana = 0 ; 
			m_pNpcList[iNpcH]->m_iManaStock++;
			if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
				_GrandMagicLaunchMsgSend(1, 2);
				MeteorStrikeMsgHandler(2);
				m_pNpcList[iNpcH]->m_iManaStock = 0;
				m_iElvineMana = 0;
			}
			wsprintf(G_cTxt, "(!) Elvine GMG %d/%d", m_pNpcList[iNpcH]->m_iManaStock, m_pNpcList[iNpcH]->m_iMaxMana);
			PutLogList(G_cTxt);
		}
		break;
	}
}

// October 19, 2004 - 3.51 translated
BOOL CGame::_bNpcBehavior_Detector(int iNpcH)
{
int dX, dY;
 short sOwnerH;
 char  cOwnerType, cSide;
 BOOL  bFlag = FALSE;
                       
	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return FALSE;

	for (dX = m_pNpcList[iNpcH]->m_sX-10; dX <= m_pNpcList[iNpcH]->m_sX+10; dX++)
	for (dY = m_pNpcList[iNpcH]->m_sY-10; dY <= m_pNpcList[iNpcH]->m_sY+10; dY++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

		cSide = 0;
		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				cSide = m_pClientList[sOwnerH]->m_cSide;
				break;

			case DEF_OWNERTYPE_NPC:
				cSide = m_pNpcList[sOwnerH]->m_cSide;
				break;
			}
		}

		if ((cSide != 0) && (cSide != m_pNpcList[iNpcH]->m_cSide)) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
					SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);			
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
					SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);			
				}
				break;
			}
			
			bFlag = TRUE;
		}
	}

	return bFlag;
}

// October 19,2004 - 3.51 translated
void CGame::NpcBehavior_Dead(int iNpcH)			   
{
 DWORD dwTime;

	if (m_pNpcList[iNpcH] == NULL) return; 

	dwTime = timeGetTime();
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
	}

	if ((dwTime - m_pNpcList[iNpcH]->m_dwDeadTime) > m_pNpcList[iNpcH]->m_dwRegenTime)
		DeleteNpc(iNpcH);
}

// v2.15 2002-8-7 // 2002-09-06 #1
BOOL CGame::_bDecodeNpcItemConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token;
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iNpcConfigListIndex = 0, k = 0;
 class CStrTok * pStrTok;
 class CNpcItem * pTempNpcItem = NULL ;
  
	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:

				switch (cReadModeB) {

				case 1:
					// NPC 
					if (strlen(token) > 20)	{
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Too long Npc name.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					for (iNpcConfigListIndex = 0; iNpcConfigListIndex < DEF_MAXNPCTYPES; iNpcConfigListIndex++)
						if (m_pNpcConfigList[iNpcConfigListIndex] != NULL) {
							if(strcmp(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName,token) == 0) {
								PutLogList(token);
								break;	
							}
						}
					if (iNpcConfigListIndex == DEF_MAXNPCTYPES ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - No exist Npc Name");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:
					if( strlen(token) > 2 ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Type Error.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iNpcItemType = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (strlen(token) > 20)	{
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Too long Item name.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					if (pTempNpcItem == NULL)
						pTempNpcItem = new class CNpcItem();

					if( memcmp(token,"[ENDITEM]",9) == 0 ){
						cReadModeA = 0 ;
						cReadModeB = 0 ;

						if ( pTempNpcItem  != NULL) {
							delete pTempNpcItem ; 
							pTempNpcItem = NULL ;
						}
						break;
					}
					
					strcpy(pTempNpcItem->m_cName, token);
					if(!m_bReceivedItemList)	// ITEM List  .
					{
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration error - Before Item List receiving.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					for(k=0; k < DEF_MAXITEMTYPES; k++)
					{
						if ( m_pItemConfigList[k] == NULL )
							continue;
			
						if (strcmp(token, m_pItemConfigList[k]->m_cName) == 0 ) {
							pTempNpcItem->m_sItemID = m_pItemConfigList[k]->m_sIDnum;
							break;
						}
					}

					if ( k == DEF_MAXITEMTYPES ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration error - Do Not exist in ITEM LIST");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					cReadModeB = 4;
					break;

				case 4:
					//  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					pTempNpcItem->m_sFirstProbability = atoi(token);

					if (pTempNpcItem->m_sFirstProbability <= 0 ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - First probability have wrong value");
						delete pContents;
						delete pStrTok;
						return FALSE ; 
					}

					//      . 
					
						
					cReadModeB = 5;
					break;

				case 5:
					//  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					pTempNpcItem->m_sSecondProbability = atoi(token);

					if (pTempNpcItem->m_sSecondProbability <= 0 ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Second probability have wrong value");
						delete pContents;
						delete pStrTok;
						return FALSE ; 
					}

					//      . 
					

					cReadModeB = 3;
			
					// vector      . 
					m_pNpcConfigList[iNpcConfigListIndex]->m_vNpcItem.push_back(*pTempNpcItem);

					// 2002-09-17 #1 NPCITEM Type 2 
					if( m_pNpcConfigList[iNpcConfigListIndex]->m_iNpcItemMax < pTempNpcItem->m_sSecondProbability )
						m_pNpcConfigList[iNpcConfigListIndex]->m_iNpcItemMax = pTempNpcItem->m_sSecondProbability;

					break;

				} // switch #2

			default: 
				break;

			} // switch #1
		} // if
		else {

			if (memcmp(token, "NpcItem", 7) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			
			}
		}
		token = pStrTok->pGet();
	}

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file contents error!");
		return FALSE;
	}

	m_bNpcItemConfig = TRUE;

	return TRUE;

} 

BOOL CGame::bGetItemNameWhenDeleteNpc(int & iItemID, short sNpcType)
{ 
	if (m_bNpcItemConfig == TRUE) {
		
		class    CNpcItem	CTempNpcItem;
		int    iResult;
		int    iNpcIndex;
		int    iNumNpcitem;
		int    iIndex;
		int    iDiceValue;
		BOOL    bFirstDice = FALSE, bSecondDice = FALSE;

		for ( iNpcIndex = 0; iNpcIndex < DEF_MAXNPCTYPES; iNpcIndex++) {
			if (m_pNpcConfigList[iNpcIndex] != NULL) {
				if(m_pNpcConfigList[iNpcIndex]->m_sType == sNpcType ) break; 
			}
		}

		if ( iNpcIndex == DEF_MAXNPCTYPES ) return FALSE;

		if( m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size() <=  0 )  return FALSE;

		switch( m_pNpcConfigList[iNpcIndex]->m_iNpcItemType ) {
		case 1:
			//        .
			iResult = iDice( 1, m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size() ) - 1;

			CTempNpcItem = m_pNpcConfigList[iNpcIndex]->m_vNpcItem.at(iResult);
  
			if ( iDice(1,CTempNpcItem.m_sFirstProbability  ) == CTempNpcItem.m_cFirstTargetValue ) bFirstDice  = TRUE;
			if ( iDice(1,CTempNpcItem.m_sSecondProbability ) == CTempNpcItem.m_cSecondTargetValue) bSecondDice = TRUE;

			if ( (bFirstDice == TRUE) && (bSecondDice == TRUE) ) {
				iItemID = CTempNpcItem.m_sItemID;

				wsprintf(G_cTxt, "NpcType 1 (%d) size(%d) %s(%d) (%d)", sNpcType, m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size(), CTempNpcItem.m_cName, CTempNpcItem.m_sItemID, iItemID);
				PutLogList(G_cTxt);

			}
			break;

		case 2:
			iNumNpcitem = m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size();
			iDiceValue  = iDice(1, m_pNpcConfigList[iNpcIndex]->m_iNpcItemMax);

			for(iIndex = 0; iIndex < iNumNpcitem; iIndex++) {
				CTempNpcItem = m_pNpcConfigList[iNpcIndex]->m_vNpcItem.at(iIndex);

				if( CTempNpcItem.m_sFirstProbability <= iDiceValue && iDiceValue < CTempNpcItem.m_sSecondProbability ) {
					iItemID = CTempNpcItem.m_sItemID;

					wsprintf(G_cTxt, "NpcType 2 (%d) size(%d) %s(%d) (%d)", sNpcType, m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size(), CTempNpcItem.m_cName, CTempNpcItem.m_sItemID, iItemID);
					PutLogList(G_cTxt);
					break;
				}
			}
			break;

		} // switch

		if ( iItemID <= 0 )
			return FALSE;

		return TRUE;

	}
	else {
	int iResult; 
	// NPC       . 

	switch (sNpcType) { 
		case 49: // Hellclaw 
			iResult = iDice(1,20100);
			if ((iResult >= 1) && (iResult <=  5000)) iItemID = 308 ;		    // MagicNecklace(MS10)
			else if ((iResult > 5000) && (iResult <=  10000)) iItemID = 259 ;	// MagicWand(M.Shield)
			else if ((iResult > 10000) && (iResult <= 13000))  iItemID = 337 ;  // RubyRing
			else if ((iResult > 13000) && (iResult <= 15000))  iItemID = 335 ;  // EmeraldRing
			else if ((iResult > 15000) && (iResult <= 17500))  iItemID = 300 ;  // MagicNecklace(RM10)
			else if ((iResult > 17500) && (iResult <= 18750))  iItemID = 311 ;  // MagicNecklace(DF+10)
			else if ((iResult > 18750) && (iResult <= 19000))  iItemID = 305 ;  // MagicNecklace(DM+1)
			else if ((iResult > 19000) && (iResult <= 19700))  iItemID = 634 ;  // RingofWizard
			else if ((iResult > 19700) && (iResult <= 19844))  iItemID = 635 ;  // RingofMage
			else if ((iResult > 19844) && (iResult <= 19922))  iItemID = 643 ;  // KnecklaceOfIceEle	
			else if ((iResult > 19922) && (iResult <= 19961))  iItemID = 640 ;  // KnecklaceOfSufferent
			else if ((iResult > 19961) && (iResult <= 19981))  iItemID = 637 ;  // KnecklaceOfLightPro
			else if ((iResult > 19981) && (iResult <= 19991))  iItemID = 620 ;  // MerienShield	
			else if ((iResult > 19991) && (iResult <= 19996))  iItemID = 644 ;  // KnecklaceOfAirEle	
			else if ((iResult > 19996) && (iResult <= 19999))  iItemID = 614 ;  // SwordofIceElemental	
			else if ((iResult > 19999) && (iResult <= 20000))  iItemID = 636 ;	// RingofGrandMage
			else if ((iResult > 20001) && (iResult <= 20100))  iItemID = 280; // Pandora's Box
			return TRUE;
		
		case 50: // Tigerworm
			iResult = iDice(1,10050);
			if ((iResult >= 1) && (iResult <= 4999)) {
				if (iDice(1,2) == 1) 
					 iItemID = 311 ;  // MagicNecklace(DF+10)
				else iItemID = 305 ;  // MagicNecklace(DM+1)
			}
			else if ((iResult > 5000) && (iResult <= 7499))  iItemID = 614 ;  // SwordofIceElemental	
			else if ((iResult > 7500) && (iResult <= 8749))  iItemID = 290 ;  // Flameberge+3(LLF)
			else if ((iResult > 8750) && (iResult <= 9374))  iItemID = 633 ;  // RingofDemonpower
			else if ((iResult > 9375) && (iResult <= 9687))  iItemID = 492 ;  // BloodRapier		
			else if ((iResult > 9688) && (iResult <= 9843))  iItemID = 490 ;  // BloodSword		
			else if ((iResult > 9844) && (iResult <= 9921))  iItemID = 491 ;  // BloodAxe		
			else if ((iResult > 9922) && (iResult <= 9960))  iItemID = 291 ;  // MagicWand(MS30-LLF)	
			else if ((iResult > 9961) && (iResult <= 9980))  iItemID = 630 ;  // RingoftheXelima	
			else if ((iResult > 9981) && (iResult <= 9990))  iItemID = 612 ;  // XelimaRapier	
			else if ((iResult > 9991) && (iResult <= 9996))  iItemID = 610 ;  // XelimaBlade	
			else if ((iResult > 9996) && (iResult <= 9998))  iItemID = 611 ;  // XelimaAxe	
			else if ((iResult > 9999) && (iResult <= 10000)) iItemID = 631 ;  // RingoftheAbaddon
			else if ((iResult > 10001) && (iResult <= 10050)) iItemID = 631;  // Pandora's Box
			return TRUE;

			default:
		   break; 
		}

	if (iDice(1,45) == 13) {
		switch (sNpcType) {
		case 11: if (iDice(1,550) != 11) return FALSE; break;	  // Skeleton   2 * 100	
		case 12: if (iDice(1,400) != 11) return FALSE; break;	  // Stone-Golem 2 * 100	
		case 13: if (iDice(1,100) != 11) return FALSE; break;	  // Cyclops  6 * 100	
		case 14: if (iDice(1,700) != 11) return FALSE; break;	  // Orc 4 * 100	
		case 17: if (iDice(1,600) != 11) return FALSE; break;	  // Scorpoin 5 * 100	
		case 18: if (iDice(1,850) != 11) return FALSE; break;	  // Zombie 1 * 100	
		case 22: if (iDice(1,600) != 11) return FALSE; break;	  // Amphis 5 * 100	
		case 23: if (iDice(1,400) != 11) return FALSE; break;	  // Clay-Golem 2 * 100	
		case 27: if (iDice(1,100) != 11) return FALSE; break;	  // Hellhound 7 * 100	
		case 28: if (iDice(1,100) != 11) return FALSE; break;	  // Troll 5 * 100	
		case 29: if (iDice(1,150) != 11) return FALSE; break;	  // Orge  7 * 100	
		case 30: if (iDice(1,120) != 11) return FALSE; break;	  // Liche 1 * 100   
		case 31: break; 	                                      // Demon 5 * 100	
		case 32: if (iDice(1,200) != 11) return FALSE; break;	  // Unicorn 5 * 100	
		case 33: if (iDice(1,300) != 11) return FALSE; break;	  // WereWolf 7 * 100
		case 48: if (iDice(1,100) != 11) return FALSE; break;	  // Stalker 
		case 52: if (iDice(1,300) != 11) return FALSE; break;     // Gagoyle
		case 53: if (iDice(1,500) != 11) return FALSE; break;	  // Beholder
		case 54: if (iDice(1,200) != 11) return FALSE; break;	  // Dark-Elf
		case 57: if (iDice(1,400) != 11) return FALSE; break;	  // Giant-Frog
		case 63: if (iDice(1,300) != 11) return FALSE; break;	  // Frost
		case 79: if (iDice(1,200) != 11) return FALSE; break;	  // Nizie
		case 70: if (iDice(1,200) != 11) return FALSE; break;	  // Barlog
		case 71: if (iDice(1,200) != 11) return FALSE; break;	  // Centaurus
		default: return FALSE;
		}
	}
	else return FALSE;

if (iDice(1,10000) <= m_iRareDropRate) { // MORLA 2.6 - Rare droops
	switch (sNpcType) {
	case 11: // Skeleton
	case 17: // Scorpoin
	case 14: // Orc
	case 28: // Troll
	case 57: // Giant-Frog
		switch (iDice(1,7)) {
		case 1: iItemID = 334 ; break; // LuckyGoldRing
		case 2: iItemID = 336 ; break; // SapphireRing
		case 3: if (iDice(1,15) == 3) iItemID = 335 ; break; // EmeraldRing
		case 4: iItemID = 337 ; break; // RubyRing
		case 5: iItemID = 333 ; break; // PlatinumRing
		case 6: if (iDice(1,15) == 3) iItemID = 634 ; break; // RingofWizard
		case 7: if (iDice(1,25) == 3) iItemID = 635 ; break; // RingofMage
		}
		break;
	
	case 13: // Cyclops
	case 27: // Hellhound
	case 29: // Orge
		switch (iDice(1,7)) {
		case 1: iItemID = 311 ; break; // MagicNecklace(DF+10)
		case 2: if (iDice(1,20) == 13) iItemID = 308 ; break; // MagicNecklace(MS10)
		case 3: if (iDice(1,10) == 13) iItemID = 305 ; break; // MagicNecklace(DM+1)
		case 4: iItemID = 300 ; break; // MagicNecklace(RM10)
		case 5: if (iDice(1,30) == 13) iItemID = 632 ; break; // RingofOgrepower
		case 6: if (iDice(1,30) == 13) iItemID = 637 ; break; // KnecklaceOfLightPro
		case 7: if (iDice(1,30) == 13) iItemID = 638 ; break; // KnecklaceOfFirePro
		}
		break;

	case 18: // Zombie
	case 22: // Amphis
		switch (iDice(1,4)) {
		case 1: if (iDice(1,75) == 13) iItemID = 613 ; break; // SwordofMedusa
		case 2: if (iDice(1,20) == 13) iItemID = 639 ; break; // KnecklaceOfPoisonPro
		case 3: if (iDice(1,40) == 13) iItemID = 641 ; break; // KnecklaceOfMedusa
		case 4: if (iDice(1,30) == 13) iItemID = 640 ; break; // KnecklaceOfSufferent
		}
		break;

	case 12: // Stone-Golem
		switch (iDice(1,5)) {
		case 1: if (iDice(1,40) == 13) iItemID = 620 ; break; // MerienShield
		case 2: if (iDice(1,40) == 13) iItemID = 621 ; break; // MerienPlateMail(M)
		case 3: if (iDice(1,40) == 13) iItemID = 622 ; break; // MerienPlateMail(W)
		case 4: if (iDice(1,20) == 11) iItemID = 644 ; break; // KnecklaceOfAirEle
		case 5: if (iDice(1,20) == 11) iItemID = 647 ; break; // KnecklaceOfStoneGolem
		}
		break;

	case 23: // Clay-Golem
		switch (iDice(1,4)) {
		case 1: if (iDice(1,40) == 13) iItemID = 620 ; break; // MerienShield	
		case 2: if (iDice(1,40) == 13) iItemID = 621 ; break; // MerienPlateMail(M)
		case 3: if (iDice(1,40) == 13) iItemID = 622 ; break; // MerienPlateMail(W)
		case 4: if (iDice(1,20) == 11) iItemID = 644 ; break; // KnecklaceOfAirEle
		}
		break;

	case 32: // Unicorn
		switch (iDice(1,5)) {
		case 1: if (iDice(1,40) == 13) iItemID = 620 ; break; // MerienShield	
		case 2: if (iDice(1,40) == 13) iItemID = 621 ; break; // MerienPlateMail(M)
		case 3: if (iDice(1,40) == 13) iItemID = 622 ; break; // MerienPlateMail(W)
		case 4: if (iDice(1,20) == 11) iItemID = 644 ; break; // KnecklaceOfAirEle
		case 5: if (iDice(1,20) == 11) iItemID = 848 ; break; // Lighting Blade
		}
		break;
		
	case 33: // WereWolf
	case 48: // Stalker
		switch (iDice(1,2)) {
		case 1: if (iDice(1,30) == 3) iItemID = 290 ; break; // Flameberge+3(LLF)
		case 2: iItemID = 292 ; break; // GoldenAxe(LLF)
		}
		break;

	case 30: // Liche
		switch (iDice(1,8)) {
		case 1: if (iDice(1,10) == 3) iItemID = 380 ; break; // IceStormManual
		case 2: iItemID = 259 ; break; // MagicWand(M.Shield)
		case 3: if (iDice(1,30) == 3) iItemID = 291 ; break; // MagicWand(MS30-LLF)
		case 4: if (iDice(1,10) == 3) iItemID = 614 ; break; // SwordofIceElemental	
		case 5: if (iDice(1,10) == 3) iItemID = 642 ; break; // KnecklaceOfIcePro
		case 6: if (iDice(1,15) == 3) iItemID = 643 ; break; // KnecklaceOfIceEle	
		case 7: if (iDice(1,30) == 3) iItemID = 636 ; break; // RingofGrandMage
		case 8: if (iDice(1,30) == 3) iItemID = 734 ; break; // RingOfArcmage
		}
		break;

	case 31: // Demon 
		switch (iDice(1,8)) {
		case 1: if (iDice(1,30) == 3) iItemID = 382 ; break; // BloodyShockW.Manual
		case 2: iItemID = 491 ; break; // BloodAxe
		case 3: if (iDice(1,10) == 3) iItemID = 490 ; break; // BloodSword
		case 4: iItemID = 492 ; break; // BloodRapier
		case 5: if (iDice(1,10) == 3) iItemID = 381 ; break; // MassFireStrikeManual
		case 6: if (iDice(1,30) == 3) iItemID = 633 ; break; // RingofDemonpower
		case 7: if (iDice(1,10) == 3) iItemID = 645 ; break; // KnecklaceOfEfreet
		case 8: if (iDice(1,20) == 3) iItemID = 616 ; break; // DemonSlayer
		}
		break;

	case 52: // Gagoyle
		switch (iDice(1,12)) {
		case 1: if (iDice(1,30) == 3) iItemID = 382 ; break; // BloodyShockW.Manual	
		case 2: if (iDice(1,20) == 3) iItemID = 610 ; break; // XelimaBlade	
		case 3: if (iDice(1,20) == 3) iItemID = 611 ; break; // XelimaAxe	
		case 4: if (iDice(1,20) == 3) iItemID = 612 ; break; // XelimaRapier
		case 5: if (iDice(1,10) == 3) iItemID = 381 ; break; // MassFireStrikeManual
		case 6: if (iDice(1,30) == 3) iItemID = 633 ; break; // RingofDemonpower
		case 7: if (iDice(1,10) == 3) iItemID = 645 ; break; // KnecklaceOfEfreet
		case 8: if (iDice(1,40) == 3) iItemID = 630 ; break; // RingoftheXelima	
		case 9: if (iDice(1,50) == 3) iItemID = 631 ; break; // RingoftheAbaddon
		case 10: if (iDice(1,20) == 3) iItemID = 735; break; // RingOfDragonpower
		case 11: if (iDice(1,40) == 3) iItemID = 20 ; break; // Excalibur
		case 12: if (iDice(1,60) == 3) iItemID = 846; break; // The_Devastator
		}
		break;

	case 53: // Beholder
		if (iDice(1,20) == 11) iItemID = 646;  // KnecklaceOfBeholder
		break; 
		

	case 54: // Dark-Elf
		if (iDice(1,20) == 11) iItemID = 618;  // DarkElfBow
		break; 
		

	case 63: // Frost
		if (iDice(1,40) == 11) iItemID = 845;  // StormBringer
		break; 
		

	case 79: // Nizie
		if (iDice(1,20) == 11) iItemID = 845;  // StormBringer	
		break;  
		

	case 70: // Barlog
		if (iDice(1,40) == 11) iItemID = 846;  // The_Devastator
		break;  
		

	case 71: // Centaurus
		if (iDice(1,20) == 11) iItemID = 848;  // Lighting Blade
		break; 
		

	} }

	if (iItemID == 0) 
		return FALSE; 
	else return TRUE; 
	}
}



BOOL CGame::_bCheckCharacterData(int iClientH)
{
 int i;
 int iTotalPoints;

	if (((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr) > m_sCharStatLimit) || (m_pClientList[iClientH]->m_iVit > m_sCharStatLimit) || ((m_pClientList[iClientH]->m_iDex+m_pClientList[iClientH]->m_iAngelicDex) > m_sCharStatLimit) ||
        ((m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag) > m_sCharStatLimit) || ((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt) > m_sCharStatLimit) || (m_pClientList[iClientH]->m_iCharisma > m_sCharStatLimit)) {
		wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) stat points are greater then server accepts.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}
			

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];
		if ((iTotalPoints-21 > m_sCharSkillLimit) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) - has more than allowed skill points (%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, iTotalPoints);
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}

	if ((strcmp(m_pClientList[iClientH]->m_cLocation, "elvine") != 0) && 
		(strcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter") != 0) && 
		(strcmp(m_pClientList[iClientH]->m_cLocation, "arehunter") != 0) && 
		(strcmp(m_pClientList[iClientH]->m_cLocation, "aresden") != 0) &&
		(m_pClientList[iClientH]->m_iLevel >= 20) &&
		(m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		wsprintf(G_cTxt, "Traveller Hack: (%s) Player: (%s) is a traveller and is greater than level 19.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}

	if ((m_pClientList[iClientH]->m_iLevel > m_iPlayerMaxLevel) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) level above max server level.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}

	if (m_pClientList[iClientH]->m_iExp < 0) {
		wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) experience is below 0 - (Exp:%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iExp);
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}

	if ((m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) HP: current/maximum (%d/%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iHP, iGetMaxHP(iClientH));
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}

	if ((m_pClientList[iClientH]->m_iMP > iGetMaxMP(iClientH)) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) MP: current/maximum (%d/%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iMP, iGetMaxMP(iClientH));
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}

	if ((m_pClientList[iClientH]->m_iSP > iGetMaxSP(iClientH)) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) SP: current/maximum (%d/%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iSP, iGetMaxSP(iClientH));
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}

	for (i = 0; i < DEF_MAXBANNED; i++) {
		if(strlen(m_stBannedList[i].m_cBannedIPaddress) == 0) break; //No more GM's on list
		if ((strlen(m_stBannedList[i].m_cBannedIPaddress)) == (strlen(m_pClientList[iClientH]->m_cIPaddress))) {
			if(memcmp(m_stBannedList[i].m_cBannedIPaddress, m_pClientList[iClientH]->m_cIPaddress, strlen(m_pClientList[iClientH]->m_cIPaddress)) == 0){
				wsprintf(G_cTxt,"Client Rejected: Banned: (%s)", m_pClientList[iClientH]->m_cIPaddress);
				PutLogList(G_cTxt);
				return FALSE;
			}
			else {

			}
		}
	}

	return TRUE;
}

/*********************************************************************************************************************
**  void CGame::GlobalEndHeldenianMode()																			**
**  description		:: Called by admin command, or winning condition			                        			**
**             		:: Type 1: Last Tower destroyed																	**
**					:: Type 2: ???																					**
*********************************************************************************************************************/
void CGame::GlobalEndHeldenianMode()
{char * cp, cData[32];
	DWORD * dwp;
	if (m_cHeldenianWinner == -1) return;
	if (m_bIsHeldenianMode == FALSE) return;
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_ENDHELDENIAN;
	cp++;
	dwp = (DWORD *)cp;
	*dwp = m_dwHeldenianGUID;
	cp += 4;
	dwp = (DWORD *)cp;
	*dwp = (int)m_cHeldenianWinner;
	cp += 4;
	bStockMsgToGateServer(cData, 9);
	LocalEndHeldenianMode(m_dwHeldenianGUID, (int)m_cHeldenianWinner);
}

/*********************************************************************************************************************
**  void CGame::LocalEndHeldenianMode(DWORD dwHeldenianGUID, int iWinner)											**
**  description		:: Called by global end or Gate if global end commes from another gserver             			**
**             		:: & writes the GUID file																		**
**					::																								**
*********************************************************************************************************************/
void CGame::LocalEndHeldenianMode(DWORD dwHeldenianGUID, int iWinner)
{	if (m_bIsHeldenianMode == FALSE) return;
	wsprintf(G_cTxt, "(!) Received LocalEndHeldenian. (Winner %d)", iWinner);
	PutLogList(G_cTxt);
	m_bIsHeldenianMode		 = FALSE;
	m_bHeldenianWarInitiated = FALSE;	
	m_cHeldenianWinner		 = iWinner;
	m_sLastHeldenianWinner	 = iWinner;	
	m_dwHeldenianFinishTime   = 0;
	m_dwHeldenianWarStartTime = 0; 
	_CreateHeldenianGUID(m_dwHeldenianGUID, m_cHeldenianWinner);
	
int m;	
 int j, n;
	for (j = 0; j < DEF_MAXCLIENTS; j++)
	{	if (m_pClientList[j] == NULL)					 continue;
		if (m_pClientList[j]->m_bIsInitComplete != TRUE) continue;
		SendNotifyMsg(NULL, j, DEF_NOTIFY_HELDENIANEND, NULL, NULL, NULL, NULL);
		// DEF_NOTIFY_HELDENIANVICTORY used at XP time
		m_pClientList[j]->m_cWarType = 0; // Client has been informed, he'll get XP
	}
	for (m = 0; m < DEF_MAXMAPS; m++)
	{	if (m_pMapList[m] == NULL) break;		
		if (m_pMapList[m]->m_bIsHeldenianMap == TRUE) 
		{	for (j = 0; j < DEF_MAXCLIENTS; j++)
			{	if (m_pClientList[j] == NULL)					 continue;
				if (m_pClientList[j]->m_bIsInitComplete != TRUE) continue;
				if (m_pClientList[j]->m_cMapIndex != m)			 continue;
				SendNotifyMsg(NULL, j, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL);
				RequestTeleportHandler(j, "1   ", NULL, -1, -1);
			}
			for (n = 0; n < DEF_MAXNPCS; n++)
			{	if (   (m_pNpcList[n] != NULL) && (m_pMapList[m_pNpcList[n]->m_cMapIndex] != NULL) 
					&& (m_pNpcList[n]->m_cMapIndex == m))
				{	if (m_pNpcList[n]->m_bIsSummoned == TRUE) 
					{	RemoveEventNpc(n); 
					}else
					{	m_pNpcList[n]->m_cSide = m_pNpcList[n]->m_cOriginalSide; // All mobs become agressive again
			}	}	}
			RemoveOccupyFlags(m);
	}	}
	wsprintf(G_cTxt,"(!) Heldenian Mode OFF.");
	PutLogList(G_cTxt);
	PutLogList(" ");
}



/*********************************************************************************************************************
**  BOOL CGame::RemoveOccupyFlags(int iMapIndex)																	**
**  description		:: Removes all occupy flags from given map										       			**
**             		:: 																								**
**	Called at Heldenian begin and Heldenian end...																	**
*********************************************************************************************************************/
void CGame::RemoveOccupyFlags(int iMapIndex)
{DWORD dwTime = timeGetTime();
 int i;
 short dX, dY;
 int iDynamicObjectIndex;
 class CTile * pTile;
 int iy, ix;
	if (m_pMapList[iMapIndex] == NULL) return;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++) 
	{	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] == NULL)
		{	continue;
		}else // remove this OccupyFlag
		{	dX = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX;
			dY = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY;
			iDynamicObjectIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iDynamicObjectIndex;
			m_pMapList[iMapIndex]->m_pOccupyFlag[i] = NULL;			
			m_pMapList[iMapIndex]->m_iTotalOccupyFlags--;

			pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + dX + dY*m_pMapList[iMapIndex]->m_sSizeY);
			if (m_pDynamicObjectList[iDynamicObjectIndex] == NULL) continue;
			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT
				, iMapIndex, dX, dY, m_pDynamicObjectList[iDynamicObjectIndex]->m_sType
				, iDynamicObjectIndex, NULL);
			m_pMapList[iMapIndex]->SetDynamicObject(NULL, NULL, dX, dY, dwTime);

			if (m_pDynamicObjectList[iDynamicObjectIndex] == NULL) 
			{	for (ix = dX - 2; ix <= dX + 2; ix++)
				for (iy = dY - 2; iy <= dY + 2; iy++) 
				{	pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + ix + iy*m_pMapList[iMapIndex]->m_sSizeY);
					pTile->m_sOwner = NULL;
	}	}	}	}
 int j;
	for (i = 0; i < m_pMapList[iMapIndex]->m_sSizeX; i++) // Then remove all m_iOccupyStatus
	for (j = 0; j < m_pMapList[iMapIndex]->m_sSizeY; j++)  	
	{	pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + i + j*m_pMapList[iMapIndex]->m_sSizeY);
		pTile->m_iOccupyStatus = 0; 
	}
}

/*********************************************************************************************************************
**  void CGame::_CreateHeldenianGUID(DWORD dwHeldenianGUID, int iWinnerSide)										**
**  description		:: Create GUID file at event's strating, & finishing for each server	              			**
**             		:: Used when server starts																		**
**																													**
*********************************************************************************************************************/
void CGame::_CreateHeldenianGUID(DWORD dwHeldenianGUID, int iWinnerSide)
{char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"HeldenianGUID.Txt");		
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) 
	{	wsprintf(G_cTxt, "(!) Cannot create HeldenianGUID (%s) file.", dwHeldenianGUID);
		PutLogList(G_cTxt);
	}else 
	{	ZeroMemory(cTemp, sizeof(cTemp));		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "HeldenianGUID = %d\n", dwHeldenianGUID);
		strcat(cTemp, cTxt);
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);		
		wsprintf(G_cTxt, "(!) HeldenianGUID (%d) file created. (Winner %d)", dwHeldenianGUID, iWinnerSide);
		PutLogList(G_cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}

/*********************************************************************************************************************
**  BOOL CGame::bCheckHeldenianMap(int sAttackerH, int iMapIndex, char cType)										**
**  description			:: checks if the player is in the specified map												**
**  last updated		:: November 22, 2004; 6:19 PM; Hypnotoad													**
**	return value		:: BOOL																						**
**  commentary			::	-	translated from scratch using IDA Pro												**
**						::	-	changed pTile->m_cOwner to m_iOccupyStatus											**
**						::	-	added check to prevent access violation if pTile == NULL							**
**						::	-	removed 4 return(s) after "iRet = 1;" and placed at end								**
*********************************************************************************************************************/
BOOL CGame::bCheckHeldenianMap(int sAttackerH, char cType) 
{	if (m_bHeldenianWarInitiated == FALSE) return FALSE;
 short tX, tY;
 BOOL iRet;
 int  iMapIndex;
 class CTile * pTile;
	iRet = FALSE;
	if (cType == DEF_OWNERTYPE_PLAYER) 
	{	if (m_pClientList[sAttackerH] == NULL)					return FALSE;
		if (m_pClientList[sAttackerH]->m_cSide < 1)				return FALSE;
		if (m_pClientList[sAttackerH]->m_cSide > 2)				return FALSE;
		iMapIndex = m_pClientList[sAttackerH]->m_cMapIndex;
		if (m_pMapList[iMapIndex]->m_bIsHeldenianMap != TRUE)	return FALSE;
		if (m_iGodHMapIndex  == iMapIndex)						return FALSE;
		tX = m_pClientList[sAttackerH]->m_sX;
		tY = m_pClientList[sAttackerH]->m_sY;
		if (   (tX <= 0) || (tX >= m_pMapList[iMapIndex]->m_sSizeX) 
			|| (tY <= 0) || (tY >= m_pMapList[iMapIndex]->m_sSizeY)) return FALSE;
		pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + tX + tY*m_pMapList[iMapIndex]->m_sSizeY);
		if (pTile == NULL) return FALSE;
		if (pTile->m_iOccupyStatus != NULL) 
		{	if (pTile->m_iOccupyStatus < 0) 
			{	if (m_pClientList[sAttackerH]->m_cSide == 1) 
				{	iRet = TRUE;
				}
			}else if (pTile->m_iOccupyStatus > 0) 
			{	if (m_pClientList[sAttackerH]->m_cSide == 2) 
				{	iRet = TRUE;
		}	}	}		
	}else if (cType == DEF_OWNERTYPE_NPC) 
	{	if (m_pNpcList[sAttackerH] == NULL)						return FALSE;
		if (m_pNpcList[sAttackerH]->m_cSide < 1)				return FALSE;
		if (m_pNpcList[sAttackerH]->m_cSide > 2)				return FALSE;
		iMapIndex = m_pNpcList[sAttackerH]->m_cMapIndex;
		if (m_pMapList[iMapIndex]->m_bIsHeldenianMap != TRUE)	return FALSE;	
		if (m_iGodHMapIndex  == iMapIndex)						return FALSE;
		tX = m_pNpcList[sAttackerH]->m_sX;
		tY = m_pNpcList[sAttackerH]->m_sY;
		if (   (tX <= 0) || (tX >= m_pMapList[iMapIndex]->m_sSizeX) 
			|| (tY <= 0) || (tY >= m_pMapList[iMapIndex]->m_sSizeY)) return FALSE;
		pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + tX + tY*m_pMapList[iMapIndex]->m_sSizeY);
		if (pTile == NULL) return FALSE;
		if (pTile->m_iOccupyStatus != NULL) 
		{	if (pTile->m_iOccupyStatus < 0) 
			{	if (m_pNpcList[sAttackerH]->m_cSide == 1) 
				{	iRet = TRUE;
				}
			}else if (pTile->m_iOccupyStatus > 0) 
				{	if (m_pNpcList[sAttackerH]->m_cSide == 2) 
				{	iRet = TRUE;
	}	}	}	}
	return iRet;
}

/*********************************************************************************************************************
**  BOOL CGame::RequestHeldenianTeleportList(int iClientH, char * pData, DWORD dwMsgSize)							**
**  description		:: A player requested to go Heldenian maps...										 			**
*********************************************************************************************************************/
void CGame::RequestHeldenianTeleportList(int iClientH, char * pData, DWORD dwMsgSize)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	if (m_pClientList[iClientH]->m_iLockedMapTime != NULL) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);
		return;
	}
	// Prevent hack use in target maps
	if ((m_iBTFieldMapIndex != -1)    && (m_pClientList[iClientH]->m_cMapIndex == m_iBTFieldMapIndex)   ) return;
	if ((m_iGodHMapIndex != -1)       && (m_pClientList[iClientH]->m_cMapIndex == m_iGodHMapIndex)      ) return;
char	*cp, cData[512];
int		iRet;
DWORD	*dwp;
WORD	*wp;
int		*listCount;
char	cNpcName[21];
int		*ip;
int		index = 0;
int		m_iDestinationX, m_iDestinationY, m_iCost;
char	m_cTargetMap[11];
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cNpcName, sizeof(cNpcName));
	strncpy(cNpcName, cp, 20);
	cp += 20;
	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_HELDENIAN_TP_LIST;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	cp = cData + 6;
	listCount = (int*) cp; 
	*listCount = 0;
	cp += 4; // sizeof(int)
	// Message must be sent by Gail...
	if (strcmp(cNpcName, "Gail") != 0) return;
	if (   (m_bIsHeldenianMode == TRUE) 
		&& (m_pClientList[iClientH]->m_bIsPlayerCivil != TRUE) 
		&& (m_cHeldenianWinner == -1) // Not possible to TP if already won
		&& ((m_pClientList[iClientH]->m_cSide == 2) || (m_pClientList[iClientH]->m_cSide ==1) )) 
	{	if (m_cHeldenianType == 2) 
		{	ZeroMemory(m_cTargetMap, sizeof(m_cTargetMap));	
			memcpy(m_cTargetMap, "HRampart", 8);
			if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) 
			{	m_iDestinationX = 81;
				m_iDestinationY = 42;
				m_iCost			= 0;	
				index			= 3;			
			}else 
			{	m_iDestinationX = 156;
				m_iDestinationY = 153;
				m_iCost			= 0;	
				index			= 4;	
			}
		}else // Players can go fight Heldenian
		{	ZeroMemory(m_cTargetMap, sizeof(m_cTargetMap));	
			memcpy(m_cTargetMap, "BtField", 7);
			if (m_pClientList[iClientH]->m_cSide == 1) 
			{	m_iDestinationX = 68;
				m_iDestinationY = 225;
				m_iCost = 0;
				index = 1;
			}else 
			{	m_iDestinationX = 202;
				m_iDestinationY = 70;
				m_iCost = 0;
				index = 2;		
		} 	}
		ip = (int*) cp;
		*ip = index;
		cp += 4;
		memcpy(cp, m_cTargetMap, 10);
		cp += 10;
		ip = (int*) cp;
		*ip = m_iDestinationX;
		cp += 4;
		ip = (int*) cp;
		*ip = m_iDestinationY;
		cp += 4;
		ip = (int*) cp;
		*ip = m_iCost;
		cp += 4;
		(*listCount) ++;
	}
	if (   (m_bIsHeldenianMode == FALSE) 
		&& (m_pClientList[iClientH]->m_bIsPlayerCivil != TRUE) 
		&& (m_sLastHeldenianWinner ==  m_pClientList[iClientH]->m_cSide)) 
// Winners of previous Heldenian can go to BattleField all the time
	{	ZeroMemory(m_cTargetMap, sizeof(m_cTargetMap));			
		memcpy(m_cTargetMap, "BtField", 7);
		if (m_pClientList[iClientH]->m_cSide == 1) 
		{	m_iDestinationX = -1;
			m_iDestinationY = -1;
			m_iCost			= 4000;	
			index			= 11;
		}else  
		{	m_iDestinationX = -1;
			m_iDestinationY = -1;
			m_iCost			= 4000;
			index			= 12;
		}
		ip = (int*) cp;
		*ip = index;
		cp += 4;
		memcpy(cp, m_cTargetMap, 10);
		cp += 10;
		ip = (int*) cp;
		*ip = m_iDestinationX;
		cp += 4;
		ip = (int*) cp;
		*ip = m_iDestinationY;
		cp += 4;
		ip = (int*) cp;
		*ip = m_iCost;
		cp += 4;
		(*listCount) ++;
		ZeroMemory(m_cTargetMap, sizeof(m_cTargetMap));			
		memcpy(m_cTargetMap, "middleland", 10);
		m_iDestinationX = 388+iDice(1,10);
		m_iDestinationY = 262+iDice(1,10);
		m_iCost			= 1000;
		index			= 10;
		ip = (int*) cp;
		*ip = index;
		cp += 4;
		memcpy(cp, m_cTargetMap, 10);
		cp += 10;
		ip = (int*) cp;
		*ip = m_iDestinationX;
		cp += 4;
		ip = (int*) cp;
		*ip = m_iDestinationY;
		cp += 4;
		ip = (int*) cp;
		*ip = m_iCost;
		cp += 4;
		(*listCount) ++;
	}
	if ( (*listCount) == 0 )*wp  = DEF_MSGTYPE_REJECT;
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10 + (*listCount) * 26 );
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}
/*********************************************************************************************************************
**  BOOL CGame::RequestHeldenianTeleportNow(int iClientH, char * pData, DWORD dwMsgSize)							**
**  description		:: Suposed to be free TP to ML for heldenian winners								 			**
**  TP is available from Gail, here, but winner TP is also available at CH for higher price							**
*********************************************************************************************************************/
void CGame::RequestHeldenianTeleportNow(int iClientH, char * pData, DWORD dwMsgSize)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
int		m_iDestinationX, m_iDestinationY, m_iCost;
char	m_cTargetMap[11];
ZeroMemory(m_cTargetMap, sizeof(m_cTargetMap));	
	char	*cp, cData[64];
	int		iRet;
	DWORD	*dwp;
	WORD	*wp;
	int		index;
	WORD	wConfirm = DEF_MSGTYPE_CONFIRM;
	short	sError = 0;
	// CHARGED_TELEPORT index
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	index = (int) (*cp);
	cp += 4;
	switch (index) {
	default: // Other Heldenian TP  (hack?)
		wConfirm = DEF_MSGTYPE_REJECT;
		sError = 7;
		break;
	case 1: // Ares TP to BtField, Heldenian time	
		if ((m_bIsHeldenianMode == FALSE) || (m_cHeldenianType != 1))			
		{	wConfirm = DEF_MSGTYPE_REJECT;
			sError = 7;
		}else
		{	memcpy(m_cTargetMap, "BtField", 7);
			m_iDestinationX = 68;
			m_iDestinationY = 225;
			m_iCost = 0;
		}
		break;
	case 2: // Elvi TP to BtField, Heldenian time	
		if ((m_bIsHeldenianMode == FALSE) || (m_cHeldenianType != 1))	
		{	wConfirm = DEF_MSGTYPE_REJECT;
			sError = 7;
		}else
		{	memcpy(m_cTargetMap, "BtField", 7);
			m_iDestinationX = 202;
			m_iDestinationY = 70;
			m_iCost = 0;
		}		
		break;
	case 3: // Winners TP to Rampart, Heldenian time
	case 4: // Loosers TP to Rampart, Heldenian time	
		if ((m_bIsHeldenianMode == FALSE) || (m_cHeldenianType != 2))
		{	wConfirm = DEF_MSGTYPE_REJECT;
			sError = 7;
		}else
		{	memcpy(m_cTargetMap, "HRampart", 8);				
			if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) 
			{	m_iDestinationX = 81;
				m_iDestinationY = 42;
				m_iCost			= 0;			
			}else 
			{	m_iDestinationX = 156;
				m_iDestinationY = 153;
				m_iCost			= 0;		
		}	}
		break;	
	case 10: // Winner TP to ML (near TOH)		
		if (   (m_bIsHeldenianMode == TRUE) 
			|| (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE) 
			|| (m_sLastHeldenianWinner !=  m_pClientList[iClientH]->m_cSide)) 
		{	wConfirm = DEF_MSGTYPE_REJECT;
			sError = 7;
		}else
		{	memcpy(m_cTargetMap, "middleland", 10);				
			m_iDestinationX = 388 + iDice(1,10);
			m_iDestinationY = 262 + iDice(1,10);
			m_iCost			= 1000;			
		}
		break;
	case 11: // Winner Ares TP to BtField	
	case 12: // Winner Elvi TP to BtField
		if (   (m_bIsHeldenianMode == TRUE) 
			|| (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE) 
			|| (m_sLastHeldenianWinner !=  m_pClientList[iClientH]->m_cSide)) 	
		{	wConfirm = DEF_MSGTYPE_REJECT;
			sError = 7;
		}else
		{	memcpy(m_cTargetMap, "BtField", 7);
			if (m_pClientList[iClientH]->m_cSide == 1) 
			{	m_iDestinationX = -1;
				m_iDestinationY = -1;
				m_iCost			= 4000;	
			}else if (m_pClientList[iClientH]->m_cSide == 2) 
			{	m_iDestinationX = -1;
				m_iDestinationY = -1;
				m_iCost			= 4000;
			}else
			{	wConfirm = DEF_MSGTYPE_REJECT;
				sError = 7;
		}	}
		break;
	}
	if (wConfirm == DEF_MSGTYPE_CONFIRM )
	{	DWORD dwGoldCount = dwGetItemCount(iClientH, "Gold");
		if( dwGoldCount >= m_iCost )
		{	int iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - m_iCost);
			iCalcTotalWeight(iClientH);
			m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += m_iCost;
		}else
		{	wConfirm = DEF_MSGTYPE_REJECT;
			sError = 6;
	}	}
	// Invalid Charged-teleport
	if ( wConfirm == DEF_MSGTYPE_REJECT )
	{	ZeroMemory(cData, sizeof(cData));
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_CHARGED_TELEPORT;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wConfirm;
		cp = cData + DEF_INDEX2_MSGTYPE + 2;
		short	*sp;
		sp	= (short*) cp;
		*sp	= sError;
		cp += 2;
		// Teleport List
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6 + 2 );
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
		return;
	}
	// teleport
	RequestTeleportHandler(iClientH, "2   ", m_cTargetMap, m_iDestinationX, m_iDestinationY);	
}

/*********************************************************************************************************************
**  void CGame::GlobalStartHeldenianMode()																			**
**  description		:: Tell Gate server to ask all gservers to start Heldenian                           			**
**             		:: and starts Heldenian localy																	**
**	Called by ManualStartHeldenianMode																				**
*********************************************************************************************************************/
void CGame::GlobalStartHeldenianMode()
{char cData[120], * cp;
 DWORD dwNewHeldenianGUID, *dwp;
 WORD * wp;
	dwNewHeldenianGUID = timeGetTime();
	ZeroMemory(cData,sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_STARTHELDENIAN; // 21
	cp++;	
	wp  = (WORD *)cp;
	*wp = m_cHeldenianType;
	cp += 2;
	wp  = (WORD *)cp;
	*wp = m_sLastHeldenianWinner;
	cp += 2;
	dwp = (DWORD *)cp;
	*dwp = dwNewHeldenianGUID;
	cp += 4;
	bStockMsgToGateServer(cData, 9);
	LocalStartHeldenianMode(m_cHeldenianType, m_sLastHeldenianWinner, dwNewHeldenianGUID);				
}

/*********************************************************************************************************************
**  void CGame::LocalStartHeldenianMode(short sV1, short sV2, DWORD dwHeldenianGUID)								**
**  description		:: localy performs all required tasks upon recieving heldenian initiate message					**
**					::																								**
**	Called locally if Heldenian started from this serger, or called by gate message									**
*********************************************************************************************************************/
void CGame::LocalStartHeldenianMode(short sV1, short sV2, DWORD dwHeldenianGUID)
{int i, x, iNamingValue;
 char cName[11], cTmp[21], cNpcWaypointIndex[10], cSide, cOwnerType;
 short sOwnerH;
 BOOL bRet;
 int dX, dY;
	if (m_bIsHeldenianMode == TRUE) return;
	m_cHeldenianType		= sV1;
	m_sLastHeldenianWinner	= sV2;
	m_cHeldenianWinner		= -1;
	m_dwHeldenianGUID		= dwHeldenianGUID;
	m_bHeldenianWarInitiated = FALSE;
	_CreateHeldenianGUID(m_dwHeldenianGUID, m_sLastHeldenianWinner);
	m_iHeldenianAresdenLeftTower = 0;
	m_iHeldenianElvineLeftTower = 0;
	m_iHeldenianAresdenDead = 0;
	m_iHeldenianElvineDead = 0;
	
	// Tell that you can TP to battlefield, and about construction points
	for (i = 0; i < DEF_MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL) 
		{	if (m_pClientList[i]->m_bIsInitComplete != TRUE) break;
			m_pClientList[i]->m_cWarType = 2;
			SendNotifyMsg(NULL, i, DEF_NOTIFY_HELDENIANTELEPORT,  NULL , NULL, NULL, NULL); // You can now, go to the battle field
			m_pClientList[i]->m_dwHeldenianGUID    = m_dwHeldenianGUID;				
			m_pClientList[i]->m_iWarContribution   = 0;
			m_pClientList[i]->m_iConstructionPoint = 10000 + (m_pClientList[i]->m_iCharisma * 100);
			if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXHELDENIANSUMMONPOINT) m_pClientList[i]->m_iConstructionPoint = DEF_MAXHELDENIANSUMMONPOINT;
			m_pClientList[i]->m_cWarType = 2;// character have been informed of heldenian starting...
			SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 0, NULL); //0: Tell player of acquired points
			UpdateHeldenianStatus(i);
	}	}
	// Recall clients already on battlefield; remove any Heldenian mob, and create current war towers/gates
	for (x = 0; x < DEF_MAXMAPS; x++) 
	{	if (m_pMapList[x] == NULL) break;
		if (m_pMapList[x]->m_bIsHeldenianMap == TRUE) 
		{	RemoveOccupyFlags(x);
			for (i = 0; i < DEF_MAXCLIENTS; i++) // Tell everybody on Heldenian map and recall them
			{	if (   (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) 
					&& (m_pClientList[i]->m_cMapIndex == x)	)
				{	SendNotifyMsg(NULL, i, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL);
					RequestTeleportHandler(i, "1   ", NULL, -1, -1);
			}	}
			for (i = 0; i < DEF_MAXNPCS; i++) // Remove summons from last Heldenian
			{	if (   (m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_bIsKilled == FALSE) 
					&& (m_pNpcList[i]->m_cMapIndex == x))
				{	if (m_pNpcList[i]->m_bIsSummoned == TRUE) 
					{	RemoveEventNpc(i); 
					}else
					{	// Remove most mobs, and other Mobs become neutral
						// All mobs become neutral as players don't have spells or attacks...
						if (iDice(1,10) != 5)
						{	m_pNpcList[i]->m_bIsUnsummoned = TRUE; 	
							RemoveEventNpc(i);
						}else m_pNpcList[i]->m_cSide = 0; 
			}	}	}		
			if (m_cHeldenianType == 1) 
			{	if (strcmp(m_pMapList[x]->m_cName, "BtField") == 0) 
				{	for (i = 0; i < MAX_HELDENIANTOWER; i++) 
					{	iNamingValue = m_pMapList[x]->iGetEmptyNamingValue();
						if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID < 1)  break;
						if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID > DEF_MAXNPCTYPES) break;
						if (iNamingValue != -1) 
						{	dX = m_pMapList[x]->m_stHeldenianTower[i].dX;
							dY = m_pMapList[x]->m_stHeldenianTower[i].dY;
 							cSide = m_pMapList[x]->m_stHeldenianTower[i].cSide;
							ZeroMemory(cTmp, sizeof(cTmp));
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 87)&&(cSide == 1)) strcpy(cTmp, "CT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 87)&&(cSide == 2)) strcpy(cTmp, "CT-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 89)&&(cSide == 1)) strcpy(cTmp, "AGC-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 89)&&(cSide == 2)) strcpy(cTmp, "AGC-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 36)&&(cSide == 1)) strcpy(cTmp, "AGT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 36)&&(cSide == 2)) strcpy(cTmp, "AGT-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 37)&&(cSide == 1)) strcpy(cTmp, "CGT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 37)&&(cSide == 2)) strcpy(cTmp, "CGT-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 39)&&(cSide == 1)) strcpy(cTmp, "DT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 39)&&(cSide == 2)) strcpy(cTmp, "DT-Elvine"); 
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = i + 65;
							bRet = bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, NULL, NULL, cSide, FALSE, TRUE, FALSE, TRUE, NULL);
							if (bRet == FALSE) 
							{	m_pMapList[x]->SetNamingValueEmpty(iNamingValue);
							}else 
							{	m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[sOwnerH] != NULL) && (sOwnerH > 0) && (sOwnerH < DEF_MAXNPCS)) 
								{	m_pNpcList[sOwnerH]->m_iBuildCount = 0;								
									m_pNpcList[sOwnerH]->m_sAppr2 = 0;
									m_pNpcList[sOwnerH]->m_cSide = cSide;
								}
								if (cSide == 1)	m_iHeldenianAresdenLeftTower ++;
								if (cSide == 2) m_iHeldenianElvineLeftTower ++;
					}	}	}
					wsprintf(G_cTxt,"HeldenianAresdenLeftTower : %d , HeldenianElvineLeftTower : %d", m_iHeldenianAresdenLeftTower, m_iHeldenianElvineLeftTower);
					PutLogList(G_cTxt);
					PutLogEventFileList(G_cTxt);
					UpdateHeldenianStatus(-1);
				}
			}else if (m_cHeldenianType == 2) 
			{	// Set master flag
				if (strcmp(m_pMapList[x]->m_cName, "GodH") == 0)  
				{	__bSetOccupyFlag(x, m_pMapList[x]->m_sHeldenianWinningZoneX, m_pMapList[x]->m_sHeldenianWinningZoneY
							, m_sLastHeldenianWinner, 616, -1, TRUE); 
				}
				// Possibilty to set towers, detectors etc....
				if (strcmp(m_pMapList[x]->m_cName, "HRampart") == 0) 
				{	for (i = 0; i < MAX_HELDENIANTOWER; i++) 
					{	if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID < 1)  break;
						if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID > DEF_MAXNPCTYPES) break;
						iNamingValue = m_pMapList[x]->iGetEmptyNamingValue();						
						if (iNamingValue != -1) 
						{	dX = m_pMapList[x]->m_stHeldenianTower[i].dX;
							dY = m_pMapList[x]->m_stHeldenianTower[i].dY;
							cSide = m_sLastHeldenianWinner;
							ZeroMemory(cTmp, sizeof(cTmp));
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 87)&&(cSide == 1)) strcpy(cTmp, "CT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 87)&&(cSide == 2)) strcpy(cTmp, "CT-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 89)&&(cSide == 1)) strcpy(cTmp, "AGC-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 89)&&(cSide == 2)) strcpy(cTmp, "AGC-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 36)&&(cSide == 1)) strcpy(cTmp, "AGT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 36)&&(cSide == 2)) strcpy(cTmp, "AGT-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 37)&&(cSide == 1)) strcpy(cTmp, "CGT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 37)&&(cSide == 2)) strcpy(cTmp, "CGT-Elvine"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 39)&&(cSide == 1)) strcpy(cTmp, "DT-Aresden"); 
							if ((m_pMapList[x]->m_stHeldenianTower[i].sTypeID == 39)&&(cSide == 2)) strcpy(cTmp, "DT-Elvine"); 
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = i + 65;
							bRet = bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, NULL, NULL, cSide, FALSE, TRUE, FALSE, TRUE, NULL);
							if (bRet == FALSE) 
							{	m_pMapList[x]->SetNamingValueEmpty(iNamingValue);
							}else 
							{	m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[sOwnerH] != NULL) && (sOwnerH > 0) && (sOwnerH < DEF_MAXNPCS)) 
								{	m_pNpcList[sOwnerH]->m_iBuildCount = 0;							
									m_pNpcList[sOwnerH]->m_sAppr2 = 0;
									m_pNpcList[sOwnerH]->m_cSide = cSide;
				}	}	}	}	}
				// Set Gates
				if (strcmp(m_pMapList[x]->m_cName, "HRampart") == 0) 
				{	for (i = 0; i < DEF_MAXHELDENIANDOOR; i++) 
					{	if (m_pMapList[x]->m_stHeldenianGateDoor[i].dX < 1)  break;
						iNamingValue = m_pMapList[x]->iGetEmptyNamingValue();
						if (iNamingValue != -1) 
						{	dX = m_pMapList[x]->m_stHeldenianGateDoor[i].dX;
							dY = m_pMapList[x]->m_stHeldenianGateDoor[i].dY;
							ZeroMemory(cTmp, sizeof(cTmp));
							if (m_sLastHeldenianWinner == 1) strcpy(cTmp, "gate-a"); 
							else							 strcpy(cTmp, "gate-e"); 
							cSide = m_sLastHeldenianWinner;
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = i + 65;
							bRet = bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, NULL, NULL, m_sLastHeldenianWinner, FALSE, TRUE, FALSE, TRUE, NULL);
							if (bRet == FALSE) 
							{	m_pMapList[x]->SetNamingValueEmpty(iNamingValue);
							}else 
							{	m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[sOwnerH] != NULL) && (sOwnerH > 0) && (sOwnerH < DEF_MAXNPCS)) 
								{	m_pNpcList[sOwnerH]->m_iBuildCount = 0;
									m_pNpcList[sOwnerH]->m_cSide = cSide;
									m_pNpcList[sOwnerH]->m_cDir = m_pMapList[x]->m_stHeldenianGateDoor[i].cDir;
									wsprintf(G_cTxt,"(!) Gate installed at %d,%d", dX, dY);
									PutLogList(G_cTxt);
	}	}	}	}	}	}	}	}
	m_bIsHeldenianMode = TRUE;	
	m_dwHeldenianFinishTime   = timeGetTime() + m_dwHeldenianEndTime;  // war will end   in 1h45 
	m_dwHeldenianWarStartTime = timeGetTime() + m_dwHeldenianWarTime;  // war will start in 0h15
	wsprintf(G_cTxt,"(!) Heldenian mode ON. (type %d, last winner:%d)", m_cHeldenianType, m_sLastHeldenianWinner);
	PutLogList(G_cTxt);
	PutLogList(" ");
	PutLogEventFileList(G_cTxt);
	PutLogEventFileList(" ");
}

/*********************************************************************************************************************
**  void CGame::ManualStartHeldenianMode(int iClientH, char *pData, DWORD dwMsgSize)								**
**  description		:: Admin order to star Heldenian, starts heldenian			                        			**
**             		:: "/beginheldenian 1" or "/beginheldenian 2"													**
**	Called by Amin order																							**
*********************************************************************************************************************/
void CGame::ManualStartHeldenianMode(int iClientH, char *pData, DWORD dwMsgSize)
{char cBuff[256], * token, seps[] = "= \t\n";
 class CStrTok * pStrTok;
	if (m_bIsHeldenianMode == TRUE) return;
	if (m_bIsApocalypseMode == TRUE) return;
	if (m_bIsCrusadeMode == TRUE) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3)
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	m_cHeldenianType = 1;
	if (token != NULL) 
	{	switch (atoi(token)) {
		case 2:
			m_cHeldenianType = 2;
			break;
		default:
			m_cHeldenianType = 1;
			break;
	}	}
	if (m_sLastHeldenianWinner == 0) m_cHeldenianType = 1;
	delete pStrTok;
	wsprintf(G_cTxt,"Admin Order(%s): begin Heldenian", m_pClientList[iClientH]->m_cCharName);
	PutLogList(G_cTxt);
	GlobalStartHeldenianMode();
}

/*********************************************************************************************************************
**  void CGame::ManualEndHeldenianMode(int iClientH, char *pData, DWORD dwMsgSize)									**
**  description		:: Called by Amin order, stops heldenian					                        			**
**             		:: "/endheldenian 0" or"/endheldenian 1" or "/endheldenian 2"									**
**																													**
*********************************************************************************************************************/
void CGame::ManualEndHeldenianMode(int iClientH, char *pData, DWORD dwMsgSize)
{char	seps[] = "= \t\n";
 char	* token, cBuff[256];
 class	CStrTok * pStrTok;
	if ((dwMsgSize)	<= 0) return;	
	if (iClientH == NULL) return;	
	if (m_bIsHeldenianMode == FALSE) return;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3)
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) // draw
	{	m_cHeldenianWinner = 0;
		wsprintf(G_cTxt,"GM Order(%s): Heldenian terminated, Draw", m_pClientList[iClientH]->m_cCharName);
	}else if (token != NULL) 
	{	if (_bGetIsStringIsNumber(token) == TRUE) 
		{	switch(atoi(token)) {
			case 1:
				m_cHeldenianWinner = 1;
				wsprintf(G_cTxt,"GM Order(%s): Heldenian terminated, Aresden victory", m_pClientList[iClientH]->m_cCharName);
				break;
			case 2:
				m_cHeldenianWinner = 2;
				wsprintf(G_cTxt,"GM Order(%s): Heldenian terminated, Elvine victory", m_pClientList[iClientH]->m_cCharName);
				break;
			default:	
				m_cHeldenianWinner = 0;
				wsprintf(G_cTxt,"GM Order(%s): Heldenian terminated, Draw", m_pClientList[iClientH]->m_cCharName);
				break;
			}
		}else 
		{	m_cHeldenianWinner = 0;	
			wsprintf(G_cTxt,"GM Order(%s): Heldenian terminated, Draw", m_pClientList[iClientH]->m_cCharName);
		}
	}
	PutLogList(G_cTxt);
	GlobalEndHeldenianMode();
	delete pStrTok;
}

void CGame::AdminOrder_GetFightzoneTicket(int iClientH)
{
 int iReserveTime, iFightzoneTN, iFightzoneN;
 char cTemp[21];
 SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fightzone", 9) == 0) {
		
		iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth*10000 + SysTime.wDay*100 + (SysTime.wHour +3);  
		
		ZeroMemory(cTemp, sizeof(cTemp));
		strcpy(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName +9));
		iFightzoneN  = m_pClientList[iClientH]->m_iFightzoneNumber;
		iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
		m_pClientList[iClientH]->m_iFightzoneNumber = atoi(cTemp);
		
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		
		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
		m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
	}
	else {
		iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth*10000 + SysTime.wDay*100 + (SysTime.wHour +2);  
		
		ZeroMemory(cTemp, sizeof(cTemp));
		strcpy(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName +9));
		iFightzoneN  = m_pClientList[iClientH]->m_iFightzoneNumber;
		iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
		m_pClientList[iClientH]->m_iFightzoneNumber = 1;
		
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);

		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
		m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
	}
}

void CGame::CheckCrusadeResultCalculation(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cWarType != 1) return;

	if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_dwCrusadeGUID != 0)) {
		if (m_pClientList[iClientH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION) m_pClientList[iClientH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;	
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_iCrusadeWinnerSide == 0) {
				GetExp(iClientH, (m_pClientList[iClientH]->m_iWarContribution/6));
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);		
				_bCrusadeLog(DEF_CRUSADELOG_GETEXP, iClientH, (m_pClientList[iClientH]->m_iWarContribution/6), NULL) ;
			}
			else {
				if (m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide) {
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*100;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 100) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*40 ;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel;
					GetExp(iClientH, m_pClientList[iClientH]->m_iWarContribution);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);
					_bCrusadeLog(DEF_CRUSADELOG_GETEXP,iClientH,m_pClientList[iClientH]->m_iWarContribution,NULL) ;
				}
				else if (m_iCrusadeWinnerSide != m_pClientList[iClientH]->m_cSide) {
					m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel;
					GetExp(iClientH, (m_pClientList[iClientH]->m_iWarContribution/10));
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, -1*m_pClientList[iClientH]->m_iWarContribution, NULL);						
					_bCrusadeLog(DEF_CRUSADELOG_GETEXP,iClientH,(m_pClientList[iClientH]->m_iWarContribution/10),NULL) ;
				}
			}
		}
		else {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
		}
		m_pClientList[iClientH]->m_iCrusadeDuty     = 0;
		m_pClientList[iClientH]->m_iWarContribution = 0;
		m_pClientList[iClientH]->m_dwCrusadeGUID    = 0;
		m_pClientList[iClientH]->m_dwSpeedHackCheckTime = timeGetTime();
		m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	}
}

void CGame::CheckHeldenianResultCalculation(int iClientH)
{
 double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cWarType != 2) return;
	if ((m_cHeldenianType == 0) || (m_pClientList[iClientH]->m_dwHeldenianGUID == 0)) return;
	if (m_pClientList[iClientH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION) m_pClientList[iClientH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;
	if (m_pClientList[iClientH]->m_dwHeldenianGUID == m_dwHeldenianGUID) {
		if (m_sLastHeldenianWinner == 0) {
		}
		else if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) {
			if (m_pClientList[iClientH]->m_iLevel <= 80) {
				m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*200;
			}
			else if (m_pClientList[iClientH]->m_iLevel > 100) {
				m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*100;				
			}
			else {
				m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*30;				
			}
			dV2 = (double)m_pClientList[iClientH]->m_iExpStock;
			dV3 = (double)m_pClientList[iClientH]->m_iWarContribution*1.2;
			dV1 = dV2 + dV3;
			GetExp(iClientH, dV1);
		}
		else if (m_pClientList[iClientH]->m_cSide != m_sLastHeldenianWinner) {
			
			GetExp(iClientH, (m_pClientList[iClientH]->m_iWarContribution/5));
		}
		m_pClientList[iClientH]->m_iWarContribution = 0;
		m_pClientList[iClientH]->m_dwHeldenianGUID = 0;
		m_pClientList[iClientH]->m_dwSpeedHackCheckTime = timeGetTime();
		m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	}
}


/*********************************************************************************************************************
**  BOOL CGame::UpdateHeldenianStatus(int iClientH)																	**
**  description		:: Informs every client of the progression of the battle (Type 1 Heldenian)	           			**
**             		:: give -1 as parameter to inform everybody on BtField.											**
**					:: give iClientH to inform only one client														**
*********************************************************************************************************************/
BOOL CGame::UpdateHeldenianStatus(int iClientH)
{	if (m_bIsHeldenianMode == FALSE)  return FALSE;
	if (m_cHeldenianType != 1)		  return FALSE; 
	if (iClientH != -1) 
	{	if (   (m_pClientList[iClientH] != NULL) 
			&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) 
			&& (m_pClientList[iClientH]->m_cMapIndex == m_iBTFieldMapIndex)) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANCOUNT, m_iHeldenianAresdenLeftTower
							, m_iHeldenianElvineLeftTower, m_iHeldenianAresdenFlags, NULL, m_iHeldenianElvineFlags
							, m_iHeldenianAresdenDead, m_iHeldenianElvineDead);
			return TRUE;
		}
	}else // Update for everybody
	{
BOOL bFlag = TRUE;
int iShortCutIndex = 0;
int i;
		while(bFlag)
		{	i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) 
			{	bFlag = FALSE;	
			}else
			{	if (   (m_pClientList[i] != NULL) 
					&& (m_pClientList[i]->m_bIsInitComplete == TRUE)
					&& (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) 
					&& (m_pClientList[i]->m_cMapIndex == m_iBTFieldMapIndex)) 
				{	SendNotifyMsg(NULL, i, DEF_NOTIFY_HELDENIANCOUNT, m_iHeldenianAresdenLeftTower
							, m_iHeldenianElvineLeftTower, m_iHeldenianAresdenFlags, NULL, m_iHeldenianElvineFlags
							, m_iHeldenianAresdenDead, m_iHeldenianElvineDead);
	}	}	}	}
	return TRUE;
}

/*********************************************************************************************************************
**  int iGetPlayerStatus(int iClientH, short sOwnerH)																**
**  DESCRIPTION			:: returns client tile's mistatus															**
**  LAST_UPDATED		:: March 16, 2005; 12:31 PM; Hypnotoad														**
**	RETURN_VALUE		:: int																						**
**  NOTES				::	- not available in 2.03				 													**
**	MODIFICATION		:: N/A																						**
**********************************************************************************************************************/
int CGame::iGetPlayerStatus(int iClientH, short sOwnerH)
{
 int iRet;

	if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) {
		if (iClientH != sOwnerH) {
			iRet = m_pClientList[sOwnerH]->m_iStatus & 0x0F0FFFF7F;
		}
		iRet = m_pClientList[sOwnerH]->m_iStatus;
	}
	iRet = m_pClientList[sOwnerH]->m_iStatus;
	return iRet;
}

void CGame::RemoveEventNpc(int iNpcH)
{
	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	m_pNpcList[iNpcH]->m_bIsKilled = TRUE;
	m_pNpcList[iNpcH]->m_iHP = 0;
	m_pNpcList[iNpcH]->m_iLastDamage = 0;
	m_pNpcList[iNpcH]->m_dwRegenTime = 0;
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--;

	ReleaseFollowMode(iNpcH);
	m_pNpcList[iNpcH]->m_iTargetIndex = 0;
	m_pNpcList[iNpcH]->m_cTargetType = 0;
			
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, NULL, 1, NULL);
	if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	}
	else {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);
	}
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	m_pNpcList[iNpcH]->m_cBehavior = 4;
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	m_pNpcList[iNpcH]->m_dwDeadTime = timeGetTime();

}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         LocalStartApocalypse
//		   called by:      started by Gate msg
//         -> Notify players
//         -> Opens the gates
//		   -> Prevent npc generation on "kill all to go out" maps
//		   -> Execute local Openning or closing gates by GM command
//**************************************************************************************
void CGame::LocalStartApocalypse(DWORD dwApocalypseGUID)
{	if (dwApocalypseGUID == 1)// Means want to open Gate
	{	ForceOpen_ApocalypseGate();
		return;
	}
	if (dwApocalypseGUID == 2)// Means want to open Gate
	{	ForceClose_ApocalypseGate();
		return;
	}	
 int i;
	m_bIsApocalypseMode = TRUE;
	if (dwApocalypseGUID != NULL) 
	{	m_dwApocalypseGUID = dwApocalypseGUID;
		_CreateApocalypseGUID(dwApocalypseGUID);	
		m_dwApocalypseGateOpenTime = dwApocalypseGUID;
		m_dwApocalypseGateCloseTime = dwApocalypseGUID +20*60*1000; // will close in 20 minutes
	}
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL) 
		{	SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);	
	}	}
	for (i = 0; i < DEF_MAXMAPS; i++)
	{	if (m_pMapList[i] != NULL) 
		{	if (m_pMapList[i]->m_iApocalypseMobGenType != 0) 
			//1 for no respawn, 2 for Boss spawn when map empty
			{	m_pMapList[i]->m_iMaximumObjectDefault = m_pMapList[i]->m_iMaximumObject;
				m_pMapList[i]->m_iMaximumObject = 0;	
	}	}	}
	OpenCloseApocalypseGate();
	wsprintf(G_cTxt,"(!)Apocalypse Mode ON.");
	PutLogList(G_cTxt);		
	PutLogList(" ");		
	PutLogEventFileList(G_cTxt);	
	PutLogEventFileList(" ");
}

//**************************************************************************************
// SNOOPY: GlobalStartApocalypseMode
//		   Called by: by local command or GM command
//         -> Notify all game servers to start apocalypse
//         -> Used to force Open or Closed the initial Gates
//**************************************************************************************
void CGame::GlobalStartApocalypseMode(int iClientH, int iMode)
{	char * cp, cData[120];
	DWORD * dwp, dwApocalypseGUID;
	char cString[200];
	ZeroMemory(cString, sizeof(cString));
	if ((iClientH != 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 3)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if ((m_bIsApocalypseMode == TRUE) && (iMode == 0)) return;
	if (m_bIsHeldenianMode == TRUE) return;
	if (m_bIsCrusadeMode == TRUE) return;	

	switch (iMode){
	case 1: // Force open Gates
		dwApocalypseGUID = 1; 
		if (iClientH !=0)
		{	wsprintf(G_cTxt, "Admin Order(%s): /openapocalypsegate \tAdminIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cIPaddress);
			wsprintf(cString, "Apocalypse gate opening in progress.");
		}else
		{	wsprintf(G_cTxt, "Local command: openapocalypsegate");
		}		
		break;
	case 2: // Force close gates
		dwApocalypseGUID = 2; 
		if (iClientH !=0)
		{	wsprintf(G_cTxt, "Admin Order(%s): /closeapocalypsegate \tAdminIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
			wsprintf(cString, "Apocalypse gate closing in progress.");
		}else
		{	wsprintf(G_cTxt, "Local command: closeapocalypsegate");
		}			
		break;
	case 0: // Start Apocalypse
		dwApocalypseGUID = timeGetTime(); 
		if (dwApocalypseGUID < 10) dwApocalypseGUID += 10;
		if (iClientH !=0)
		{	wsprintf(G_cTxt, "Admin Order(%s): /beginapocalypse \tAdminIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cIPaddress);
			wsprintf(cString, "Apocalypse starting in progress.");
		}else
		{	wsprintf(G_cTxt, "Local command: beginapocalypse");
		}	
		break;
	}
	PutAdminLogFileList(G_cTxt);		
	PutLogEventFileList(G_cTxt);
	PutLogList(G_cTxt);	
	if (iClientH !=0)
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cString);
	}
	
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_BEGINAPOCALYPSE;
	cp++;
	dwp = (DWORD *)cp;
	*dwp = dwApocalypseGUID;
	cp += 4;
	bStockMsgToGateServer(cData, 5);
	LocalStartApocalypse(dwApocalypseGUID); // Gate will no return order to this server
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         GlobalEndApocalypseMode:  
//         -> Notify all game servers
//**************************************************************************************
void CGame::GlobalEndApocalypseMode(int iClientH)
{	char * cp, cData[120];
	if (m_bIsApocalypseMode == FALSE) return;

	if (iClientH > 0)	
	{	wsprintf(G_cTxt, "Admin Order(%s): /endapocalypse \tAdminIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		char cString[200];
		ZeroMemory(cString, sizeof(cString));
		wsprintf(cString, "Apocalypse ending in progress.");
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cString);
	}else
	{	wsprintf(G_cTxt, "Automated: endapocalypse");
	}
	PutAdminLogFileList(G_cTxt);		
	PutLogEventFileList(G_cTxt);
	PutLogList(G_cTxt);	

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_ENDAPOCALYPSE;
	cp++;	
	bStockMsgToGateServer(cData, 5);
	LocalEndApocalypse(); // Gate will not return order to this server
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         LocalEndApocalypse: started by Gate msg
//         -> Notify players
//         -> Close the gates
//		   -> Enable npc generation on all maps
//**************************************************************************************
void CGame::LocalEndApocalypse()
{	wsprintf(G_cTxt, "(!) Received LocalEndApocalypse.");
	PutLogList(G_cTxt);
	m_bIsApocalypseMode = FALSE;
	m_bIsApocalypseGateOpen	= FALSE; 
 int i;	
 DWORD  dwTime = timeGetTime();
	m_dwApocalypseGateCloseTime = dwTime -1;
	m_dwApocalypseGateOpenTime = dwTime -100; // alreaddy closed
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL)
		{	SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEENDMSG, NULL, NULL, NULL, NULL);
			if (   (m_pClientList[i]->m_iAdminUserLevel == 0)
				&& (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsApocalypseMap == TRUE)) 
			{	// forced recall
				SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
				RequestTeleportHandler(i, "0   ");
	}	}	}	
	// restore normal spawn on apoc maps
	for (i = 0; i < DEF_MAXMAPS; i++)
	{	if (m_pMapList[i] != NULL) 
		{	if (m_pMapList[i]->m_iApocalypseMobGenType != 0) 
			//1 for not respawn, 2 for Boss spawn.
			{	m_pMapList[i]->m_iMaximumObject = m_pMapList[i]->m_iMaximumObjectDefault;
			}
			if (m_pMapList[i]->m_cDynamicGateType == 4 )
			{	m_pMapList[i]->m_cDynamicGateType = 3;
			}
			if (m_pMapList[i]->m_cDynamicGateType == 2)
			{	GenerateSlime(i);	// to force the gate to close		
			}
			Open_EmptyMap_Gate(i);
	}	}
	wsprintf(G_cTxt,"(!) Apocalypse Mode OFF.");
	PutLogList(G_cTxt);
	PutLogList(" ");
	PutLogEventFileList(G_cTxt);
	PutLogEventFileList(" ");
}

void CGame::SendThunder(int iClient, short sX, short sY, short sV3, short sV4)
{	char  * cp, cData[100];
	DWORD * dwp;
	WORD * wp;
	short * sp;
	int iRet;
	ZeroMemory(cData, sizeof(cData));	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_EVENT_COMMON;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_COMMONTYPE_MAGIC;	
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = sX;
	cp += 2;
	sp  = (short *)cp;
	*sp = sY;
	cp += 2;
	sp  = (short *)cp;
	*sp = sX;
	cp += 2;
	sp  = (short *)cp;
	*sp = sY;
	cp += 2;
	sp  = (short *)cp;
	*sp = sV3;
	cp += 2;
	sp  = (short *)cp;
	*sp = sV4;
	cp += 2;
	iRet = m_pClientList[iClient]->m_pXSock->iSendMsg(cData, 18);
}
void CGame::DoAbaddonThunderDamageHandler(char cMapIndex)
{	int iResult;
 int i;
	if (iDice(1, 15) != 13) return;
	DWORD dwTime = timeGetTime();
	for (i = 0; i < DEF_MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL) 
		{	if ((memcmp(m_pClientList[i]->m_cMapName, "abaddon", 7) == 0) 
				|| (m_pClientList[i]->m_cMapIndex == cMapIndex))
			{	switch (iDice(1,4)) {
				case 1:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 203, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX-iDice(1,7), m_pClientList[i]->m_sY+iDice(1,5), 161, m_pClientList[i]->m_sType);
					break;
				case 2:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 202, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX+iDice(1,7), m_pClientList[i]->m_sY-iDice(1,5), 161, m_pClientList[i]->m_sType);
					break;
				case 3:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 201, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX+iDice(1,7), m_pClientList[i]->m_sY+5-iDice(1,9), 161, m_pClientList[i]->m_sType);
					break;
				case 4:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 200, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX+5-iDice(1,9), m_pClientList[i]->m_sY+7-iDice(1,4), 161, m_pClientList[i]->m_sType);
					break;
				}				
				if (m_pClientList[i]->m_iAdminUserLevel > 0) continue;	
				iResult = iDice(1,20) + 100;
				 if (  (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
					|| (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5)) 
				{   iResult /= 2;
				}
				// Not for v3.51: DEF_NOTIFY_0BE5
				m_pClientList[i]->m_iHP -= iResult;
				if (m_pClientList[i]->m_iHP <= 0) 
				{	ClientKilledHandler(i, NULL, NULL, iResult);
				}else if (iResult > 0) 
				{	m_pClientList[i]->m_dwRecentAttackTime = dwTime;
					SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iResult, NULL, NULL);
					if (m_pClientList[i]->m_bSkillUsingStatus[19] != TRUE) 
					{	m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(0, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
						m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					}
					if (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] == 1)	// Hold person
					{   SendNotifyMsg(NULL, i, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 1, NULL, NULL);
						bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);						
						m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					}else if (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] == 2)	// Para entangle
					{   SendNotifyMsg(NULL, i, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 2, NULL, NULL);
						bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);						
						m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
	}	}	}	}	}
}

BOOL CGame::MobBossGenerator(int iMapIndex)
{
 char cNpcName[21], cName[11], cSA, cNpcWaypointIndex[11];
 int iProbSA, iKindSA, dX, dY, iNamingValue;	
 BOOL bFirmBerserk, bRet;
 int i;

	if (m_pMapList[iMapIndex]->m_bIsBossInMap == TRUE) return FALSE;
	iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();

	if (iNamingValue == -1) {
	
	}
	else {
		ZeroMemory(cName, sizeof(cName));
		switch(m_pMapList[iMapIndex]->m_iApocalypseBossMobNpcID) {
		case 10:  strcpy(cNpcName,"Slime");				iProbSA = 5;  iKindSA = 1;  break;
		case 16:  strcpy(cNpcName,"Giant-Ant");			iProbSA = 10; iKindSA = 2;  break;
		case 14:  strcpy(cNpcName,"Orc");				iProbSA = 15; iKindSA = 1;  break;
		case 18:  strcpy(cNpcName,"Zombie");			iProbSA = 15; iKindSA = 3;  break;
		case 11:  strcpy(cNpcName,"Skeleton");			iProbSA = 35; iKindSA = 8;  break;
		case 6:   strcpy(cNpcName,"Orc-Mage");			iProbSA = 30; iKindSA = 7;  break;
		case 17:  strcpy(cNpcName,"Scorpion");			iProbSA = 15; iKindSA = 3;  break;
		case 12:  strcpy(cNpcName,"Stone-Golem");		iProbSA = 25; iKindSA = 5;  break;
		case 13:  strcpy(cNpcName,"Cyclops");			iProbSA = 35; iKindSA = 8;  break;
		case 22:  strcpy(cNpcName,"Amphis");			iProbSA = 20; iKindSA = 3;  break;
		case 23:  strcpy(cNpcName,"Clay-Golem");		iProbSA = 20; iKindSA = 5;  break;
		case 24:  strcpy(cNpcName,"Guard-Aresden");		iProbSA = 1; iKindSA = 10;  break;
		case 25:  strcpy(cNpcName,"Guard-Elvine");		iProbSA = 1; iKindSA = 10;  break;
		case 26:  strcpy(cNpcName,"Guard-Neutral");		iProbSA = 1; iKindSA = 10;  break;
		case 27:  strcpy(cNpcName,"Hellbound");			iProbSA = 20; iKindSA = 1;  break;
		case 29:  strcpy(cNpcName,"Orge");              iProbSA = 20; iKindSA = 1;  break;
		case 30:  strcpy(cNpcName,"Liche");				iProbSA = 30; iKindSA = 8;  break;
		case 31:  strcpy(cNpcName,"Demon");				iProbSA = 20; iKindSA = 8;  break;
		case 32:  strcpy(cNpcName,"Unicorn");			iProbSA = 35; iKindSA = 7;  break;
		case 33:  strcpy(cNpcName,"WereWolf");			iProbSA = 25; iKindSA = 1;  break;
		case 34:  strcpy(cNpcName,"Dummy");				iProbSA = 5;  iKindSA = 1;  break;
		case 35:  strcpy(cNpcName,"Attack-Dummy");		iProbSA = 5;  iKindSA = 1;  break;
		case 48:  strcpy(cNpcName,"Stalker");			iProbSA = 20; iKindSA = 3;  break;
		case 49:  strcpy(cNpcName,"Hellclaw");			iProbSA = 20; iKindSA = 8;  break;
		case 50:  strcpy(cNpcName,"Tigerworm");			iProbSA = 20; iKindSA = 8;  break;
		case 54:  strcpy(cNpcName,"Dark-Elf");			iProbSA = 20; iKindSA = 8;  break;
		case 53:  strcpy(cNpcName,"Beholder");			iProbSA = 20; iKindSA = 8;  break;
		case 52:  strcpy(cNpcName,"Gagoyle");			iProbSA = 20; iKindSA = 8;  break;
		case 57:  strcpy(cNpcName,"Giant-Frog");		iProbSA = 10; iKindSA = 2;  break;
		case 58:  strcpy(cNpcName,"Mountain-Giant");	iProbSA = 25; iKindSA = 1;  break;
		case 59:  strcpy(cNpcName,"Ettin");				iProbSA = 20; iKindSA = 8;  break;
		case 60:  strcpy(cNpcName,"Cannibal-Plant");	iProbSA = 20; iKindSA = 5;  break;
		case 61:  strcpy(cNpcName,"Rudolph");			iProbSA = 20; iKindSA = 1;  break;
		case 62:  strcpy(cNpcName,"DireBoar");			iProbSA = 20; iKindSA = 1;  break;
		case 63:  strcpy(cNpcName,"Frost");				iProbSA = 20; iKindSA = 8;  break;
		case 65:  strcpy(cNpcName,"Ice-Golem");			iProbSA = 20; iKindSA = 8;  break;
		case 66:  strcpy(cNpcName,"Wyvern");			iProbSA = 20; iKindSA = 9;  break;
		case 55:  strcpy(cNpcName,"Rabbit");			iProbSA = 20; iKindSA = 1;  break;
		case 67:  strcpy(cNpcName,"McGaffin");			iProbSA = 20; iKindSA = 1;  break;
		case 68:  strcpy(cNpcName,"Perry");				iProbSA = 20; iKindSA = 1;  break;
		case 69:  strcpy(cNpcName,"Devlin");			iProbSA = 20; iKindSA = 1;  break;
		// Ice-Wyvern
		case 73:  strcpy(cNpcName,"Fire-Wyvern");		iProbSA = 20; iKindSA = 9;  break;
		case 70:  strcpy(cNpcName,"Barlog");			iProbSA = 20; iKindSA = 1;  break;
		case 80:  strcpy(cNpcName,"Tentocle");			iProbSA = 20; iKindSA = 1;  break;
		case 71:  strcpy(cNpcName,"Centaurus");			iProbSA = 20; iKindSA = 1;  break;
		case 75:  strcpy(cNpcName,"Giant-Lizard");		iProbSA = 20; iKindSA = 1;  break;
		case 78:  strcpy(cNpcName,"Minotaurs");			iProbSA = 20; iKindSA = 1;  break;
		case 81:  strcpy(cNpcName,"Abaddon");			iProbSA = 20; iKindSA = 9;  break;
		case 72:  strcpy(cNpcName,"Claw-Turtle");		iProbSA = 20; iKindSA = 1;  break;
		case 74:  strcpy(cNpcName,"Giant-Crayfish");	iProbSA = 20; iKindSA = 1;  break;
		case 76:  strcpy(cNpcName,"Giant-Plant");		iProbSA = 20; iKindSA = 1;  break;
		case 77:  strcpy(cNpcName,"MasterMage-Orc");	iProbSA = 20; iKindSA = 1;  break;
		case 79:  strcpy(cNpcName,"Nizie");				iProbSA = 20; iKindSA = 1;  break;
		default:  strcpy(cNpcName,"Orc");				iProbSA = 15; iKindSA = 1; 	break;
		}
		cSA = _cGetSpecialAbility(iKindSA);
		bFirmBerserk = TRUE;
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = 95;
		cName[1] = i + 65;
		bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 53, cSA, DEF_MOVETYPE_RANDOMAREA, &dX, &dY, cNpcWaypointIndex, &m_pMapList[iMapIndex]->m_rcApocalypseBossMobRect, NULL, -1, FALSE, FALSE, bFirmBerserk, FALSE, FALSE);
		if (bRet == FALSE) {
			m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
			return FALSE;
		} 
		else{
			m_pNpcList[bRet]->m_bIsBossMob = TRUE;
			m_pMapList[iMapIndex]->m_bIsBossInMap = TRUE;
			return TRUE;
		}
	}
	return FALSE;
}

BOOL CGame::bReadSettingsConfigFile(char * cFn) 
{ 
   FILE * pFile; 
   HANDLE hFile; 
   DWORD  dwFileSize; 
   char * cp, * token, cReadMode, cTxt[120], cGSMode[16] = "", len; 
   char seps[] = "= \t\n"; 
   class CStrTok * pStrTok; 

   cReadMode = 0; 

   hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
   dwFileSize = GetFileSize(hFile, NULL); 
   if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile); 

   pFile = fopen(cFn, "rt"); 
   if (pFile == NULL) { 
      //      . 
      PutLogList("(!) Cannot open configuration file."); 
      return FALSE; 
   } 
   else { 
      PutLogList("(!) Reading settings file..."); 
      cp = new char[dwFileSize+2]; 
      ZeroMemory(cp, dwFileSize+2); 
      fread(cp, dwFileSize, 1, pFile); 

      pStrTok = new class CStrTok(cp, seps); 
      token = pStrTok->pGet(); 
      while( token != NULL )   { 

         if (cReadMode != 0) { 
            switch (cReadMode) { 

            case 1: 
               if ((strlen(token) != 0) && (strlen(token) <= 10000) && (strlen(token) >= 1)) 
               { 
                  m_iPrimaryDropRate = atoi(token); 
               } 
               else 
               { 
                  wsprintf(cTxt, "(!!!) Primary drop rate(%s) invalid must be between 1 to 10000", token); 
                  PutLogList(cTxt); 
               } 
               wsprintf(cTxt, "(*) Primary drop rate: (%d)", m_iPrimaryDropRate); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 2: 
               if ((strlen(token) != 0) && (strlen(token) <= 10000) && (strlen(token) >= 1)) 
               { 
                  m_iSecondaryDropRate = atoi(token); 
               } 
               else 
               { 
                  wsprintf(cTxt, "(!!!) Secondary drop rate(%s) invalid must be between 1 to 10000", token); 
                  PutLogList(cTxt); 
               } 
               wsprintf(cTxt, "(*) Secondary drop rate: (%d)", m_iSecondaryDropRate); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 3: 
               if ((memcmp(token, "classic", 7) == 0) || (memcmp(token, "CLASSIC", 7) == 0)) 
               { 
                  m_bEnemyKillMode = FALSE; 
                  wsprintf(cTxt, "(*) Enemy Kill Mode: CLASSIC"); 
                  PutLogList(cTxt); 
               } 
               else if ((memcmp(token, "deathmatch", 10) == 0) || (memcmp(token, "DEATHMATCH", 10) == 0)) 
               { 
                  m_bEnemyKillMode = TRUE; 
                  wsprintf(cTxt, "(*) Enemy Kill Mode: DEATHMATCH"); 
                  PutLogList(cTxt); 
               } 
               else 
               { 
                  wsprintf(cTxt, "(!!!) ENEMY-KILL-MODE: (%s) must be either DEATHMATCH or CLASSIC", token); 
                  PutLogList(cTxt); 
                  return FALSE; 
               } 
               cReadMode = 0; 
               break; 

            case 4: 
               if ((strlen(token) != 0) && (strlen(token) <= 100) && (strlen(token) >= 1)) 
               { 
                  m_iEnemyKillAdjust = atoi(token); 
               } 
               else 
               { 
                  wsprintf(cTxt, "(!!!) ENEMY-KILL-ADJUST: (%s) invalid must be between 1 to 100", token); 
                  PutLogList(cTxt); 
               } 
               wsprintf(cTxt, "(*) Player gains (%d) EK per enemy kill.", m_iEnemyKillAdjust); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 5: 
               if ((memcmp(token, "on", 2) == 0) || (memcmp(token, "ON", 2) == 0)) 
               { 
                  m_bAdminSecurity = TRUE; 
                  wsprintf(cTxt, "(*) Administator actions limited through security."); 
                  PutLogList(cTxt); 
               } 
               if ((memcmp(token, "off", 3) == 0) || (memcmp(token, "OFF", 3) == 0)) 
               { 
                  m_bAdminSecurity = FALSE; 
                  wsprintf(cTxt, "(*) Administator vulnerability ignored."); 
                  PutLogList(cTxt); 
               } 

               cReadMode = 0; 
               break; 

            case 6: 
               m_sRaidTimeMonday = atoi(token); 
               if (m_sRaidTimeMonday == 0) m_sRaidTimeMonday = 3; 
               wsprintf(cTxt, "(*) Monday Raid Time : (%d) minutes", m_sRaidTimeMonday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 7: 
               m_sRaidTimeTuesday = atoi(token); 
               if (m_sRaidTimeTuesday == 0) m_sRaidTimeTuesday = 3; 
               wsprintf(cTxt, "(*) Tuesday Raid Time : (%d) minutes", m_sRaidTimeTuesday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 8: 
               m_sRaidTimeWednesday = atoi(token); 
               if (m_sRaidTimeWednesday == 0) m_sRaidTimeWednesday = 3; 
               wsprintf(cTxt, "(*) Wednesday Raid Time : (%d) minutes", m_sRaidTimeWednesday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 9: 
               m_sRaidTimeThursday = atoi(token); 
               if (m_sRaidTimeThursday == 0) m_sRaidTimeThursday = 3; 
               wsprintf(cTxt, "(*) Thursday Raid Time : (%d) minutes", m_sRaidTimeThursday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 10: 
               m_sRaidTimeFriday = atoi(token); 
               if (m_sRaidTimeFriday == 0) m_sRaidTimeFriday = 10; 
               wsprintf(cTxt, "(*) Friday Raid Time : (%d) minutes", m_sRaidTimeFriday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 11: 
               m_sRaidTimeSaturday = atoi(token); 
               if (m_sRaidTimeSaturday == 0) m_sRaidTimeSaturday = 45; 
               wsprintf(cTxt, "(*) Saturday Raid Time : (%d) minutes", m_sRaidTimeSaturday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 12: 
               m_sRaidTimeSunday = atoi(token); 
               if (m_sRaidTimeSunday == 0) m_sRaidTimeSunday = 60; 
               wsprintf(cTxt, "(*) Sunday Raid Time : (%d) minutes", m_sRaidTimeSunday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 
		
			case 13:
				if ((memcmp(token, "player", 6) == 0) || (memcmp(token, "PLAYER", 6) == 0))
				{
					m_bLogChatOption = 1;
					wsprintf(cTxt, "(*) Logging Player Chat.");
					PutLogList(cTxt);
				}
				if ((memcmp(token, "gm", 2) == 0) || (memcmp(token, "GM", 2) == 0))
				{
					m_bLogChatOption = 2;
					wsprintf(cTxt, "(*) Logging GM Chat.");
					PutLogList(cTxt);
				}
				if ((memcmp(token, "all", 3) == 0) || (memcmp(token, "ALL", 3) == 0))
				{
					m_bLogChatOption = 3;
					wsprintf(cTxt, "(*) Logging All Chat.");
					PutLogList(cTxt);
				}
				if ((memcmp(token, "none", 4) == 0) || (memcmp(token, "NONE", 4) == 0))
				{
					m_bLogChatOption = 4;
					wsprintf(cTxt, "(*) Not Logging Any Chat.");
					PutLogList(cTxt);
				}
				cReadMode = 0;
				break;

            case 14: 
               m_iSummonGuildCost = atoi(token); 
               wsprintf(cTxt, "(*) Summoning guild costs (%d) gold", m_iSummonGuildCost); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break;
 
			case 15: 
               m_sSlateSuccessRate = atoi(token); 
               wsprintf(cTxt, "(*) Slate Success Rate (%d) percent", m_sSlateSuccessRate); 
               PutLogList(cTxt); 
			   if (m_sSlateSuccessRate == 0) m_sSlateSuccessRate = 14; 
               cReadMode = 0; 
               break;

			case 16: 
               m_sCharStatLimit = atoi(token); 
               if (m_sCharStatLimit == 0) m_sCharStatLimit = 200; 
               cReadMode = 0;
               break;

			case 17: 
               m_sCharSkillLimit = atoi(token); 
               if (m_sCharSkillLimit == 0) m_sCharSkillLimit = 700; 
               cReadMode = 0;
               break;

			case 18: 
               m_cRepDropModifier = atoi(token); 
               wsprintf(cTxt, "(*) Rep<->Drop modifier: (%d)", m_cRepDropModifier); 
               PutLogList(cTxt); 
               if (m_cRepDropModifier < 0) m_cRepDropModifier = 0;
               cReadMode = 0; 
               break;

			case 19: 
               ZeroMemory(m_cSecurityNumber, sizeof(m_cSecurityNumber));
			   len = strlen(token);
			   if(len > 10) len = 10;
			   memcpy(m_cSecurityNumber, token, len);
               wsprintf(cTxt, "(*) Security number memorized!"); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break;

			case 20: 
               m_iPlayerMaxLevel = atoi(token); 
               if (m_iPlayerMaxLevel == 0) m_iPlayerMaxLevel = DEF_PLAYERMAXLEVEL; 
               cReadMode = 0;
               break;

			case 25: 
					if ((strlen(token) < 1) || (strlen(token) > 10000)) 
					{ 
						wsprintf(cTxt, "(!!!) Rare drop rate invalid must be between 1 to 10000"); 
						PutLogList(cTxt);
						return FALSE; 
					} 
					else 
					{ 
						m_iRareDropRate = atoi(token);
					} 
					wsprintf(cTxt, "(*) Rare drop rate: (%d)", m_iRareDropRate); 
					PutLogList(cTxt); 
					cReadMode = 0; 
					break;
			
			}
         } 
         else { 
            if (memcmp(token, "primary-drop-rate"      , 17) == 0)   cReadMode = 1; 
            if (memcmp(token, "secondary-drop-rate"      , 19) == 0)   cReadMode = 2; 
            if (memcmp(token, "enemy-kill-mode"         , 15) == 0)   cReadMode = 3; 
            if (memcmp(token, "enemy-kill-adjust"      , 17) == 0)   cReadMode = 4; 
            if (memcmp(token, "admin-security"         , 14) == 0)   cReadMode = 5; 
            if (memcmp(token, "monday-raid-time"      , 16) == 0)   cReadMode = 6; 
            if (memcmp(token, "tuesday-raid-time"      , 17) == 0)   cReadMode = 7; 
            if (memcmp(token, "wednesday-raid-time"      , 19) == 0)   cReadMode = 8; 
            if (memcmp(token, "thursday-raid-time"      , 18) == 0)   cReadMode = 9; 
            if (memcmp(token, "friday-raid-time"      , 16) == 0)   cReadMode = 10; 
            if (memcmp(token, "saturday-raid-time"      , 18) == 0)   cReadMode = 11; 
            if (memcmp(token, "sunday-raid-time"      , 16) == 0)   cReadMode = 12; 
			if (memcmp(token, "log-chat-settings", 17) == 0)		cReadMode = 13;
			if (memcmp(token, "summonguild-cost", 16) == 0)		cReadMode = 14;
			if (memcmp(token, "slate-success-rate", 18) == 0)		cReadMode = 15;
			if (memcmp(token, "character-stat-limit", 20) == 0)		cReadMode = 16;
			if (memcmp(token, "character-skill-limit", 21) == 0)		cReadMode = 17;
			if (memcmp(token, "rep-drop-modifier", 17) == 0)		cReadMode = 18;
			if (memcmp(token, "admin-security-code", 19) == 0)		cReadMode = 19;
			if (memcmp(token, "max-player-level", 16) == 0)		cReadMode = 20;
			if (memcmp(token, "rare-drop-rate"      , 14) == 0)	cReadMode = 25;
		 } 

         token = pStrTok->pGet(); 
      } 

      delete pStrTok; 
      delete cp; 
   } 
   if (pFile != NULL) fclose(pFile); 

   return TRUE; 
} 

BOOL CGame::bGetEmptyArea(short sOwnerH, char cMapIndex, short pX, short pY, char cArea)
{
 short sAreaSquared;
 int i;

	if ((cArea > 5) || (cArea < 2)) return FALSE;
	sAreaSquared = cArea*cArea;
	for (i = 0; i < sAreaSquared; i++) {
		if (m_pMapList[cMapIndex]->bGetMoveableArea(sOwnerH, pX + _tmp_cEmptyPosX[i], pY + _tmp_cEmptyPosY[i]) == FALSE) return FALSE;
		if (m_pMapList[cMapIndex]->bGetIsTeleport(pX + _tmp_cEmptyPosX[i], pY + _tmp_cEmptyPosY[i]) == TRUE) return FALSE;
	}
	return TRUE;	
}

BOOL CGame::bGetNpcMovementArea(short sOwnerH, short pX, short pY, char cMapIndex, char cArea)
{
 short sAreaSquared, sPositionY, sPositionX, sX, sY;
 int i;

	sAreaSquared = cArea*cArea;
	if ((cArea > 5) || (cArea < 2)) return FALSE;
	if (m_pNpcList[sOwnerH]->m_sType == 91) return TRUE;
	for (i = 1; i < sAreaSquared; i++) {
		if (_tmp_cEmptyPosX[i] > 0) {
			sPositionX = 2;
		}
		else if (_tmp_cEmptyPosX[i] < 0) {
			sPositionX = -2;
		}
		else {
			sPositionX = 0;
		}

		if (_tmp_cEmptyPosY[i] > 0) {
			sPositionY = 2;
		}
		else if (_tmp_cEmptyPosY[i] < 0) {
			sPositionY = -2;
		}
		else {
			sPositionY = 0;
		}
		if (bGetEmptyArea(sOwnerH, cMapIndex, pX + sPositionX, pY + sPositionY, cArea) != FALSE) {
			sX = pX + sPositionX;
			sY = pY + sPositionY;	
			pX = sX;
			pY = sY;
			return TRUE;
		}
	}
	return FALSE;
}

char CGame::cGetNextMoveArea(short sOwnerH, short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn, int * pError, char cArea)
{
  char  cDir, cTmpDir;
 int   aX, aY, dX, dY;
  int   i, iResX, iResY;
 short sAreaSquared;

	if ((sX == dstX) && (sY == dstY)) return 0;
	sAreaSquared = cArea*cArea;
	if ((cArea > 5) || (cArea < 2)) return 0;

	dX = sX;
	dY = sY;
	if ((abs(dX - dstX)+4 <= 1) && (abs(dY - dstY)+4 <= 1)) {
		iResX = dstX;
		iResY = dstY;
	}
	else m_Misc.GetPoint(dX, dY, dstX, dstY, &iResX, &iResY, pError);
	cDir = m_Misc.cGetNextMoveDir(dX, dY, iResX, iResY);

	if (cTurn == 0) {
		for (i = cDir; i <= cDir + 7; i++) {
			cTmpDir = i;
			if (cTmpDir != 0) {
				if (cTmpDir > 8) cTmpDir -= 8;
				aX = _tmp_cTmpDirX[cTmpDir];
				aY = _tmp_cTmpDirY[cTmpDir];
				if (bGetEmptyArea(sOwnerH, cMapIndex, dX + aX, dY + aY, cArea) != FALSE) {
					return cTmpDir;
				}
			}
		}
	}
	if (cTurn == 1) {
		for (i = cDir; i >= cDir - 7;i--) {
			cTmpDir = i;
			if (cTmpDir < 1) cTmpDir += 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (bGetEmptyArea(sOwnerH, cMapIndex, dX + aX, dY + aY, cArea) != FALSE) {
				return cTmpDir;
			}
		}
	}
	return 0;
}

/*********************************************************************************************************************
**  void CGame::SetExchangeItem(int iClientH, int iItemIndex, int iAmount)											**
**  DESCRIPTION			:: set exchange item																		**
**  LAST_UPDATED		:: March 20, 2005; 6:31 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- make sure there that the item player places in trade exists							**
**							- stores item number in other character													**
**							- counts total item numbers sent														**
**  MODIFICATION		::	- n/a																					**
**********************************************************************************************************************/
void CGame::SetExchangeItem(int iClientH, int iItemIndex, int iAmount)
{
 int iExH, i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;
	iExH = m_pClientList[iClientH]->m_iExchangeH;
	if ((m_pClientList[iExH] == NULL) || 
		(memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[m_pClientList[iClientH]->m_iExchangeH]->m_cCharName, 10) != 0)) {
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
		return;
	}
	for (i = 0; i < m_pClientList[iClientH]->m_iExchangeCount; i++) {
		if (m_pClientList[iClientH]->m_cExchangeItemIndex[i] == (char)iItemIndex) {
			_ClearExchangeStatus(iExH);
			_ClearExchangeStatus(iClientH);
			return;
		}
	}
	if ((m_pClientList[iClientH]->m_cExchangeMode != 2) && (m_pClientList[iClientH]->m_cExchangeMode != 1))	return;
	if ((m_pClientList[iExH]->m_cExchangeMode != 2) && (m_pClientList[iExH]->m_cExchangeMode != 1)) return;
	if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
	// new - make sure there that the item player places in trade exists
	if (m_pClientList[iItemIndex]->m_pItemList == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount < iAmount) return;
	m_pClientList[iClientH]->m_cExchangeItemIndex[m_pClientList[iClientH]->m_iExchangeCount] = (char)iItemIndex;
	m_pClientList[iClientH]->m_iExchangeItemAmount[m_pClientList[iClientH]->m_iExchangeCount] = iAmount;
	ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->m_iExchangeCount], sizeof(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->m_iExchangeCount]));
	memcpy(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->m_iExchangeCount], m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, 20);
	m_pClientList[iClientH]->m_iExchangeCount++;
	// new - stores item number in other character
	m_pClientList[iExH]->m_iExchangeAlterIndex[m_pClientList[iExH]->m_iExchangeComplete] = iItemIndex;
	// new - counts total item numbers sent
	m_pClientList[iExH]->m_iExchangeComplete++;
	SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_SETEXCHANGEITEM, iItemIndex+1000, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
		          m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
				  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
				  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
				  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 +100,
				  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute); 

	SendNotifyMsg(iClientH, iExH, DEF_NOTIFY_SETEXCHANGEITEM, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
		          m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
				  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
				  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
				  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 +100,
				  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
}

/*********************************************************************************************************************
**  void CGame::ConfirmExchangeItem(int iClientH)																	**
**  DESCRIPTION			:: confirms exchange																		**
**  LAST_UPDATED		:: March 20, 2005; 5:51 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- trade cancels if player changes HGServer												**
**							- trade cancels if player is disconnected or in waiting process							**
**							- trade cancels if player is trading with himself										**
**							- trade cancels if player is trading with noone											**
**							- trade cancels if player is recieves an item which hasnt been traded					**
**							- trade cancels if other player receives an item which you didn't trade					**
**							- changed weight calculations to support multiple items									**
**							- trade cancels if there is not enough item space for trade to occur					**
**  MODIFICATION		::	- GM can't trade if admin-security = true												**
**********************************************************************************************************************/
void CGame::ConfirmExchangeItem(int iClientH)
{
 int iExH;
 int iItemWeightA, iItemWeightB, iWeightLeftA, iWeightLeftB, iAmountLeft, i;
 class CItem * pItemA[4], * pItemB[4], * pItemAcopy[4], * pItemBcopy[4];
 
	if (m_pClientList[iClientH] == NULL) return;
	// modification - GM can't trade if admin-security = true
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return; 
	iExH = m_pClientList[iClientH]->m_iExchangeH;
	// March 20, 2005 - closes trade when player changes HGServer
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) { 
		_ClearExchangeStatus(iClientH);
		_ClearExchangeStatus(iExH);
		return;
	}
	// March 20, 2005 - closes trade when player is disconnected or in waiting process
	if ((m_bOnExitProcess == TRUE) || 
		(m_pClientList[iClientH]->m_bIsForceDisconnect == TRUE) || 
		(m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE)) { 
		_ClearExchangeStatus(iClientH);
		_ClearExchangeStatus(iExH);
		return;
	}
	if (m_pClientList[iClientH]->m_iExchangeH == NULL) return;
	iExH = m_pClientList[iClientH]->m_iExchangeH;
	// March 20, 2005 - cancel trade if player is trading with himself
	if (iClientH == iExH) {
		_ClearExchangeStatus(iClientH);
		return;
	}
	// March 20, 2005 - cancel trade if player is trading with noone
	if (m_pClientList[iExH] == NULL) {
		_ClearExchangeStatus(iClientH);
		return;
	}
	if ((memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0) ||
	    (m_pClientList[iExH]->m_cExchangeMode == 0) ||
		(memcmp(m_pClientList[iExH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName, 10) != 0)) {
		_ClearExchangeStatus(iClientH);
		_ClearExchangeStatus(iExH);
		return;
	}
	m_pClientList[iClientH]->m_bIsExchangeConfirm = TRUE;
	if (m_pClientList[iExH]->m_bIsExchangeConfirm != TRUE) return;
	for (i = 0; i<m_pClientList[iClientH]->m_iExchangeCount; i++) {
		if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]] == NULL) {
			_ClearExchangeStatus(iClientH);
			_ClearExchangeStatus(iExH);
			return;
		}
		if (memcmp(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName, m_pClientList[iClientH]->m_cExchangeItemName[i], 20) != 0) {
			_ClearExchangeStatus(iClientH);
			_ClearExchangeStatus(iExH);
			return;
		}
		// March 20, 2005 - cancel trade if player is recieving an item which hasnt been dropped by the other player
		if (m_pClientList[iClientH]->m_cExchangeItemIndex[i] != m_pClientList[iExH]->m_iExchangeAlterIndex[i]) {
			_ClearExchangeStatus(iClientH);
			_ClearExchangeStatus(iExH);
			return;
		}
	}
	for (i = 0; i < m_pClientList[iExH]->m_iExchangeCount; i++) {
		if (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] == NULL) {
			_ClearExchangeStatus(iClientH);
			_ClearExchangeStatus(iExH);
			return;
		}
		if (memcmp(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName, m_pClientList[iExH]->m_cExchangeItemName[i], 20) != 0) {
			_ClearExchangeStatus(iClientH);
			_ClearExchangeStatus(iExH);
			return;
		}
		// March 20, 2005 - cancel trade if other player is receiving item which you didn't drop
		if (m_pClientList[iExH]->m_cExchangeItemIndex[i] != m_pClientList[iClientH]->m_iExchangeAlterIndex[i]) {
			_ClearExchangeStatus(iClientH);
			_ClearExchangeStatus(iExH);
			return;
		}
	}
	iWeightLeftA = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
	iWeightLeftB = _iCalcMaxLoad(iExH) - iCalcTotalWeight(iExH);
	iItemWeightA = 0;
	iItemWeightB = 0;
	for (i = 0; i < m_pClientList[iClientH]->m_iExchangeCount; i++) {
		// March 20, 2005 - changed to += to get total weight of all iClientH's traded items
		iItemWeightA += iGetItemWeight(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]], m_pClientList[iClientH]->m_iExchangeItemAmount[i]);
	}
	for (i = 0; i < m_pClientList[iExH]->m_iExchangeCount; i++) {
		// March 20, 2005 - changed to += to get total weight of all iExH's traded items
		iItemWeightB += iGetItemWeight(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]], m_pClientList[iExH]->m_iExchangeItemAmount[i]);
	}
	//See if the other person can take the item weightload
	if ((iWeightLeftA < iItemWeightB) || (iWeightLeftB < iItemWeightA)) {
		_ClearExchangeStatus(iClientH);
		_ClearExchangeStatus(iExH);
		return;
	}
	// March 20, 2005 - cancels trade if people trading do not have enough free space for all the items
	if ((_iGetItemSpaceLeft(iClientH) < m_pClientList[iClientH]->m_iExchangeCount) || 
		(_iGetItemSpaceLeft(iExH) < m_pClientList[iExH]->m_iExchangeCount)) {
		_ClearExchangeStatus(iClientH);
		_ClearExchangeStatus(iExH);
		return;
	}
	for (i = 0; i < m_pClientList[iClientH]->m_iExchangeCount; i++) {
		if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
			if (m_pClientList[iClientH]->m_iExchangeItemAmount[i] > m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_dwCount) {
				_ClearExchangeStatus(iClientH);
				_ClearExchangeStatus(iExH);
				return;		
			}
		}
	}
	for (i = 0; i < m_pClientList[iExH]->m_iExchangeCount; i++) {
		if ((m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			if (m_pClientList[iExH]->m_iExchangeItemAmount[i] > m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_dwCount) {
				_ClearExchangeStatus(iClientH);
				_ClearExchangeStatus(iExH);
				return;		
			}
		}
	}
	for (i = 0; i < m_pClientList[iClientH]->m_iExchangeCount; i++) {
		if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]] == NULL) {
			_ClearExchangeStatus(iClientH);
			_ClearExchangeStatus(iExH);
			return;		
		}
	}
	for (i = 0; i < m_pClientList[iExH]->m_iExchangeCount; i++) {
		if (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] == NULL) {
			_ClearExchangeStatus(iClientH);
			_ClearExchangeStatus(iExH);
			return;		
		}
	}
	for(i = 0; i < m_pClientList[iClientH]->m_iExchangeCount; i++) {
		if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
			pItemA[i] = new class CItem;
			_bInitItemAttr(pItemA[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
			pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
			pItemAcopy[i] = new class CItem;
			_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
			bCopyItemContents(pItemAcopy[i], pItemA[i]);
			pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
		}
		else {
			pItemA[i] = (class CItem *)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]];
			pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
			pItemAcopy[i] = new class CItem;
			_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
			bCopyItemContents(pItemAcopy[i], pItemA[i]);
			pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
			_bItemLog(DEF_ITEMLOG_EXCHANGE, iClientH, iExH, pItemAcopy[i],FALSE);
		}
	}
	for (i = 0; i <m_pClientList[iExH]->m_iExchangeCount; i++){
		if ((m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			pItemB[i] = new class CItem;
			_bInitItemAttr(pItemB[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
			pItemB[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
			pItemBcopy[i] = new class CItem;
			_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
			bCopyItemContents(pItemBcopy[i], pItemB[i]);
			pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
		}
		else {
			pItemB[i] = (class CItem *)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]];
			pItemB[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
			pItemBcopy[i] = new class CItem;
			_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
			bCopyItemContents(pItemBcopy[i], pItemB[i]);
			pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
			_bItemLog(DEF_ITEMLOG_EXCHANGE, iExH, iClientH, pItemBcopy[i], FALSE);
		}
	}
	for (i = 0; i<m_pClientList[iExH]->m_iExchangeCount; i++) {
		delete pItemBcopy[i];
		pItemBcopy[i] = NULL;
		if ((m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			iAmountLeft = (int)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_dwCount - m_pClientList[iExH]->m_iExchangeItemAmount[i];
			if (iAmountLeft < 0) iAmountLeft = 0;	  
			SetItemCount(iExH, m_pClientList[iExH]->m_cExchangeItemIndex[i], iAmountLeft);
		}
		else {
			ReleaseItemHandler(iExH, m_pClientList[iExH]->m_cExchangeItemIndex[i], TRUE);
			SendNotifyMsg(NULL, iExH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iExH]->m_cExchangeItemIndex[i], m_pClientList[iExH]->m_iExchangeItemAmount[i], NULL, m_pClientList[iClientH]->m_cCharName);
			m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] = NULL;
		}
		bAddItem(iExH, pItemA[i], NULL);
	}
	for (i = 0; i < m_pClientList[iClientH]->m_iExchangeCount; i++){
		delete pItemAcopy[i];
		pItemAcopy[i] = NULL;
		if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
			iAmountLeft = (int)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_dwCount - m_pClientList[iClientH]->m_iExchangeItemAmount[i];
			if (iAmountLeft < 0) iAmountLeft = 0;	 
			SetItemCount(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex[i], iAmountLeft);
		}
		else {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex[i], TRUE);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iClientH]->m_cExchangeItemIndex[i], m_pClientList[iClientH]->m_iExchangeItemAmount[i], NULL, m_pClientList[iExH]->m_cCharName);
			m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]] = NULL;
		}
		bAddItem(iClientH, pItemB[i], NULL);
	}
	
	m_pClientList[iClientH]->m_cExchangeMode = 0;
	m_pClientList[iClientH]->m_bIsExchangeConfirm = FALSE;
	ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
	m_pClientList[iClientH]->m_iExchangeH = NULL;
	for (i = 0; i < 4; i++) {
		m_pClientList[iClientH]->m_cExchangeItemIndex[i]	= 0;
		m_pClientList[iClientH]->m_iExchangeItemAmount[i]	= 0;
		m_pClientList[iClientH]->m_iExchangeAlterIndex[i]	= 0;
		ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName[i], sizeof(m_pClientList[iClientH]->m_cExchangeItemName[i]));
	}
	m_pClientList[iClientH]->m_iExchangeCount = 0;
	m_pClientList[iClientH]->m_iExchangeComplete = 0;
	
	m_pClientList[iExH]->m_cExchangeMode = 0;
	m_pClientList[iExH]->m_bIsExchangeConfirm = FALSE;
	ZeroMemory(m_pClientList[iExH]->m_cExchangeName, sizeof(m_pClientList[iExH]->m_cExchangeName));
	m_pClientList[iExH]->m_iExchangeH = NULL;
	for (i = 0; i < 4; i++) {
		m_pClientList[iExH]->m_cExchangeItemIndex[i]	= 0;
		m_pClientList[iExH]->m_iExchangeItemAmount[i]	= 0;
		m_pClientList[iExH]->m_iExchangeAlterIndex[i]	= 0;
		ZeroMemory(m_pClientList[iExH]->m_cExchangeItemName[i], sizeof(m_pClientList[iExH]->m_cExchangeItemName[i]));
	}
	m_pClientList[iExH]->m_iExchangeCount = 0;
	m_pClientList[iExH]->m_iExchangeComplete = 0;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iExH,     DEF_NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);
	iCalcTotalWeight(iClientH);
	iCalcTotalWeight(iExH);
}

/*********************************************************************************************************************
**  void CGame::SetExchangeItem(int iClientH, int iItemIndex, int iAmount)											**
**  DESCRIPTION			:: exchange item handler																	**
**  LAST_UPDATED		:: March 20, 2005; 6:31 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- stores item number																	**
**							- counts total item numbers																**
**  MODIFICATION		::	- n/a																					**
**********************************************************************************************************************/
void CGame::ExchangeItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char *pItemName)
{
 short sOwnerH;
 char  cOwnerType;
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount < iAmount) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;
	if (m_pClientList[iClientH]->m_cExchangeMode == 1) return;
	if (wObjectID >= DEF_MAXCLIENTS) return;
	// new
	for (i = 0; i < 4; i++) {
		m_pClientList[iClientH]->m_cExchangeItemIndex[i] = 0;
		m_pClientList[iClientH]->m_iExchangeItemAmount[i] = 0;
		m_pClientList[iClientH]->m_iExchangeAlterIndex[i] = 0;
		ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName[i], sizeof(m_pClientList[iClientH]->m_cExchangeItemName[i]));
	}
	m_pClientList[iClientH]->m_iExchangeCount = 0;
	m_pClientList[iClientH]->m_iExchangeComplete = 0;
	if (m_pClientList[iClientH]->m_cExchangeMode != 0) {
			_ClearExchangeStatus(iClientH);
			_ClearExchangeStatus(m_pClientList[iClientH]->m_iExchangeH);
			return;		
	}
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
	if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
		if (wObjectID != NULL) { 
			if (wObjectID < 10000) {
				if ((m_pClientList[wObjectID] != NULL) && ((WORD)sOwnerH != wObjectID)) {
					sOwnerH = NULL;
				}
			}
			else sOwnerH = NULL;
		}
		if ((sOwnerH == NULL) || (m_pClientList[sOwnerH] == NULL)) {
			_ClearExchangeStatus(iClientH); 
		}
		else {
			if ((m_pClientList[sOwnerH]->m_cExchangeMode == 1) || (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) ||
				(m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) {
				_ClearExchangeStatus(iClientH);
			}
			else {
				for (i = 0; i < 4; i++) {
					m_pClientList[sOwnerH]->m_cExchangeItemIndex[i] = 0;
					m_pClientList[sOwnerH]->m_iExchangeItemAmount[i] = 0;
					m_pClientList[sOwnerH]->m_iExchangeAlterIndex[i] = 0;
					ZeroMemory(m_pClientList[sOwnerH]->m_cExchangeItemName[i], sizeof(m_pClientList[sOwnerH]->m_cExchangeItemName[i]));
				}
				m_pClientList[sOwnerH]->m_iExchangeCount = 0;
				m_pClientList[sOwnerH]->m_iExchangeComplete = 0;

				m_pClientList[iClientH]->m_cExchangeMode = 1;
				m_pClientList[iClientH]->m_iExchangeH = sOwnerH;
				ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
				strcpy(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[sOwnerH]->m_cCharName);

				m_pClientList[sOwnerH]->m_cExchangeMode = 2;
				m_pClientList[sOwnerH]->m_iExchangeH = iClientH;
				ZeroMemory(m_pClientList[sOwnerH]->m_cExchangeName, sizeof(m_pClientList[sOwnerH]->m_cExchangeName));
				strcpy(m_pClientList[sOwnerH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName);

				m_pClientList[iClientH]->m_cExchangeItemIndex[m_pClientList[iClientH]->m_iExchangeCount] = sItemIndex;
				m_pClientList[iClientH]->m_iExchangeItemAmount[m_pClientList[iClientH]->m_iExchangeCount] = iAmount;
				ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->m_iExchangeCount], sizeof(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->m_iExchangeCount]));
				memcpy(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->m_iExchangeCount], m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, 20);
				m_pClientList[iClientH]->m_iExchangeCount++;
				// new - stores item number
				m_pClientList[sOwnerH]->m_iExchangeAlterIndex[m_pClientList[sOwnerH]->m_iExchangeComplete] = (int)sItemIndex;
				// new - counts total item numbers stored
				m_pClientList[sOwnerH]->m_iExchangeComplete++;
				SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_OPENEXCHANGEWINDOW, sItemIndex+1000, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				              m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 +100,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);

				SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_OPENEXCHANGEWINDOW, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				              m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 +100,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);
			}
		}
	}
	else {
		_ClearExchangeStatus(iClientH);
	}
}

/*********************************************************************************************************************
**  void CGame::_ClearExchangeStatus(int iToH)																		**
**  DESCRIPTION			:: clear exchange status																	**
**  LAST_UPDATED		:: March 20, 2005; 7:15 PM; Hypnotoad														**
**	RETURN_VALUE		:: void																						**
**  NOTES				::	- clears all trade variables															**
**  MODIFICATION		::	- n/a																					**
**********************************************************************************************************************/
void CGame::_ClearExchangeStatus(int iToH)
{
 int i;
	
	if ((iToH <= 0) || (iToH >= DEF_MAXCLIENTS)) return;
	if (m_pClientList[iToH] == NULL) return;
	if (m_pClientList[iToH]->m_cExchangeMode != 0) {
		SendNotifyMsg(NULL, iToH, DEF_NOTIFY_CANCELEXCHANGEITEM, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);	
	}
	m_pClientList[iToH]->m_cExchangeMode    = 0;
	m_pClientList[iToH]->m_bIsExchangeConfirm = FALSE;
	for (i = 0; i < 4; i++) {
		m_pClientList[iToH]->m_cExchangeItemIndex[i] = 0;
		m_pClientList[iToH]->m_iExchangeAlterIndex[i] = 0;
		m_pClientList[iToH]->m_iExchangeItemAmount[i] = 0;
		ZeroMemory(m_pClientList[iToH]->m_cExchangeItemName[i], sizeof(m_pClientList[iToH]->m_cExchangeItemName[i]));
	}
	m_pClientList[iToH]->m_iExchangeCount = 0;
	m_pClientList[iToH]->m_iExchangeH = NULL;
}

void CGame::CancelExchangeItem(int iClientH)
{
 int iExH;
	
	iExH = m_pClientList[iClientH]->m_iExchangeH;
	_ClearExchangeStatus(iExH);
	_ClearExchangeStatus(iClientH);
}

/*********************************************************************************************************************
**  BOOL CGame::RequestHeldenianScroll(int iClientH, char * pData, DWORD dwMsgSize)									**
**  description		:: A player requested some scroll										 						**
**  Scrolls are only available for current battle, and usable only by the player that brought it					**					::																								**
*********************************************************************************************************************/
void CGame::RequestHeldenianScroll(int iClientH, char * pData, DWORD dwMsgSize)
{char  *cp, cData[256], cTmpName[21];
 int   iItemNbe;
 class CItem * pItem;
 int   iRet, iEraseReq, iNeededPts;
 short * sp;
 WORD  * wp;
 DWORD * dwp;
	if (m_pClientList[iClientH] == NULL)					 return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_bIsHeldenianMode == FALSE)						 return;
	if (_iGetItemSpaceLeft(iClientH) == 0) 
	{	SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
		return;
	}
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	cp += 20;
	wp = (WORD *)cp;
	iItemNbe = (int) *wp; // 0x00 l a i
	cp += 2;
	wsprintf(G_cTxt, "PC(%s) obtained a summon scroll (%d).   %s(%d %d)"
			, m_pClientList[iClientH]->m_cCharName
			, iItemNbe
			, m_pClientList[iClientH]->m_cMapName
			, m_pClientList[iClientH]->m_sX
			, m_pClientList[iClientH]->m_sY);	
	PutLogList(G_cTxt);	
	switch (iItemNbe) {
	case 875: // Sorceress
		iNeededPts = 2000;
		break;
	case 876: // Ancient Temple Knight
		iNeededPts = 3000;
		break;
	case 877: // Elf Master
		iNeededPts = 1500;
		break;
	case 878: // DarkShadow Knight
		iNeededPts = 3000;
		break;
	case 879: // Heavy Battle Tank
		iNeededPts = 4000;
		break;
	case 880: // Barbarian
		iNeededPts = 3000;
		break;
	default:
		iNeededPts = 999999;
		PutLogList("Gail asked to create a wrong item!");	
		break;
	}
	if (m_pClientList[iClientH]->m_iConstructionPoint < iNeededPts)
	{	return; // Unable to get item...
	}else
	{	// Get the scroll
		m_pClientList[iClientH]->m_iConstructionPoint -= iNeededPts;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 0, NULL); // 0:tell client
	}
	// Them create the summonScroll
	pItem = NULL;
	pItem = new class CItem;
	if (pItem == NULL) return;
	if ((_bInitItemAttr(pItem, iItemNbe) == TRUE)) 
	{	pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
		memcpy(&pItem->m_sItemSpecEffectValue1, &m_dwHeldenianGUID, 4);
		
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
		{	ZeroMemory(cData, sizeof(cData));
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;				
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);				
			*cp = 1;
			cp++;				
			memcpy(cp, pItem->m_cName, 20);
			cp += 20;				
			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;				
			*cp = pItem->m_cItemType;
			cp++;				
			*cp = pItem->m_cEquipPos;
			cp++;				
			*cp = (char)0; 
			cp++;				
			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;				
			*cp = pItem->m_cGenderLimit;
			cp++;				
			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;				
			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;				
			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;				
			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;
			*cp = pItem->m_cItemColor;
			cp++;
			*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
			cp++;				
			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;
			if (iEraseReq == 1) delete pItem;				
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}
		}else 
		{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				                                                         m_pClientList[iClientH]->m_sY, pItem);			
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4			
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;				
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
		}	}
	}else 
	{	delete pItem;
		pItem = NULL;
	}
}

void CGame::HeldenianWinner()
{
 
}



void CGame::CalcMeteorStrikeEffectHandler(int iMapIndex)
{
 int i, iActiveStructure, iStructureHP[DEF_MAXSTRIKEPOINTS] ;
 char * cp, * cp2, cData[120], cWinnerSide, cTempData[120];
 WORD * wp;

	if (m_bIsCrusadeMode == FALSE) return;
	for(i = 0 ; i < DEF_MAXSTRIKEPOINTS; i++) iStructureHP[i] = 0;
	iActiveStructure = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iActiveStructure++;
			iStructureHP[i] = m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP ;
		}
	}
	wsprintf(G_cTxt, "ActiveStructure:%d  MapIndex:%d AresdenMap:%d ElvineMap:%d", iActiveStructure, iMapIndex, m_iAresdenMapIndex, m_iElvineMapIndex);
	PutLogList(G_cTxt);
	if (iActiveStructure == 0) {
		if (iMapIndex == m_iAresdenMapIndex) {
			cWinnerSide = 2;
			LocalEndCrusadeMode(2);
		}
		else if (iMapIndex == m_iElvineMapIndex) {
			cWinnerSide = 1;
			LocalEndCrusadeMode(1);
		}
		else {
			cWinnerSide = 0;
			LocalEndCrusadeMode(0); 
		}
		
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_ENDCRUSADE;
		cp++;

		*cp = cWinnerSide;
		cp++;			

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;

		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;

		bStockMsgToGateServer(cData, 18);
	}
	else {
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_GRANDMAGICRESULT;
		cp++;
		
		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD) iActiveStructure;
		cp += 2;

		ZeroMemory(cTempData, sizeof(cTempData));
		cp2 = (char *)(cTempData); 

		wp = (WORD *)cp2;
		*wp = (WORD) m_pMapList[iMapIndex]->m_iTotalStrikePoints;
		cp2 += 2;

		for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints;i++) {
			wp = (WORD *)cp2;
			*wp = (WORD) iStructureHP[i];
			cp2 += 2;
		}
		memcpy(cp, cTempData,(m_pMapList[iMapIndex]->m_iTotalStrikePoints*2)+2);
		bStockMsgToGateServer(cData, (m_pMapList[iMapIndex]->m_iTotalStrikePoints*2)+20);
		GrandMagicResultHandler(m_pMapList[iMapIndex]->m_cName, m_stMeteorStrikeResult.iCrashedStructureNum, m_stMeteorStrikeResult.iStructureDamageAmount, m_stMeteorStrikeResult.iCasualties, iActiveStructure, m_pMapList[iMapIndex]->m_iTotalStrikePoints, cTempData);
	}
	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;
}

BOOL CGame::_bDecodeNpcConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iNpcConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// NPC
					if (strlen(token) > 20)	{
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Too long Npc name.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					ZeroMemory(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, sizeof(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName));
					memcpy(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, token, strlen(token));
					cReadModeB = 2;
					break;
				case 2:
					// m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					// m_iHitDice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iHitDice = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					// m_iDefenseRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iDefenseRatio = atoi(token);
					cReadModeB = 5;
					break;
				case 5:
					// m_iHitRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iHitRatio = atoi(token);
					cReadModeB = 6;
					break;
				case 6:
					// m_iMinBravery
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMinBravery = atoi(token);
					cReadModeB = 7;
					break;
				case 7:
					// m_iExpDiceMin
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDiceMin = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_iExpDiceMax
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDiceMax = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_iGoldDiceMin
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iGoldDiceMin = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_iGoldDiceMax
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iGoldDiceMax = atoi(token);
					cReadModeB = 11;
					break;
				
				case 11:
					// m_cAttackDiceThrow
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceThrow = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// m_cAttackDiceRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceRange = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					// m_cSize
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cSize = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cSide = atoi(token);
					cReadModeB = 15;
					break;
				
				case 15:
					// ActionLimit 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cActionLimit = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// Action Time
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_dwActionTime = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// ResistMagic
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cResistMagic = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// cMagicLevel
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cMagicLevel = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// cGenDayWeekLimit  //     
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cDayOfWeekLimit = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// cChatMsgPresence
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence = atoi(token);
					
					if (m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence == 1) {
						//    .   . 


					}
					cReadModeB = 21;
					break;

				case 21:
					// m_cTargetSearchRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cTargetSearchRange = atoi(token);
										
					cReadModeB = 22;
					break;		

				case 22:
					// Npc   
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_dwRegenTime = atoi(token);
										
					cReadModeB = 23;
					break;

				case 23:
					// Attribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttribute = atoi(token);
										
					cReadModeB = 24;
					break;

				case 24:
					// Absorb Magic Damage
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iAbsDamage = atoi(token);
					
					cReadModeB = 25;
					break;

				case 25:
					// Maximum Mana Point
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMaxMana = atoi(token);
					
					cReadModeB = 26;
					break;

				case 26:
					// MagicHitRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMagicHitRatio = atoi(token);
									
					cReadModeB = 27;
					break;

				case 27:
					// AttackRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iAttackRange = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					iNpcConfigListIndex++;
					break;

				
				}
				break;

			

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Npc", 3) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pNpcConfigList[iNpcConfigListIndex] = new class CNpc(" ");
			}

			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! NPC configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) NPC(Total:%d) configuration - success!", iNpcConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

void CGame::LocalEndCrusadeMode(int iWinnerSide)
{
 int i, n;

	wsprintf(G_cTxt, "LocalEndCrusadeMode(%d)", iWinnerSide);
	PutLogList(G_cTxt);

	if (m_bIsCrusadeMode == FALSE) return;
	m_bIsCrusadeMode = FALSE;
	PutLogList("(!)Crusade Mode OFF.");

	for (n = 0 ; n < DEF_MAXNPCS; n++)
	if (m_pNpcList[n] != NULL) {
		switch (m_pNpcList[n]->m_sType) {
		case 36:
		case 37:
		case 38:
		case 39:
		case 40:
		case 41:
		case 42:
		case 43:
		case 44:
		case 45:
		case 46:
		case 47:
		case 51:
			RemoveEventNpc(n);
			break;
		}
	}

	_CreateCrusadeGUID(m_dwCrusadeGUID, iWinnerSide);
	m_iCrusadeWinnerSide = iWinnerSide;
	m_iLastCrusadeWinner = iWinnerSide;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
		m_pClientList[i]->m_iCrusadeDuty = 0;
		m_pClientList[i]->m_iConstructionPoint = 0;
		m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
		SendNotifyMsg(NULL, i, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, NULL, NULL, m_iCrusadeWinnerSide);
	}
	
	if (iWinnerSide == 2) {
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, FALSE, FALSE, "Elvine Win!");
	}
	else if (iWinnerSide == 1) {
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, FALSE, FALSE, "Aresden Win!");
	}
	else{
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, FALSE, FALSE, "Draw!");
	}
}


void CGame::ClearMap()
{int i, k, j, m;
 class CItem * pItem;
 short sRemainItemSprite, sRemainItemSpriteFrame;
 char cRemainItemColor;
	for (m = 0; m < DEF_MAXMAPS; m++) 
	{	if (m_pMapList[m] != NULL)
		{	for(j = 1; j < m_pMapList[m]->m_sSizeX; j++) 
			{	for(k = 1; k < m_pMapList[m]->m_sSizeY; k++)
				{	do 
					{	pItem = m_pMapList[m]->pGetItem(j, k, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
						if (pItem != NULL) 
						{	delete pItem;
					}	} 
					while (pItem != NULL);
	}	}	}	}
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL) 
		{	RequestTeleportHandler(i, "2 ", m_pClientList[i]->m_cMapName, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
	}	}
	m_iNotifyCleanMap = TRUE;
}

void CGame::SendNotifyMsg(int iFromH, int iToH, WORD wMsgType, DWORD sV1, DWORD sV2, DWORD sV3, char * pString, DWORD sV4, DWORD sV5, DWORD sV6, DWORD sV7, DWORD sV8, DWORD sV9, char * pString2)
{
 char cData[1000];
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 int   * ip, iRet, i;
	
	if (m_pClientList[iToH] == NULL) return;

	ZeroMemory(cData, sizeof(cData));

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);			   
	*wp  = wMsgType;

	cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2);

	// !!! sV1, sV2, sV3 DWORD .
	switch (wMsgType) {

		

	//New Party Status - ZeroEoyPnk
	case DEF_SEND_PARTYHP:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;
		
		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		ip  = (int *)cp;
		*ip = (int)sV3;
		cp += 4;

		ip  = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		ip  = (int *)cp;
		*ip = (int)sV5;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_SEND_PARTYCOORDS:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		ip  = (int *)cp;
		*ip = (int)sV3;
		cp += 4;

		if (pString != NULL) memcpy(cp, pString, 12);
		cp += 12;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);
		break;

	

	//50Cent - HP Bar
	case DEF_SEND_NPCHP:
		ip  = (int *)cp;
        *ip = (int)sV1;
        cp += 4;

		ip  = (int *)cp;
		*ip = (int)sV2;
        cp += 4;
        iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
        break;


	// Centuu: msgs agrupados
	case DEF_NOTIFY_DEATHMATCHSTART: // MORLA 2.3 - DEATHMACH ON
	case DEF_NOTIFY_DEATHMATCHEND: // MORLA 2.3 - DEATHMACH OFF
	case DEF_NOTIFY_EVENTTPOFF:
    case DEF_NOTIFY_EVENTEND:
	case DEF_NOTIFY_EVENTSTART:
	case DEF_NOTIFY_MORLEARPJ: 
	case DEF_NOTIFY_NOMOREAGRICULTURE:
	case DEF_NOTIFY_AGRICULTURESKILLLIMIT:
	case DEF_NOTIFY_AGRICULTURENOAREA:
	case DEF_NOTIFY_APOCFORCERECALLPLAYERS:
	case DEF_NOTIFY_APOCGATESTARTMSG:
	case DEF_NOTIFY_APOCGATEENDMSG:
	case DEF_NOTIFY_NORECALL:
	case DEF_NOTIFY_ABADDONTHUNDER:
	case DEF_NOTIFY_0BE8:
	case DEF_NOTIFY_HELDENIANTELEPORT:
	case DEF_NOTIFY_HELDENIANEND:
	case DEF_NOTIFY_RESURRECTPLAYER:
	case DEF_NOTIFY_SLATE_EXP:
	case DEF_NOTIFY_SLATE_MANA:
	case DEF_NOTIFY_SLATE_INVINCIBLE:
	case DEF_NOTIFY_SLATE_CREATEFAIL:
	case DEF_NOTIFY_NOMORECRUSADESTRUCTURE:
	case DEF_NOTIFY_EXCHANGEITEMCOMPLETE:
	case DEF_NOTIFY_CANCELEXCHANGEITEM:
	case DEF_NOTIFY_NOTFLAGSPOT:
	case DEF_NOTIFY_CRAFTING_SUCCESS:		
	case DEF_NOTIFY_POTIONSUCCESS:
	case DEF_NOTIFY_LOWPOTIONSKILL:
	case DEF_NOTIFY_POTIONFAIL:
	case DEF_NOTIFY_NOMATCHINGPOTION:
	case DEF_NOTIFY_ADMINUSERLEVELLOW:
	case DEF_NOTIFY_TOBERECALLED:
	case DEF_NOTIFY_CANNOTITEMTOBANK:
	case DEF_NOTIFY_STATECHANGE_FAILED:	
	case DEF_NOTIFY_SETTING_FAILED:
	case DEF_NOTIFY_NOGUILDMASTERLEVEL:
	case DEF_NOTIFY_CANNOTBANGUILDMAN:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_HELDENIANCOUNT:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV4;		
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV5;		
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV6;		
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22); // 14 -> 22
		break;

	// New 18/05/2004
	case DEF_NOTIFY_SPAWNEVENT:
		*cp = (char)sV3;
		cp++;

		sp = (short *)cp;
		*cp = sV1;
		cp += 2;

		sp = (short *)cp;
		*cp = sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 11);
		break;

	
	case DEF_NOTIFY_QUESTCOUNTER:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;


	
	case DEF_NOTIFY_APOCGATECLOSE:
	case DEF_NOTIFY_APOCGATEOPEN:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;

		ip  = (int *)cp;
		*ip = sV2;
		cp += 4;

		memcpy(cp,pString,10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;

	case DEF_NOTIFY_ABADDONKILLED:
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;
	
	case DEF_NOTIFY_FORCERECALLTIME:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	// New 16/05/2004
	//0xB4E2,
	case DEF_NOTIFY_HELDENIANVICTORY:
	case DEF_NOTIFY_MONSTERCOUNT:
	case DEF_NOTIFY_SLATE_STATUS:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_SLATE_CREATESUCCESS:
		dwp  = (DWORD *)cp;
		*dwp = sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	// New 07/05/2004
	// Party Notify Msg's
	case DEF_NOTIFY_PARTY:
		switch(sV1) {
		case 4:
		case 6:
			wp = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;

			memcpy(cp,pString,10);
			cp += 10;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
			break;
		case 5:
			wp = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;

			memcpy(cp, pString, sV3 * 11);
			cp += sV3 * 11;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12 + (sV3 * 11));
			break;
		default:
			wp = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV4;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
				break;
		}
		break;

	case DEF_NOTIFY_REQRANGO: // Morla2.2 - Notify Rango
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;

		ip  = (int *)cp;
		*ip = sV2;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;

	case DEF_NOTIFY_REQGUILDNAMEANSWER:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);
		break;

	// New 06/05/2004
	// Upgrade Notify Msg's
	case DEF_NOTIFY_ITEMUPGRADEFAIL:
		sp  = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,8);
		break;

	case DEF_NOTIFY_MAJESTIC_LEVEL:
	case DEF_NOTIFY_ITEMATTRIBUTECHANGE:
	case DEF_NOTIFY_GIZONITEMUPGRADELEFT:
		sp  = (short *)cp;
		*sp = sV1;
		cp += 2;

		dwp = (DWORD *)cp;
		*dwp = sV2;
		cp += 4;

		dwp = (DWORD *)cp;
		*dwp = sV3;
		cp += 4;

		dwp = (DWORD *)cp;
		*dwp = sV4;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,20);
		break;

	case DEF_NOTIFY_UPGRADEHEROCAPE:
	case DEF_NOTIFY_GIZONITEMCANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		*cp = (char)sV2;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		*cp = (char)sV6;
		cp++;

		*cp = (char)sV7;
		cp++;

		dwp = (DWORD *)cp;
		*dwp = sV8;
		cp += 4;

		memcpy(cp,pString,20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,41);
		break;

// 2.06 - by KLKS
	case DEF_NOTIFY_CHANGEPLAYMODE:
		memcpy(cp,pString,10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,16);
		break;
//

	case DEF_NOTIFY_TCLOC:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		
		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV5;
		cp += 2;
		
		memcpy(cp, pString2, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;
	
	//New 11/05/2004
	case DEF_NOTIFY_GRANDMAGICRESULT:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		if (sV9 > 0) {
			memcpy(cp,pString2,(sV9*2)+2);
			cp += (sV9*2)+2;
		}
		else{
			sp = (short *)cp;
			*sp = 0;
			cp += 2;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, (sV9*2)+26);
		break;
	
	case DEF_NOTIFY_MAPSTATUSNEXT:
	case DEF_NOTIFY_MAPSTATUSLAST:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6+sV1);
		break;
	
	case DEF_NOTIFY_LOCKEDMAP:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 18);
		break;
	
	case DEF_NOTIFY_BUILDITEMSUCCESS:
	case DEF_NOTIFY_BUILDITEMFAIL:
		
		if (sV1 >= 0) {
			sp = (short *)cp;
			*sp = (short)sV1;
			cp += 2;
		}
		else {
			sp = (short *)cp;
			*sp = (short)sV1 + 10000;
			cp += 2;
		}

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
		
	case DEF_NOTIFY_HELP:
	case DEF_NOTIFY_QUESTREWARD:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;
				
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;
		
	case DEF_NOTIFY_CANNOTCONSTRUCT:
	case DEF_NOTIFY_METEORSTRIKECOMING:
	case DEF_NOTIFY_METEORSTRIKEHIT:
	case DEF_NOTIFY_HELPFAILED:
	case DEF_NOTIFY_SPECIALABILITYENABLED:
	case DEF_NOTIFY_FORCEDISCONN:
	case DEF_NOTIFY_OBSERVERMODE:
	case DEF_NOTIFY_QUESTCOMPLETED:
	case DEF_NOTIFY_QUESTABORTED:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_QUESTCONTENTS:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;
	
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 44);
		break;
		
	case DEF_NOTIFY_ENERGYSPHERECREATED:
	case DEF_NOTIFY_ITEMCOLORCHANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SETEXCHANGEITEM:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		*cp = (char)sV5;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;
		
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		// v1.42
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
		break;
	
	case DEF_NOTIFY_OPENEXCHANGEWINDOW:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		*cp = (char)sV5;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		// v1.42
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
		break;
	
	case DEF_NOTIFY_ITEMPOSLIST:
		for (i = 0; i < DEF_MAXITEMS; i++) {
			sp = (short *)cp;
			*sp = (short)m_pClientList[iToH]->m_ItemPosList[i].x;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_pClientList[iToH]->m_ItemPosList[i].y;
			cp += 2;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + DEF_MAXITEMS*4);
		break;
	
	case DEF_NOTIFY_ENEMYKILLS:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_CRUSADE:
		ip = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_NOTIFY_CONSTRUCTIONPOINT:
	case DEF_NOTIFY_SPECIALABILITYSTATUS:
	case DEF_NOTIFY_DAMAGEMOVE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case DEF_NOTIFY_DOWNSKILLINDEXSET:
	case DEF_NOTIFY_RESPONSE_CREATENEWPARTY:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_ADMINIFO:
		switch (sV1) {
		case 1:
			// NPC  .
			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHP;
			cp += 4;
			
			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iDefenseRatio;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_bIsSummoned;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_cActionLimit;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHitDice;
			cp += 4;

			dwp  = (DWORD *)cp; // v1.4
			*dwp = m_pNpcList[sV2]->m_dwDeadTime;
			cp += 4;

			dwp  = (DWORD *)cp; 
			*dwp = m_pNpcList[sV2]->m_dwRegenTime;
			cp += 4;

			ip  = (int *)cp; 
			*ip	= (int)m_pNpcList[sV2]->m_bIsKilled;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26 + 12);
			break;
		}
		break;

	case DEF_NOTIFY_HELDENIANSTART:
	case DEF_NOTIFY_NPCTALK:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString != NULL) memcpy(cp, pString, 20);
		cp += 20;

		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 64);
		break;

	// Crafting
	case DEF_NOTIFY_CRAFTING_FAIL:		//reversed by Snoopy: 0x0BF1:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SUPERATTACKLEFT:
		sp = (short *)cp;
		*sp = m_pClientList[iToH]->m_iSuperAttackLeft;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_SAFEATTACKMODE:
		*cp = m_pClientList[iToH]->m_bIsSafeAttackMode;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;
	
	case DEF_NOTIFY_QUERY_JOINPARTY:
	case DEF_NOTIFY_IPACCOUNTINFO:
		strcpy(cp, pString);
		cp += strlen(pString);

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
		break;
	
	case DEF_NOTIFY_REWARDGOLD:
		dwp = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iRewardGold;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SERVERSHUTDOWN:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_GLOBALATTACKMODE:
	case DEF_NOTIFY_WHETHERCHANGE:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;
		
	case DEF_NOTIFY_FISHCANCELED:
	case DEF_NOTIFY_FISHSUCCESS:
	case DEF_NOTIFY_FISHFAIL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_DEBUGMSG:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_FISHCHANCE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
				
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_ENERGYSPHEREGOALIN:
	case DEF_NOTIFY_EVENTFISHMODE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_NOTICEMSG:
		memcpy(cp, pString, strlen(pString));
		cp += strlen(pString);

		*cp = NULL;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, strlen(pString) + 7);
		break;

	case DEF_NOTIFY_CANNOTRATING:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_RATINGPLAYER:
		*cp = (char)sV1;
		cp++;

		memcpy(cp, pString, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iRating;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_NOTIFY_PLAYERSHUTUP:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 19);
		break;
	
	case DEF_NOTIFY_TIMECHANGE:
	case DEF_NOTIFY_HUNGER:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_PLAYERPROFILE:
		if (strlen(pString) > 100) {
			memcpy(cp, pString, 100);
			cp += 100;
		}
		else {
			memcpy(cp, pString, strlen(pString));
			cp += strlen(pString);
		}
		*cp = NULL;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7 + strlen(pString));
		break;

	// New 10/05/2004 Changed
	case DEF_NOTIFY_WHISPERMODEON:
	case DEF_NOTIFY_WHISPERMODEOFF:
	case DEF_NOTIFY_PLAYERNOTONGAME:
		memcpy(cp, pString, 10);
		cp += 10;

		memcpy(cp, "          ", 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 27);
		break;

	// New 15/05/2004 Changed
	case DEF_NOTIFY_PLAYERONGAME:
		memcpy(cp, pString, 10);
		cp += 10;

		if (pString[0] != 0) {
			memcpy(cp, pString2, 14);
			cp += 14;
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 31);
		break;
	
	// New 06/05/2004
	case DEF_NOTIFY_ITEMSOLD:
	case DEF_NOTIFY_ITEMREPAIRED:
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV1;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case DEF_NOTIFY_REPAIRALLPRICES:
        wp = (WORD *)cp;
        *wp = (WORD)m_pClientList[iToH]->totalItemRepair;
        cp += 2;
        for(i = 0; i < m_pClientList[iToH]->totalItemRepair; i++)
        {
            *cp = (char)m_pClientList[iToH]->m_stRepairAll[i].index;
            cp++;

            wp = (WORD *)cp;
            *wp = (WORD)m_pClientList[iToH]->m_stRepairAll[i].price;
            cp += 2;
        }
        iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8 + (m_pClientList[iToH]->totalItemRepair * 3));
        break;

	// New 06/05/2004
	case DEF_NOTIFY_REPAIRITEMPRICE:
	case DEF_NOTIFY_SELLITEMPRICE:
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV1;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV3;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV4;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 42);
		break;

	case DEF_NOTIFY_CANNOTREPAIRITEM:
	case DEF_NOTIFY_CANNOTSELLITEM:
		wp = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);

		break;
	
	case DEF_NOTIFY_SHOWMAP:
		wp  = (WORD *)cp;  //   
		*wp = (WORD)sV1;
		cp += 2;
		
		wp  = (WORD *)cp;  //   (0 aresden, 1 elvine, 3 middleland...)
		*wp = (WORD)sV2;
		cp += 2;
	
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SKILLUSINGEND:
		wp  = (WORD *)cp;  //    
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_TOTALUSERS:
		wp  = (WORD *)cp;    
		*wp = (WORD)m_iTotalGameServerClients; 
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_MAGICEFFECTOFF:
	case DEF_NOTIFY_MAGICEFFECTON:
		wp  = (WORD *)cp;  //    
		*wp = (WORD)sV1;
		cp += 2;
		
		dwp  = (DWORD *)cp;  //     
		*dwp = (DWORD)sV2;
		cp += 4;

		dwp  = (DWORD *)cp;  //     
		*dwp = (DWORD)sV3;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;
	
	case DEF_NOTIFY_SERVERCHANGE:

		memcpy(cp, m_pClientList[iToH]->m_cMapName, 10);
		cp += 10;  
		
		// World Server connection across hgservers, behind router problem
		// ArchAngel fix
		if (m_iGameServerMode == 1) // Mode = 1 is LAN or ROUTER (behind router)
        {	if (memcmp(m_cLogServerAddr, m_cGameServerAddr, 15) == 0)
			{	memcpy(cp, m_cGameServerAddrExternal, 15);
			}else
			{	memcpy(cp, m_cLogServerAddr, 15);
			}
		}else if (m_iGameServerMode == 2)// mode = 2 INTERNET
		{	memcpy(cp, m_cLogServerAddr, 15);
		}
		cp += 15;
		ip = (int *)cp;
		*ip = m_iLogServerPort;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16 +19);

		break;

	case DEF_NOTIFY_SKILL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_SETITEMCOUNT:
		wp  = (WORD *)cp;  //    
		*wp = (WORD)sV1;
		cp += 2;
		
		dwp  = (DWORD *)cp;  //    
		*dwp = (DWORD)sV2;
		cp += 4;
				
		*cp = (char)sV3;
		cp++;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 13);
		break;

	case DEF_NOTIFY_ITEMDEPLETED_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED:
	case DEF_NOTIFY_DROPITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;
		
	case DEF_NOTIFY_CANNOTGIVEITEM:
	case DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED:
	case DEF_NOTIFY_GIVEITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_ENEMYKILLREWARD:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;

		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iEnemyKillCount;
		cp += 4;

		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMaxEK;
		cp += 4;

		memcpy(cp, m_pClientList[sV1]->m_cCharName, 10);
		cp += 10;
		memcpy(cp, m_pClientList[sV1]->m_cGuildName, 20);
		cp += 20;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[sV1]->m_iGuildRank;
		cp += 2;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[iToH]->m_iWarContribution;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case DEF_NOTIFY_USERJOIN:
		memcpy(cp, pString, 21);
		cp += 21;
		memcpy(cp, pString2, 22);
		cp += 22;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case DEF_NOTIFY_PKCAPTURED:
		// PK .
		// PK PKcount
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		memcpy(cp, pString, 10);
		cp += 10;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iRewardGold;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iExp;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case DEF_NOTIFY_PKPENALTY:
		// PK  .
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iStr;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iVit;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iDex;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iInt;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMag;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iCharisma;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iPKCount;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;
	
	case DEF_NOTIFY_TRAVELERLIMITEDLEVEL:
	case DEF_NOTIFY_LIMITEDLEVEL:
		//        .
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_ITEMRELEASED:
	case DEF_NOTIFY_ITEMLIFESPANEND:
		//  ,       . 
		sp  = (short *)cp;
		*sp = (short)sV1;	//   
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2;	//    
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_KILLED:
		//   :     . 
		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26);
		break;
	
	case DEF_NOTIFY_EXP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;

		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iRating;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case DEF_NOTIFY_HP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iHP;
		cp += 4;

		
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMP; // v2.04 0926 HP  MP  .    
		cp += 4;

		RefreshPartyStatus(iToH);

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14); 
		break;

	case DEF_NOTIFY_MP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMP;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_SP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iSP;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_CHARISMA:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iCharisma;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

		// 2003-04-14     .. wtf korean junk
	
	case DEF_NOTIFY_RESUR_ON:
	case DEF_NOTIFY_RESUR_OFF:
		
			int i;

			for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
				*cp = m_pClientList[iToH]->m_cMagicMastery[i];
				cp++;
			}

			for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
				*cp = m_pClientList[iToH]->m_cSkillMastery[i];
				cp++;
			}

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
		
		break;

	case DEF_NOTIFY_STATECHANGE_SUCCESS:
	case DEF_NOTIFY_SETTING_SUCCESS:
	case DEF_NOTIFY_LEVELUP:
		ip  = (int *)cp;
		*ip = m_pClientList[iToH]->m_iLevel;
		cp += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iStr;		
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iVit;								
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iDex;			
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iInt;					
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iMag;						
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iCharisma;
		cp  += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;

		
	case DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION:
	case DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION:
	case DEF_NOTIFY_CANNOTJOINMOREGUILDSMAN:
		
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		if (m_pClientList[iFromH] != NULL)
			 memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = DEF_GUILDSTARTRANK;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case DEF_COMMONTYPE_JOINGUILDREJECT:			
    case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:		
    case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		if (m_pClientList[iFromH] != NULL)
			 memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = DEF_GUILDSTARTRANK;
		cp += 2;

		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;

	case DEF_NOTIFY_GUILDDISBANDED:
		
		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;
	  
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 36);
		break;

	// v1.4311-3       ..
	case DEF_NOTIFY_FIGHTZONERESERVE:
		ip = (int *)cp;
		*ip = (int )sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break; 
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		//     .
		//         . Time Out  . 
		return;
	}
}

void CGame::RequestItemUpgradeHandler(int iClientH, int iItemIndex)
{
	int i, iItemX,iItemY, iSoM, iSoX, iSomH, iSoxH; // v2.172
	DWORD dwTemp, dwSWEType, iValue;
	double dV1, dV2, dV3;
	short sItemUpgrade = 2;

	if (m_pClientList[iClientH] == NULL) return;
	if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return;
	if (HeroItemChecker(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum, 0, 0, 0) != 0) {
		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
			(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
			(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3) ) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return;
		}
		if (iUpgradeHeroCapeRequirements(iClientH, iItemIndex) > 0) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_UPGRADEHEROCAPE, iItemIndex, 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
			_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, -1, m_pClientList[iClientH]->m_pItemList[iItemIndex], FALSE);
		}
		else {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			_bItemLog(DEF_ITEMLOG_UPGRADEFAIL, iClientH, -1, m_pClientList[iClientH]->m_pItemList[iItemIndex], FALSE);
		}
		return;
	}
	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
	if (iValue >= 15 || iValue < 0 ) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 1, NULL, NULL, NULL);
		return;
	}
	if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 717) && (iValue >= 7) && (iValue < 0)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 1, NULL, NULL, NULL);
		return;
	}
	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
	//centuu: angels
	case 46: // Pendants are category 46
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType != 1) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
			return; // Pendants are type 1
		}
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cEquipPos < 11) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
			return; // Pendants are left finger or more
		}
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType != 14) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
			return; // Pendants are EffectType 14
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectValue1) {
		default: // Other items are not upgradable
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
			return; // Pendants are EffectType 14
		case 16: // AngelicPandent(STR)
		case 17: // AngelicPandent(DEX)
		case 18: // AngelicPandent(INT)
		case 19: // AngelicPandent(MAG)
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return;
			}
			if(iValue >= 10)
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return;
			}
			switch (iValue) {
			case 0: sItemUpgrade = 10; break;
			case 1: sItemUpgrade = 11; break;
			case 2: sItemUpgrade = 13; break;
			case 3: sItemUpgrade = 16; break;
			case 4: sItemUpgrade = 20; break;
			case 5: sItemUpgrade = 25; break;
			case 6: sItemUpgrade = 31; break;
			case 7: sItemUpgrade = 38; break;
			case 8: sItemUpgrade = 46; break;
			case 9: sItemUpgrade = 55; break;
			default:
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				break;
			}
			if (   (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) 
				|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) 
				|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3)) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return; 
			}
			if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
			iValue++;
			if (iValue > 10) iValue = 10;
			dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
			dwTemp = dwTemp & 0x0FFFFFFF;
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
			 
			break;
		}
		break;

	case 1:
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 703: // SangAhFlameberge
		case 709: // DarkKnightFlameberge
		case 718: // DarkKnightGreatSword
		case 727: // DarkKnightFlamebergW
		case 736: // SangAhGiantSword
		case 737: // DarkKnightGiantSword
		case 745: // BlackKnightTemple
		case 989: // BlackKnightHammer
		case 990: // BlackKnightBH
		case 991: // BlackKnightBBH
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) { 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}
			sItemUpgrade = (iValue*(iValue+6)/8) + 2 ;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType != 0) {
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3)) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return;
				}
			}
			if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) { 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade ; 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
			if ((iValue == 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 703)) { // SangAhFlameberge 
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 736) == FALSE) { // SangAhGiantSword 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			} 
			else if ((iValue == 0) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 709) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 727))) { // DarkKnightFlameberge DarkKnightFlamebergW
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 737) == FALSE) { // DarkKnightGiantSword
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			} 
			else if ((iValue >= 6) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 737)) { // DarkKnightGiantSword
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 745) == FALSE) { // BlackKnightTemple
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);				
			}
			else if ((iValue >=	12) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 745)) { // BlackKnightTemple 
				iValue += 2;
				if (iValue > 15) iValue = 15;
				if (iValue == 15) m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = 9;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);				
			}
			// MORLA 2.6 - Upgrades para el Hammer
			else if ((iValue >= 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 989)) { // DarkKnightHammer
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 990) == FALSE) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}
			else if ((iValue >= 6) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 990)) { // DarkKnightBH
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 991) == FALSE) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			} 
			else if ((iValue >=	12) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 991)) { //DarkKnightBBH
				iValue += 2;
				if (iValue > 15) iValue = 15;
				if (iValue == 15) m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = 9;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);				
			}

			else {
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
			}
			break;

		case 717: // DarkKnightRapier
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return;
			}
			sItemUpgrade = (iValue*(iValue+6)/8) + 2;
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))	{
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return; 
			}
			if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) { 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade ; 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
			iValue++;
			if (iValue > 7) iValue = 7;
			dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
			dwTemp = dwTemp & 0x0FFFFFFF;
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
			break;
		
		default:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				if (dwSWEType == 9) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return;
				}
			}
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
				case 656: iSoX++; iSoxH = i; break;
				case 657: iSoM++; iSomH = i; break;
				}
			}
			if (iSoX > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == FALSE) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, FALSE, TRUE);
					ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);	
					return;
				}
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
					iValue++;
					if (iValue > 10) {
						iValue = 10;
					}
					else {
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
						ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);
					}
				}
				else {
					iValue++;
					if (iValue > 7) {
						iValue = 7;
					}
					else {
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
						ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);
					}
				}
			}
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			break;
		}
		return;

	case 3:
		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
			dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
			if (dwSWEType == 9) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return;
			}
		}
		iSoX = iSoM = 0;
		for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
			case 656: iSoX++; iSoxH = i; break;
			case 657: iSoM++; iSomH = i; break;
			}
		}
		if (iSoX > 0) {
			if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == FALSE) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, FALSE, TRUE);
				ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);	
				return;
			}
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
				iValue++;
				if (iValue > 10) {
					iValue = 10;
				}
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);
				}
			}
			else {
				iValue++;
				if (iValue > 7) {
					iValue = 7;
				}
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);
				}
			}
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
		return;

	case 5:
		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
			dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
			if (dwSWEType == 8) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return;
			}
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 623:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return;
		default: 
			break;
		}
		iSoX = iSoM = 0;
		for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
				case 656: iSoX++; iSoxH = i; break;
				case 657: iSoM++; iSomH = i; break;
			}
		}
		if (iSoM > 0) {
			if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH, TRUE) == FALSE) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, FALSE, TRUE);
				ItemDepleteHandler(iClientH, iSomH, FALSE, TRUE);	
				return;
			}
			iValue++;
			if (iValue > 10) {
				iValue = 10;
			}
			else {
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
					dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					dV2 = 0.2f * dV1;
					dV3 = dV1 + dV2;
				}
				else {
					dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					dV2 = 0.15f * dV1;
					dV3 = dV1 + dV2;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan += dV2;
				ItemDepleteHandler(iClientH, iSomH, FALSE, TRUE);	
			}
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
		return;
	
	case  6:
	case 15:
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 621: // MerienPlateMailM
		case 622: // MerienPlateMailW 
		case 700: // SangAhHauberk 
		case 701: // SangAhFullHel
		case 702: // SangAhLeggings  
		case 704: // SangAhPlateMail 
		case 706: // DarkKnightHauberk
		case 707: // DarkKnightFullHelm 
		case 708: // DarkKnightLeggings  
		case 710: // DarkKnightPlateMail 
		case 711: // DarkMageHauberk 
		case 712: // DarkMageChainMail
		case 713: // DarkMageLeggings  
		case 716: // DarkMageLedderArmor
		case 719: // DarkMageScaleMail
		case 724: // DarkKnightHauberkW
		case 725: // DarkKnightFullHelmW 
		case 726: // DarkKnightLeggingsW 
		case 728: // DarkKnightPlateMailW 
		case 729: // DarkMageHauberkW 
		case 730: // DarkMageChainMailW 
		case 731: // DarkMageLeggingsW 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return;

		default:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				if (dwSWEType == 8) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return;
				}
			}
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break;
					case 657: iSoM++; iSomH = i; break;
				}
			}
			if (iSoM > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH, TRUE) == FALSE) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, FALSE, TRUE);
					ItemDepleteHandler(iClientH, iSomH, FALSE, TRUE);	
					return;
				}
				iValue++;
				if (iValue > 10) {
					iValue = 10;
				}
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.2f * dV1;
						dV3 = dV1 + dV2;
					}
					else {
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.15f * dV1;
						dV3 = dV1 + dV2;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan += dV2;
					ItemDepleteHandler(iClientH, iSomH, FALSE, TRUE);	
				}
			}
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);

			break;
		}
		return;

	case 8:
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
			case 291: // MagicWand(MS30-LLF) 
			case 714: // DarkMageMagicStaff 
			case 732: // DarkMageMagicStaffW 
			case 738: // DarkMageMagicWand
			case 746: // BlackMageTemple
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3)) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return; 
				}
				if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) { 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
					return; 
				}
				sItemUpgrade = (iValue*(iValue+6)/8) + 2 ;
				if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) { 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
					return; 
				}
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
				if (iValue == 0 ) {
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				}
				if((iValue >= 4) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 714) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 732))) {
					iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
					iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;
					delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;
					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 738) == FALSE) { // DarkMageMagicWand
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						return;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
					iValue += 2;
					if (iValue > 15) iValue = 15;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					break;
				} 
				if((iValue >= 6) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 738)) {
					iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
					iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;
					delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;
					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 746) == FALSE) { // BlackMageTemple 
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						return;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
					iValue += 2;
					if (iValue > 15) iValue = 15;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					break;
				} 
				if((iValue >= 12) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 746)) {
					iValue += 2;
					if (iValue > 15) iValue = 15;
					if (iValue == 15) m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = 9;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					break;
				}
				else {
					iValue += 2;
					if (iValue > 15) iValue = 15; 
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF; //   
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); //   
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					break;
				}
				break;

			default:
				//  
				// v2.16 2002-5-21 
				iSoX = iSoM = 0;
				for (i = 0; i < DEF_MAXITEMS; i++)
					if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
						switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
							case 656: iSoX++; iSoxH = i; break; //    
							case 657: iSoM++; iSomH = i; break; //    
						}
					}
					//    .
					if (iSoX > 0) {
						//    .
						if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == FALSE) {
							//   
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
							iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
							if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, FALSE, TRUE); // v2.172 +1 -> +2    
							//    .
							ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);	
							return;
						}

						iValue++;
						if (iValue > 7) 
							iValue = 7;
						else {
							//  .   
							dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
							dwTemp = dwTemp & 0x0FFFFFFF; //   
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); //   	
							//    .
							ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);
						}
					}

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);

					break;
		}
		break;

	default:
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
		break;
	}
}

int CGame::HeroItemChecker(int iItemID, short sEnemyKill, char cContribution, char cSide)
{

	switch(iItemID) {

	case 400: // AresdenHeroCape 
		if (sEnemyKill != 0) sEnemyKill = 300; 
		if (cContribution != 0) cContribution = 0;  
		if (cSide != 0) cSide = 1; 
		break;

	case 401: // ElvineHeroCape 
		if (sEnemyKill != 0) sEnemyKill = 300; 
		if (cContribution != 0) cContribution = 0;  
		if (cSide != 0) cSide = 2; 
		break;

	// eHeroHelm
	case 403: // aHeroHelm(M)
	case 404: // aHeroHelm(W)
		if (sEnemyKill != 0) sEnemyKill = 150; 
		if (cContribution != 0) cContribution = 20; 
		if (cSide != 0) cSide = 1; 
		break;
	case 405: // aHeroHelm(M)
	case 406: // aHeroHelm(W)
		if (sEnemyKill != 0) sEnemyKill = 150; 
		if (cContribution != 0) cContribution = 20; 
		if (cSide != 0) cSide = 2; 
		break;

	// eHeroCap
	case 407: // aHeroCap(M)
	case 408: // aHeroCap(W)
		if (sEnemyKill != 0) sEnemyKill = 100; 
		if (cContribution != 0) cContribution = 20; 
		if (cSide != 0) cSide = 1; 
		break;
	case 409: // aHeroCap(M)
	case 410: // aHeroCap(W)
		if (sEnemyKill != 0) sEnemyKill = 100; 
		if (cContribution != 0) cContribution = 20; 
		if (cSide != 0) cSide = 2; 
		break;

	// eHeroArmor
	case 411: // eHeroArmor(M)
	case 412: // eHeroArmor(W)
		if (sEnemyKill != 0) sEnemyKill = 300; 
		if (cContribution != 0) cContribution = 30; 
		if (cSide != 0) cSide = 1; 
		break;
	case 413: // eHeroArmor(M)
	case 414: // eHeroArmor(W)
		if (sEnemyKill != 0) sEnemyKill = 300; 
		if (cContribution != 0) cContribution = 30; 
		if (cSide != 0) cSide = 2; 
		break;

	// aHeroRobe
	case 415: // aHeroRobe(M)
	case 416: // aHeroRobe(W)
		if (sEnemyKill != 0) sEnemyKill = 200; 
		if (cContribution != 0) cContribution = 20; 
		if (cSide != 0) cSide = 1; 
		break;
	case 417: // aHeroRobe(M)
	case 418: // aHeroRobe(W)
		if (sEnemyKill != 0) sEnemyKill = 200; 
		if (cContribution != 0) cContribution = 20; 
		if (cSide != 0) cSide = 2; 
		break;

	// aHeroHauberk
	case 419: // aHeroHauberk(M)
	case 420: // aHeroHauberk(W)
		if (sEnemyKill != 0) sEnemyKill = 100; 
		if (cContribution != 0) cContribution = 10; 
		if (cSide != 0) cSide = 1; 
		break;
	case 421: // eHeroHauberk(M)
	case 422: // eHeroHauberk(W)
		if (sEnemyKill != 0) sEnemyKill = 100; 
		if (cContribution != 0) cContribution = 10; 
		if (cSide != 0) cSide = 2; break;

	// aHeroLeggings
	case 423: // aHeroLeggings(M)
	case 424: // aHeroLeggings(W)
		if (sEnemyKill != 0) sEnemyKill = 150; 
		if (cContribution != 0) cContribution = 15; 
		if (cSide != 0) cSide = 1; 
		break;
	case 425: // eHeroLeggings(M)
	case 426: // eHeroLeggings(W)
		if (sEnemyKill != 0) sEnemyKill = 150; 
		if (cContribution != 0) cContribution = 15; 
		if (cSide != 0) cSide = 2; 
		break;
	
	case 427: // AresdenHeroCape+1 
		if (cSide != 0) cSide = 1; 
		break;

	case 428: // ElvineHeroCape+1
		if (cSide != 0) cSide = 2; 
		break;

	default: 
		return 0;
	}
	return iItemID;

}

int CGame::iUpgradeHeroCapeRequirements(int iClientH, int iItemIndex)
{
 int iAfterItemID, iRequiredEnemyKills, iRequiredContribution, iStoneNumber, i;
 int iBeforeItemID;
	
	iAfterItemID = 0;
	iRequiredEnemyKills = 10000;
	iRequiredContribution = 10000;
	iStoneNumber = 0;
	i = 0;
	iBeforeItemID = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum;
	if (iBeforeItemID == 400) {
		_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)m_pClientList[iClientH]->m_pItemList[iItemIndex], FALSE);
		iAfterItemID = 427;
		iRequiredEnemyKills = 30;
		iRequiredContribution = 50;
		iStoneNumber = 657;
	}
	else if (iBeforeItemID == 401) {
		_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)m_pClientList[iClientH]->m_pItemList[iItemIndex], FALSE);
		iAfterItemID = 428;
		iRequiredEnemyKills = 30;
		iRequiredContribution = 50;
		iStoneNumber = 657;
	}
	else {
		return -1;
	}
	if ((iRequiredEnemyKills > m_pClientList[iClientH]->m_iEnemyKillCount) || (iRequiredEnemyKills == 10000)) return 0;
	if ((iRequiredContribution > m_pClientList[iClientH]->m_iContribution) || (iRequiredContribution == 10000)) return 0;
	for (i = 0; i < DEF_MAXITEMS; i++) {
		if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == iStoneNumber)) break;
	}
	if ((i == 50) || (iStoneNumber == 0)) return 0;
	if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], iAfterItemID) == FALSE) return -1;
	m_pClientList[iClientH]->m_iEnemyKillCount -= iRequiredEnemyKills;
	m_pClientList[iClientH]->m_iContribution -= iRequiredContribution;
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		ItemDepleteHandler(iClientH, i, FALSE, TRUE);
		return 1;
	}
	return -1;
}


void CGame::ItemDepleteHandler(int iClientH, short sItemIndex, BOOL bIsUseItemResult, BOOL bIsItemUsed)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((bIsItemUsed == 1) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_MATERIAL) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 380) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 381) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 382)) {
		_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, -1, m_pClientList[iClientH]->m_pItemList[sItemIndex], FALSE);
	}
	else if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 247) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 248)) {
		_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, -1, m_pClientList[iClientH]->m_pItemList[sItemIndex], FALSE);	
	}
	ReleaseItemHandler(iClientH, sItemIndex, TRUE);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMDEPLETED_ERASEITEM, sItemIndex, (int)bIsUseItemResult, NULL, NULL);
	delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	iCalcTotalWeight(iClientH);
}

// centu - Agregado Majestic Level
BOOL CGame::bCheckLevelUp(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return FALSE;
	
	if (m_pClientList[iClientH]->m_iExp < m_pClientList[iClientH]->m_iNextLevelExp) return FALSE;
	
	while (m_pClientList[iClientH]->m_iExp >= m_pClientList[iClientH]->m_iNextLevelExp) { 
		if (m_pClientList[iClientH]->m_iLevel < m_iPlayerMaxLevel) {
			m_pClientList[iClientH]->m_iLevel++;
			m_pClientList[iClientH]->m_iLU_Pool += 3;
					
			if (m_pClientList[iClientH]->m_iLevel > 100)
				if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
					ForceChangePlayMode(iClientH, TRUE);

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LEVELUP, NULL, NULL, NULL, NULL);

			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1];
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
				
			CalcTotalItemEffect(iClientH, -1, FALSE);
		}
		else {
			m_pClientList[iClientH]->m_iMajesticLevel++;
			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel+m_pClientList[iClientH]->m_iMajesticLevel];
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < m_iMaxGizonItem) {
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft += m_iMaxGizonPerLevel;
			}

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAJESTIC_LEVEL, m_pClientList[iClientH]->m_iMajesticLevel, NULL, NULL, NULL, NULL);
					
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 1, NULL, NULL, NULL);
		}
	}
	return TRUE;
}

void CGame::RequestTeleportHandler(int iClientH, char * pData, char * cMapName, int dX, int dY)
{
 char  * pBuffer, cTempMapName[21];
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cDestMapName[11], cDir, cMapIndex, cPoints;
 short * sp, sX, sY, sSummonPoints, sV1;
 int   * ip, i, iRet, iSize, iDestX, iDestY, iExH, iMapSide, iTemp, iTemp2, iMapside, iMapside2, iQuestNumber, iQuestType;
 BOOL    bRet, bIsLockedMapNotify;
 SYSTEMTIME SysTime;

	cPoints = 0;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsForceDisconnect == TRUE) return;
	if ((m_pClientList[iClientH]->m_cSide == 2) && 
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) &&
		((pData[0] == '1')  || (pData[0] == '3'))) {
		if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) return;
	}	
	if ((m_pClientList[iClientH]->m_cSide == 1) && 
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) &&
		((pData[0] == '1')  || (pData[0] == '3'))) {
		if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) return;
	}
	bIsLockedMapNotify = FALSE;
	// Prevent recalls spells/scrolls, and any recall type magic if forbidden on the map
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsRecallImpossible == TRUE) 
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0) 
		&& (m_pClientList[iClientH]->m_bIsKilled == FALSE) 
		&& (m_pClientList[iClientH]->m_iHP > 0)) 
	{	if (   (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsApocalypseMap == TRUE)
				&& (m_bIsApocalypseMode == FALSE))
		{	// Can recall
		}else // either Apocalypse running on Apoc map or not an apoc map
		{	if ((pData[0] == '3') ||(pData[0] == '1')) 
			// '0' is forced recall
			// '1' is recall spells
			// '2' is fixed, stated destination such as tickets or GM TPing characters
			// '3' is fixed, stated destination but forbidden on NoRecall map
			// '' Means client is on TP tile and asks the server to perform the TP.
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NORECALL, NULL, NULL, NULL, NULL);
				return;
	}	}	}
	if (m_pClientList[iClientH]->m_cExchangeMode != 0) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}
	m_pClientList[iClientH]->m_dwLastActionTime = m_pClientList[iClientH]->m_dwAFKCheckTime = timeGetTime();
	
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_TELEPORT);
	
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(13, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;
	ZeroMemory(cDestMapName, sizeof(cDestMapName));
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSearchTeleportDest(sX, sY, cDestMapName, &iDestX, &iDestY, &cDir);
	if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
		iMapSide = iGetMapLocationSide(cDestMapName);
		if (iMapSide > 3) iMapSide -= 2;
		if ((iMapSide != 0) && (m_pClientList[iClientH]->m_cSide == iMapSide)) {

		}
		else {
			iDestX = -1;
			iDestY = -1;
			bIsLockedMapNotify = TRUE;
			ZeroMemory(cDestMapName, sizeof(cDestMapName));
			strcpy(cDestMapName, m_pClientList[iClientH]->m_cLockedMapName);
		}
	}
	if ((bRet == TRUE) && (cMapName == NULL)) {
		for (i = 0; i < DEF_MAXMAPS; i++) {
			if ((m_pMapList[i] != NULL) && (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0)) {
				m_pClientList[iClientH]->m_sX   = iDestX;
				m_pClientList[iClientH]->m_sY   = iDestY;
				m_pClientList[iClientH]->m_cDir = cDir;
				m_pClientList[iClientH]->m_cMapIndex = i;
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);
				goto RTH_NEXTSTEP;
			}
		}
		m_pClientList[iClientH]->m_sX   = iDestX;
		m_pClientList[iClientH]->m_sY   = iDestY;
		m_pClientList[iClientH]->m_cDir = cDir;
		ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
		memcpy(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);
		SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);
		bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE);
		m_pClientList[iClientH]->m_bIsOnServerChange = TRUE;
		m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
		return;
	}
	else {
		switch (pData[0]) {
		case '0':
		case '1':
			ZeroMemory(cTempMapName, sizeof(cTempMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) { 
				strcpy(cTempMapName, "default"); 
			}
			else if (m_pClientList[iClientH]->m_iLevel > 80) {
				if (m_pClientList[iClientH]->m_cSide == 1) {
					strcpy(cTempMapName, "aresden");
				}
				else {
					strcpy(cTempMapName, "elvine");
				}
			}
			else if (m_pClientList[iClientH]->m_cSide == 1) {
				strcpy(cTempMapName, "arefarm");
			}
			else {
				strcpy(cTempMapName, "elvfarm");
			}
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}
			for (i = 0; i < DEF_MAXMAPS; i++) {
				if ((m_pMapList[i] != NULL) && (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0)) {
					
					short playerCoordX = m_pClientList[iClientH]->m_sX;
					short playerCoordY = m_pClientList[iClientH]->m_sY;

					GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);

					if (playerCoordX == m_pClientList[iClientH]->m_sX && playerCoordY == m_pClientList[iClientH]->m_sY)
					{
						RequestTeleportHandler(iClientH, "1");
						return;
					}

					m_pClientList[iClientH]->m_cMapIndex = i;
					ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);
					goto RTH_NEXTSTEP;
				}
			}
			m_pClientList[iClientH]->m_sX   = -1;
			m_pClientList[iClientH]->m_sY   = -1;
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE], NULL, NULL);
			SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);	
			bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE, FALSE);
			m_pClientList[iClientH]->m_bIsOnServerChange = TRUE;
			m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
			return;

		case '2':
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && 
				(m_pClientList[iClientH]->m_iLockedMapTime > 0) &&
				(memcmp(cMapName, "resurr", 6) != 0)) {
				dX = -1;
				dY = -1;
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}
			else {
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, cMapName);
			}
			cMapIndex = iGetMapIndex(cTempMapName);
			if (cMapIndex == -1) {
				m_pClientList[iClientH]->m_sX   = dX;
				m_pClientList[iClientH]->m_sY   = dY;
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE], NULL, NULL);
				SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);
				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE);
				m_pClientList[iClientH]->m_bIsOnServerChange   = TRUE;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
				return;
			}
			m_pClientList[iClientH]->m_sX   = dX;
			m_pClientList[iClientH]->m_sY   = dY;
			m_pClientList[iClientH]->m_cMapIndex = cMapIndex;
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);  
			goto RTH_NEXTSTEP;		
		
		case '3':
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && 
				(m_pClientList[iClientH]->m_iLockedMapTime > 0) &&
				(memcmp(cMapName, "resurr", 6) != 0)) {
				dX = -1;
				dY = -1;
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}
			else {
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, cMapName);
			}
			cMapIndex = iGetMapIndex(cTempMapName);
			if (cMapIndex == -1) {
				m_pClientList[iClientH]->m_sX   = dX;
				m_pClientList[iClientH]->m_sY   = dY;
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE], NULL, NULL);
				SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);
				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE);
				m_pClientList[iClientH]->m_bIsOnServerChange   = TRUE;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
				return;
			}		
			m_pClientList[iClientH]->m_sX   = dX;
			m_pClientList[iClientH]->m_sY   = dY;
			m_pClientList[iClientH]->m_cMapIndex = cMapIndex;
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);  
			goto RTH_NEXTSTEP;
		}
	}

RTH_NEXTSTEP:;

	SetPlayingStatus(iClientH);
	iTemp = m_pClientList[iClientH]->m_iStatus;
	iTemp = 0x0FFFFFFF & iTemp;
	iTemp2 = iGetPlayerABSStatus(iClientH);
	iTemp = iTemp | (iTemp2 << 28);
	m_pClientList[iClientH]->m_iStatus = iTemp;
	
	if ((m_pClientList[iClientH]->m_pIsProcessingAllowed == TRUE) && 
		(m_sLastHeldenianWinner != m_pClientList[iClientH]->m_cSide) && 
		(m_sLastHeldenianWinner != 0)) {
		cPoints = 100;
	}
	if (bIsLockedMapNotify == TRUE) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);
	}
	pBuffer = new char [DEF_MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE+1);

	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) {
		bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	}
	else {
		GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);
	}

	sp  = (short *)cp;
	*sp = iClientH;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;

	ip  = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;

	ip  = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iStatus;
	cp += 4;

	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;

	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) {
		*cp = 1;
	}
	else {
		*cp = m_cDayOrNight;
	}
	cp++;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) {
		*cp = NULL;
	}
	else {
		*cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	}
	cp++;

	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;

	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	}

	*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;

	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;

	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;
	
	*cp = cPoints;
	cp++;

	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 10, m_pClientList[iClientH]->m_sY - 7, iClientH, cp);
	cp += iSize;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, iSize + 66);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}
	if(pBuffer != NULL) delete pBuffer;
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
	m_pClientList[iClientH]->m_bIsWarLocation = FALSE;
	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
	if ((m_pClientList[iClientH]->m_cSide == 1) && 
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) && 
		(m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		CheckForceRecallTime(iClientH);
	}
	else if ((m_pClientList[iClientH]->m_cSide == 2) && 
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) && 
		(m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		CheckForceRecallTime(iClientH);	
	}
	else if ((m_pClientList[iClientH]->m_cSide == 0) &&
		(m_bIsCrusadeMode == TRUE) &&
		((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) ||
		(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0))) {
		if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			CheckForceRecallTime(iClientH);	
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
		}
	}
	// Heldenian: TP to GodH go to appropriate place...
	if ((m_bIsHeldenianMode == TRUE) && (bRet == TRUE) && (cMapName == NULL))
	{	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "HRampart", 8) == 0)
		{	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
			{	if (memcmp(cDestMapName, "GodH", 4) == 0)
				{	if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner)
					{	iDestX = 54;
						iDestY = 67;
						cDir = 4;
					}else
					{	iDestX = 192 + iDice(1,20);
						iDestY = 166 + iDice(1,10);
						cDir = 7;
	}	}	}	}	}
	iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
	if (iMapside > 3) iMapside2 = iMapside - 2;
	else iMapside2 = iMapside;
	m_pClientList[iClientH]->m_bIsInsideEnemyBuilding = 0;
	if ((m_pClientList[iClientH]->m_cSide != iMapside2) && (iMapside != 0)) {
		if ((iMapside <= 2) && 
			(m_pClientList[iClientH]->m_iAdminUserLevel == 0) && 
			(m_pClientList[iClientH]->m_cSide != 0)) {
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
			m_pClientList[iClientH]->m_bIsInsideEnemyBuilding = TRUE;
		}
	}
	else{
		if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) &&
			(m_iFightzoneNoForceRecall == FALSE) && 
			(m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*60*20 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20;
		}
		else{
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0) ||
				(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0)) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
					m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
					m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
					if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
					}
					else if(m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 100) {
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
					}
				}
			}
		}
	}
	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FORCERECALLTIME, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, NULL, NULL, NULL);
		wsprintf(G_cTxt,"(!) Game Server Force Recall Time %d (%d)min", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall/20) ;
		PutLogList(G_cTxt) ;
	}
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);
	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
	}
	if (m_bIsCrusadeMode == TRUE) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			m_pClientList[iClientH]->m_iCrusadeDuty			= 0;
			m_pClientList[iClientH]->m_iConstructionPoint	= 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}
		else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
	}
	// Heldenian mode on
	else if (m_bIsHeldenianMode == TRUE) 
	{	sSummonPoints = 10000 + m_pClientList[iClientH]->m_iCharisma*100;
		if (sSummonPoints > DEF_MAXHELDENIANSUMMONPOINT) sSummonPoints = DEF_MAXHELDENIANSUMMONPOINT;
		if (m_pClientList[iClientH]->m_dwHeldenianGUID == NULL) 
		{	m_pClientList[iClientH]->m_dwHeldenianGUID    = m_dwHeldenianGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
		}else if (m_pClientList[iClientH]->m_dwHeldenianGUID != m_dwHeldenianGUID) 
		{	m_pClientList[iClientH]->m_dwHeldenianGUID    = m_dwHeldenianGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
		}
		if (m_cHeldenianWinner == -1) 
		{	if (m_bHeldenianWarInitiated == TRUE) 
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL);
			}else
			{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, NULL, NULL, NULL, NULL);
			}
		}
		m_pClientList[iClientH]->m_cWarType = 2;// character have been informed of heldenian starting...
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);
		UpdateHeldenianStatus(iClientH);
	}
	else if ((m_pClientList[iClientH]->m_dwCrusadeGUID != 0) && (m_pClientList[iClientH]->m_cWarType == 1)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, NULL, NULL, -1);
	}
	// The Heldenian he has participated is over...
	else if ( (m_pClientList[iClientH]->m_cWarType == 2) // Just finished Heldenian
			&& (m_pClientList[iClientH]->m_dwHeldenianGUID == m_dwHeldenianGUID)
			&& (m_pClientList[iClientH]->m_dwHeldenianGUID != NULL)) 
	{	m_pClientList[iClientH]->m_iConstructionPoint = 0;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANEND, NULL, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_cWarType = 0; // Character is informed of Hedenian end... so he'll get XP later
	}
	else {
		m_pClientList[iClientH]->m_dwCrusadeGUID		= 0;
		m_pClientList[iClientH]->m_iWarContribution		= 0;
		m_pClientList[iClientH]->m_iConstructionPoint	= 0;
	}		
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
		wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAJESTIC_LEVEL, m_pClientList[iClientH]->m_iMajesticLevel, NULL, NULL, NULL, NULL);

	//50Cent - Critical Count Login Fix
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
	
	iQuestNumber = m_pClientList[iClientH]->m_iQuest;
	if ((iQuestNumber != 0) && (m_pQuestConfigList[iQuestNumber] != 0)) {
		iQuestType = m_pQuestConfigList[iQuestNumber]->m_iType;
		if (iQuestType == 1) {
			if (_bCheckIsQuestCompleted(iClientH) == TRUE) {
				sV1 = m_pQuestConfigList[iQuestNumber]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount;
				if (sV1 < 0) sV1 = 0;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOUNTER, sV1, NULL, NULL, NULL);
			}
		}
	}
	// SNOOPY: Send gate positions if applicable.
	Notify_ApocalypseGateState(iClientH);
	RefreshPartyCoords(iClientH);
}

void CGame::RequestRestartHandler(int iClientH)
{
 char  cTmpMap[32];

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) {
		strcpy(cTmpMap,m_pClientList[iClientH]->m_cMapName) ;
		ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
		if (m_pClientList[iClientH]->m_cSide == 0) {
			strcpy(m_pClientList[iClientH]->m_cMapName, "default");
		}
		else if (m_pClientList[iClientH]->m_cSide == 1) {
			if (m_bIsCrusadeMode == TRUE) {
				if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
					ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
					m_pClientList[iClientH]->m_iLockedMapTime = 300;
					m_pClientList[iClientH]->m_iDeadPenaltyTime = 600;
				}
				else {
					memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
					m_pClientList[iClientH]->m_iDeadPenaltyTime = 600;
				}
			}
			else if (strcmp(cTmpMap, "elvine") == 0){
				memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
				strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
				m_pClientList[iClientH]->m_iLockedMapTime = 180 ;	
			}
			else if (m_pClientList[iClientH]->m_iLevel > 80) {
				memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cMapName, "arefarm", 7);
			}
		}
		else {
			if (m_bIsCrusadeMode == TRUE) {
				if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
					ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
					m_pClientList[iClientH]->m_iLockedMapTime = 300;
					m_pClientList[iClientH]->m_iDeadPenaltyTime = 600;
				}
				else {
					memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
					m_pClientList[iClientH]->m_iDeadPenaltyTime = 600;
				}
			}
			if (strcmp(cTmpMap, "aresden") == 0){
				memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);
				strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
				m_pClientList[iClientH]->m_iLockedMapTime = 180;
			}
			else if (m_pClientList[iClientH]->m_iLevel > 80) {
				memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cMapName, "elvfarm", 7);
			}
		}
		m_pClientList[iClientH]->m_bIsKilled = FALSE;
		m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
		m_pClientList[iClientH]->m_iHungerStatus = 100;
		ZeroMemory(cTmpMap, sizeof(cTmpMap));
		strcpy(cTmpMap, m_pClientList[iClientH]->m_cMapName);
		RequestTeleportHandler(iClientH, "2   ", cTmpMap, -1, -1);
	}
	RefreshPartyStatus(iClientH);
}

void CGame::LocalStartCrusadeMode(DWORD dwCrusadeGUID)
{
 int i, z, tX, tY, iNamingValue, c, m, n;
 char cName[6], cNpcName[21], cNpcWayPoint[11];

	if (m_bIsCrusadeMode == TRUE) return;
	if (m_bIsHeldenianMode == TRUE) return;
	if (m_bIsApocalypseMode == TRUE) return;
	m_bIsCrusadeMode = TRUE;
	m_iCrusadeWinnerSide = 0;
	if (dwCrusadeGUID != NULL) {
		_CreateCrusadeGUID(dwCrusadeGUID, NULL);
		m_dwCrusadeGUID = dwCrusadeGUID;
	}
	
	for (c = 1; c < DEF_MAXCLIENTS; c++)
	if ((m_pClientList[c] != NULL) && (m_pClientList[c]->m_bIsInitComplete == TRUE)) {
		m_pClientList[c]->m_iCrusadeDuty = 0;
		m_pClientList[c]->m_iConstructionPoint = 0;
		m_pClientList[c]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		SendNotifyMsg(NULL, c, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[c]->m_iCrusadeDuty, NULL, NULL);
	}

	for (m = 0; m < DEF_MAXMAPS; m++)
	if (m_pMapList[m] != NULL) m_pMapList[m]->RestoreStrikePoints();
	
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
	if (m_stCrusadeStructures[i].cType != NULL) {
		for (z = 0; z < DEF_MAXMAPS; z++)
		if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, m_stCrusadeStructures[i].cMapName) == 0)) {
			//     .
			iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				//    NPC  .     .
				//  ?
			}
			else {
				// NPC .
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = z+65;
				
				switch (m_stCrusadeStructures[i].cType) {
				case 36:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "AGT-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "AGT-Elvine");
					break;

				case 37: 
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "CGT-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "CGT-Elvine");
					break;

				case 40:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "ESG-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "ESG-Elvine");
					break;

				case 41:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "GMG-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "GMG-Elvine");
					break;

				case 42:
					strcpy(cNpcName, "ManaStone");
					break;

				default: 
					strcpy(cNpcName, m_pNpcConfigList[m_stCrusadeStructures[i].cType]->m_cNpcName); 
					break;
				}

				tX = (int)m_stCrusadeStructures[i].dX;
				tY = (int)m_stCrusadeStructures[i].dY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
					//   NameValue .
					m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					wsprintf(G_cTxt, "(!) Creating Crusade Structure(%s) at %s(%d, %d)", cNpcName, m_stCrusadeStructures[i].cMapName, tX, tY);
					PutLogList(G_cTxt);
				}
			}
		}
	}
	
	PutLogList("(!)Crusade Mode ON.");
	_bCrusadeLog(DEF_CRUSADELOG_STARTCRUSADE, NULL, NULL, NULL);
}

void CGame::MobGenerator()
{
 int i, x, j, iNamingValue, iResult, iTotalMob;
	char cNpcName[21], cName_Master[11], cName_Slave[11], cWaypoint[11];
	char cSA;
	int  pX, pY, iMapLevel, iProbSA, iKindSA, iResultNum, iNpcID;
	BOOL bMaster, bFirmBerserk, bIsSpecialEvent;
	bool bIsGuard = FALSE;

	if (m_bOnExitProcess == TRUE) return;

	for (i = 0; i < DEF_MAXMAPS; i++) {

		if (m_pMapList[i] != NULL) {
			iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
		}

		if ( (m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE) && (iResultNum > m_pMapList[i]->m_iTotalActiveObject) ) {
			if ((m_iMiddlelandMapIndex != -1) && (m_iMiddlelandMapIndex == i) && (m_bIsCrusadeMode == TRUE)) break;

			iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
			if (iNamingValue != -1) {
				// Master Mob????????.
				ZeroMemory(cName_Master, sizeof(cName_Master));
				wsprintf(cName_Master, "XX%d", iNamingValue);
				cName_Master[0] = '_';
				cName_Master[1] = i + 65;

				ZeroMemory(cNpcName, sizeof(cNpcName));

				bFirmBerserk = FALSE;
				iResult = iDice(1,100);
				switch (m_pMapList[i]->m_cRandomMobGeneratorLevel) {

				case 1: // arefarm, elvfarm, aresden, elvine
					if ((iResult >= 1) && (iResult < 20)) {
						iResult = 1; // Slime
					}
					else if ((iResult >= 20) && (iResult < 40)) {
						iResult = 2; // Giant-Ant
					}
					else if ((iResult >= 40) && (iResult < 85)) {
						iResult = 24; // Rabbit
					}
					else if ((iResult >= 85) && (iResult < 95)) {
						iResult = 25; // Cat
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						iResult = 3; // Orc
					}
					iMapLevel = 1;
					break;

				case 2:
					if ((iResult >= 1) && (iResult < 40)) {
						iResult = 1;
					}
					else if ((iResult >= 40) && (iResult < 80)) {
						iResult = 2;
					}
					else iResult = 10;
					iMapLevel = 1;
					break;

				case 3:     // v1.4334 ????????? ????
					if ((iResult >= 1) && (iResult < 20)) {
						switch (iDice(1,2)) {
				case 1: iResult = 3;  break;
				case 2: iResult = 4;  break;
						}
					}
					else if ((iResult >= 20) && (iResult < 25)) {
						iResult = 30;
					}
					else if ((iResult >= 25) && (iResult < 50)) {
						switch (iDice(1,3)) {	
				case 1: iResult = 5;  break;
				case 2: iResult = 6;  break;
				case 3:	iResult = 7;  break;
						}
					}
					else if ((iResult >= 50) && (iResult < 75)) {
						switch (iDice(1,7)) {
				case 1:
				case 2:	iResult = 8;  break;
				case 3:	iResult = 11; break;
				case 4: iResult = 12; break;
				case 5:	iResult = 18; break;
				case 6:	iResult = 26; break;
				case 7: iResult = 28; break;
						}
					}
					else if ((iResult >= 75) && (iResult <= 100)) {
						switch (iDice(1,5)) {	
				case 1:
				case 2: iResult = 9;  break;
				case 3:	iResult = 13; break;
				case 4: iResult = 14; break;
				case 5:	iResult = 27; break;
						}
					}
					iMapLevel = 3;
					break;

				case 4:
					if ((iResult >= 1) && (iResult < 50)) {
						switch (iDice(1,2)) {
				case 1:	iResult = 2;  break;
				case 2: iResult = 10; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						switch (iDice(1,2)) {
				case 1: iResult = 8;  break;
				case 2: iResult = 11; break;
						}
					}
					else if ((iResult >= 80) && (iResult <= 100)) {
						switch (iDice(1,2)) {
				case 1: iResult = 14; break;
				case 2:	iResult = 9;  break;
						}
					}
					iMapLevel = 2;
					break;

				case 5:
					if ((iResult >= 1) && (iResult < 30)) {
						switch (iDice(1,5)) {
				case 1:
				case 2: 
				case 3:
				case 4: 
				case 5: iResult = 2;  break;
						}
					}
					else if ((iResult >= 30) && (iResult < 60)) {
						switch (iDice(1,2)) {
				case 1: iResult = 3;  break;
				case 2: iResult = 4;  break;
						}
					}
					else if ((iResult >= 60) && (iResult < 80)) {
						switch (iDice(1,2)) {
				case 1: iResult = 5;  break;
				case 2: iResult = 7;  break;
						}
					}
					else if ((iResult >= 80) && (iResult < 95)) {
						switch (iDice(1,3)) {
				case 1:
				case 2: iResult = 8;  break;
				case 3:	iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch (iDice(1,3)) {
				case 1: iResult = 11; break;
				case 2: iResult = 14; break;
				case 3: iResult = 9;  break;
						}
					}
					iMapLevel = 3;
					break;

				case 6: // huntzone3, huntzone4
					if ((iResult >= 1) && (iResult < 60)) {
						switch (iDice(1,4)) {
				case 1: iResult = 5;  break; // Skeleton
				case 2:	iResult = 6;  break; // Orc-Mage
				case 3: iResult = 12; break; // Cyclops
				case 4: iResult = 11; break; // Troll
						}
					}
					else if ((iResult >= 60) && (iResult < 90)) {
						switch (iDice(1,5)) {
				case 1:
				case 2: iResult = 8;  break; // Stone-Golem
				case 3:	iResult = 11; break; // Troll
				case 4:	iResult = 12; break; // Cyclops 
				case 5:	iResult = 43; break; // Tentocle
						}
					}
					else if ((iResult >= 90) && (iResult <= 100)) {
						switch (iDice(1,9)) {
				case 1:	iResult = 26; break;
				case 2:	iResult = 9;  break;
				case 3: iResult = 13; break;
				case 4: iResult = 14; break;
				case 5:	iResult = 18; break;
				case 6:	iResult = 28; break;
				case 7: iResult = 27; break;
				case 8: iResult = 29; break;
						}
					}
					iMapLevel = 4;
					break;

				case 7: // areuni, elvuni
					if ((iResult >= 1) && (iResult < 50)) {
						switch (iDice(1,5)) {
						case 1: iResult = 3;  break; // Orc
						case 2: iResult = 6;  break; // Orc-Mage
						case 3: iResult = 10; break; // Amphis
						case 4: iResult = 3;  break; // Orc
						case 5: iResult = 50; break; // Giant-Tree
						}
					}
					else if ((iResult >= 50) && (iResult < 60)) { 
						iResult = 29; // Rudolph
					}
					else if ((iResult >= 60) && (iResult < 85)) { 
						switch (iDice(1,4)) {
						case 1: iResult = 50; break; // Giant-Tree
						case 2: 
						case 3: iResult = 6;  break; // Orc-Mage
						case 4: iResult = 12; break; // Troll
						}
					}
					else if ((iResult >= 85) && (iResult <= 100)) {
						switch (iDice(1,4)) {
				case 1: iResult = 12;  break; // Troll
				case 2:
				case 3:
					if (iDice(1,100) < 3) 
						iResult = 17; // Unicorn
					else iResult = 12; // Troll
					break;
				case 4: iResult = 29;  break; // Cannibal-Plant
						}
					}
					iMapLevel = 4;
					break;

				case 8:
					if ((iResult >= 1) && (iResult < 70)) {
						switch (iDice(1,2)) {
						case 1:	iResult = 4;  break;
						case 2: iResult = 5;  break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						switch (iDice(1,2)) {
						case 1: iResult = 8;  break;
						case 2: iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						iResult = 14; break;
					}
					iMapLevel = 4;
					break;

				case 9:
					if ((iResult >= 1) && (iResult < 70)) {
						switch (iDice(1,2)) {
				case 1:	iResult = 4;  break;
				case 2: iResult = 5;  break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						switch (iDice(1,3)) {
				case 1: iResult = 8;  break;
				case 2: iResult = 9;  break;
				case 3: iResult = 13; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch (iDice(1,6)) {
				case 1: 
				case 2: 
				case 3: iResult = 9;  break;
				case 4: 
				case 5: iResult = 14; break;
				case 6: iResult = 15; break;
						}
					}

					if ((iDice(1,3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;
					iMapLevel = 5;
					break;

				case 10:
					if ((iResult >= 1) && (iResult < 70)) {
						switch (iDice(1,3)) {
				case 1:	iResult = 9; break;
				case 2: iResult = 5; break;
				case 3: iResult = 8; break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						switch (iDice(1,3)) {
				case 1:
				case 2:	iResult = 13; break;
				case 3: iResult = 14; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch (iDice(1,3)) {
				case 1:
				case 2: iResult = 14; break;
				case 3: iResult = 15; break;
						}
					}
					// Demon?? Berserk ????? ??? ?????
					if ((iDice(1,3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;
					iMapLevel = 5;
					break;

				case 11:
					if ((iResult >= 1) && (iResult < 30)) {
						switch (iDice(1,5)) {
				case 1:
				case 2: 
				case 3:
				case 4: 
				case 5: iResult = 2; break;
						}
					}
					else if ((iResult >= 30) && (iResult < 60)) {
						switch (iDice(1,2)) {
				case 1: iResult = 3; break;
				case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 60) && (iResult < 80)) {
						switch (iDice(1,2)) {
				case 1: iResult = 5; break;
				case 2: iResult = 7; break;
						}
					}
					else if ((iResult >= 80) && (iResult < 95)) {
						switch (iDice(1,3)) {
				case 1:
				case 2: iResult = 10;  break;
				case 3:	iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch (iDice(1,3)) {
				case 1: iResult = 11; break;
				case 2: iResult = 7; break;
				case 3: iResult = 8; break;
						}
					}
					iMapLevel = 4;
					break;

				case 12:
					if ((iResult >= 1) && (iResult < 50)) {
						switch (iDice(1,3)) {
				case 1:	iResult = 1 ; break;
				case 2: iResult = 2 ; break;
				case 3: iResult = 10; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 85)) {
						switch (iDice(1,2)) {
				case 1: iResult = 5; break;
				case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 85) && (iResult <= 100)) {
						switch (iDice(1,3)) {
				case 1: iResult = 8; break;
				case 2: iResult = 11; break;
				case 3: iResult = 26; break;
						}
					}
					iMapLevel = 4;
					break;

				case 13:
					if ((iResult >= 1) && (iResult < 15)) {
						iResult = 4;
						bFirmBerserk = TRUE;
						iTotalMob = 4 - (iDice(1,2) - 1);
						break;
					}
					else if ((iResult >= 15) && (iResult < 40)) {
						iResult = 14;
						bFirmBerserk = TRUE;
						iTotalMob = 4 - (iDice(1,2) - 1);
						break;
					}
					else if ((iResult >= 40) && (iResult < 60)) {
						iResult = 9;
						bFirmBerserk = TRUE;
						iTotalMob = 4 - (iDice(1,2) - 1);
						break;
					}						
					else if ((iResult >= 60) && (iResult < 75)) {
						iResult = 13;
						bFirmBerserk = TRUE;
						iTotalMob = 4 - (iDice(1,2) - 1);
						break;
					}
					else if ((iResult >= 75) && (iResult < 95)) {
						iResult = 23;
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						iResult = 22;
					}
					iMapLevel = 5;
					break;

				case 14: // icebound
					if ((iResult >= 1) && (iResult < 30)) {
						iResult = 23; // Dark-Elf
					}
					else if ((iResult >= 30) && (iResult < 50)) {
						iResult = 31; // Ice-Golem
					}
					else if ((iResult >= 50) && (iResult < 70)) {
						iResult = 22; // Beholder
						bFirmBerserk = TRUE;
						iTotalMob = 4 - (iDice(1,2) - 1);
					}
					else if ((iResult >= 70) && (iResult < 90)) {
						iResult = 32; // DireBoar
					}
					else if ((iResult >= 90) && (iResult <= 100)) {
						iResult = 33; // Frost
					}
					iMapLevel = 5;
					break;

				case 15:
					if ((iResult >= 1) && (iResult < 35)) {
						iResult = 23; 
						bFirmBerserk = TRUE;
					}
					else if ((iResult >= 35) && (iResult < 50)) {
						iResult = 22;
						bFirmBerserk = TRUE;
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						iResult = 15;
					}
					else if ((iResult >= 80) && (iResult <= 100)) {
						iResult = 21;
					}
					iMapLevel = 4;
					break;

				case 16: // 2ndmiddle, huntzone1, huntzone2, 
					if ((iResult >= 1) && (iResult < 40)) {
						switch (iDice(1,3)) {
						case 1:	iResult = 7;  break; // Scorpion
						case 2: iResult = 2;  break; // Giant-Ant
						case 3: iResult = 10; break; // Amphis
						}
					}
					else if ((iResult >= 40) && (iResult < 50)) {
						iResult = 30; // Rudolph
					}
					else if ((iResult >= 50) && (iResult < 85)) {
						switch (iDice(1,2)) {
						case 1: iResult = 5;  break; // Skeleton
						case 2: iResult = 4;  break; // Zombie
						}
					}
					else if ((iResult >= 85) && (iResult <= 100)) {
						switch (iDice(1,3)) {
						case 1: iResult = 8;  break; // Stone-Golem
						case 2: iResult = 11; break; // Clay-Golem
						case 3: iResult = 7;  break; // Scorpion
						}
					}
					iMapLevel = 1;
					break;

				case 17:
					if ((iResult >= 1) && (iResult < 30)) {
						switch (iDice(1,4)) {
						case 1:	iResult = 22;  break; // Giant-Frog
						case 2: iResult = 8;   break; // Stone-Golem
						case 3: iResult = 24;  break; // Rabbit
						case 4: iResult = 5;   break;
						}
					}
					else if ((iResult >= 30) && (iResult < 40)) {
						iResult = 30;
					}
					else if ((iResult >= 40) && (iResult < 70)) {
						iResult = 32;
					}
					else if ((iResult >= 70) && (iResult < 90)) {
						iResult = 31;
						if (iDice(1,5) == 1) {
							bFirmBerserk = TRUE;
						}
					}
					else if ((iResult >= 90) && (iResult <= 100)) {
						iResult = 33;
					}
					iMapLevel = 1;
					break;

				case 18: // druncncity
					if ((iResult >= 1) && (iResult < 2)) {
						iResult = 39; // Tentocle
					}
					else if ((iResult >= 2) && (iResult < 12)) {
						iResult = 44; // ClawTurtle
					}
					else if ((iResult >= 12) && (iResult < 50)) {
						iResult = 48; // Nizie
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						iResult = 45; // Giant-Crayfish
					}
					else if ((iResult >= 80) && (iResult < 90)) {
						iResult = 34; // Stalker
					}			
					else if ((iResult >= 90) && (iResult <= 100)) {
						iResult = 26; // Giant-Frog
					}					
					iMapLevel = 4;
					break;

				case 19:
					if ((iResult >= 1) && (iResult < 15)) {
						iResult = 44;
					}
					else if ((iResult >= 15) && (iResult < 25)) {
						iResult = 46;
					}
					else if ((iResult >= 25) && (iResult < 35)) {
						iResult = 21;
					}
					else if ((iResult >= 35) && (iResult < 60)) {
						iResult = 43;
					}				
					else if ((iResult >= 60) && (iResult < 85)) {
						iResult = 23;
					}		
					else if ((iResult >= 85) && (iResult <= 100)) {
						iResult = 22;
					}
					iMapLevel = 4;
					break;

				case 20:
					if ((iResult >= 1) && (iResult < 2)) {
						iResult = 41;
					}
					else if ((iResult >= 2) && (iResult < 3)) {
						iResult = 40;
					}
					else if ((iResult >= 3) && (iResult < 8)) {
						iResult = 53;
					}
					else if ((iResult >= 8) && (iResult < 9)) {
						iResult = 39;
					}
					else if ((iResult >= 9) && (iResult < 20)) {
						iResult = 21;
					}
					else if ((iResult >= 20) && (iResult < 35)) {
						iResult = 16;
					}
					else if ((iResult >= 35) && (iResult < 45)) {
						iResult = 44;
					}
					else if ((iResult >= 45) && (iResult < 55)) {
						iResult = 45;
					}
					else if ((iResult >= 55) && (iResult < 75)) {
						iResult = 28;
					}
					else if ((iResult >= 75) && (iResult < 95)) {
						iResult = 43;
					}
					else if ((iResult >= 95) && (iResult < 100)) {
						iResult = 22;
					}
					iMapLevel = 4;
					break;

				case 21:
					if ((iResult >= 1) && (iResult < 94)) {
						iResult = 17; // Unicorn
						bFirmBerserk = TRUE;
					}
					else if ((iResult >= 94) && (iResult < 95)) {
						iResult = 36; // Wyvern
					}
					else if ((iResult >= 95) && (iResult < 96)) {
						iResult = 37; // Fire-Wyvern
					}
					else if ((iResult >= 96) && (iResult < 97)) {
						iResult = 47; // MasterMage-Orc
					}
					else if ((iResult >= 97) && (iResult < 98)) {
						iResult = 35; // Hellclaw
					}				
					else if ((iResult >= 98) && (iResult < 99)) {
						iResult = 49; // Tigerworm
					}		
					else if ((iResult >= 99) && (iResult <= 100)) {
						iResult = 51; // Abaddon
					}
					iMapLevel = 4;
					break;
	
				}			

				pX = NULL;
				pY = NULL;
// KaoZureS - No respawn en heldenian
			if (strcmp(m_pMapList[i]->m_cName,"BtField") == 0) {
				if (m_bIsHeldenianMode == TRUE) {
					m_pMapList[i]->m_iMaximumObject = 0; }
				else { m_pMapList[i]->m_iMaximumObject = 900; } 
			}
//				bIsSpecialEvent = TRUE;
				if ((m_bIsSpecialEventTime == TRUE) && (iDice(1,10) == 3)) bIsSpecialEvent = TRUE;

				if (bIsSpecialEvent == TRUE) {
					switch (m_cSpecialEventType) {
					case 1:
						if (m_pMapList[i]->m_iMaxPx != 0) {
							pX = m_pMapList[i]->m_iMaxPx*20 +10;
							pY = m_pMapList[i]->m_iMaxPy*20 +10;

							if (pX < 0) pX = 0;
							if (pY < 0) pY = 0;

							if (m_bIsCrusadeMode == TRUE) {
								if (strcmp(m_pMapList[i]->m_cName, "aresden") == 0)
									switch(iDice(1,6)) {
									case 1: iResult = 20; break;
									case 2: iResult = 53; break;
									case 3: iResult = 55; break;
									case 4: iResult = 57; break;
									case 5: iResult = 59; break;
									case 6: iResult = 61; break;
								}
								else if (strcmp(m_pMapList[i]->m_cName, "elvine") == 0)
									switch(iDice(1,6)) {
									case 1: iResult = 19; break;
									case 2: iResult = 52; break;
									case 3: iResult = 54; break;
									case 4: iResult = 56; break;
									case 5: iResult = 58; break;
									case 6: iResult = 60; break;
								}
							}
							wsprintf(G_cTxt, "(!) Mob-Event Map(%s)[%d (%d,%d)]", m_pMapList[i]->m_cName, iResult, pX, pY);
						}
						break;

					case 2:
						if (iDice(1,3) == 2) {
							if ((memcmp(m_pMapList[i]->m_cLocationName, "aresden", 7)   == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "middled1n", 9) == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "arefarm", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "elvfarm", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "elvine", 6)    == 0)) {
									if (iDice(1,30) == 5) 
										iResult = 16;
									else iResult = 5;
								}
							else iResult = 16;
						}
						else iResult = 17;

						m_bIsSpecialEventTime = FALSE;
						break;
					}
				}

				ZeroMemory(cNpcName, sizeof(cNpcName));
				//Random Monster Spawns
				switch (iResult) {
				case 1:  strcpy(cNpcName, "Slime");				iNpcID = 10; iProbSA = 5;  iKindSA = 1; break;
				case 2:  strcpy(cNpcName, "Giant-Ant");			iNpcID = 16; iProbSA = 10; iKindSA = 2; break;
				case 3:  strcpy(cNpcName, "Orc");				iNpcID = 14; iProbSA = 15; iKindSA = 1; break;
				case 4:  strcpy(cNpcName, "Zombie");			iNpcID = 18; iProbSA = 15; iKindSA = 3; break;
				case 5:  strcpy(cNpcName, "Skeleton");			iNpcID = 11; iProbSA = 35; iKindSA = 8; break;
				case 6:  strcpy(cNpcName, "Orc-Mage");			iNpcID = 14; iProbSA = 30; iKindSA = 7; break;
				case 7:  strcpy(cNpcName, "Scorpion");			iNpcID = 17; iProbSA = 15; iKindSA = 3; break;
				case 8:  strcpy(cNpcName, "Stone-Golem");		iNpcID = 12; iProbSA = 25; iKindSA = 5; break;
				case 9:  strcpy(cNpcName, "Cyclops");			iNpcID = 13; iProbSA = 35; iKindSA = 8; break;
				case 10: strcpy(cNpcName, "Amphis");			iNpcID = 22; iProbSA = 20; iKindSA = 3; break;
				case 11: strcpy(cNpcName, "Clay-Golem");		iNpcID = 23; iProbSA = 20; iKindSA = 5; break;
				case 12: strcpy(cNpcName, "Troll");				iNpcID = 28; iProbSA = 25; iKindSA = 3; break; 
				case 13: strcpy(cNpcName, "Orge");				iNpcID = 29; iProbSA = 25; iKindSA = 1; break;
				case 14: strcpy(cNpcName, "Hellbound");			iNpcID = 27; iProbSA = 25; iKindSA = 8; break;
				case 15: strcpy(cNpcName, "Liche");				iNpcID = 30; iProbSA = 30; iKindSA = 8; break;
				case 16: strcpy(cNpcName, "Demon");				iNpcID = 31; iProbSA = 20; iKindSA = 8; break;
				case 17: strcpy(cNpcName, "Unicorn");			iNpcID = 32; iProbSA = 35; iKindSA = 7; break;
				case 18: strcpy(cNpcName, "WereWolf");			iNpcID = 33; iProbSA = 25; iKindSA = 1; break;
				case 19: strcpy(cNpcName, "YB-Aresden");		iNpcID = -1;  iProbSA = 15; iKindSA = 1; break;
				case 20: strcpy(cNpcName, "YB-Elvine");			iNpcID = -1;  iProbSA = 15; iKindSA = 1; break;
				case 21: strcpy(cNpcName, "Gagoyle");			iNpcID = 52; iProbSA = 20; iKindSA = 8; break;
				case 22: strcpy(cNpcName, "Beholder");			iNpcID = 53; iProbSA = 20; iKindSA = 5; break;
				case 23: strcpy(cNpcName, "Dark-Elf");			iNpcID = 54; iProbSA = 20; iKindSA = 3; break;
				case 24: strcpy(cNpcName, "Rabbit");			iNpcID = -1; iProbSA = 5;  iKindSA = 1; break;
				case 25: strcpy(cNpcName, "Cat");				iNpcID = -1; iProbSA = 10; iKindSA = 2; break;
				case 26: strcpy(cNpcName, "Giant-Frog");		iNpcID = 57; iProbSA = 10; iKindSA = 2; break;
				case 27: strcpy(cNpcName, "Mountain-Giant");	iNpcID = 58; iProbSA = 25; iKindSA = 1; break;
				case 28: strcpy(cNpcName, "Ettin");				iNpcID = 59; iProbSA = 20; iKindSA = 8; break;
				case 29: strcpy(cNpcName, "Cannibal-Plant");	iNpcID = 60; iProbSA = 20; iKindSA = 5; break;
				case 30: strcpy(cNpcName, "Rudolph");			iNpcID = -1; iProbSA = 20; iKindSA = 5; break;
				case 31: strcpy(cNpcName, "Ice-Golem");			iNpcID = 65; iProbSA = 35; iKindSA = 8; break;
				case 32: strcpy(cNpcName, "DireBoar");			iNpcID = 62; iProbSA = 20; iKindSA = 5; break;
				case 33: strcpy(cNpcName, "Frost");				iNpcID = 63; iProbSA = 30; iKindSA = 8; break;
				case 34: strcpy(cNpcName, "Stalker");           iNpcID = 48; iProbSA = 20; iKindSA = 1; break;
				case 35: strcpy(cNpcName, "Hellclaw");			iNpcID = 49; iProbSA = 20; iKindSA = 1; break;
				case 36: strcpy(cNpcName, "Wyvern");			iNpcID = 66; iProbSA = 20; iKindSA = 1; break;
				case 37: strcpy(cNpcName, "Fire-Wyvern");		iNpcID = -1; iProbSA = 20; iKindSA = 1; break; 
				case 38: strcpy(cNpcName, "Barlog");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 39: strcpy(cNpcName, "Tentocle");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 40: strcpy(cNpcName, "Centaurus");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 41: strcpy(cNpcName, "Giant-Lizard");		iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 42: strcpy(cNpcName, "Minotaurs");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 43: strcpy(cNpcName, "Tentocle");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 44: strcpy(cNpcName, "Claw-Turtle");		iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 45: strcpy(cNpcName, "Giant-Crayfish");	iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 46: strcpy(cNpcName, "Giant-Plant");		iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 47: strcpy(cNpcName, "MasterMage-Orc");	iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 48: strcpy(cNpcName, "Nizie");				iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 49: strcpy(cNpcName, "Tigerworm");			iNpcID = 50; iProbSA = 20; iKindSA = 1; break;
				case 50: strcpy(cNpcName, "Giant-Plant");		iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 51: strcpy(cNpcName, "Abaddon");			iNpcID = -1; iProbSA = 20; iKindSA = 9; break;
				case 52: strcpy(cNpcName, "YW-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 53: strcpy(cNpcName, "YW-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 54: strcpy(cNpcName, "YY-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 55: strcpy(cNpcName, "YY-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 56: strcpy(cNpcName, "XB-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 57: strcpy(cNpcName, "XB-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 58: strcpy(cNpcName, "XW-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 59: strcpy(cNpcName, "XW-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 60: strcpy(cNpcName, "XY-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 61: strcpy(cNpcName, "XY-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				default: strcpy(cNpcName, "Orc");				iNpcID = 14; iProbSA = 15; iKindSA = 1; break;
				}

				cSA = 0;
				if (iDice(1,100) <= iProbSA) {
					cSA = _cGetSpecialAbility(iKindSA);
				}

				if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk, TRUE)) == FALSE) {
					m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
				}
				else {

				}
			}	

			switch (iResult) {
			case 1:	 iTotalMob = iDice(1,5)-1; break;
			case 2:	 iTotalMob = iDice(1,5)-1; break;
			case 3:	 iTotalMob = iDice(1,5)-1; break;
			case 4:	 iTotalMob = iDice(1,3)-1; break;
			case 5:	 iTotalMob = iDice(1,3)-1; break;

			case 6:  iTotalMob = iDice(1,3)-1; break;
			case 7:  iTotalMob = iDice(1,3)-1; break;
			case 8:  iTotalMob = iDice(1,2)-1; break;
			case 9:  iTotalMob = iDice(1,2)-1; break;
			case 10: iTotalMob = iDice(1,5)-1; break;
			case 11: iTotalMob = iDice(1,3)-1; break;
			case 12: iTotalMob = iDice(1,5)-1; break;
			case 13: iTotalMob = iDice(1,3)-1; break;
			case 14: iTotalMob = iDice(1,2)-1; break;
			case 15: iTotalMob = iDice(1,3)-1; break;
			case 16: iTotalMob = iDice(1,2)-1; break;
			case 17: iTotalMob = iDice(1,2)-1; break;

			case 18: iTotalMob = iDice(1,5)-1; break;
			case 19: iTotalMob = iDice(1,2)-1; break;
			case 20: iTotalMob = iDice(1,2)-1; break;
			case 21: iTotalMob = iDice(1,5)-1; break;
			case 22: iTotalMob = iDice(1,2)-1; break;
			case 23: iTotalMob = iDice(1,2)-1; break;

			case 24: iTotalMob = iDice(1,4)-1; break;
			case 25: iTotalMob = iDice(1,2)-1; break;
			case 26: iTotalMob = iDice(1,3)-1; break;
			case 27: iTotalMob = iDice(1,3)-1; break;

			case 28: iTotalMob = iDice(1,3)-1; break;
			case 29: iTotalMob = iDice(1,5)-1; break;
			case 30: iTotalMob = iDice(1,3)-1; break;
			case 31: iTotalMob = iDice(1,3)-1; break;

			case 32: iTotalMob = 1; break;
			case 33: iTotalMob = 1; break;
			case 34: iTotalMob = 1; break;
			case 35: iTotalMob = 1; break;
			case 36: iTotalMob = 1; break;

			case 37: iTotalMob = 1; break;
			case 38: iTotalMob = 1; break;
			case 39: iTotalMob = 1; break;
			case 40: iTotalMob = 1; break;
			case 41: iTotalMob = 1; break;

			case 42: iTotalMob = iDice(1,3)-1; break;
			case 43: iTotalMob = 1; break;
			case 44: iTotalMob = iDice(1,3)-1; break; 
			case 45: iTotalMob = 1; break;
			default: iTotalMob = 0; break;
			}

			if (bMaster == FALSE) iTotalMob = 0;

			if (iTotalMob > 2) {
				switch (iResult) {
				case 1:  // Slime 
				case 2:  // Giant-Ant
				case 3:  // Orc
				case 4:  // Zombie
				case 5:  // Skeleton
				case 6:  // Orc-Mage
				case 7:  // Scorpion
				case 8:  // Stone-Golem
				case 9:  // Cyclops
				case 10: // Amphis
				case 11: // Clay-Golem
				case 12: // Troll
				case 13: // Orge
				case 14: // Hellbound
				case 15: // Liche
				case 16: // Demon
				case 17: // Unicorn
				case 18: // WereWolf
				case 19:
				case 20:
				case 21:
				case 22:
				case 23:
				case 24:
				case 25:
				case 26:
				case 27:
				case 28:
				case 29:
				case 30:
				case 31:
				case 32:
					if (iDice(1,5) == 1) iTotalMob = 0;  // 75% ???????? ???.
					break;

				case 33:
				case 34:
				case 35:
				case 36:
				case 37:
				case 38:
				case 39:
				case 40:
				case 41:
				case 42:
				case 44:
				case 45:
				case 46:
				case 47:
				case 48:
				case 49:
					if (iDice(1,5) != 1) iTotalMob = 0;  // 75% ???????????????
					break;
				}
			}

			if (bIsSpecialEvent == TRUE) {
				switch (m_cSpecialEventType) {
				case 1:
					if ((iResult != 35) && (iResult != 36) && (iResult != 37) && (iResult != 49) 
						&& (iResult != 51) && (iResult != 15) && (iResult != 16) && (iResult != 21)) iTotalMob = 12;
					for (x = 1; x < DEF_MAXCLIENTS; x++)
					if ((iNpcID != -1) && (m_pClientList[x] != NULL) && (m_pClientList[x]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, x, DEF_NOTIFY_SPAWNEVENT, pX, pY, iNpcID, NULL, NULL, NULL);
					}
					break;

				case 2:
					if ((memcmp(m_pMapList[i]->m_cLocationName, "aresden", 7) == 0) ||
						(memcmp(m_pMapList[i]->m_cLocationName, "elvine",  6) == 0) ||
						(memcmp(m_pMapList[i]->m_cLocationName, "elvfarm",  7) == 0) ||
						(memcmp(m_pMapList[i]->m_cLocationName, "arefarm",  7) == 0) ) {
							iTotalMob = 0;
						}
						break;
				}
				m_bIsSpecialEventTime = FALSE;
			}

			for (j = 0; j < iTotalMob; j++) {
				iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {
					ZeroMemory(cName_Slave, sizeof(cName_Slave));
					wsprintf(cName_Slave, "XX%d", iNamingValue);
					cName_Slave[0] = 95; // original '_';
					cName_Slave[1] = i + 65;

					cSA = 0;

					if (iDice(1,100) <= iProbSA) {
						cSA = _cGetSpecialAbility(iKindSA);
					}

					if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
						m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
					}
					else {
						bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
					}
				}
			}
		}

		//50Cent - MobGenerator Fix
		if(m_pMapList[i] != NULL) {
            for(j = 1; j < DEF_MAXSPOTMOBGENERATOR; j++)
                if((m_pMapList[i]->m_iTotalActiveObject + m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs) < m_pMapList[i]->m_iMaximumObject) {

				if ( (iDice(1,3) == 2) && (m_pMapList[i]->m_stSpotMobGenerator[j].bDefined == TRUE) &&
					(m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs > m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs) ) {
						iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {

							ZeroMemory(cNpcName, sizeof(cNpcName));
							switch (m_pMapList[i]->m_stSpotMobGenerator[j].iMobType) {
								// spot-mob-generator
									case 10:  strcpy(cNpcName,"Slime");				iProbSA = 5;  iKindSA = 1;  break;
									case 16:  strcpy(cNpcName,"Giant-Ant");			iProbSA = 10; iKindSA = 2;  break;
									case 14:  strcpy(cNpcName,"Orc");				iProbSA = 15; iKindSA = 1;  break;
									case 18:  strcpy(cNpcName,"Zombie");			iProbSA = 15; iKindSA = 3;  break;
									case 11:  strcpy(cNpcName,"Skeleton");			iProbSA = 35; iKindSA = 8;  break;
									case 6:   strcpy(cNpcName,"Orc-Mage");			iProbSA = 30; iKindSA = 7;  break;
									case 17:  strcpy(cNpcName,"Scorpion");			iProbSA = 15; iKindSA = 3;  break;
									case 12:  strcpy(cNpcName,"Stone-Golem");		iProbSA = 25; iKindSA = 5;  break;
									case 13:  strcpy(cNpcName,"Cyclops");			iProbSA = 35; iKindSA = 8;  break;
									case 22:  strcpy(cNpcName,"Amphis");			iProbSA = 20; iKindSA = 3;  break;
									case 23:  strcpy(cNpcName,"Clay-Golem");		iProbSA = 20; iKindSA = 5;  break;
									case 24:  strcpy(cNpcName,"Guard-Aresden");		bIsGuard = TRUE; break;
									case 25:  strcpy(cNpcName,"Guard-Elvine");		bIsGuard = TRUE; break;
									case 26:  strcpy(cNpcName,"Guard-Neutral");		bIsGuard = TRUE; break;
									case 27:  strcpy(cNpcName,"Hellbound");			iProbSA = 20; iKindSA = 1;  break;
									case 29:  strcpy(cNpcName,"Orge");              iProbSA = 20; iKindSA = 1;  break;
									case 30:  strcpy(cNpcName,"Liche");				iProbSA = 30; iKindSA = 8;  break;
									case 31:  strcpy(cNpcName,"Demon");				iProbSA = 20; iKindSA = 8;  break;
									case 32:  strcpy(cNpcName,"Unicorn");			iProbSA = 35; iKindSA = 7;  break;
									case 33:  strcpy(cNpcName,"WereWolf");			iProbSA = 25; iKindSA = 1;  break;
									case 34:  strcpy(cNpcName,"Dummy");				iProbSA = 5;  iKindSA = 1;  break;
									case 35:  strcpy(cNpcName,"Attack-Dummy");		iProbSA = 5;  iKindSA = 1;  break;
									case 48:  strcpy(cNpcName,"Stalker");			iProbSA = 20; iKindSA = 3;  break;
										
									case 49:  strcpy(cNpcName,"Hellclaw");			iProbSA = 20; iKindSA = 8;  break;
									case 50:  strcpy(cNpcName,"Tigerworm");			iProbSA = 20; iKindSA = 8;  break;
									case 54:  strcpy(cNpcName,"Dark-Elf");			iProbSA = 20; iKindSA = 8;  break;
									case 53:  strcpy(cNpcName,"Beholder");			iProbSA = 20; iKindSA = 8;  break;
									case 52:  strcpy(cNpcName,"Gagoyle");			iProbSA = 20; iKindSA = 8;  break;
										
									case 57:  strcpy(cNpcName,"Giant-Frog");		iProbSA = 10; iKindSA = 2;  break;
									case 58:  strcpy(cNpcName,"Mountain-Giant");	iProbSA = 25; iKindSA = 1;  break;
									case 59:  strcpy(cNpcName,"Ettin");				iProbSA = 20; iKindSA = 8;  break;
									case 60:  strcpy(cNpcName,"Cannibal-Plant");	iProbSA = 20; iKindSA = 5;  break;
									case 61:  strcpy(cNpcName,"Rudolph");			iProbSA = 20; iKindSA = 1;  break;
									case 62:  strcpy(cNpcName,"DireBoar");			iProbSA = 20; iKindSA = 1;  break;
									case 63:  strcpy(cNpcName,"Frost");				iProbSA = 20; iKindSA = 8;  break;
									case 65:  strcpy(cNpcName,"Ice-Golem");			iProbSA = 20; iKindSA = 8;  break;
									case 66:  strcpy(cNpcName,"Wyvern");			iProbSA = 20; iKindSA = 1;  break;
									case 55:  strcpy(cNpcName,"Rabbit");			iProbSA = 20; iKindSA = 1;  break;
									case 67:  strcpy(cNpcName,"McGaffin");			iProbSA = 20; iKindSA = 1;  break;
									case 68:  strcpy(cNpcName,"Perry");				iProbSA = 20; iKindSA = 1;  break;
									case 69:  strcpy(cNpcName,"Devlin");			iProbSA = 20; iKindSA = 1;  break;
									case 73:  strcpy(cNpcName,"Fire-Wyvern");		iProbSA = 20; iKindSA = 1;  break;
									case 70:  strcpy(cNpcName,"Barlog");			iProbSA = 20; iKindSA = 1;  break;
									case 80:  strcpy(cNpcName,"Tentocle");			iProbSA = 20; iKindSA = 1;  break;
									case 71:  strcpy(cNpcName,"Centaurus");			iProbSA = 20; iKindSA = 1;  break;
									case 75:  strcpy(cNpcName,"Giant-Lizard");		iProbSA = 20; iKindSA = 1;  break;
									case 78:  strcpy(cNpcName,"Minotaurs");			iProbSA = 20; iKindSA = 1;  break;
									case 81:  strcpy(cNpcName,"Abaddon");			iProbSA = 20; iKindSA = 9;  break;
									case 72:  strcpy(cNpcName,"Claw-Turtle");		iProbSA = 20; iKindSA = 1;  break;
									case 74:  strcpy(cNpcName,"Giant-Crayfish");	iProbSA = 20; iKindSA = 1;  break;
									case 76:  strcpy(cNpcName,"Giant-Plant");		iProbSA = 20; iKindSA = 1;  break;
									case 77:  strcpy(cNpcName,"MasterMage-Orc");	iProbSA = 20; iKindSA = 1;  break;
									case 79:  strcpy(cNpcName,"Nizie");				iProbSA = 20; iKindSA = 1; break;
									default: 
										strcpy(cNpcName, "Orc");
										iProbSA = 15; 
										iKindSA = 1; 
										break;
							}						
							/* NPCs not spawning in pits: 

							// 15 ShopKeeper-W
							// 19 Gandlf          
							// 20 Howard
							// 36 Arrow Gaurd Tower Kit - Aresden, Elvine
							// 37 Cannon Gaurd Tower Kit - Aresden, Elvine
							// 38 Mana Collector Kit - Aresden, Elvine
							// 39 Detector Constructor Kit - Aresden, Elvine
							// 40 Energy Shield Generator - Aresden, Elvine
							// 41 Grand Master Generator - Aresden Elvine
							// 43 Light War Beetle - Aresden, Elvine
							// 44 God's Hand Knight
							// 45 Mounted God's Hand Knight
							// 46 Temple Knight
							// 47 Battle Golem
							// 51 Catapult
							// 64 Crops
							*/
							bFirmBerserk = FALSE;
							if ((iMapLevel == 5) && (iDice(1,3) == 1)) bFirmBerserk = TRUE;

							ZeroMemory(cName_Master, sizeof(cName_Master));
							wsprintf(cName_Master, "XX%d", iNamingValue);
							cName_Master[0] = 95; // original '_';
							cName_Master[1] = i + 65;

							cSA = 0;
							// centu - guardias SIEMPRE con Magic Destruction & Clairvoyrant
							if (bIsGuard)
							{
								cSA = _cGetSpecialAbility(10);
							}
							else 
							{
								if ((m_pMapList[i]->m_stSpotMobGenerator[j].iMobType != 34) && (iDice(1,100) <= iProbSA)) {
									cSA = _cGetSpecialAbility(iKindSA);
								}
							}

							switch (m_pMapList[i]->m_stSpotMobGenerator[j].cType) {
								case 1:
									if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMAREA, &pX, &pY, cWaypoint, &m_pMapList[i]->m_stSpotMobGenerator[j].rcRect, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
										m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
									}
									else {
										m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
									}
									break;

								case 2:
									if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMWAYPOINT, NULL, NULL, m_pMapList[i]->m_stSpotMobGenerator[j].cWaypoint, NULL, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
										m_pMapList[i]->SetNamingValueEmpty(iNamingValue);	
									}
									else {
										m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
									}
									break;
							}
						}
					}
			}
		}
	}
}

void CGame::InitPlayerData(int iClientH, char * pData, DWORD dwSize)
{
 char  * cp, cName[11], cData[256], cTxt[256], cGuildStatus, cPoints = 0;
 DWORD * dwp;
 WORD  * wp;
 int iRet, iTemp, iTemp2, i, iQuestType, iQuestNumber;
 BOOL bRet;
 short sV1;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return;
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;

	cp++;

	cGuildStatus = *cp;
	cp++;

	m_pClientList[iClientH]->m_iHitRatio     = 0;
	m_pClientList[iClientH]->m_iDefenseRatio = 0;
	m_pClientList[iClientH]->m_cSide         = 0;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HUNGER, m_pClientList[iClientH]->m_iHungerStatus, NULL, NULL, NULL); // MORLA2 - Muestra el hunger status
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPDGDEATHS, m_pClientList[iClientH]->m_iDGPoints, m_pClientList[iClientH]->m_iDeaths, m_pClientList[iClientH]->m_iRating, NULL);

	bRet = _bDecodePlayerDatafileContents(iClientH, cp, dwSize - 19);
	if (bRet == FALSE) {
		wsprintf(G_cTxt, "(HACK?) Character(%s) data error!", m_pClientList[iClientH]->m_cCharName);
		DeleteClient(iClientH, FALSE, TRUE, TRUE, FALSE); 
		return;
	}
	___RestorePlayerCharacteristics(iClientH);
	if ((m_pClientList[iClientH]->m_sX == -1) && (m_pClientList[iClientH]->m_sY == -1)) {
		GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);
	}
	SetPlayingStatus(iClientH);	// New 17/05/2004
	iTemp = m_pClientList[iClientH]->m_iStatus;
	iTemp = 0x0FFFFFFF & iTemp;
	iTemp2 = iGetPlayerABSStatus(iClientH);
	iTemp = iTemp | (iTemp2 << 28);
	m_pClientList[iClientH]->m_iStatus = iTemp;
	
	if (m_pClientList[iClientH]->m_iLevel > 100 && m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE) {
			ForceChangePlayMode(iClientH, TRUE);
		}
	}
	if (m_pClientList[iClientH]->m_iLevel < m_iPlayerMaxLevel)
	{
		m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1];
	}
	else
	{
		m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + m_pClientList[iClientH]->m_iMajesticLevel];
	}
	CalcTotalItemEffect(iClientH, -1, TRUE);
	iCalcTotalWeight(iClientH);
	CheckSpecialEvent(iClientH); // new
	bCheckMagicInt(iClientH);

	// Recover summons you may had before deco...
	iRecoverFollowers(iClientH, FALSE);
	
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
	}		
	if ((cGuildStatus == 0) && (memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0)) {
		ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
		strcpy(m_pClientList[iClientH]->m_cGuildName, "NONE");
		m_pClientList[iClientH]->m_iGuildRank = -1;
		m_pClientList[iClientH]->m_iGuildGUID = -1;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GUILDDISBANDED, NULL, NULL, NULL, m_pClientList[iClientH]->m_cGuildName);
	}
	// new
	iQuestNumber = m_pClientList[iClientH]->m_iQuest;
	if ((iQuestNumber != 0) && (m_pQuestConfigList[iQuestNumber] != 0)) {
		iQuestType = m_pQuestConfigList[iQuestNumber]->m_iType;
		if (iQuestType == 1) {
			if (_bCheckIsQuestCompleted(iClientH) == TRUE) {
				sV1 = m_pQuestConfigList[iQuestNumber]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount;
				if (sV1 > 0) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOUNTER, sV1, NULL, NULL, NULL);
				}
			}
		}
	}
	// new - handles cPoints
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == TRUE) {
		cPoints = 0;
		if ((m_pClientList[iClientH]->m_cSide != m_sLastHeldenianWinner) && (m_sLastHeldenianWinner != 0)) {
			cPoints = 100;
		}
	}
	if (m_pClientList[iClientH] == NULL) {
		wsprintf(cTxt, "<%d> InitPlayerData error - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		return;
	}
	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITPLAYER;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		wsprintf(cTxt, "<%d> InitPlayerData - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		DeleteClient(iClientH, FALSE, TRUE, TRUE, FALSE); // 4 true
		return;
	}
	m_pClientList[iClientH]->m_bIsInitComplete = TRUE;
	bSendMsgToLS(MSGID_ENTERGAMECONFIRM, iClientH, TRUE, FALSE); // 3 true
	if (m_pClientList[iClientH]->m_iPartyID != NULL) {	
		ZeroMemory(cData, sizeof(cData));
		cp	 = (char *)cData;
		dwp	 = (DWORD *)cp;
		*dwp = MSGID_PARTYOPERATION;
		cp	+= 4;

		wp	 = (WORD*)cp;
		*wp  = 5; 
		cp  += 2;

		wp   = (WORD *)cp;
		*wp  = iClientH;
		cp  += 2;

		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp  += 10;

		wp   = (WORD *) cp;
		*wp  = m_pClientList[iClientH]->m_iPartyID;
		cp  += 2;

		SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);	
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) {
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
				wsprintf(G_cTxt, "PartyID:%d member:%d In Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				break;
			}
		}
	}

	m_pClientList[iClientH]->m_dwLastActionTime = m_pClientList[iClientH]->m_dwAFKCheckTime = timeGetTime();

	if (m_iTotalClients > DEF_MAXONESERVERUSERS) {
		switch (iDice(1,2)) {
			case 1: 
				RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1); break;
			case 2: 
				switch (m_pClientList[iClientH]->m_cSide) {
				case 0: RequestTeleportHandler(iClientH, "2   ", "resurr1", -1, -1); break;
				case 1: RequestTeleportHandler(iClientH, "2   ", "resurr1", -1, -1); break;
				case 2: RequestTeleportHandler(iClientH, "2   ", "resurr2", -1, -1); break;
			}
			break;
		}
	}

	return;
}


void CGame::AdminOrder_SummonGuild(int iClientH, char *pData, DWORD dwMsgSize)
{char   seps[] = "= \t\n";
 char   * token, * cp, cBuff[256], cMapName[11];
 char cGuildName[20];
 WORD   *wp;
 int    pX, pY, i;
 class  CStrTok * pStrTok;
 DWORD  dwGoldCount;

	if (m_pClientList[iClientH] == NULL) return;
    if ((dwMsgSize) <= 0) return;
    if (   (m_pClientList[iClientH]->m_iAdminUserLevel < 4)
		&& (m_pClientList[iClientH]->m_iAdminUserLevel != 0))
    {	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
    }
    if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) // Check if gm:
    {	if (m_pClientList[iClientH]->m_iGuildRank != 0) return; 
		dwGoldCount = dwGetItemCount(iClientH, "Gold");  // dwGoldCount = player gold
		if (m_iSummonGuildCost > dwGoldCount)
		{	return;
		}else // if summonguildcost is less than player gold
		{	SetItemCount(iClientH, "Gold", dwGoldCount - m_iSummonGuildCost); // reduce gold by summonguildcost   
		}
	}else
    {	
    }
    ZeroMemory(cBuff, sizeof(cBuff));
    memcpy(cBuff, pData, dwMsgSize);
    pStrTok = new class CStrTok(cBuff, seps);
    token = pStrTok->pGet();
    token = pStrTok->pGet();
    if (token == NULL)
    {	delete pStrTok;
		return;
    }
    pX = m_pClientList[iClientH]->m_sX;
    pY = m_pClientList[iClientH]->m_sY;
    ZeroMemory(cMapName, sizeof(cMapName));
    memcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);
    ZeroMemory(cGuildName, sizeof(cGuildName));
    if (strlen(token) > 20)
		 memcpy(cGuildName, token, 20);
    else memcpy(cGuildName, token, strlen(token));
    for (i = 0; i < DEF_MAXCLIENTS; i++)
    if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cGuildName, token) == 0))
	{	wsprintf(G_cTxt,"PC(%s) summoned by Guild(%s) to %s.", m_pClientList[i]->m_cCharName, cGuildName, cMapName);
		PutLogList(G_cTxt);
		RequestTeleportHandler(i, "2   ", cMapName, pX, pY); 
	}
    wsprintf(G_cTxt,"Guild(%s) summoned by PC(%s) to %s.", cGuildName, m_pClientList[iClientH]->m_cCharName, cMapName);
    PutLogList(G_cTxt);
    ZeroMemory(cBuff, sizeof(cBuff));
    cp = (char *)cBuff;
    *cp = GSM_REQUEST_SUMMONGUILD;
    cp++;
    memcpy(cp, cGuildName, 20);
    cp += 20;
    memcpy(cp, cMapName, 10);
    cp += 10;
    wp = (WORD *)cp;
    *wp = m_pClientList[iClientH]->m_sX;
    cp += 2;
    wp = (WORD *)cp;
    *wp = m_pClientList[iClientH]->m_sY;
    cp += 2;
    bStockMsgToGateServer(cBuff, 35);
    delete pStrTok;
} 

void CGame::AdminOrder_BanIP(int iClientH, char *pData, DWORD dwMsgSize)
{
 char seps[] = "= ";
 char * token, cBuff[256];
 class CStrTok * pStrTok;
 char * pk;
 char cNick[20], cIPtoBan[21];
 int i;
 FILE * pFile;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize) <= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel <= 3) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token == NULL) {
		delete pStrTok;
		return;
	}
	strcpy(cNick, token);
	pk = pStrTok->pGet();

	ZeroMemory(cIPtoBan, sizeof(cIPtoBan));

	for (i = 0; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cNick, strlen(cNick)) == 0)) {
			strcpy(cIPtoBan, m_pClientList[i]->m_cIPaddress);
			//opens cfg file
			pFile = fopen("..\\GameConfigs\\BannedList.cfg", "a");
			//shows log
			wsprintf(G_cTxt,"<%d> Client IP Banned: (%s)", i, cIPtoBan);
			PutLogList(G_cTxt);
				//modifys cfg file
				fprintf(pFile, "banned-ip = %s", cIPtoBan);
				fprintf(pFile, "\n");
				fclose(pFile);
			//updates BannedList.cfg on the server
			LocalUpdateConfigs(3);
			//disconnects player, and he can't connect again.. :)
			DeleteClient(i, TRUE, TRUE);
			return;
		}
	}
	delete pStrTok;
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         OpenCloseApocalypseGate 
//         Called by ::ForceOpen_ApocalypseGate, ::ForceClose_ApocalypseGate
//         Called by ::LocalStartApocalypse
//         Check if Gates's needs to be openned or closed 
//		   then notify any change to all clients.on current server
//		   NB: Opens/closes only type 1 Gates
//**************************************************************************************
void CGame::OpenCloseApocalypseGate()
{	DWORD  dwTime = timeGetTime();
	BOOL bIsOpen = m_bIsApocalypseGateOpen;	
	if (   (dwTime >= m_dwApocalypseGateOpenTime)
		&& (dwTime < m_dwApocalypseGateCloseTime))
	{	m_bIsApocalypseGateOpen	= TRUE;
	}else
	{	m_bIsApocalypseGateOpen	= FALSE;
	}
	// If nothing has changed return...
	if (bIsOpen == m_bIsApocalypseGateOpen) return;

	if (m_bIsApocalypseGateOpen	== TRUE) 
	{	wsprintf(G_cTxt,"(!)Apocalypse Gate opened.");
	}else
	{	wsprintf(G_cTxt,"(!)Apocalypse Gate closed.");
	}
	PutLogList(G_cTxt);	
	PutLogEventFileList(G_cTxt);
	// Then notify all clients of change,
 int i;		
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL)
		{	Notify_ApocalypseGateState(i);
		}	
	}
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions: (used also for Admin Gate)
//         Notify_ApocalypseGateState 
//         Called by ::RequestInitDataHandler (when client log in)
//         Called by ::RequestTeleportHandler (when client changes map on same server)
//         Called by ::OpenCloseApocalypseGate (when Gate is openned or closed)
//         Notify the client of Gate's state, needed to show in player's screen
//**************************************************************************************
void CGame::Notify_ApocalypseGateState(int iClientH)
{	if (iClientH <= 0)	return;
	if (m_pClientList[iClientH] <= 0)	return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	int iMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	int gX, gY;
	switch (m_pMapList[iMapIndex]->m_cDynamicGateType){
	case 0:	// No gate on current map		
		if (m_bIsApocalypseMode == FALSE) break;
		if(m_bIsApocalypseGateOpen == TRUE) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEOPEN, 0, 0, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);
		}else
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATECLOSE, 0, 0, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEENDMSG, NULL, NULL, NULL, NULL);
		}
		break;
	case 1:	// Initial Dynamic gates (toh, IB, D4...)
		if (m_bIsApocalypseMode == FALSE) break;
		gX = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2)/2;
		gY = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2)/2;
		if(m_bIsApocalypseGateOpen == TRUE) 
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEOPEN, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);
		}else
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATECLOSE, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEENDMSG, NULL, NULL, NULL, NULL);
		}
		break;
	case 2: // Empty maps Dynamic gates (inferniaA, inferniaB, procella...)
		if (m_bIsApocalypseMode == FALSE) break;
		gX = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2)/2;
		gY = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2)/2;
		if (m_pMapList[iMapIndex]->m_iTotalActiveObject == 0)
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEOPEN, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);
		}else
		{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATECLOSE, gX, gY , NULL, m_pClientList[iClientH]->m_cMapName);
		}
		break;
	case 3: // Hide the n3 gates ..
		if (m_bIsApocalypseMode == FALSE) break;
		gX = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2)/2;
		gY = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2)/2;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATECLOSE, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
		break;	
	case 4: // Show the gate on abaddon map..when Abaddon spawning.
		if (m_bIsApocalypseMode == FALSE) break;
		gX = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2)/2;
		gY = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2)/2;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEOPEN, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);
		break;
	case 5:	// GM command Dynamic gates (even not in apocalypse mode)
		gX = m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 + 1;
		gY = m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 + 1;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEOPEN, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
		break;
	}
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions: (used also for Admin Gate)
//         Use_ApocalypseGate 
//         Called by ::CheckClientResponseTime()
//         Test if client uses Dynamic Gate, then TP him. used as well out of apoc mode (gate 5)
//**************************************************************************************
void CGame::Use_ApocalypseGate(int iClientH)
{	if (iClientH <= 0)	return;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	int iMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	switch(m_pMapList[iMapIndex]->m_cDynamicGateType) {
	case 0: // No Dynamic Gate on this map
		return; break;
	case 1: // Apocalypse normal gate
		if (m_bIsApocalypseMode == FALSE)		return;
		if (m_bIsApocalypseGateOpen == FALSE)	return; 
		break;
	case 2: // Apocalypse gate opened when map empty
		if (m_bIsApocalypseMode == FALSE)		return;
		if (m_pMapList[iMapIndex]->m_iTotalActiveObject != 0) return; 
		break;
	case 3: // Apocalypse gate still closed
		return; break;
	case 4: // Apocalypse gate opened when Abaddon spawned.
		if (m_bIsApocalypseMode == FALSE)		return;
		break;
	case 5: // Admin created gate
		break;
	}
	if (   (m_pClientList[iClientH]->m_sX >= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1)
		&& (m_pClientList[iClientH]->m_sX <= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2)
		&& (m_pClientList[iClientH]->m_sY >= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1)
		&& (m_pClientList[iClientH]->m_sY <= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2))
	{	RequestTeleportHandler(iClientH, "2   "
								, m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap
								, m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtX
								, m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtY);	
	}
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         Open_EmptyMap_Gate 
//		   Called by ::DeleteNpc when last npc killed on map disapears
//         Show just-openned gates to the client
//**************************************************************************************
void CGame::Open_EmptyMap_Gate(int MapIndex)
{	if (m_pMapList[MapIndex]->m_cDynamicGateType < 2 )	return; 
	
 int i;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	{	if (m_pClientList[i] == NULL) continue;
		if (m_pClientList[i]->m_cMapIndex != MapIndex) continue;
		Notify_ApocalypseGateState(i);		
	} 
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         GenerateApocalypseBoss 
//		   Called by ::NpcKilledHandler
//         Creates the appropriate npc depending on map definition file
//         then change the Dynamic Gate type from 3 to 4 (to open it)
//**************************************************************************************
void CGame::GenerateApocalypseBoss(int MapIndex)
{	if (m_pMapList[MapIndex]->m_iTotalActiveObject != 0) return;
	char cName[21], cNpcName[21], cNpcWaypoint[11];	
	int x, i5;
	int iNamingValue;
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

	iNamingValue = m_pMapList[MapIndex]->iGetEmptyNamingValue();
	if (iNamingValue == -1) 
	{}else 
	{	ZeroMemory(cNpcName, sizeof(cNpcName));
		switch (m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID) {
		case 0: break;
		case 49: strcpy(cNpcName, "Hellclaw");break;
		case 50: strcpy(cNpcName, "Tigerworm");break;	
		case 66: strcpy(cNpcName, "Wyvern");break;	
		case 73: strcpy(cNpcName, "Fire-Wyvern");break;	
		case 81: strcpy(cNpcName, "Abaddon");break;	
		default: strcpy(cNpcName, "Demon");break;	
		}
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = MapIndex+65;	
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[MapIndex]->m_cName, 0, 0
			, DEF_MOVETYPE_RANDOMAREA, NULL, NULL, cNpcWaypoint, &m_pMapList[MapIndex]->m_sApocalypseBossMobRect, NULL, -1, FALSE, FALSE, FALSE, TRUE) == FALSE) 
		{	m_pMapList[MapIndex]->SetNamingValueEmpty(iNamingValue);
		}else 
		{	wsprintf(G_cTxt, "%s has spawned in %s"
				, cNpcName
				, m_pMapList[MapIndex]->m_cName);
			PutLogList(G_cTxt);	
			PutLogFileList(G_cTxt);	
			PutLogEventFileList(G_cTxt);			
		}
		// Search npc ID
		for (i5 = 1; i5 < DEF_MAXNPCS; i5++)
		{	if ((m_pNpcList[i5] != NULL) && (memcmp(m_pNpcList[i5]->m_cName, cName, 5) == 0) ) 
			{	break;
		}	}
		// Show Spawns on minimap, and tell everybody on Apocalypse server.					
		DWORD wX = m_pNpcList[i5]->m_sX;
		DWORD wY = m_pNpcList[i5]->m_sX;
		for (x = 1; x < DEF_MAXCLIENTS; x++)
		if (   (m_pClientList[x] != NULL) 
			&& (m_pClientList[x]->m_bIsInitComplete == TRUE))
		{	if(memcmp(m_pMapList[MapIndex]->m_cName, m_pMapList[m_pClientList[x]->m_cMapIndex]->m_cName, strlen(m_pMapList[MapIndex]->m_cName)) == 0)
			{	SendNotifyMsg(NULL, x, DEF_NOTIFY_SPAWNEVENT, wX, wY, m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID, NULL, NULL, NULL);
			}
			// Tell everybody on this server if Abaddon has appeared
			if (m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID == 81) 
			{	char cInfoString[100];
				ZeroMemory(cInfoString,  sizeof(cInfoString));
				wsprintf(cInfoString, "Abbadon has appeared ...");
				SendNotifyMsg(NULL, x, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		}	}

		// Prepare Abaddon's death, and Apocalypse end.
		if (m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID == 81)
		{	// Abaddon should die by himself		
			DWORD dwTime = timeGetTime();
			dwTime += 1000*60*5; // 5 minute
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_KILL_ABADDON, 0, dwTime, i5
						, DEF_OWNERTYPE_NPC, MapIndex, 0, 0, 0, 0, 0);
			dwTime = timeGetTime();
			dwTime += 1000*60*15; // 15 minutes
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_END_APOCALYPSE, 0, dwTime, 0
						, 0, MapIndex, 0, 0, 0, 0, 0);
		}
		// Finally open the Exit Gate if type 3 & not 2
		// NB: if m_iApocalypseMobGenType 2 with GateType 2, need to Kill the boss to open the gate.
		if (m_pMapList[MapIndex]->m_cDynamicGateType == 3 )
		{	m_pMapList[MapIndex]->m_cDynamicGateType = 4;
			Open_EmptyMap_Gate(MapIndex);
	}	}
}
//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         GenerateSlime 
//         Generate a npc now to close the gate
//**************************************************************************************
void CGame::GenerateSlime(int MapIndex)
{	if (m_pMapList[MapIndex]->m_iTotalActiveObject != 0) return;
	char cName[21], cNpcName[21], cNpcWaypoint[11];	
	int iNamingValue;
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

	iNamingValue = m_pMapList[MapIndex]->iGetEmptyNamingValue();
	if (iNamingValue == -1) 
	{}else 
	{	strcpy(cNpcName, "Slime");
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = MapIndex+65;							
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[MapIndex]->m_cName, 0, 0
			, DEF_MOVETYPE_RANDOMAREA, NULL, NULL, cNpcWaypoint, &m_pMapList[MapIndex]->m_sApocalypseBossMobRect, NULL, NULL, FALSE, FALSE, FALSE, TRUE) == FALSE) 
		{	m_pMapList[MapIndex]->SetNamingValueEmpty(iNamingValue);
	}	}
}

//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         ForceOpen_ApocalypseGate 
//         Local execution off a global GM command to force open the gate
//			Beware this will affect only current server
//**************************************************************************************
void CGame::ForceOpen_ApocalypseGate()
{	if (m_bIsApocalypseMode == FALSE)	return;	
	DWORD  dwTime = timeGetTime();
	m_dwApocalypseGateOpenTime = dwTime;
	m_dwApocalypseGateCloseTime = dwTime +15*60*1000; // will close in 15 minutes
	OpenCloseApocalypseGate();
}
//**************************************************************************************
// SNOOPY: Revamped Apocalypse functions:
//         ForceClose_ApocalypseGate 
//         GM command to force open the gate
//         Beware this will affect only current server
//**************************************************************************************
void CGame::ForceClose_ApocalypseGate()
{	if (m_bIsApocalypseMode == FALSE)	return;	
	DWORD  dwTime = timeGetTime();
	m_dwApocalypseGateCloseTime = dwTime -1;
	m_dwApocalypseGateOpenTime = dwTime -100; // alreaddy closed
	OpenCloseApocalypseGate();
}


void CGame::AdminOrder_BanPj(int iClientH, char* pData, DWORD dwMsgSize) // MORLA 2.12 - Morlear PJ
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cPlayerName[11];
	class  CStrTok * pStrTok;


	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) return;

	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token == NULL) {
		delete pStrTok;
		return;
	}

	if (strlen(token) > 10) {
		memcpy(cPlayerName, token, 10);
	}
	else{
		memcpy(cPlayerName, token, strlen(token));
	}

	for(int i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL) {
			if (memcmp(cPlayerName, m_pClientList[i]->m_cCharName, 10) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
					wsprintf(cBuff,"GM Order(%s): Ban Player (%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);					
					SendNotifyMsg(NULL, i, DEF_NOTIFY_MORLEARPJ, NULL, NULL, NULL, NULL); 
				}
				delete pStrTok;
				return;
			}
		}
	}
	delete pStrTok;
}

//50Cent - Repair All
void CGame::RequestRepairAllItemsHandler(int iClientH)
{
    int i, price;
    double d1, d2, d3;
    if (m_pClientList[iClientH] == NULL) return;
    if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

    m_pClientList[iClientH]->totalItemRepair = 0;

    for(i = 0; i < DEF_MAXITEMS; i++)
        if(m_pClientList[iClientH]->m_pItemList[i] != NULL)
            if(((m_pClientList[iClientH]->m_pItemList[i]->m_cCategory >= 1) && (m_pClientList[iClientH]->m_pItemList[i]->m_cCategory <= 12)) ||
               ((m_pClientList[iClientH]->m_pItemList[i]->m_cCategory >= 43) && (m_pClientList[iClientH]->m_pItemList[i]->m_cCategory <= 50)))
            {
                if(m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan == m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan)
                    continue;
                if(m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan == 0)
                    price = (m_pClientList[iClientH]->m_pItemList[i]->m_wPrice / 2);
                else
                {
                    d1 = (double)(m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan);
                    if(m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan != 0)
                        d2 = (double)(m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan);
                    else
                        d2 = 1.0f;
                    d3 = ((d1 / d2) * 0.5f);
                    d2 = (double)(m_pClientList[iClientH]->m_pItemList[i]->m_wPrice);
                    d3 = (d3 * d2);
                    price = ((m_pClientList[iClientH]->m_pItemList[i]->m_wPrice / 2) - (short)(d3));
                }
                m_pClientList[iClientH]->m_stRepairAll[m_pClientList[iClientH]->totalItemRepair].index = i;
                m_pClientList[iClientH]->m_stRepairAll[m_pClientList[iClientH]->totalItemRepair].price = price;
                m_pClientList[iClientH]->totalItemRepair++;
            }
    SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPAIRALLPRICES, NULL, NULL, NULL, NULL);
}

void CGame::RequestRepairAllItemsDeleteHandler(int iClientH, int index)
{
    int i;
    if (m_pClientList[iClientH] == NULL) return;
    if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

    for(i = index; i < m_pClientList[iClientH]->totalItemRepair; i++)
        m_pClientList[iClientH]->m_stRepairAll[i] = m_pClientList[iClientH]->m_stRepairAll[i + 1];
    m_pClientList[iClientH]->totalItemRepair--;
    SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPAIRALLPRICES, NULL, NULL, NULL, NULL);
}

void CGame::RequestRepairAllItemsConfirmHandler(int iClientH)
{
 char   * cp, cData[120];
 DWORD  * dwp;
 WORD   * wp;
 int      iRet, i, totalPrice = 0;

    if (m_pClientList[iClientH] == NULL) return;
    if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
    if (m_pClientList[iClientH]->m_pIsProcessingAllowed == FALSE) return;

    for(i = 0; i < m_pClientList[iClientH]->totalItemRepair; i++)
        totalPrice += m_pClientList[iClientH]->m_stRepairAll[i].price;

    if(dwGetItemCount(iClientH, "Gold") < (DWORD)totalPrice)
    {
        dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
        *dwp = MSGID_NOTIFY;
        wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
        *wp  = DEF_NOTIFY_NOTENOUGHGOLD;
        cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
        *cp  = 0;
        cp++;
        
        iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
        switch (iRet) {
        case DEF_XSOCKEVENT_QUENEFULL:
        case DEF_XSOCKEVENT_SOCKETERROR:
        case DEF_XSOCKEVENT_CRITICALERROR:
        case DEF_XSOCKEVENT_SOCKETCLOSED:
            DeleteClient(iClientH, TRUE, TRUE);
            return;
        }
        return;
    }
    else
    {
        for(i = 0; i < m_pClientList[iClientH]->totalItemRepair; i++)
        {
            m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_stRepairAll[i].index]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_stRepairAll[i].index]->m_wMaxLifeSpan;
             SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMREPAIRED, m_pClientList[iClientH]->m_stRepairAll[i].index, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_stRepairAll[i].index]->m_wCurLifeSpan, NULL, NULL);
        }
        iCalcTotalWeight(SetItemCount(iClientH, "Gold", dwGetItemCount(iClientH, "Gold") - totalPrice));
        m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += totalPrice;
    }
}


// MORLA 2.4 - Trade Items
void CGame::RequestPurchaseItemHandler2(int iClientH, char * pItemName, int iNum)
{
 class CItem * pItem;
 char  * cp, cItemName[21], cData[100];
 short * sp;
 DWORD * dwp, dwItemCount;
 WORD  * wp, wTempPrice;
 int   i, iRet, iEraseReq;
 int iEKCost = 0, iDPCost = 0;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) {
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) ||
				(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)) {

			}
			else return;
		}

		if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) ||
				(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 7) == 0)) {

			}
			else return;
		}
	}
	
	ZeroMemory(cData, sizeof(cData));	
	ZeroMemory(cItemName, sizeof(cItemName));
	// MORLA 2.5 - Trade items x EKs
	if (memcmp(pItemName, "XelimaBlade", 11) == 0) { iDPCost = 0; iEKCost = 3500; }
	if (memcmp(pItemName, "XelimaAxe", 9) == 0) { iDPCost = 0; iEKCost = 4500; }
	if (memcmp(pItemName, "XelimaRapier", 12) == 0) { iDPCost = 0; iEKCost = 2000; }
	if (memcmp(pItemName, "KlonessBlade", 12) == 0) { iDPCost = 0; iEKCost = 3500; }
	if (memcmp(pItemName, "KlonessAxe", 10) == 0) { iDPCost = 0; iEKCost = 3500; }
	if (memcmp(pItemName, "KlonessEsterk", 13) == 0) { iDPCost = 0; iEKCost = 3000; }
	if (memcmp(pItemName, "BerserkWand(MS.20)", 18) == 0) { iDPCost = 0; iEKCost = 4500; }
	if (memcmp(pItemName, "KlonessWand(MS.20)", 18) == 0) { iDPCost = 0; iEKCost = 2000; }
	if (memcmp(pItemName, "ResurWand(MS.20)", 16) == 0) { iDPCost = 0; iEKCost = 2000; }
	if (memcmp(pItemName, "I.M.CManual", 11) == 0) { iDPCost = 0; iEKCost = 3000; }
	if (memcmp(pItemName, "MerienShield", 12) == 0) { iDPCost = 0; iEKCost = 6000; }
	if (memcmp(pItemName, "MerienPlateMailM", 16) == 0) { iDPCost = 0; iEKCost = 4000; }
	if (memcmp(pItemName, "MerienPlateMailW", 16) == 0) { iDPCost = 0; iEKCost = 4000; }
	if (memcmp(pItemName, "SwordofMedusa", 13) == 0) { iDPCost = 0; iEKCost = 5000; }
	if (memcmp(pItemName, "DemonSlayer", 11) == 0) { iDPCost = 0; iEKCost = 1000; }
	if (memcmp(pItemName, "DarkElfBow", 10) == 0) { iDPCost = 0; iEKCost = 500; }
	if (memcmp(pItemName, "GiantBattleHammer", 17) == 0) { iDPCost = 0; iEKCost = 6000; }
	if (memcmp(pItemName, "StormBringer", 12) == 0) { iDPCost = 0; iEKCost = 4000; }
	if (memcmp(pItemName, "DarkExecutor", 12) == 0) { iDPCost = 0; iEKCost = 4500; }
	if (memcmp(pItemName, "LightingBlade", 13) == 0) { iDPCost = 0; iEKCost = 4500; }
	if (memcmp(pItemName, "RingoftheAbaddon", 16) == 0) { iDPCost = 0; iEKCost = 2500; }
	if (memcmp(pItemName, "RingofArcmage", 13) == 0) { iDPCost = 0; iEKCost = 2500; }
	if (memcmp(pItemName, "NecklaceOfMerien", 16) == 0) { iDPCost = 0; iEKCost = 4000; }
	if (memcmp(pItemName, "NecklaceOfXelima", 16) == 0) { iDPCost = 0; iEKCost = 4000; }
	if (memcmp(pItemName, "KnecklaceOfMedusa", 17) == 0) { iDPCost = 0; iEKCost = 5000; }
	if (memcmp(pItemName, "KnecklaceOfIceEle", 17) == 0) { iDPCost = 0; iEKCost = 2000; }
	if (memcmp(pItemName, "HeroNeckMage(MD+35)", 19) == 0) { iDPCost = 0; iEKCost = 4000; }
	if (memcmp(pItemName, "HeroNeckWar(DM+35)", 18) == 0) { iDPCost = 0; iEKCost = 4000; }
	if (memcmp(pItemName, "RingofHeroMage", 14) == 0) { iDPCost = 0; iEKCost = 4000; }
	if (memcmp(pItemName, "RingOfHeroWar", 13) == 0) { iDPCost = 0; iEKCost = 4000; }
	if (memcmp(pItemName, "HeroWand", 8) == 0) { iDPCost = 0; iEKCost = 4000; }

	// MORLA 2.5 - Trade items x DeathMach Points
	if (memcmp(pItemName, "ZemstoneofSacrifice", 19) == 0) { iDPCost = 3; iEKCost = 0; }
	if (memcmp(pItemName, "StoneOfXelima", 13) == 0) { iDPCost = 4; iEKCost = 0; }
	if (memcmp(pItemName, "StoneOfMerien", 13) == 0) { iDPCost = 4; iEKCost = 0; }
	if (memcmp(pItemName, "RingofDemonpower", 16) == 0) { iDPCost = 10; iEKCost = 0; }
	if (memcmp(pItemName, "RingofGrandMage", 15) == 0) { iDPCost = 10; iEKCost = 0; }
	if (memcmp(pItemName, "MagicWand(MS30-LLF)", 18) == 0) { iDPCost = 12; iEKCost = 0; }
	if (memcmp(pItemName, "HuntSword", 9) == 0) { iDPCost = 100; iEKCost = 0; }
	if (memcmp(pItemName, "GladeitorHauberk", 16) == 0) { iDPCost = 50; iEKCost = 0; }
	if (memcmp(pItemName, "GladeitorBerkW", 14) == 0) { iDPCost = 50; iEKCost = 0; }
	if (memcmp(pItemName, "GladeitorHelmM", 14) == 0) { iDPCost = 60; iEKCost = 0; }
	if (memcmp(pItemName, "GladeitorHelmW", 14) == 0) { iDPCost = 60; iEKCost = 0; }
	if (memcmp(pItemName, "GladeitorHatM", 13) == 0) { iDPCost = 30; iEKCost = 0; }
	if (memcmp(pItemName, "GladeitorHatW", 13) == 0) { iDPCost = 30; iEKCost = 0; }
	if (memcmp(pItemName, "GladeitorLeggs", 14) == 0) { iDPCost = 60; iEKCost = 0; }
	if (memcmp(pItemName, "GladeitorLeggsW", 15) == 0) { iDPCost = 60; iEKCost = 0; }
	if (memcmp(pItemName, "GladeitorMailM", 14) == 0) { iDPCost = 70; iEKCost = 0; }
	if (memcmp(pItemName, "GladeitorMailW", 14) == 0) { iDPCost = 70; iEKCost = 0; }
	if (memcmp(pItemName, "GladeitorAxe", 12) == 0) { iDPCost = 80; iEKCost = 0; }
	if (memcmp(pItemName, "GladeitorWandMS70", 17) == 0) { iDPCost = 40; iEKCost = 0; }

	if ((m_pClientList[iClientH]->m_iEnemyKillCount < iEKCost)
		|| (m_pClientList[iClientH]->m_iDGPoints < iDPCost)) return;
	
	if ((iDPCost == 0) && (iEKCost == 0)) return;

		memcpy(cItemName, pItemName, 20);
		dwItemCount = 1;

	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			delete pItem;
		}
		else {
			
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMTRADE;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0;
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;
				
				wp  = (WORD *)cp;
				*wp = iEKCost;
				wTempPrice = iEKCost;
				cp += 2;
				
				if (iEraseReq == 1) delete pItem;

				
				m_pClientList[iClientH]->m_iEnemyKillCount -= iEKCost;
				m_pClientList[iClientH]->m_iDGPoints -= iDPCost;
			    SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL); 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPDGDEATHS, m_pClientList[iClientH]->m_iDGPoints, m_pClientList[iClientH]->m_iDeaths, m_pClientList[iClientH]->m_iRating, NULL);
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
				
				iCalcTotalWeight(iClientH);
					
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
			else 
			{
				delete pItem;

				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
 	}
}

//New Party Status - ZeroEoyPnk - 06/09/2010
void CGame::RefreshPartyStatus(int iClientH)
{
	int i, HPParty, NotifyClient, PartyId, x, MaxHpParty, TotalMembers, PartySex;

	NotifyClient = 0;
	HPParty = 0;
	PartySex = 0;
	MaxHpParty = 0;
	TotalMembers = 0;
	x = 0;

	if (m_pClientList[iClientH] == NULL) return;

	if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) 
	{
		HPParty = m_pClientList[iClientH]->m_iHP;
		MaxHpParty = iGetMaxHP(iClientH, FALSE);
		PartySex = m_pClientList[iClientH]->m_cSex;
		TotalMembers = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers;
		for(i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++)
		{
			x++;
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				PartyId = x;
			}
		}
		for(i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++)
		{
			NotifyClient = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
			if (m_pClientList[NotifyClient] != NULL) 
			{
				SendNotifyMsg(NULL, NotifyClient, DEF_SEND_PARTYHP, PartyId, HPParty, MaxHpParty, NULL, PartySex);
			}
		}
	}
}

void CGame::RefreshPartyCoords(int iClientH)
{
	int i, x, Party_sX, Party_sY, NotifyClient, PartyId, TotalMembers;
	char MapName[12];
	if (m_pClientList[iClientH] == NULL) return;

	NotifyClient = 0;
	PartyId = 0;
	Party_sX = 0;
	Party_sY = 0;
	x = 0;

	if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) 
	{
		Party_sX = m_pClientList[iClientH]->m_sX;
		Party_sY = m_pClientList[iClientH]->m_sY;
		ZeroMemory(MapName, sizeof(MapName));
		strcpy(MapName, m_pClientList[iClientH]->m_cMapName);
		TotalMembers = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers;
		for(i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++)
		{
			x++;
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				PartyId = x;
			}
		}
		for(i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++)
		{
			NotifyClient = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
			if (m_pClientList[NotifyClient] != NULL) 
			{
				SendNotifyMsg(NULL, NotifyClient, DEF_SEND_PARTYCOORDS, PartyId, Party_sX, Party_sY, MapName, NULL, NULL);
			}
		}
	}
}

void CGame::PlayerOrder_ChangeCity(int iClientH, BOOL bChange) 
{
	if (m_pClientList[iClientH] == NULL) return;  
	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft >= 1000) {
		if (bChange == TRUE) { 
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0 ||
				memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) { 
				strcpy(m_pClientList[iClientH]->m_cLocation, "NONE"); 
				m_pClientList[iClientH]->m_bIsPlayerCivil = FALSE;
				ShowClientMsg(iClientH, " Now you're a Traveller.");
			}

			if (memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) {
				ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
				strcpy(m_pClientList[iClientH]->m_cGuildName, "NONE");
				m_pClientList[iClientH]->m_iGuildRank = -1;
				m_pClientList[iClientH]->m_iGuildGUID = -1;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GUILDDISBANDED, NULL, NULL, NULL, m_pClientList[iClientH]->m_cGuildName);
			}

			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 1000;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CHANGEPLAYMODE, NULL, NULL, NULL, m_pClientList[iClientH]->m_cLocation);
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, m_pClientList[iClientH]->m_iLevel, NULL, NULL, NULL);
		}
		else if (bChange == FALSE) return;
	}
	else {
		ShowClientMsg(iClientH, " You don't have 1000 Majestic Points.");
		return;
	}
}

//dkset by diuude and update by drawjer and modified by Ovl
void CGame::GetDkSet(int iClientH) 
{
 class CItem * pItem;
 int dkM[] = {706,707,708,710};
 int dkW[] = {724,725,726,728};
 int dmM[] = {711,712,713,913};
 int dmW[] = {729,730,731,914};
 int weapon, iItemID, i, iEraseReq;
 DWORD  dwGoldCount = dwGetItemCount(iClientH, "Gold");
 
	if(m_pClientList[iClientH] == NULL) return;
	if(m_pClientList[iClientH]->m_iLevel < m_iPlayerMaxLevel) return;
	if (dwGoldCount < 500000) {
		ShowClientMsg(iClientH, " You don't have 500,000 Gold.");
		return; // centu - el dk set cuesta 500k
	}
	if (((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "cityhall_1") == 0) || (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "cityhall_2") == 0))) {
		for (i = 0; i <= 4; i++) 
		{
			pItem = new class CItem;
			iItemID = -1;
			if (m_pClientList[iClientH]->m_cSex == 1)
			{
				if (m_pClientList[iClientH]->m_iStr > m_pClientList[iClientH]->m_iInt)
				{
					iItemID = dkM[i];
				}
				else
				{
					iItemID = dmM[i];
				}
			}
			else
			{
				if (m_pClientList[iClientH]->m_iStr > m_pClientList[iClientH]->m_iInt)
				{
					iItemID = dkW[i];
				}
				else
				{
					iItemID = dmW[i];
				}
			}
			if (i == 4)
			{
				if (m_pClientList[iClientH]->m_iStr > m_pClientList[iClientH]->m_iInt)
				{ 
					if (m_pClientList[iClientH]->m_cSex == 1) 
					{
						weapon = 709;
					} 
					else if (m_pClientList[iClientH]->m_cSex == 2) 
					{
						weapon = 727;
					}
				}
				else
				{ 
					if (m_pClientList[iClientH]->m_cSex == 1) 
					{
						weapon = 714;
					} 
					else if (m_pClientList[iClientH]->m_cSex == 2) 
					{
						weapon = 732;
					}
				}
				iItemID = weapon;
			}
			SetItemCount(iClientH, "Gold", (dwGoldCount - 500000));
			if (iItemID != -1) //if any error occures, dont crash character
			{
				_bInitItemAttr(pItem, iItemID);
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				_bAddClientItemList(iClientH, pItem, &iEraseReq);
				SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, NULL);
			}
		}
	} 
} 


void CGame::AFKChecker()
{     int i;
    int sX, sY;
    DWORD dwTimeNow = timeGetTime();
    for (i = 1; i < DEF_MAXCLIENTS; i++)
    {    if (m_pClientList[i] != NULL)
        {    if (   (m_pClientList[i]->m_bIsInitComplete == TRUE)
                && ((dwTimeNow - m_pClientList[i]->m_dwAFKCheckTime) > 300000)
                && (m_pClientList[i]->m_iHP > 0)
                && ((m_pClientList[i]->m_iStatus & 0x00000010) == 0))
            {   sX = m_pClientList[i]->m_sX;
                if (m_pClientList[i]->m_bSkillUsingStatus[19] == TRUE)
                     sY = m_pClientList[i]->m_sY +1;                    
                else sY = m_pClientList[i]->m_sY;        
                SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[i]->m_cMapIndex
                    , sX, sY, sX, sY, 247, m_pClientList[i]->m_sType);
    }    }    }
}

/******************************************************************************************************************
***** void CGame::AdminOrder_Event(int iClientH, int iCode, char *pData, DWORD dwMsgSize)                     *****
*****---------------------------------------------------------------------------------------------------------*****
***** Crditos        :: By Centuu.-                                                                          *****    
***** Descripcin     :: Inicia un evento y activa el TP al mismo.                                            *****
******************************************************************************************************************/
void CGame::AdminOrder_Event(int iClientH, int iCode, char *pData, DWORD dwMsgSize)
{
 char   * token, cBuff[256], seps[] = "= \t\n", cMapName[11];
 class  CStrTok * pStrTok;
 int i;
    
    if (m_pClientList[iClientH] == NULL) return;
    if ((dwMsgSize)    <= 0) return;
    if (m_bIsHeldenianMode == TRUE) return;
    if (m_bIsApocalypseMode == TRUE) return;
    if (m_bIsCrusadeMode == TRUE) return;
    if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
        // Centuu : Slo los GMs pueden usar este comando.
        SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
        return;
    }
    ZeroMemory(cBuff, sizeof(cBuff));
    memcpy(cBuff, pData, dwMsgSize);
    pStrTok = new class CStrTok(cBuff, seps);
    token = pStrTok->pGet();
    token = pStrTok->pGet();
    switch (iCode) {
    case 1:
        if (token == NULL) return;
        strcpy(cEventMapName, token);
        ZeroMemory(cMapName, sizeof(cMapName));
        memcpy(cMapName, cEventMapName, 11);
        m_bIsEventEnabled = TRUE;
        m_bIsEventTPEnabled = TRUE;
        for (i = 1; i < DEF_MAXCLIENTS; i++) {
            if (m_pClientList[i] == NULL) return;
            SendNotifyMsg(NULL, i, DEF_NOTIFY_EVENTSTART, NULL, NULL, NULL, NULL);
        }
        break;
    case 2:
        m_bIsEventEnabled = FALSE;
        m_bIsEventTPEnabled = FALSE;
        for (i = 1; i < DEF_MAXCLIENTS; i++) {
            if (m_pClientList[i] == NULL) return;
            SendNotifyMsg(NULL, i, DEF_NOTIFY_EVENTEND, NULL, NULL, NULL, NULL);
        }
        break;
    case 3:
        m_bIsEventTPEnabled = FALSE;
        for (i = 1; i < DEF_MAXCLIENTS; i++) {
            if (m_pClientList[i] == NULL) return;
            SendNotifyMsg(NULL, i, DEF_NOTIFY_EVENTTPOFF, NULL, NULL, NULL, NULL);
        }
        break;
    }
    PutAdminLogFileList(G_cTxt);
    PutLogEventFileList(G_cTxt);
    PutLogList(G_cTxt);
    delete pStrTok;
}
/*****************************************************************************************************************
***** void CGame::EventTeleport(int iClientH)                                                                *****
*****--------------------------------------------------------------------------------------------------------*****
***** Crditos        :: By Centuu.-                                                                         *****
***** Descripcin     :: TP hacia determinado evento comenzado por el code de arriba.                        *****
*****************************************************************************************************************/
void CGame::EventTeleport(int iClientH)
{
    if (m_pClientList[iClientH] == NULL) return;
    if ((m_bIsEventEnabled == FALSE) || (m_bIsEventTPEnabled == FALSE)) {
        // Centuu : Si el evento no comenz el Tp no se puede utilizar.
        SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "Command deactivated.");
        return;
    }
    // Centuu : Mapa del evento.
    RequestTeleportHandler(iClientH, "2   ", cEventMapName, -1, -1);
}


// SNOOPY: reconnecting clients will recover summons 
void CGame::iRecoverFollowers(int  iClientH, BOOL bControlAll)
{	if (m_pClientList[iClientH] == NULL) return;
 int i, iTotal;
 char  cKillerMsg[128];	
	iTotal = 0;
	for (i = 1; i < DEF_MAXNPCS; i++) 
	if (   (m_pNpcList[i] != NULL) 
		&& (m_pNpcList[i]->m_cFollowOwnerType > 7)	// Reduce cases to process
		&& ((m_pNpcList[i]->m_bIsSummoned	  == TRUE) || (m_pNpcList[i]->m_dwTamingTime != 0))
		&& (m_pNpcList[i]->m_bIsKilled		  == FALSE))
	{	switch (m_pNpcList[i]->m_cFollowOwnerType) {
		case DEF_OWNERTYPE_PLAYER_FREE: // Anybody can take control
			if (   (bControlAll == TRUE)
				&& (m_pNpcList[i]->m_cSide == m_pClientList[iClientH]->m_cSide))
			{	m_pNpcList[i]->m_iFollowOwnerIndex	= iClientH;
				m_pNpcList[i]->m_cFollowOwnerType	= DEF_OWNERTYPE_PLAYER;
				m_pNpcList[i]->m_cMoveType			= DEF_MOVETYPE_FOLLOW;
				strcpy(m_pNpcList[i]->m_cFollowOwnerCharName, m_pClientList[iClientH]->m_cCharName);
				//Tell client				
				ZeroMemory(cKillerMsg, sizeof(cKillerMsg));		
				wsprintf(cKillerMsg, "A %s soldier accepted to follow you.",m_pNpcList[i]->m_cNpcName );
				ShowClientMsg(iClientH, cKillerMsg);
			}
			break;
		case DEF_OWNERTYPE_PLAYER_WAITING:
			if (strcmp(m_pNpcList[i]->m_cFollowOwnerCharName, m_pClientList[iClientH]->m_cCharName) == 0)
			{	m_pNpcList[i]->m_iFollowOwnerIndex	= iClientH;
				m_pNpcList[i]->m_cFollowOwnerType	= DEF_OWNERTYPE_PLAYER;
				m_pNpcList[i]->m_cMoveType			= DEF_MOVETYPE_FOLLOW;
				//Tell client				
				ZeroMemory(cKillerMsg, sizeof(cKillerMsg));	
				if ( (m_bIsHeldenianMode == TRUE)
					&& (m_pMapList[m_pNpcList[i]->m_cMapIndex] != NULL)
					&& (m_pMapList[m_pNpcList[i]->m_cMapIndex]->m_bIsHeldenianMap == 1))
				{	wsprintf(cKillerMsg, "Recovered control of a %s soldier.",m_pNpcList[i]->m_cNpcName );
					ShowClientMsg(iClientH, cKillerMsg);
				}else
				{	wsprintf(cKillerMsg, "Recovered control of a %s summon.",m_pNpcList[i]->m_cNpcName );
					ShowClientMsg(iClientH, cKillerMsg);
			}	}
			break;
	}	}
	return ;
}

void CGame::PlayerCommandAddMaster(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
 class  CStrTok * pStrTok;
 int i;

    if (m_pClientList[iClientH] == NULL) return;
    if ((dwMsgSize)    <= 0) return;

if (m_pClientList[iClientH]->m_iGuildRank != 0 ) {
        // ???? ??????? ?????* ?? ?????? ??????? ????.
        SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOGUILDMASTERLEVEL, NULL, NULL, NULL, NULL);
        return;
    }

    ZeroMemory(cName, sizeof(cName));
    ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
    ZeroMemory(cTargetName, sizeof(cTargetName));
    ZeroMemory(cNpcName, sizeof(cNpcName));
    ZeroMemory(cBuff, sizeof(cBuff));
    memcpy(cBuff, pData, dwMsgSize);

    pStrTok = new class CStrTok(cBuff, seps);
    token = pStrTok->pGet();
    token = pStrTok->pGet();
       
    if (token != NULL) {
        // token      
        if (strlen(token) > 10)
             memcpy(cTargetName, token, 10);
        else memcpy(cTargetName, token, strlen(token));
             
        for (i = 1; i < DEF_MAXCLIENTS; i++)
        if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
            //   .     
            
            if (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[i]->m_cGuildName, 20) != 0)  {
                // ????? ???????? ???? ?????? ????????.
                
                SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "Error: Cannot Add Master...");
                delete pStrTok;
                return;
            }
m_pClientList[i]->m_iGuildRank = 0;
SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "New Guild Master Added");
SendNotifyMsg(iClientH, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "You are Now a GuildMaster");

                }

            delete pStrTok;
            return;
        }

        //   .
        SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);

    delete pStrTok;
    return;
}

void CGame::PlayerOrder_DeleteGuildMaster(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
 class  CStrTok * pStrTok;
 int i;

    if (m_pClientList[iClientH] == NULL) return;
    if ((dwMsgSize)    <= 0) return;

if (m_pClientList[iClientH]->m_iGuildRank != 0 ) {
        // ???? ??????? ?????* ?? ?????? ??????? ????.
        SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOGUILDMASTERLEVEL, NULL, NULL, NULL, NULL);
        return;
    }

    ZeroMemory(cName, sizeof(cName));
    ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
    ZeroMemory(cTargetName, sizeof(cTargetName));
    ZeroMemory(cNpcName, sizeof(cNpcName));
    ZeroMemory(cBuff, sizeof(cBuff));
    memcpy(cBuff, pData, dwMsgSize);

    pStrTok = new class CStrTok(cBuff, seps);
    token = pStrTok->pGet();
    token = pStrTok->pGet();
       
    if (token != NULL) {
        // token??  ???? ????  ?? ??
        if (strlen(token) > 10)
             memcpy(cTargetName, token, 10);
        else memcpy(cTargetName, token, strlen(token));
             
        for (i = 1; i < DEF_MAXCLIENTS; i++)
        if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
            // ? ?? ???.     
            
            if (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[i]->m_cGuildName, 20) != 0)  {
                // ????? ???????? ???? ?????? ????????.
                
                SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "Error: Cannot Delete Master...");
                delete pStrTok;
                return;
            }
m_pClientList[i]->m_iGuildRank = 12;
SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "Guild Master Deleted");
SendNotifyMsg(iClientH, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "You are No longer a GuildMaster");

                }

            delete pStrTok;
            return;
        }

        // ?? ???? ??.
        SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);

    delete pStrTok;
    return;
}

// majestic log
BOOL CGame::bReadMajesticLogSettings() 
{ 
  FILE * pFile; 
  HANDLE hFile; 
  DWORD  dwFileSize; 
  char * cp, * token, cReadMode;
  char cFn[120]; 
  char seps[] = "= \t\n"; 
  class CStrTok * pStrTok; 

  cReadMode = 0; 

  strcpy (cFn,"..\\GameConfigs\\MajesticSettings.cfg");

  hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
  dwFileSize = GetFileSize(hFile, NULL); 
  if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile); 

  pFile = fopen(cFn, "rt"); 
  if (pFile == NULL) {  
     return FALSE; 
  } 
  else { 
     cp = new char[dwFileSize+2]; 
     ZeroMemory(cp, dwFileSize+2); 
     fread(cp, dwFileSize, 1, pFile); 

     pStrTok = new class CStrTok(cp, seps); 
     token = pStrTok->pGet(); 
     while( token != NULL )   { 

        if (cReadMode != 0) { 
           switch (cReadMode) { 

           case 1: 
              if ((strlen(token) != 0) && (strlen(token) <= 10000) && (strlen(token) >= 1)) 
               { 
                  m_iMaxGizonItem = atoi(token); 
               } 
				cReadMode = 0;
				break; 

           
		   case 3:
			   
				if ((strlen(token) != 0) && (strlen(token) <= 10000) && (strlen(token) >= 1)) 
               { 
                  m_iMaxGizonPerLevel = atoi(token); 
               } 
              cReadMode = 0;
			   break;
             }
        } 
        else { 
           if (memcmp(token, "max-gizon-item"  , 14) == 0)   cReadMode = 1;
           if (memcmp(token, "max-gizon-item-per-level", 24) == 0)   cReadMode = 3;
        } 

        token = pStrTok->pGet(); 
    } 

     delete pStrTok; 
     delete cp; 
  } 
  if (pFile != NULL) fclose(pFile); 

  PutLogList("(!) Loaded Majestic Log Config");

  return TRUE; 
}  

BOOL CGame::CheckDenialServiceAttack(int iClientH, DWORD dwClientTime)
{	DWORD dwTime = timeGetTime();
	if (m_pClientList[iClientH] == NULL) return FALSE; 
	// Find a Denial of service attack by packet sent time
	if (m_pClientList[iClientH]->m_dwDSLAT == 0)
		// Start with 1st msg
	{	m_pClientList[iClientH]->m_dwDSLAT		= dwClientTime;
		m_pClientList[iClientH]->m_dwDSLATOld	= dwClientTime;
		m_pClientList[iClientH]->m_dwDSLATS		= dwTime;
		m_pClientList[iClientH]->m_iDSCount		= 0;
	}else 
	{	if (dwClientTime >= m_pClientList[iClientH]->m_dwDSLAT)
			// current message was sent later than previous (normal case)
		{	m_pClientList[iClientH]->m_dwDSLAT = dwClientTime;
		}else
			// current message was sent before previous
		{	if (m_pClientList[iClientH]->m_dwDSLATOld == dwClientTime)
				// If we receive more late msg with same time
			{	m_pClientList[iClientH]->m_iDSCount++;
				if (((dwTime - m_pClientList[iClientH]->m_dwDSLATS) > 10*1000) && (m_pClientList[iClientH]->m_iDSCount > 5))
					// Receiving a "late" msg more than 10 sec after !
					// This is an attack!
				{	wsprintf(G_cTxt, "DS check: PC(%s) - Denial of service attack! (Disc.) \tIP(%s)"
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cIPaddress);
					DeleteClient(iClientH, TRUE, TRUE);
					PutHackLogFileList(G_cTxt);
					PutLogList(G_cTxt);
					return FALSE;
				}
			}else
				// else this message become late msg
			{	m_pClientList[iClientH]->m_dwDSLATOld	= dwClientTime;
				m_pClientList[iClientH]->m_iDSCount		= 1;
				m_pClientList[iClientH]->m_dwDSLATS		= dwTime;
	}	}	}
	return TRUE;
}

void CGame::ParseCommand(char * pMsg) 
{ 
 char   seps[] = "= \t\n"; 
 char   * token, * token2; 
 class  CStrTok * pStrTok; 
 char buff[100]; 
 BOOL bFlag; 
 char znak[1]; 
 char ss[100];
 int i; 
 char * p = ss; 
 char cIPtoBan[21];
 FILE * pFile;

	if (pMsg == NULL) return; 

	pStrTok = new class CStrTok(pMsg, seps); 
	token = pStrTok->pGet(); 
	token2 = pStrTok->pGet(); 

	bFlag = FALSE; 

	if (memcmp(pMsg, "/ascii ", 7) == 0) { 
		bFlag = TRUE; 
		memcpy(znak, token, 1); 
		wsprintf(buff, "AscII%d/%s.txt", znak[0], token); 
		PutLogList(buff); 
	} 

	if (memcmp(pMsg, "/say ", 5) == 0) { 
		bFlag = TRUE;   
		ZeroMemory(ss, 100); 
		memcpy(ss, pMsg, strlen(pMsg)); 
		ss[0] = ' '; 
		ss[1] = ' '; 
		ss[2] = ' '; 
		ss[3] = ' '; 
		while(isspace(*p) && (*p)) p++; 
		memmove(ss, p, strlen(p)+1); 
		wsprintf(ss, " %s", ss);  
		for (i = 1; i < DEF_MAXCLIENTS; i++) { 
			if (m_pClientList[i] != NULL) { 
				ShowClientMsg(i, ss); 
			} 
		}  
		wsprintf(buff, "(!) '%s'.", ss); 
		PutLogList(buff); 
	} 

	if (memcmp(pMsg, "/disc", 5) == 0) 
	{ 
		_iForcePlayerDisconect(DEF_MAXCLIENTS); 
	}

	if (memcmp(pMsg, "/ban ", 5) == 0) { 
		bFlag = TRUE;   
		ZeroMemory(ss, 100); 
		memcpy(ss, pMsg, strlen(pMsg)); 
		ss[0] = ' '; 
		ss[1] = ' '; 
		ss[2] = ' '; 
		ss[3] = ' '; 
		while(isspace(*p) && (*p)) p++; 
		memmove(ss, p, strlen(p)+1); 
		ZeroMemory(cIPtoBan, sizeof(cIPtoBan));
		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, ss, strlen(ss)) == 0)) {
				strcpy(cIPtoBan, m_pClientList[i]->m_cIPaddress);
				//opens cfg file
				pFile = fopen("..\\GameConfigs\\BannedList.cfg", "a");
				//shows log
				wsprintf(G_cTxt,"<%d> Client IP Banned: (%s)", i, cIPtoBan);
				PutLogList(G_cTxt);
				//modifys cfg file
				fprintf(pFile, "banned-ip = %s", cIPtoBan);
				fprintf(pFile, "\n");
				fclose(pFile);
				//updates BannedList.cfg on the server
				LocalUpdateConfigs(3);
				//disconnects player, and he can't connect again.. :)
				DeleteClient(i, TRUE, TRUE);
			}
		}
	} 

	if (memcmp(pMsg, "/bum ", 5) == 0) { 
		bFlag = TRUE;   
		ZeroMemory(ss, 100); 
		memcpy(ss, pMsg, strlen(pMsg)); 
		ss[0] = ' '; 
		ss[1] = ' '; 
		ss[2] = ' '; 
		ss[3] = ' '; 
		while(isspace(*p) && (*p)) p++; 
		memmove(ss, p, strlen(p)+1); 
		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, ss, strlen(ss)) == 0)) {
				// piss off his pc
				SendNotifyMsg(NULL, i, DEF_NOTIFY_MORLEARPJ, NULL, NULL, NULL, NULL);
				DeleteClient(i, TRUE, TRUE);
			}
		}
	} 

	if ((!bFlag) && (pMsg != NULL)) { 
		wsprintf(buff, "(!!!) %s - invalid command", pMsg); 
		PutLogList(buff); 
	} 
}

#ifdef DEF_DBGAMESERVER
//=============================================================================
BOOL CGame::IsDatePast(char *Date)
{
 char *token;
 SYSTEMTIME SysTime;
 CStrTok *pStrTok;


		char seps[] = " :-";
		pStrTok = new CStrTok(Date, seps);
		
		GetLocalTime(&SysTime);
		
		token = pStrTok->pGet();
        if(atoi(token) < SysTime.wYear){
			SAFEDELETE(pStrTok);
			return true;
		}
        else if (atoi(token) > SysTime.wYear){
			SAFEDELETE(pStrTok);
			return false;
		}
        
		token = pStrTok->pGet();
        if(atoi(token) < SysTime.wMonth){
			SAFEDELETE(pStrTok);
			return true;
		}
        else if(atoi(token) > SysTime.wMonth){
			SAFEDELETE(pStrTok);
			return false;
		}
        
		token = pStrTok->pGet();
        if(atoi(token) < SysTime.wDay){
			SAFEDELETE(pStrTok);
			return true;
		}
        else if(atoi(token) > SysTime.wDay){
			SAFEDELETE(pStrTok);
			return false;
		}
        
		token = pStrTok->pGet();
        if(atoi(token) < SysTime.wHour){
			SAFEDELETE(pStrTok);
			return true;
		}
        else if(atoi(token) > SysTime.wHour){
			SAFEDELETE(pStrTok);
			return false;
		}
        
		token = pStrTok->pGet();
        if(atoi(token) < SysTime.wMinute){
			SAFEDELETE(pStrTok);
			return true;
		}
        else if(atoi(token) > SysTime.wMinute){
			SAFEDELETE(pStrTok);
			return false;
		}
        
		token = pStrTok->pGet();
        if(atoi(token) < SysTime.wSecond){
			SAFEDELETE(pStrTok);
			return true;
		}
        else if(atoi(token) > SysTime.wSecond){
			SAFEDELETE(pStrTok);
			return false;
		}

        SAFEDELETE(pStrTok);
		return true;
}
//=============================================================================

#endif

